This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    continuous-integration.ncl
    continuous-integration.yml
    generated-workflow.ncl
    update-flake-lock.yml
    util.ncl
    workflow.ncl
  dependabot.yml
  settings.yml
examples/
  github-workflow/
    github/
      matrix.ncl
      setup-steps.ncl
    ci.ncl
    github-workflow.json
    github-workflow.schema.ncl
    README.md
  simple-schema/
    README.md
    schema-test.ncl
    test.schema.json
    test.schema.ncl
lib/
  arrays.ncl
  main.ncl
  Nickel-pkg.ncl
  numbers.ncl
  records.ncl
  strings.ncl
src/
  contract.rs
  extract.rs
  lib.rs
  main.rs
  object.rs
  references.rs
  schema.rs
  transform.rs
  traverse.rs
  typ.rs
  utils.rs
tests/
  integration/
    inputs/
      record_contract.json
      shadowing.json
  snapshots/
    integration__tests__integration__inputs__record_contract.json.snap
    integration__tests__integration__inputs__shadowing.json.snap
    transforms__tests__transforms__inputs__inline_defs.json.snap
    transforms__tests__transforms__inputs__nested_all_of.json.snap
  transforms/
    inputs/
      inline_defs.json
      nested_all_of.json
  integration.rs
  json_schema_test_suite_test.rs
  transforms.rs
.envrc
.gitattributes
.gitignore
build.rs
Cargo.toml
flake.lock
flake.nix
LICENSE-APACHE
LICENSE-MIT
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/continuous-integration.ncl">
# This file configures our github workflows, but in order for changes to take
# effect, it needs to be exported to yaml and the yaml changes need to be
# committed.
#
# Run `nix run .#generate-ci` to generate the yaml.
let workflow = import "workflow.ncl"
in
let rec
  checkout | workflow.Step = {
    name = "Checking out the repository",
    uses = "actions/checkout@v5",
    with = {
      fetch-depth = "0",
    },
  },
  nix | workflow.Step = {
    name = "Installing Nix",
    uses = "cachix/install-nix-action@v31",
    with = {
      nix_path = "nixpkgs=channel:nixos-unstable",
      extra_nix_config = m%"
        experimental-features = nix-command flakes
        accept-flake-config = true
        fallback = true
      "%,
    }
  },
  flake_check | workflow.Step = {
    name = "Run all checks",
    run = "nix flake check --print-build-logs",
  },
  check_steps = [checkout, nix, flake_check],
in
{
  name = "Continuous integration",
  on = {
    push = { branches = ["master"] },
    pull_request = {},
    merge_group = {},
  },

  jobs = {
    "build-and-test-linux" = {
      runs-on = "ubuntu-latest",
      steps = check_steps,
    },
    "build-and-test-macos" = {
      runs-on = "macos-latest",
      steps = check_steps,
    }
  },
} | workflow.Workflow
</file>

<file path=".github/workflows/continuous-integration.yml">
# This file is autogenerated. Edit the nickel source instead.
jobs:
  build-and-test-linux:
    continue-on-error: false
    runs-on: ubuntu-latest
    steps:
    - name: Checking out the repository
      uses: actions/checkout@v5
      with:
        fetch-depth: '0'
    - name: Installing Nix
      uses: cachix/install-nix-action@v31
      with:
        extra_nix_config: |-
          experimental-features = nix-command flakes
          accept-flake-config = true
          fallback = true
        nix_path: nixpkgs=channel:nixos-unstable
    - name: Run all checks
      run: nix flake check --print-build-logs
  build-and-test-macos:
    continue-on-error: false
    runs-on: macos-latest
    steps:
    - name: Checking out the repository
      uses: actions/checkout@v5
      with:
        fetch-depth: '0'
    - name: Installing Nix
      uses: cachix/install-nix-action@v31
      with:
        extra_nix_config: |-
          experimental-features = nix-command flakes
          accept-flake-config = true
          fallback = true
        nix_path: nixpkgs=channel:nixos-unstable
    - name: Run all checks
      run: nix flake check --print-build-logs
name: Continuous integration
on:
  merge_group: {}
  pull_request: {}
  push:
    branches:
    - master
</file>

<file path=".github/workflows/generated-workflow.ncl">
# DO NOT EDIT
# This file was automatically generated using json-schema-to-nickel
let js2n = import "../../lib/main.ncl" in
let rec refs = {
  definitions.branch =
    std.contract.Sequence [refs.definitions.globs, Array Dyn ],
  definitions.concurrency = {
    cancel-in-progress
      | std.contract.any_of [
        Bool,
        std.contract.Sequence [refs.definitions.expressionSyntax, String ]
      ]
      | optional,
    group | String
  },
  definitions.configuration =
    std.contract.any_of [ String, Number, Bool, { _ | js2n.Always }, Array js2n.Always],
  definitions.container = {
    credentials
      | {
        password | String | optional,
        username | String | optional,
        ..
      }
      | optional,
    env | refs.definitions.env | optional,
    image | String,
    options | String | optional,
    ports
      | js2n.array.MinItems 1
      | Array (std.contract.any_of [ Number, String ])
      | optional,
    volumes | js2n.array.MinItems 1 | Array String | optional
  },
  definitions.defaults =
    std.contract.Sequence [
      js2n.record.MinProperties 1,
      {
        run
          | js2n.record.MinProperties 1
          | {
            shell | refs.definitions.shell | String | optional,
            working-directory
              | refs.definitions.working-directory
              | String
              | optional
          }
          | optional
      }
    ],
  definitions.env =
    std.contract.any_of [
      { _ | std.contract.any_of [ Bool, Number, String ] },
      std.contract.Sequence [refs.definitions.stringContainingExpressionSyntax, String ]
    ],
  definitions.environment = { name | String, url | String | optional },
  definitions.event =
    std.contract.Sequence [
      std.enum.TagOrString,
      [|
        'repository_dispatch,
        'workflow_run,
        'workflow_dispatch,
        'workflow_call,
        'watch,
        'status,
        'release,
        'registry_package,
        'push,
        'pull_request_target,
        'pull_request_review_comment,
        'pull_request_review,
        'pull_request,
        'public,
        'project_column,
        'project_card,
        'project,
        'page_build,
        'milestone,
        'merge_group,
        'label,
        'issues,
        'issue_comment,
        'gollum,
        'fork,
        'discussion_comment,
        'discussion,
        'deployment_status,
        'deployment,
        'delete,
        'create,
        'check_suite,
        'check_run,
        'branch_protection_rule
      |]
    ],
  definitions.eventObject = js2n.Nullable { .. },
  definitions.expressionSyntax =
    std.string.Matches "^\\$\\{\\{(.|[\r\n])*\\}\\}$",
  definitions.globs =
    std.contract.Sequence [js2n.array.MinItems 1, Array (js2n.string.MinLength 1)],
  definitions.jobNeeds =
    std.contract.any_of [
      std.contract.Sequence [
        js2n.array.MinItems 1,
        Array (
          std.contract.Sequence [refs.definitions.name, String ]
        )
      ],
      std.contract.Sequence [refs.definitions.name, String ]
    ],
  definitions.matrix =
    std.contract.any_of [
      std.contract.Sequence [
        js2n.record.MinProperties 1,
        js2n.record.Record {
          properties = {
            exclude =
              std.contract.any_of [
                std.contract.Sequence [
                  refs.definitions.expressionSyntax,
                  String
                ],
                std.contract.Sequence [
                  js2n.array.MinItems 1,
                  Array (
                    { _ | refs.definitions.configuration }
                  )
                ]
              ],
            include =
              std.contract.any_of [
                std.contract.Sequence [
                  refs.definitions.expressionSyntax,
                  String
                ],
                std.contract.Sequence [
                  js2n.array.MinItems 1,
                  Array (
                    { _ | refs.definitions.configuration }
                  )
                ]
              ]
          },
          required = {},
          patterns = {},
          additional =
            'Some (
              std.contract.any_of [
                std.contract.Sequence [
                  js2n.array.MinItems 1,
                  Array refs.definitions.configuration
                ],
                std.contract.Sequence [refs.definitions.expressionSyntax, String ]
              ]
            )
        }
      ],
      std.contract.Sequence [refs.definitions.expressionSyntax, String ]
    ],
  definitions.name = std.string.Matches "^[_a-zA-Z][a-zA-Z0-9_-]*$",
  definitions.normalJob = {
    concurrency
      | std.contract.any_of [
        String,
        std.contract.Sequence [refs.definitions.concurrency, { _ | Dyn }]
      ]
      | optional,
    container
      | std.contract.any_of [
        String,
        std.contract.Sequence [refs.definitions.container, { _ | Dyn }]
      ]
      | optional,
    continue-on-error
      | std.contract.any_of [
        Bool,
        std.contract.Sequence [refs.definitions.expressionSyntax, String ]
      ]
      | optional,
    defaults | refs.definitions.defaults | { _ | Dyn } | optional,
    env | refs.definitions.env | optional,
    environment
      | std.contract.any_of [
        String,
        std.contract.Sequence [refs.definitions.environment, { _ | Dyn }]
      ]
      | optional,
    "if" | std.contract.any_of [ Bool, Number, String ] | optional,
    name | String | optional,
    needs | refs.definitions.jobNeeds | optional,
    outputs | js2n.record.MinProperties 1 | { _ | String } | optional,
    permissions | refs.definitions.permissions | optional,
    runs-on
      | std.contract.any_of [
        String,
        std.contract.Sequence [
          js2n.array.MinItems 1,
          js2n.array.Items [ String ] String
        ],
        js2n.record.Record {
          properties = {
            group = String,
            labels =
              std.contract.any_of [ String, js2n.array.ArrayOf String ]
          },
          required = {},
          patterns = {},
          additional = 'Some Dyn
        },
        std.contract.Sequence [
          refs.definitions.stringContainingExpressionSyntax,
          String
        ],
        std.contract.Sequence [refs.definitions.expressionSyntax, String ]
      ],
    services
      | {
        _ | std.contract.Sequence [refs.definitions.container, { _ | Dyn }]
      }
      | optional,
    steps
      | js2n.array.MinItems 1
      | Array (
        std.contract.Sequence [refs.definitions.step, { _ | Dyn }]
      )
      | optional,
    strategy
      | {
        fail-fast | std.contract.any_of [ Bool, String ] | optional,
        matrix | refs.definitions.matrix,
        max-parallel | std.contract.any_of [ Number, String ] | optional
      }
      | optional,
    timeout-minutes
      | std.contract.any_of [
        Number,
        std.contract.Sequence [refs.definitions.expressionSyntax, String ]
      ]
      | optional
  },
  definitions.path =
    std.contract.Sequence [refs.definitions.globs, Array Dyn ],
  definitions.permissions =
    std.contract.any_of [
      std.contract.Sequence [std.enum.TagOrString, [| 'write-all, 'read-all |]],
      std.contract.Sequence [refs.definitions.permissions-event, { _ | Dyn }]
    ],
  definitions.permissions-event = {
    actions | refs.definitions.permissions-level | String | optional,
    attestations
      | refs.definitions.permissions-level
      | String
      | optional,
    checks | refs.definitions.permissions-level | String | optional,
    contents | refs.definitions.permissions-level | String | optional,
    deployments
      | refs.definitions.permissions-level
      | String
      | optional,
    discussions
      | refs.definitions.permissions-level
      | String
      | optional,
    id-token | refs.definitions.permissions-level | String | optional,
    issues | refs.definitions.permissions-level | String | optional,
    models | std.enum.TagOrString | [| 'none, 'read |] | optional,
    packages | refs.definitions.permissions-level | String | optional,
    pages | refs.definitions.permissions-level | String | optional,
    pull-requests
      | refs.definitions.permissions-level
      | String
      | optional,
    repository-projects
      | refs.definitions.permissions-level
      | String
      | optional,
    security-events
      | refs.definitions.permissions-level
      | String
      | optional,
    statuses | refs.definitions.permissions-level | String | optional
  },
  definitions.permissions-level =
    std.contract.Sequence [std.enum.TagOrString, [| 'none, 'write, 'read |]],
  definitions.ref =
    std.contract.Sequence [
      js2n.Nullable {
        branches | refs.definitions.branch | Array Dyn | optional,
        branches-ignore
          | refs.definitions.branch
          | Array Dyn
          | optional,
        paths | refs.definitions.path | Array Dyn | optional,
        paths-ignore | refs.definitions.path | Array Dyn | optional,
        tags | refs.definitions.branch | Array Dyn | optional,
        tags-ignore | refs.definitions.branch | Array Dyn | optional,
        ..
      },
      js2n.Nullable (
        std.contract.Sequence [
          std.contract.not (
            std.contract.any_of [
              js2n.Null,
              Bool,
              Number,
              String,
              js2n.record.Required ["branches", "branches-ignore"],
              Array Dyn
            ]
          ),
          std.contract.not (
            std.contract.any_of [
              js2n.Null,
              Bool,
              Number,
              String,
              js2n.record.Required ["tags", "tags-ignore"],
              Array Dyn
            ]
          ),
          std.contract.not (
            std.contract.any_of [
              js2n.Null,
              Bool,
              Number,
              String,
              js2n.record.Required ["paths", "paths-ignore"],
              Array Dyn
            ]
          ),
          { _ | Dyn }
        ]
      )
    ],
  definitions.reusableWorkflowCallJob = {
    concurrency
      | std.contract.any_of [
        String,
        std.contract.Sequence [refs.definitions.concurrency, { _ | Dyn }]
      ]
      | optional,
    "if" | std.contract.any_of [ Bool, Number, String ] | optional,
    name | String | optional,
    needs | refs.definitions.jobNeeds | optional,
    permissions | refs.definitions.permissions | optional,
    secrets
      | js2n.OneOf [
        refs.definitions.env,
        std.contract.Sequence [std.enum.TagOrString, [| 'inherit |]]
      ]
      | optional,
    strategy
      | {
        fail-fast | std.contract.any_of [ Bool, String ] | optional,
        matrix | refs.definitions.matrix,
        max-parallel | std.contract.any_of [ Number, String ] | optional
      }
      | optional,
    uses | std.string.Matches "^(.+\\/)+(.+)\\.(ya?ml)(@.+)?$",
    with | refs.definitions.env | optional
  },
  definitions.shell =
    std.contract.any_of [
      String,
      std.contract.Sequence [
        std.enum.TagOrString,
        [| 'powershell, 'cmd, 'sh, 'python, 'pwsh, 'bash |]
      ]
    ],
  definitions.step =
    std.contract.Sequence [
      js2n.record.DependentFields { shell = ["run"], working-directory = ["run"] },
      js2n.OneOf [
        std.contract.any_of [
          js2n.Null,
          Bool,
          Number,
          String,
          js2n.record.Required ["uses"],
          Array Dyn
        ],
        std.contract.any_of [
          js2n.Null,
          Bool,
          Number,
          String,
          js2n.record.Required ["run"],
          Array Dyn
        ]
      ],
      {
        continue-on-error
          | std.contract.any_of [
            Bool,
            std.contract.Sequence [refs.definitions.expressionSyntax, String ]
          ]
          | optional,
        env | refs.definitions.env | optional,
        id | String | optional,
        "if" | std.contract.any_of [ Bool, Number, String ] | optional,
        name | String | optional,
        run | String | optional,
        shell | refs.definitions.shell | String | optional,
        timeout-minutes
          | std.contract.any_of [
            Number,
            std.contract.Sequence [refs.definitions.expressionSyntax, String ]
          ]
          | optional,
        uses | String | optional,
        with
          | std.contract.any_of [
            js2n.Null,
            Bool,
            Number,
            String,
            {
              args | String | optional,
              entrypoint | String | optional,
              ..
            },
            Array Dyn
          ]
          | refs.definitions.env
          | optional,
        working-directory
          | refs.definitions.working-directory
          | String
          | optional
      }
    ],
  definitions.stringContainingExpressionSyntax =
    std.string.Matches "^.*\\$\\{\\{(.|[\r\n])*\\}\\}.*$",
  definitions.types = std.contract.any_of [js2n.array.MinItems 1, String ],
  definitions.workflowDispatchInput =
    std.contract.Sequence [
      js2n.IfThenElse
        (
          std.contract.any_of [
            js2n.Null,
            Bool,
            Number,
            String,
            js2n.record.Record {
              properties = { type = js2n.Const "string" },
              required = { type = true },
              patterns = {},
              additional = 'Some Dyn
            },
            Array Dyn
          ]
        )
        (
          std.contract.any_of [
            js2n.Null,
            Bool,
            Number,
            String,
            { "default" | String | optional, .. },
            Array Dyn
          ]
        )
        js2n.Always,
      js2n.IfThenElse
        (
          std.contract.any_of [
            js2n.Null,
            Bool,
            Number,
            String,
            js2n.record.Record {
              properties = { type = js2n.Const "boolean" },
              required = { type = true },
              patterns = {},
              additional = 'Some Dyn
            },
            Array Dyn
          ]
        )
        (
          std.contract.any_of [
            js2n.Null,
            Bool,
            Number,
            String,
            { "default" | Bool | optional, .. },
            Array Dyn
          ]
        )
        js2n.Always,
      js2n.IfThenElse
        (
          std.contract.any_of [
            js2n.Null,
            Bool,
            Number,
            String,
            js2n.record.Record {
              properties = { type = js2n.Const "number" },
              required = { type = true },
              patterns = {},
              additional = 'Some Dyn
            },
            Array Dyn
          ]
        )
        (
          std.contract.any_of [
            js2n.Null,
            Bool,
            Number,
            String,
            { "default" | Number | optional, .. },
            Array Dyn
          ]
        )
        js2n.Always,
      js2n.IfThenElse
        (
          std.contract.any_of [
            js2n.Null,
            Bool,
            Number,
            String,
            js2n.record.Record {
              properties = { type = js2n.Const "environment" },
              required = { type = true },
              patterns = {},
              additional = 'Some Dyn
            },
            Array Dyn
          ]
        )
        (
          std.contract.any_of [
            js2n.Null,
            Bool,
            Number,
            String,
            { "default" | String | optional, .. },
            Array Dyn
          ]
        )
        js2n.Always,
      js2n.IfThenElse
        (
          std.contract.any_of [
            js2n.Null,
            Bool,
            Number,
            String,
            js2n.record.Record {
              properties = { type = js2n.Const "choice" },
              required = { type = true },
              patterns = {},
              additional = 'Some Dyn
            },
            Array Dyn
          ]
        )
        (
          std.contract.any_of [
            js2n.Null,
            Bool,
            Number,
            String,
            js2n.record.Required ["options"],
            Array Dyn
          ]
        )
        js2n.Always,
      {
        "default"
          | std.contract.any_of [js2n.Null, Bool, Number, String, { _ | Dyn }, Array Dyn ]
          | optional,
        deprecationMessage | String | optional,
        description | String,
        options | js2n.array.MinItems 1 | Array String | optional,
        required | Bool | optional,
        type
          | std.enum.TagOrString
          | [| 'environment, 'number, 'boolean, 'choice, 'string |]
          | optional
      }
    ],
  definitions.working-directory = String
}
in
{
  concurrency
    | std.contract.any_of [ String, refs.definitions.concurrency]
    | optional,
  defaults | refs.definitions.defaults | { _ | Dyn } | optional,
  env | refs.definitions.env | optional,
  jobs
    | js2n.record.MinProperties 1
    | {
      _ | js2n.OneOf [
        refs.definitions.normalJob,
        refs.definitions.reusableWorkflowCallJob
      ]
    }
    | std.record.FieldsMatch "^[_a-zA-Z][a-zA-Z0-9_-]*$",
  name | String | optional,
  on
    | std.contract.any_of [
      refs.definitions.event,
      std.contract.Sequence [js2n.array.MinItems 1, Array refs.definitions.event],
      {
        branch_protection_rule
          | js2n.Nullable {
            types
              | std.contract.any_of [
                String,
                Array (
                  std.contract.Sequence [
                    std.enum.TagOrString,
                    [| 'deleted, 'edited, 'created |]
                  ]
                )
              ]
              | refs.definitions.types
              | optional,
            ..
          }
          | refs.definitions.eventObject
          | optional,
        check_run
          | js2n.Nullable {
            types
              | std.contract.any_of [
                String,
                Array (
                  std.contract.Sequence [
                    std.enum.TagOrString,
                    [|
                      'requested_action,
                      'completed,
                      'rerequested,
                      'created
                    |]
                  ]
                )
              ]
              | refs.definitions.types
              | optional,
            ..
          }
          | refs.definitions.eventObject
          | optional,
        check_suite
          | js2n.Nullable {
            types
              | std.contract.any_of [
                String,
                Array (
                  std.contract.Sequence [
                    std.enum.TagOrString,
                    [| 'rerequested, 'requested, 'completed |]
                  ]
                )
              ]
              | refs.definitions.types
              | optional,
            ..
          }
          | refs.definitions.eventObject
          | optional,
        create | refs.definitions.eventObject | optional,
        delete | refs.definitions.eventObject | optional,
        deployment | refs.definitions.eventObject | optional,
        deployment_status | refs.definitions.eventObject | optional,
        discussion
          | js2n.Nullable {
            types
              | std.contract.any_of [
                String,
                Array (
                  std.contract.Sequence [
                    std.enum.TagOrString,
                    [|
                      'unanswered,
                      'answered,
                      'category_changed,
                      'unlocked,
                      'locked,
                      'unlabeled,
                      'labeled,
                      'unpinned,
                      'pinned,
                      'transferred,
                      'deleted,
                      'edited,
                      'created
                    |]
                  ]
                )
              ]
              | refs.definitions.types
              | optional,
            ..
          }
          | refs.definitions.eventObject
          | optional,
        discussion_comment
          | js2n.Nullable {
            types
              | std.contract.any_of [
                String,
                Array (
                  std.contract.Sequence [
                    std.enum.TagOrString,
                    [| 'deleted, 'edited, 'created |]
                  ]
                )
              ]
              | refs.definitions.types
              | optional,
            ..
          }
          | refs.definitions.eventObject
          | optional,
        fork | refs.definitions.eventObject | optional,
        gollum | refs.definitions.eventObject | optional,
        issue_comment
          | js2n.Nullable {
            types
              | std.contract.any_of [
                String,
                Array (
                  std.contract.Sequence [
                    std.enum.TagOrString,
                    [| 'deleted, 'edited, 'created |]
                  ]
                )
              ]
              | refs.definitions.types
              | optional,
            ..
          }
          | refs.definitions.eventObject
          | optional,
        issues
          | js2n.Nullable {
            types
              | std.contract.any_of [
                String,
                Array (
                  std.contract.Sequence [
                    std.enum.TagOrString,
                    [|
                      'demilestoned,
                      'milestoned,
                      'unlocked,
                      'locked,
                      'unlabeled,
                      'labeled,
                      'unassigned,
                      'assigned,
                      'reopened,
                      'closed,
                      'unpinned,
                      'pinned,
                      'transferred,
                      'deleted,
                      'edited,
                      'opened
                    |]
                  ]
                )
              ]
              | refs.definitions.types
              | optional,
            ..
          }
          | refs.definitions.eventObject
          | optional,
        label
          | js2n.Nullable {
            types
              | std.contract.any_of [
                String,
                Array (
                  std.contract.Sequence [
                    std.enum.TagOrString,
                    [| 'deleted, 'edited, 'created |]
                  ]
                )
              ]
              | refs.definitions.types
              | optional,
            ..
          }
          | refs.definitions.eventObject
          | optional,
        merge_group
          | js2n.Nullable {
            types
              | std.contract.any_of [
                String,
                Array (
                  std.contract.Sequence [std.enum.TagOrString, [| 'checks_requested |]]
                )
              ]
              | refs.definitions.types
              | optional,
            ..
          }
          | refs.definitions.eventObject
          | optional,
        milestone
          | js2n.Nullable {
            types
              | std.contract.any_of [
                String,
                Array (
                  std.contract.Sequence [
                    std.enum.TagOrString,
                    [|
                      'deleted,
                      'edited,
                      'opened,
                      'closed,
                      'created
                    |]
                  ]
                )
              ]
              | refs.definitions.types
              | optional,
            ..
          }
          | refs.definitions.eventObject
          | optional,
        page_build | refs.definitions.eventObject | optional,
        project
          | js2n.Nullable {
            types
              | std.contract.any_of [
                String,
                Array (
                  std.contract.Sequence [
                    std.enum.TagOrString,
                    [|
                      'deleted,
                      'edited,
                      'reopened,
                      'closed,
                      'updated,
                      'created
                    |]
                  ]
                )
              ]
              | refs.definitions.types
              | optional,
            ..
          }
          | refs.definitions.eventObject
          | optional,
        project_card
          | js2n.Nullable {
            types
              | std.contract.any_of [
                String,
                Array (
                  std.contract.Sequence [
                    std.enum.TagOrString,
                    [|
                      'deleted,
                      'edited,
                      'converted,
                      'moved,
                      'created
                    |]
                  ]
                )
              ]
              | refs.definitions.types
              | optional,
            ..
          }
          | refs.definitions.eventObject
          | optional,
        project_column
          | js2n.Nullable {
            types
              | std.contract.any_of [
                String,
                Array (
                  std.contract.Sequence [
                    std.enum.TagOrString,
                    [| 'deleted, 'moved, 'updated, 'created |]
                  ]
                )
              ]
              | refs.definitions.types
              | optional,
            ..
          }
          | refs.definitions.eventObject
          | optional,
        public | refs.definitions.eventObject | optional,
        pull_request
          | js2n.Nullable {
            branches | Array Dyn | optional,
            branches-ignore | Array Dyn | optional,
            paths | Array Dyn | optional,
            paths-ignore | Array Dyn | optional,
            tags | Array Dyn | optional,
            tags-ignore | Array Dyn | optional,
            types
              | std.contract.any_of [
                String,
                Array (
                  std.contract.Sequence [
                    std.enum.TagOrString,
                    [|
                      'dequeued,
                      'enqueued,
                      'auto_merge_disabled,
                      'auto_merge_enabled,
                      'review_request_removed,
                      'review_requested,
                      'demilestoned,
                      'milestoned,
                      'unlocked,
                      'locked,
                      'ready_for_review,
                      'converted_to_draft,
                      'synchronize,
                      'reopened,
                      'closed,
                      'edited,
                      'opened,
                      'unlabeled,
                      'labeled,
                      'unassigned,
                      'assigned
                    |]
                  ]
                )
              ]
              | refs.definitions.types
              | optional
          }
          | refs.definitions.ref
          | optional,
        pull_request_review
          | js2n.Nullable {
            types
              | std.contract.any_of [
                String,
                Array (
                  std.contract.Sequence [
                    std.enum.TagOrString,
                    [| 'dismissed, 'edited, 'submitted |]
                  ]
                )
              ]
              | refs.definitions.types
              | optional,
            ..
          }
          | refs.definitions.eventObject
          | optional,
        pull_request_review_comment
          | js2n.Nullable {
            types
              | std.contract.any_of [
                String,
                Array (
                  std.contract.Sequence [
                    std.enum.TagOrString,
                    [| 'deleted, 'edited, 'created |]
                  ]
                )
              ]
              | refs.definitions.types
              | optional,
            ..
          }
          | refs.definitions.eventObject
          | optional,
        pull_request_target
          | js2n.Nullable {
            branches | js2n.Always | optional,
            branches-ignore | js2n.Always | optional,
            paths | js2n.Always | optional,
            paths-ignore | js2n.Always | optional,
            tags | js2n.Always | optional,
            tags-ignore | js2n.Always | optional,
            types
              | std.contract.any_of [
                String,
                Array (
                  std.contract.Sequence [
                    std.enum.TagOrString,
                    [|
                      'auto_merge_disabled,
                      'auto_merge_enabled,
                      'review_request_removed,
                      'review_requested,
                      'unlocked,
                      'locked,
                      'ready_for_review,
                      'converted_to_draft,
                      'synchronize,
                      'reopened,
                      'closed,
                      'edited,
                      'opened,
                      'unlabeled,
                      'labeled,
                      'unassigned,
                      'assigned
                    |]
                  ]
                )
              ]
              | refs.definitions.types
              | optional
          }
          | refs.definitions.ref
          | optional,
        push
          | js2n.Nullable {
            branches | Array String | optional,
            branches-ignore | Array String | optional,
            paths | Array String | optional,
            paths-ignore | Array String | optional,
            tags | Array String | optional,
            tags-ignore | Array String | optional
          }
          | refs.definitions.ref
          | optional,
        registry_package
          | js2n.Nullable {
            types
              | std.contract.any_of [
                String,
                Array (
                  std.contract.Sequence [
                    std.enum.TagOrString,
                    [| 'updated, 'published |]
                  ]
                )
              ]
              | refs.definitions.types
              | optional,
            ..
          }
          | refs.definitions.eventObject
          | optional,
        release
          | js2n.Nullable {
            types
              | std.contract.any_of [
                String,
                Array (
                  std.contract.Sequence [
                    std.enum.TagOrString,
                    [|
                      'released,
                      'prereleased,
                      'deleted,
                      'edited,
                      'created,
                      'unpublished,
                      'published
                    |]
                  ]
                )
              ]
              | refs.definitions.types
              | optional,
            ..
          }
          | refs.definitions.eventObject
          | optional,
        repository_dispatch | refs.definitions.eventObject | optional,
        schedule
          | js2n.array.MinItems 1
          | Array { cron | String | optional }
          | optional,
        status | refs.definitions.eventObject | optional,
        watch | refs.definitions.eventObject | optional,
        workflow_call
          | std.contract.any_of [
            js2n.Null,
            Bool,
            Number,
            String,
            {
              inputs
                | {
                  _ | {
                    "default"
                      | std.contract.any_of [ Bool, Number, String ]
                      | optional,
                    description | String | optional,
                    required | Bool | optional,
                    type
                      | std.enum.TagOrString
                      | [| 'string, 'number, 'boolean |]
                  }
                }
                | std.record.FieldsMatch "^[_a-zA-Z][a-zA-Z0-9_-]*$"
                | optional,
              outputs
                | {
                  _ | {
                    description | String | optional,
                    value | String
                  }
                }
                | std.record.FieldsMatch "^[_a-zA-Z][a-zA-Z0-9_-]*$"
                | optional,
              secrets
                | std.contract.any_of [
                  js2n.Null,
                  Bool,
                  Number,
                  String,
                  std.contract.Sequence [
                    {
                      _ | std.contract.any_of [
                        js2n.Null,
                        Bool,
                        Number,
                        String,
                        {
                          description | String | optional,
                          required | Bool | optional
                        },
                        Array Dyn
                      ]
                    },
                    std.record.FieldsMatch "^[_a-zA-Z][a-zA-Z0-9_-]*$"
                  ],
                  Array Dyn
                ]
                | optional,
              ..
            },
            Array Dyn
          ]
          | optional,
        workflow_dispatch
          | std.contract.any_of [
            js2n.Null,
            Bool,
            Number,
            String,
            {
              inputs
                | {
                  _ | std.contract.Sequence [
                    refs.definitions.workflowDispatchInput,
                    { _ | Dyn }
                  ]
                }
                | std.record.FieldsMatch "^[_a-zA-Z][a-zA-Z0-9_-]*$"
                | optional
            },
            Array Dyn
          ]
          | optional,
        workflow_run
          | js2n.Nullable {
            branches | js2n.Always | optional,
            branches-ignore | js2n.Always | optional,
            types
              | std.contract.any_of [
                String,
                Array (
                  std.contract.Sequence [
                    std.enum.TagOrString,
                    [| 'in_progress, 'completed, 'requested |]
                  ]
                )
              ]
              | refs.definitions.types
              | optional,
            workflows | js2n.array.MinItems 1 | Array String | optional,
            ..
          }
          | refs.definitions.eventObject
          | optional
      }
    ],
  permissions | refs.definitions.permissions | optional,
  run-name | String | optional
}
</file>

<file path=".github/workflows/update-flake-lock.yml">
name: update-flake-lock
on:
  workflow_dispatch: # allows manual triggering
  schedule:
    - cron: '0 0 * * 0' # runs weekly on Sunday at 00:00

jobs:
  lockfile:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
      - name: Install Nix
        uses: cachix/install-nix-action@v31
        with:
          extra_nix_config: |
            access-tokens = github.com=${{ secrets.GITHUB_TOKEN }}
      - name: Update flake.lock
        uses: DeterminateSystems/update-flake-lock@v27
        with:
          # Providing a secret token is necessary for the PRs to run CI
          # See https://github.com/DeterminateSystems/update-flake-lock#with-a-personal-authentication-token
          token: ${{ secrets.GH_TOKEN_FOR_UPDATES }}
</file>

<file path=".github/workflows/util.ncl">
{
  EagerRecordField
    | doc m%"
      `EagerRecordField name Ctr` is a contract asserting that the value is a record, with a field
      satisfying the contract `Ctr`.

      This differs from `{ name | Ctr }` in that it is one level more eager: it eagerly checks the
      existence of the field `name` and applies `Ctr` to it.

      # Examples

      ```nickel multiline
      { foo = 1, bar = 2 } | EagerRecordField "foo" Number
      
      # This doesn't fail, because the record contract is lazy and
      # foo never gets evaluated.
      ({ foo = 1, bar = 2 } | { foo | String, .. }).bar
      
      # This does fail, because EagerRecordField is that little bit more eager.
      ({ foo = 1, bar = 2 } | EagerRecordField "foo" String).bar
      # => error: contract broken by a value
      ```
    "%
    = fun field Ctr =>
      std.contract.custom (fun label record =>
        if !(std.is_record record) then
          'Error { message = "expected a record" }
        else if !(std.record.has_field field record) then
          'Error { message = "missing field `%{field}`" }
        else
          std.contract.check Ctr label (record."%{field}")
          |> match {
            'Ok v => 'Ok (std.record.update field v record),
            'Error e => 'Error e,
          }
      ),
  ArrayOf
    | Dyn -> Dyn
    | doc m%"
      An eager version of `Array`. `value | ArrayOf C` will succeed if `value` is an array and all of
      its elements satisfy the eager part of the contract `C`.

      This is lifted from the json schema lib, because it didn't feel like it made sense for the
      github contract to depend on json-schema-lib. It might make sense to have it somewhere common.

      # Examples

      ```nickel multiline
      [1, 2, 3] | ArrayOf Number
      # => [1, 2, 3]

      [1, 2, 3] | ArrayOf String
      # => error

      ["a", "b", "c"] | ArrayOf std.enum.TagOrString
      # => ['a, 'b, 'c]
      ```
    "%
    = fun ctr =>
      std.contract.custom (fun label value =>
        if !std.is_array value then
          'Error { message = "expected an array" }
        else
          value
          |> std.array.try_fold_left
            (fun acc elt =>
              std.contract.check ctr label elt
              |> match {
                'Ok v => 'Ok (acc @ [v]),
                'Error e => 'Error e
              }
            )
            []
      ),
  UniqueNames
    | doc m%"
      A contract that you can apply to an array of records, each of which has a `name` field.

      Checks that the `name` fields are all unique.

      # Examples

      ```nickel multiline
      [ { name = "hi" }, { name = "bye" } ] | UniqueNames

      [ { name = "hi" }, { name = "bye" }, { name = "hi" } ] | UniqueNames
      # => error: name `hi` is duplicated

      [ { id = "not a name" } ] | UniqueNames
      # => error: contract broken by a value
      ```
    "%
    =
      std.contract.custom (fun label vals =>
        std.contract.check (ArrayOf (EagerRecordField "name" String)) label vals
        |> match {
          'Error e => 'Error e,
          'Ok vals =>
            # Our accumulator is { _ | Bool }, representing
            # the set of field names we've seen so far.
            # (but it's a { _ | Bool } because Nickel doesn't have sets yet...
            vals
            |> std.array.try_fold_left
              (fun acc val =>
                if std.record.has_field val.name acc then
                  # This little hack allows us to point to the location of the duplicated name.
                  # We know the Number contract will fail because we already checked that the
                  # `name` fields are strings.
                  #
                  # (I also tried `std.contract.from_predicate fun _ => false`, but it didn't
                  # point to the right location for some reason.
                  let 'Error loc = std.contract.check Number label val.name in
                  'Error { message = "name `%{val.name}` is duplicated", blame_location = loc.blame_location }
                else
                  'Ok (std.record.insert val.name true acc)
              )
              {}
            |> match {
              'Ok _ => 'Ok vals,
              'Error e => 'Error e,
            }
          # let name_counts = vals |> std.array.fold_left (fun acc val => std.record.update val.name ((std.record.get_or val.name 0 acc) + 1) acc) {} in
          # let duplicated = name_counts |> std.record.filter (fun _name count => count > 1) |> std.record.fields in
          # if std.array.length duplicated == 0 then
          #   'Ok vals
          # else
          #   'Error { message = "name `%{std.array.first duplicated}` is duplicated" }
        }
      ),
}
</file>

<file path=".github/workflows/workflow.ncl">
# This is an artisinal, opinionated github workflow contract to complement the
# auto-generated one. Currently, it's a subset (i.e. a stricter contract) that
# enforces some more idiomatic nickel conventions (like, less permissiveness
# with strings vs arrays of strings, less nulls, etc.). Eventually, we may also
# experiment with fancier things like ADTs.
#
# # No "matrix"
#
# Our first opinion (that we're testing out here) is lack of support for
# github's matrix. Let's instead try to generate multiple jobs natively
# in Nickel. One limitation that I've already encountered: matrix jobs
# get names like "build-and-test (ubuntu-latest, stable)", and we can't
# imitate names like these without a matrix because spaces are disallowed
# in job names.
let
  WorkflowExport = import "generated-workflow.ncl",
  util = import "util.ncl",
in
{
  Job = {
    runs-on | String,
    continue-on-error | Bool | default = false,
    steps | Array Step | util.UniqueNames,
  },

  # TODO: make branches / branches-ignore mutually exclusive
  Ref = {
    branches | Array String | optional,
    branches-ignore | Array String | optional,
    paths | Array String | optional,
    paths-ignore | Array String | optional,
    tags | Array String | optional,
    tags-ignore | Array String | optional,
  },

  Step = {
    name | String,
    run | String | optional,
    uses | String | optional,
    with | { _ | String } | optional,
  },

  Trigger = {
    pull_request | Ref | optional,
    push | Ref | optional,
    merge_group | {} | optional
  },

  Workflow =
    {
      name | String,
      on | Trigger,
      jobs | { _ | Job },
    } | WorkflowExport,
}
</file>

<file path=".github/dependabot.yml">
version: 2
updates:

- package-ecosystem: github-actions
  directory: "/"
  schedule:
    interval: daily
    time: '00:00'
    timezone: UTC
  open-pull-requests-limit: 10
  commit-message:
      prefix: "chore"
      include: "scope"
</file>

<file path=".github/settings.yml">
repository:
  has_wiki: false

labels:
  - name: "duplicate"
    color: cfd3d7
  - name: "good first issue"
    color: 7057ff
  - name: "invalid"
    color: cfd3d7
  - name: "more data needed"
    color: bfdadc
  - name: "P0"
    color: b60205
    description: "blocker: fix immediately!"
  - name: "P1"
    color: d93f0b
    description: "critical: next release"
  - name: "P2"
    color: e99695
    description: "major: an upcoming release"
  - name: "P3"
    color: fbca04
    description: "minor: not priorized"
  - name: "P4"
    color: fef2c0
    description: "unimportant: consider wontfix or other priority"
  - name: "question"
    color: d876e3
  - name: "type: bug"
    color: 0052cc
  - name: "type: documentation"
    color: 0052cc
  - name: "type: feature request"
    color: 0052cc
  - name: "wontfix"
    color: ffffff
  - name: "merge-queue"
    color: 0e8a16
    description: "merge on green CI"
  - name: "area: contracts"
    color: 77dd77
  - name: "area: typing"
    color: 77dd77
  - name: "area: cli"
    color: 77dd77
  - name: "area: syntax"
    color: 77dd77
  - name: "area: website"
    color: 77dd77
  - name: "area: lsp"
    color: 77dd77
</file>

<file path="examples/github-workflow/github/matrix.ncl">
let name_of_config = fun config =>
  config
  |> std.record.values
  |> std.array.filter (std.is_string)
  |> std.string.join ", "
in
let sanitize = fun x =>
  std.function.pipe
    x
    [
      std.string.replace_regex "[^A-Za-z0-9-_]" "-",
      std.string.lowercase
    ]
in
{
  configs
    | Array { .. }
    | not_exported,
  matrix
    | not_exported
    | {
      name | String,
      job
        | {
          steps | Array { .. },
          ..
        },
      ..
    },
  jobs =
    configs
    |> std.array.map
      (
        fun config' =>
          {
            "%{sanitize "%{matrix.name}-%{name_of_config config'}"}" =
              (
                matrix & { config = config' }
              ).job
              & {
                name = "%{matrix.name} / (%{name_of_config config'})",
              }
          }
      )
    |> std.record.merge_all
}
</file>

<file path="examples/github-workflow/github/setup-steps.ncl">
[
  { uses = "actions/checkout@v3" },
  {
    uses = "cachix/install-nix-action@v21",
    name = "Installing Nix",
    with = {
      extra_nix_config = "experimental-features = nix-command flakes",
      nix_path = "nixpkgs=channel:nixos-unstable"
    }
  },
  {
    name = "Setup Cachix",
    with = {
      authToken = "${{ secrets.CACHIX_TWEAG_NICKEL_AUTH_TOKEN }}",
      name = "tweag-nickel"
    },
    uses = "cachix/cachix-action@v12"
  }
]
</file>

<file path="examples/github-workflow/ci.ncl">
# Our workflow contract consists of the autogenerated js2n contract,
# with some added configuration fields that aren't exported but rather
# used to configure and generate the exported parts.
let Workflow =
  (import "github-workflow.schema.ncl")
  & { configs | optional | Dyn, matrix | optional | Dyn }
in
(
  {
    configs = [
      { os = "ubuntu-latest" },
      { os = "macos-latest" }
    ],

    concurrency = {
      group = "ci-${{ github.ref }}",
      cancel-in-progress = true
    },
    name = "CI",
    on = {
      push = {
        branches = ["main"]
      },
      pull_request = {
        branches = ["main"]
      }
    },

    matrix = {
      config | default = { os = "" },

      name = "Build and Test",

      job = {
        steps =
          (import "github/setup-steps.ncl")
          @ [
            {
              run = m%"
              nix flake check --print-build-logs
              nix run .#test-examples
            "%,
              name = "Run flake check"
            },
          ],
        runs-on = config.os,
      }
    },
  }
  & (import "github/matrix.ncl")
) | Workflow
</file>

<file path="examples/github-workflow/github-workflow.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://json.schemastore.org/github-workflow.json",
  "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions",
  "additionalProperties": false,
  "definitions": {
    "architecture": {
      "type": "string",
      "enum": ["ARM32", "x64", "x86"]
    },
    "branch": {
      "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#onpushpull_requestbranchestags",
      "$ref": "#/definitions/globs",
      "description": "When using the push and pull_request events, you can configure a workflow to run on specific branches or tags. If you only define only tags or only branches, the workflow won't run for events affecting the undefined Git ref.\nThe branches, branches-ignore, tags, and tags-ignore keywords accept glob patterns that use the * and ** wildcard characters to match more than one branch or tag name. For more information, see https://help.github.com/en/github/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#filter-pattern-cheat-sheet.\nThe patterns defined in branches and tags are evaluated against the Git ref's name. For example, defining the pattern mona/octocat in branches will match the refs/heads/mona/octocat Git ref. The pattern releases/** will match the refs/heads/releases/10 Git ref.\nYou can use two types of filters to prevent a workflow from running on pushes and pull requests to tags and branches:\n- branches or branches-ignore - You cannot use both the branches and branches-ignore filters for the same event in a workflow. Use the branches filter when you need to filter branches for positive matches and exclude branches. Use the branches-ignore filter when you only need to exclude branch names.\n- tags or tags-ignore - You cannot use both the tags and tags-ignore filters for the same event in a workflow. Use the tags filter when you need to filter tags for positive matches and exclude tags. Use the tags-ignore filter when you only need to exclude tag names.\nYou can exclude tags and branches using the ! character. The order that you define patterns matters.\n- A matching negative pattern (prefixed with !) after a positive match will exclude the Git ref.\n- A matching positive pattern after a negative match will include the Git ref again."
    },
    "concurrency": {
      "type": "object",
      "properties": {
        "group": {
          "$comment": "https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#example-using-concurrency-to-cancel-any-in-progress-job-or-run-1",
          "description": "When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending. Any previously pending job or workflow in the concurrency group will be canceled.",
          "type": "string"
        },
        "cancel-in-progress": {
          "$comment": "https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#example-using-concurrency-to-cancel-any-in-progress-job-or-run-1",
          "description": "To cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true.",
          "oneOf": [
            {
              "type": "boolean"
            },
            {
              "$ref": "#/definitions/expressionSyntax"
            }
          ]
        }
      },
      "required": ["group"],
      "additionalProperties": false
    },
    "configuration": {
      "oneOf": [
        {
          "type": "string"
        },
        {
          "type": "number"
        },
        {
          "type": "boolean"
        },
        {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/configuration"
          }
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/definitions/configuration"
          }
        }
      ]
    },
    "container": {
      "type": "object",
      "properties": {
        "image": {
          "$comment": "https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idcontainerimage",
          "description": "The Docker image to use as the container to run the action. The value can be the Docker Hub image name or a registry name.",
          "type": "string"
        },
        "credentials": {
          "$comment": "https://docs.github.com/en/free-pro-team@latest/actions/reference/workflow-syntax-for-github-actions#jobsjob_idcontainercredentials",
          "description": "If the image's container registry requires authentication to pull the image, you can use credentials to set a map of the username and password. The credentials are the same values that you would provide to the `docker login` command.",
          "type": "object",
          "properties": {
            "username": {
              "type": "string"
            },
            "password": {
              "type": "string"
            }
          }
        },
        "env": {
          "$comment": "https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idcontainerenv",
          "$ref": "#/definitions/env",
          "description": "Sets an array of environment variables in the container."
        },
        "ports": {
          "$comment": "https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idcontainerports",
          "description": "Sets an array of ports to expose on the container.",
          "type": "array",
          "items": {
            "oneOf": [
              {
                "type": "number"
              },
              {
                "type": "string"
              }
            ]
          },
          "minItems": 1
        },
        "volumes": {
          "$comment": "https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idcontainervolumes",
          "description": "Sets an array of volumes for the container to use. You can use volumes to share data between services or other steps in a job. You can specify named Docker volumes, anonymous Docker volumes, or bind mounts on the host.\nTo specify a volume, you specify the source and destination path: <source>:<destinationPath>\nThe <source> is a volume name or an absolute path on the host machine, and <destinationPath> is an absolute path in the container.",
          "type": "array",
          "items": {
            "type": "string",
            "pattern": "^[^:]+:[^:]+$"
          },
          "minItems": 1
        },
        "options": {
          "$comment": "https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idcontaineroptions",
          "description": "Additional Docker container resource options. For a list of options, see https://docs.docker.com/engine/reference/commandline/create/#options.",
          "type": "string"
        }
      },
      "required": ["image"],
      "additionalProperties": false
    },
    "defaults": {
      "type": "object",
      "properties": {
        "run": {
          "type": "object",
          "properties": {
            "shell": {
              "$ref": "#/definitions/shell"
            },
            "working-directory": {
              "$ref": "#/definitions/working-directory"
            }
          },
          "minProperties": 1,
          "additionalProperties": false
        }
      },
      "minProperties": 1,
      "additionalProperties": false
    },
    "permissions": {
      "$comment": "https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#permissions",
      "description": "You can modify the default permissions granted to the GITHUB_TOKEN, adding or removing access as required, so that you only allow the minimum required access.",
      "oneOf": [
        {
          "type": "string",
          "enum": ["read-all", "write-all"]
        },
        {
          "$ref": "#/definitions/permissions-event"
        }
      ]
    },
    "permissions-event": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "actions": {
          "$ref": "#/definitions/permissions-level"
        },
        "attestations": {
          "$ref": "#/definitions/permissions-level"
        },
        "checks": {
          "$ref": "#/definitions/permissions-level"
        },
        "contents": {
          "$ref": "#/definitions/permissions-level"
        },
        "deployments": {
          "$ref": "#/definitions/permissions-level"
        },
        "discussions": {
          "$ref": "#/definitions/permissions-level"
        },
        "id-token": {
          "$ref": "#/definitions/permissions-level"
        },
        "issues": {
          "$ref": "#/definitions/permissions-level"
        },
        "packages": {
          "$ref": "#/definitions/permissions-level"
        },
        "pages": {
          "$ref": "#/definitions/permissions-level"
        },
        "pull-requests": {
          "$ref": "#/definitions/permissions-level"
        },
        "repository-projects": {
          "$ref": "#/definitions/permissions-level"
        },
        "security-events": {
          "$ref": "#/definitions/permissions-level"
        },
        "statuses": {
          "$ref": "#/definitions/permissions-level"
        }
      }
    },
    "permissions-level": {
      "type": "string",
      "enum": ["read", "write", "none"]
    },
    "env": {
      "$comment": "https://docs.github.com/en/actions/learn-github-actions/environment-variables",
      "description": "To set custom environment variables, you need to specify the variables in the workflow file. You can define environment variables for a step, job, or entire workflow using the jobs.<job_id>.steps[*].env, jobs.<job_id>.env, and env keywords. For more information, see https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idstepsenv",
      "oneOf": [
        {
          "type": "object",
          "additionalProperties": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              },
              {
                "type": "boolean"
              }
            ]
          }
        },
        {
          "$ref": "#/definitions/stringContainingExpressionSyntax"
        }
      ]
    },
    "environment": {
      "$comment": "https://docs.github.com/en/free-pro-team@latest/actions/reference/workflow-syntax-for-github-actions#jobsjob_idenvironment",
      "description": "The environment that the job references",
      "type": "object",
      "properties": {
        "name": {
          "$comment": "https://docs.github.com/en/free-pro-team@latest/actions/reference/workflow-syntax-for-github-actions#example-using-a-single-environment-name",
          "description": "The name of the environment configured in the repo.",
          "type": "string"
        },
        "url": {
          "$comment": "https://docs.github.com/en/free-pro-team@latest/actions/reference/workflow-syntax-for-github-actions#example-using-environment-name-and-url",
          "description": "A deployment URL",
          "type": "string"
        }
      },
      "required": ["name"],
      "additionalProperties": false
    },
    "event": {
      "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/events-that-trigger-workflows",
      "type": "string",
      "enum": [
        "branch_protection_rule",
        "check_run",
        "check_suite",
        "create",
        "delete",
        "deployment",
        "deployment_status",
        "discussion",
        "discussion_comment",
        "fork",
        "gollum",
        "issue_comment",
        "issues",
        "label",
        "merge_group",
        "milestone",
        "page_build",
        "project",
        "project_card",
        "project_column",
        "public",
        "pull_request",
        "pull_request_review",
        "pull_request_review_comment",
        "pull_request_target",
        "push",
        "registry_package",
        "release",
        "status",
        "watch",
        "workflow_call",
        "workflow_dispatch",
        "workflow_run",
        "repository_dispatch"
      ]
    },
    "eventObject": {
      "oneOf": [
        {
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "additionalProperties": true
    },
    "expressionSyntax": {
      "$comment": "escape `{` and `}` in pattern to be unicode compatible (#1360)",
      "type": "string",
      "pattern": "^\\$\\{\\{(.|[\r\n])*\\}\\}$"
    },
    "stringContainingExpressionSyntax": {
      "$comment": "escape `{` and `}` in pattern to be unicode compatible (#1360)",
      "type": "string",
      "pattern": "^.*\\$\\{\\{(.|[\r\n])*\\}\\}.*$"
    },
    "globs": {
      "type": "array",
      "items": {
        "type": "string",
        "minLength": 1
      },
      "minItems": 1
    },
    "machine": {
      "type": "string",
      "enum": ["linux", "macos", "windows"]
    },
    "name": {
      "type": "string",
      "pattern": "^[_a-zA-Z][a-zA-Z0-9_-]*$"
    },
    "path": {
      "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#onpushpull_requestpaths",
      "$ref": "#/definitions/globs",
      "description": "When using the push and pull_request events, you can configure a workflow to run when at least one file does not match paths-ignore or at least one modified file matches the configured paths. Path filters are not evaluated for pushes to tags.\nThe paths-ignore and paths keywords accept glob patterns that use the * and ** wildcard characters to match more than one path name. For more information, see https://help.github.com/en/github/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#filter-pattern-cheat-sheet.\nYou can exclude paths using two types of filters. You cannot use both of these filters for the same event in a workflow.\n- paths-ignore - Use the paths-ignore filter when you only need to exclude path names.\n- paths - Use the paths filter when you need to filter paths for positive matches and exclude paths."
    },
    "ref": {
      "properties": {
        "branches": {
          "$ref": "#/definitions/branch"
        },
        "branches-ignore": {
          "$ref": "#/definitions/branch"
        },
        "tags": {
          "$ref": "#/definitions/branch"
        },
        "tags-ignore": {
          "$ref": "#/definitions/branch"
        },
        "paths": {
          "$ref": "#/definitions/path"
        },
        "paths-ignore": {
          "$ref": "#/definitions/path"
        }
      },
      "oneOf": [
        {
          "type": "object",
          "allOf": [
            {
              "not": {
                "required": ["branches", "branches-ignore"]
              }
            },
            {
              "not": {
                "required": ["tags", "tags-ignore"]
              }
            },
            {
              "not": {
                "required": ["paths", "paths-ignore"]
              }
            }
          ]
        },
        {
          "type": "null"
        }
      ]
    },
    "shell": {
      "$comment": "https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsshell",
      "description": "You can override the default shell settings in the runner's operating system using the shell keyword. You can use built-in shell keywords, or you can define a custom set of shell options.",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$comment": "https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#custom-shell",
          "type": "string",
          "enum": ["bash", "pwsh", "python", "sh", "cmd", "powershell"]
        }
      ]
    },
    "step": {
      "type": "object",
      "additionalProperties": false,
      "dependencies": {
        "working-directory": ["run"],
        "shell": ["run"]
      },
      "oneOf": [
        {
          "required": ["uses"]
        },
        {
          "required": ["run"]
        }
      ],
      "properties": {
        "id": {
          "$comment": "https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idstepsid",
          "description": "A unique identifier for the step. You can use the id to reference the step in contexts. For more information, see https://help.github.com/en/articles/contexts-and-expression-syntax-for-github-actions.",
          "type": "string"
        },
        "if": {
          "$comment": "https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idstepsif",
          "description": "You can use the if conditional to prevent a step from running unless a condition is met. You can use any supported context and expression to create a conditional.\nExpressions in an if conditional do not require the ${{ }} syntax. For more information, see https://help.github.com/en/articles/contexts-and-expression-syntax-for-github-actions.",
          "type": ["boolean", "number", "string"]
        },
        "name": {
          "$comment": "https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idstepsname",
          "description": "A name for your step to display on GitHub.",
          "type": "string"
        },
        "uses": {
          "$comment": "https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idstepsuses",
          "description": "Selects an action to run as part of a step in your job. An action is a reusable unit of code. You can use an action defined in the same repository as the workflow, a public repository, or in a published Docker container image (https://hub.docker.com/).\nWe strongly recommend that you include the version of the action you are using by specifying a Git ref, SHA, or Docker tag number. If you don't specify a version, it could break your workflows or cause unexpected behavior when the action owner publishes an update.\n- Using the commit SHA of a released action version is the safest for stability and security.\n- Using the specific major action version allows you to receive critical fixes and security patches while still maintaining compatibility. It also assures that your workflow should still work.\n- Using the master branch of an action may be convenient, but if someone releases a new major version with a breaking change, your workflow could break.\nSome actions require inputs that you must set using the with keyword. Review the action's README file to determine the inputs required.\nActions are either JavaScript files or Docker containers. If the action you're using is a Docker container you must run the job in a Linux virtual environment. For more details, see https://help.github.com/en/articles/virtual-environments-for-github-actions.",
          "type": "string"
        },
        "run": {
          "$comment": "https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idstepsrun",
          "description": "Runs command-line programs using the operating system's shell. If you do not provide a name, the step name will default to the text specified in the run command.\nCommands run using non-login shells by default. You can choose a different shell and customize the shell used to run commands. For more information, see https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#using-a-specific-shell.\nEach run keyword represents a new process and shell in the virtual environment. When you provide multi-line commands, each line runs in the same shell.",
          "type": "string"
        },
        "working-directory": {
          "$ref": "#/definitions/working-directory"
        },
        "shell": {
          "$ref": "#/definitions/shell"
        },
        "with": {
          "$comment": "https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idstepswith",
          "$ref": "#/definitions/env",
          "description": "A map of the input parameters defined by the action. Each input parameter is a key/value pair. Input parameters are set as environment variables. The variable is prefixed with INPUT_ and converted to upper case.",
          "properties": {
            "args": {
              "$comment": "https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idstepswithargs",
              "type": "string"
            },
            "entrypoint": {
              "$comment": "https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idstepswithentrypoint",
              "type": "string"
            }
          }
        },
        "env": {
          "$comment": "https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idstepsenv",
          "$ref": "#/definitions/env",
          "description": "Sets environment variables for steps to use in the virtual environment. You can also set environment variables for the entire workflow or a job."
        },
        "continue-on-error": {
          "$comment": "https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idstepscontinue-on-error",
          "description": "Prevents a job from failing when a step fails. Set to true to allow a job to pass when this step fails.",
          "oneOf": [
            {
              "type": "boolean"
            },
            {
              "$ref": "#/definitions/expressionSyntax"
            }
          ],
          "default": false
        },
        "timeout-minutes": {
          "$comment": "https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idstepstimeout-minutes",
          "description": "The maximum number of minutes to run the step before killing the process.",
          "oneOf": [
            {
              "type": "number"
            },
            {
              "$ref": "#/definitions/expressionSyntax"
            }
          ]
        }
      }
    },
    "types": {
      "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#onevent_nametypes",
      "description": "Selects the types of activity that will trigger a workflow run. Most GitHub events are triggered by more than one type of activity. For example, the event for the release resource is triggered when a release is published, unpublished, created, edited, deleted, or prereleased. The types keyword enables you to narrow down activity that causes the workflow to run. When only one activity type triggers a webhook event, the types keyword is unnecessary.\nYou can use an array of event types. For more information about each event and their activity types, see https://help.github.com/en/articles/events-that-trigger-workflows#webhook-events.",
      "type": "array",
      "minItems": 1
    },
    "working-directory": {
      "$comment": "https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idstepsrun",
      "description": "Using the working-directory keyword, you can specify the working directory of where to run the command.",
      "type": "string"
    },
    "jobNeeds": {
      "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idneeds",
      "description": "Identifies any jobs that must complete successfully before this job will run. It can be a string or array of strings. If a job fails, all jobs that need it are skipped unless the jobs use a conditional statement that causes the job to continue.",
      "oneOf": [
        {
          "type": "array",
          "items": {
            "$ref": "#/definitions/name"
          },
          "minItems": 1
        },
        {
          "$ref": "#/definitions/name"
        }
      ]
    },
    "matrix": {
      "$comment": "https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idstrategymatrix",
      "description": "A build matrix is a set of different configurations of the virtual environment. For example you might run a job against more than one supported version of a language, operating system, or tool. Each configuration is a copy of the job that runs and reports a status.\nYou can specify a matrix by supplying an array for the configuration options. For example, if the GitHub virtual environment supports Node.js versions 6, 8, and 10 you could specify an array of those versions in the matrix.\nWhen you define a matrix of operating systems, you must set the required runs-on keyword to the operating system of the current job, rather than hard-coding the operating system name. To access the operating system name, you can use the matrix.os context parameter to set runs-on. For more information, see https://help.github.com/en/articles/contexts-and-expression-syntax-for-github-actions.",
      "oneOf": [
        {
          "type": "object",
          "patternProperties": {
            "^(in|ex)clude$": {
              "$comment": "https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#example-including-configurations-in-a-matrix-build",
              "oneOf": [
                {
                  "$ref": "#/definitions/expressionSyntax"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "additionalProperties": {
                      "$ref": "#/definitions/configuration"
                    }
                  },
                  "minItems": 1
                }
              ]
            }
          },
          "additionalProperties": {
            "oneOf": [
              {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/configuration"
                },
                "minItems": 1
              },
              {
                "$ref": "#/definitions/expressionSyntax"
              }
            ]
          },
          "minProperties": 1
        },
        {
          "$ref": "#/definitions/expressionSyntax"
        }
      ]
    },
    "reusableWorkflowCallJob": {
      "$comment": "https://docs.github.com/en/actions/learn-github-actions/reusing-workflows#calling-a-reusable-workflow",
      "description": "Each job must have an id to associate with the job. The key job_id is a string and its value is a map of the job's configuration data. You must replace <job_id> with a string that is unique to the jobs object. The <job_id> must start with a letter or _ and contain only alphanumeric characters, -, or _.",
      "type": "object",
      "properties": {
        "name": {
          "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idname",
          "description": "The name of the job displayed on GitHub.",
          "type": "string"
        },
        "needs": {
          "$ref": "#/definitions/jobNeeds"
        },
        "permissions": {
          "$ref": "#/definitions/permissions"
        },
        "if": {
          "$comment": "https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idif",
          "description": "You can use the if conditional to prevent a job from running unless a condition is met. You can use any supported context and expression to create a conditional.\nExpressions in an if conditional do not require the ${{ }} syntax. For more information, see https://help.github.com/en/articles/contexts-and-expression-syntax-for-github-actions.",
          "type": ["boolean", "number", "string"]
        },
        "uses": {
          "$comment": "https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_iduses",
          "description": "The location and version of a reusable workflow file to run as a job, of the form './{path/to}/{localfile}.yml' or '{owner}/{repo}/{path}/{filename}@{ref}'. {ref} can be a SHA, a release tag, or a branch name. Using the commit SHA is the safest for stability and security.",
          "type": "string",
          "pattern": "^(.+\\/)+(.+)\\.(ya?ml)(@.+)?$"
        },
        "with": {
          "$comment": "https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idwith",
          "$ref": "#/definitions/env",
          "description": "A map of inputs that are passed to the called workflow. Any inputs that you pass must match the input specifications defined in the called workflow. Unlike 'jobs.<job_id>.steps[*].with', the inputs you pass with 'jobs.<job_id>.with' are not be available as environment variables in the called workflow. Instead, you can reference the inputs by using the inputs context."
        },
        "secrets": {
          "$comment": "https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idsecrets",
          "description": "When a job is used to call a reusable workflow, you can use 'secrets' to provide a map of secrets that are passed to the called workflow. Any secrets that you pass must match the names defined in the called workflow.",
          "oneOf": [
            {
              "$ref": "#/definitions/env"
            },
            {
              "type": "string",
              "enum": ["inherit"]
            }
          ]
        },
        "strategy": {
          "$comment": "https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idstrategy",
          "description": "A strategy creates a build matrix for your jobs. You can define different variations of an environment to run each job in.",
          "type": "object",
          "properties": {
            "matrix": {
              "$ref": "#/definitions/matrix"
            },
            "fail-fast": {
              "$comment": "https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idstrategyfail-fast",
              "description": "When set to true, GitHub cancels all in-progress jobs if any matrix job fails. Default: true",
              "type": ["boolean", "string"],
              "default": true
            },
            "max-parallel": {
              "$comment": "https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idstrategymax-parallel",
              "description": "The maximum number of jobs that can run simultaneously when using a matrix job strategy. By default, GitHub will maximize the number of jobs run in parallel depending on the available runners on GitHub-hosted virtual machines.",
              "type": ["number", "string"]
            }
          },
          "required": ["matrix"],
          "additionalProperties": false
        },
        "concurrency": {
          "$comment": "https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idconcurrency",
          "description": "Concurrency ensures that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. The expression can use any context except for the secrets context. \nYou can also specify concurrency at the workflow level. \nWhen a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending. Any previously pending job or workflow in the concurrency group will be canceled. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true.",
          "oneOf": [
            {
              "type": "string"
            },
            {
              "$ref": "#/definitions/concurrency"
            }
          ]
        }
      },
      "required": ["uses"],
      "additionalProperties": false
    },
    "normalJob": {
      "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_id",
      "description": "Each job must have an id to associate with the job. The key job_id is a string and its value is a map of the job's configuration data. You must replace <job_id> with a string that is unique to the jobs object. The <job_id> must start with a letter or _ and contain only alphanumeric characters, -, or _.",
      "type": "object",
      "properties": {
        "name": {
          "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idname",
          "description": "The name of the job displayed on GitHub.",
          "type": "string"
        },
        "needs": {
          "$ref": "#/definitions/jobNeeds"
        },
        "permissions": {
          "$ref": "#/definitions/permissions"
        },
        "runs-on": {
          "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idruns-on",
          "description": "The type of machine to run the job on. The machine can be either a GitHub-hosted runner, or a self-hosted runner.",
          "anyOf": [
            {
              "$comment": "https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#github-hosted-runners",
              "type": "string"
            },
            {
              "$comment": "https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#self-hosted-runners",
              "type": "array",
              "anyOf": [
                {
                  "items": [
                    {
                      "type": "string"
                    }
                  ],
                  "minItems": 1
                }
              ]
            },
            {
              "$comment": "https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#choosing-runners-in-a-group",
              "type": "object",
              "properties": {
                "group": {
                  "type": "string"
                },
                "labels": {
                  "oneOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  ]
                }
              }
            },
            {
              "$ref": "#/definitions/stringContainingExpressionSyntax"
            },
            {
              "$ref": "#/definitions/expressionSyntax"
            }
          ]
        },
        "environment": {
          "$comment": "https://docs.github.com/en/free-pro-team@latest/actions/reference/workflow-syntax-for-github-actions#jobsjob_idenvironment",
          "description": "The environment that the job references.",
          "oneOf": [
            {
              "type": "string"
            },
            {
              "$ref": "#/definitions/environment"
            }
          ]
        },
        "outputs": {
          "$comment": "https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idoutputs",
          "description": "A map of outputs for a job. Job outputs are available to all downstream jobs that depend on this job.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "minProperties": 1
        },
        "env": {
          "$comment": "https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idenv",
          "$ref": "#/definitions/env",
          "description": "A map of environment variables that are available to all steps in the job."
        },
        "defaults": {
          "$comment": "https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_iddefaults",
          "$ref": "#/definitions/defaults",
          "description": "A map of default settings that will apply to all steps in the job."
        },
        "if": {
          "$comment": "https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idif",
          "description": "You can use the if conditional to prevent a job from running unless a condition is met. You can use any supported context and expression to create a conditional.\nExpressions in an if conditional do not require the ${{ }} syntax. For more information, see https://help.github.com/en/articles/contexts-and-expression-syntax-for-github-actions.",
          "type": ["boolean", "number", "string"]
        },
        "steps": {
          "$comment": "https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idsteps",
          "description": "A job contains a sequence of tasks called steps. Steps can run commands, run setup tasks, or run an action in your repository, a public repository, or an action published in a Docker registry. Not all steps run actions, but all actions run as a step. Each step runs in its own process in the virtual environment and has access to the workspace and filesystem. Because steps run in their own process, changes to environment variables are not preserved between steps. GitHub provides built-in steps to set up and complete a job.\nMust contain either `uses` or `run`\n",
          "type": "array",
          "items": {
            "$ref": "#/definitions/step"
          },
          "minItems": 1
        },
        "timeout-minutes": {
          "$comment": "https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idtimeout-minutes",
          "description": "The maximum number of minutes to let a workflow run before GitHub automatically cancels it. Default: 360",
          "oneOf": [
            {
              "type": "number"
            },
            {
              "$ref": "#/definitions/expressionSyntax"
            }
          ],
          "default": 360
        },
        "strategy": {
          "$comment": "https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idstrategy",
          "description": "A strategy creates a build matrix for your jobs. You can define different variations of an environment to run each job in.",
          "type": "object",
          "properties": {
            "matrix": {
              "$ref": "#/definitions/matrix"
            },
            "fail-fast": {
              "$comment": "https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idstrategyfail-fast",
              "description": "When set to true, GitHub cancels all in-progress jobs if any matrix job fails. Default: true",
              "type": ["boolean", "string"],
              "default": true
            },
            "max-parallel": {
              "$comment": "https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idstrategymax-parallel",
              "description": "The maximum number of jobs that can run simultaneously when using a matrix job strategy. By default, GitHub will maximize the number of jobs run in parallel depending on the available runners on GitHub-hosted virtual machines.",
              "type": ["number", "string"]
            }
          },
          "required": ["matrix"],
          "additionalProperties": false
        },
        "continue-on-error": {
          "$comment": "https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idcontinue-on-error",
          "description": "Prevents a workflow run from failing when a job fails. Set to true to allow a workflow run to pass when this job fails.",
          "oneOf": [
            {
              "type": "boolean"
            },
            {
              "$ref": "#/definitions/expressionSyntax"
            }
          ]
        },
        "container": {
          "$comment": "https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idcontainer",
          "description": "A container to run any steps in a job that don't already specify a container. If you have steps that use both script and container actions, the container actions will run as sibling containers on the same network with the same volume mounts.\nIf you do not set a container, all steps will run directly on the host specified by runs-on unless a step refers to an action configured to run in a container.",
          "oneOf": [
            {
              "type": "string"
            },
            {
              "$ref": "#/definitions/container"
            }
          ]
        },
        "services": {
          "$comment": "https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idservices",
          "description": "Additional containers to host services for a job in a workflow. These are useful for creating databases or cache services like redis. The runner on the virtual machine will automatically create a network and manage the life cycle of the service containers.\nWhen you use a service container for a job or your step uses container actions, you don't need to set port information to access the service. Docker automatically exposes all ports between containers on the same network.\nWhen both the job and the action run in a container, you can directly reference the container by its hostname. The hostname is automatically mapped to the service name.\nWhen a step does not use a container action, you must access the service using localhost and bind the ports.",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/container"
          }
        },
        "concurrency": {
          "$comment": "https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idconcurrency",
          "description": "Concurrency ensures that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. The expression can use any context except for the secrets context. \nYou can also specify concurrency at the workflow level. \nWhen a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending. Any previously pending job or workflow in the concurrency group will be canceled. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true.",
          "oneOf": [
            {
              "type": "string"
            },
            {
              "$ref": "#/definitions/concurrency"
            }
          ]
        }
      },
      "required": ["runs-on"],
      "additionalProperties": false
    },
    "workflowDispatchInput": {
      "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/metadata-syntax-for-github-actions#inputsinput_id",
      "description": "A string identifier to associate with the input. The value of <input_id> is a map of the input's metadata. The <input_id> must be a unique identifier within the inputs object. The <input_id> must start with a letter or _ and contain only alphanumeric characters, -, or _.",
      "type": "object",
      "properties": {
        "description": {
          "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/metadata-syntax-for-github-actions#inputsinput_iddescription",
          "description": "A string description of the input parameter.",
          "type": "string"
        },
        "deprecationMessage": {
          "description": "A string shown to users using the deprecated input.",
          "type": "string"
        },
        "required": {
          "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/metadata-syntax-for-github-actions#inputsinput_idrequired",
          "description": "A boolean to indicate whether the action requires the input parameter. Set to true when the parameter is required.",
          "type": "boolean"
        },
        "default": {
          "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/metadata-syntax-for-github-actions#inputsinput_iddefault",
          "description": "A string representing the default value. The default value is used when an input parameter isn't specified in a workflow file."
        },
        "type": {
          "$comment": "https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onworkflow_dispatchinputsinput_idtype",
          "description": "A string representing the type of the input.",
          "type": "string",
          "enum": ["string", "choice", "boolean", "number", "environment"]
        },
        "options": {
          "$comment": "https://github.blog/changelog/2021-11-10-github-actions-input-types-for-manual-workflows",
          "description": "The options of the dropdown list, if the type is a choice.",
          "type": "array",
          "items": {
            "type": "string"
          },
          "minItems": 1
        }
      },
      "allOf": [
        {
          "if": {
            "properties": {
              "type": {
                "const": "string"
              }
            },
            "required": ["type"]
          },
          "then": {
            "properties": {
              "default": {
                "type": "string"
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "type": {
                "const": "boolean"
              }
            },
            "required": ["type"]
          },
          "then": {
            "properties": {
              "default": {
                "type": "boolean"
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "type": {
                "const": "number"
              }
            },
            "required": ["type"]
          },
          "then": {
            "properties": {
              "default": {
                "type": "number"
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "type": {
                "const": "environment"
              }
            },
            "required": ["type"]
          },
          "then": {
            "properties": {
              "default": {
                "type": "string"
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "type": {
                "const": "choice"
              }
            },
            "required": ["type"]
          },
          "then": {
            "required": ["options"]
          }
        }
      ],
      "required": ["description"],
      "additionalProperties": false
    }
  },
  "properties": {
    "name": {
      "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#name",
      "description": "The name of your workflow. GitHub displays the names of your workflows on your repository's actions page. If you omit this field, GitHub sets the name to the workflow's filename.",
      "type": "string"
    },
    "on": {
      "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#on",
      "description": "The name of the GitHub event that triggers the workflow. You can provide a single event string, array of events, array of event types, or an event configuration map that schedules a workflow or restricts the execution of a workflow to specific files, tags, or branch changes. For a list of available events, see https://help.github.com/en/github/automating-your-workflow-with-github-actions/events-that-trigger-workflows.",
      "oneOf": [
        {
          "$ref": "#/definitions/event"
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/definitions/event"
          },
          "minItems": 1
        },
        {
          "type": "object",
          "properties": {
            "branch_protection_rule": {
              "$comment": "https://docs.github.com/en/actions/learn-github-actions/events-that-trigger-workflows#branch_protection_rule",
              "$ref": "#/definitions/eventObject",
              "description": "Runs your workflow anytime the branch_protection_rule event occurs. More than one activity type triggers this event.",
              "properties": {
                "types": {
                  "$ref": "#/definitions/types",
                  "items": {
                    "type": "string",
                    "enum": ["created", "edited", "deleted"]
                  },
                  "default": ["created", "edited", "deleted"]
                }
              }
            },
            "check_run": {
              "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/events-that-trigger-workflows#check-run-event-check_run",
              "$ref": "#/definitions/eventObject",
              "description": "Runs your workflow anytime the check_run event occurs. More than one activity type triggers this event. For information about the REST API, see https://developer.github.com/v3/checks/runs.",
              "properties": {
                "types": {
                  "$ref": "#/definitions/types",
                  "items": {
                    "type": "string",
                    "enum": [
                      "created",
                      "rerequested",
                      "completed",
                      "requested_action"
                    ]
                  },
                  "default": [
                    "created",
                    "rerequested",
                    "completed",
                    "requested_action"
                  ]
                }
              }
            },
            "check_suite": {
              "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/events-that-trigger-workflows#check-suite-event-check_suite",
              "$ref": "#/definitions/eventObject",
              "description": "Runs your workflow anytime the check_suite event occurs. More than one activity type triggers this event. For information about the REST API, see https://developer.github.com/v3/checks/suites/.",
              "properties": {
                "types": {
                  "$ref": "#/definitions/types",
                  "items": {
                    "type": "string",
                    "enum": ["completed", "requested", "rerequested"]
                  },
                  "default": ["completed", "requested", "rerequested"]
                }
              }
            },
            "create": {
              "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/events-that-trigger-workflows#create-event-create",
              "$ref": "#/definitions/eventObject",
              "description": "Runs your workflow anytime someone creates a branch or tag, which triggers the create event. For information about the REST API, see https://developer.github.com/v3/git/refs/#create-a-reference."
            },
            "delete": {
              "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/events-that-trigger-workflows#delete-event-delete",
              "$ref": "#/definitions/eventObject",
              "description": "Runs your workflow anytime someone deletes a branch or tag, which triggers the delete event. For information about the REST API, see https://developer.github.com/v3/git/refs/#delete-a-reference."
            },
            "deployment": {
              "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/events-that-trigger-workflows#deployment-event-deployment",
              "$ref": "#/definitions/eventObject",
              "description": "Runs your workflow anytime someone creates a deployment, which triggers the deployment event. Deployments created with a commit SHA may not have a Git ref. For information about the REST API, see https://developer.github.com/v3/repos/deployments/."
            },
            "deployment_status": {
              "$comment": "https://docs.github.com/en/github/automating-your-workflow-with-github-actions/events-that-trigger-workflows",
              "$ref": "#/definitions/eventObject",
              "description": "Runs your workflow anytime a third party provides a deployment status, which triggers the deployment_status event. Deployments created with a commit SHA may not have a Git ref. For information about the REST API, see https://developer.github.com/v3/repos/deployments/#create-a-deployment-status."
            },
            "discussion": {
              "$comment": "https://docs.github.com/en/actions/reference/events-that-trigger-workflows#discussion",
              "$ref": "#/definitions/eventObject",
              "description": "Runs your workflow anytime the discussion event occurs. More than one activity type triggers this event. For information about the GraphQL API, see https://docs.github.com/en/graphql/guides/using-the-graphql-api-for-discussions",
              "properties": {
                "types": {
                  "$ref": "#/definitions/types",
                  "items": {
                    "type": "string",
                    "enum": [
                      "created",
                      "edited",
                      "deleted",
                      "transferred",
                      "pinned",
                      "unpinned",
                      "labeled",
                      "unlabeled",
                      "locked",
                      "unlocked",
                      "category_changed",
                      "answered",
                      "unanswered"
                    ]
                  },
                  "default": [
                    "created",
                    "edited",
                    "deleted",
                    "transferred",
                    "pinned",
                    "unpinned",
                    "labeled",
                    "unlabeled",
                    "locked",
                    "unlocked",
                    "category_changed",
                    "answered",
                    "unanswered"
                  ]
                }
              }
            },
            "discussion_comment": {
              "$comment": "https://docs.github.com/en/actions/reference/events-that-trigger-workflows#discussion_comment",
              "$ref": "#/definitions/eventObject",
              "description": "Runs your workflow anytime the discussion_comment event occurs. More than one activity type triggers this event. For information about the GraphQL API, see https://docs.github.com/en/graphql/guides/using-the-graphql-api-for-discussions",
              "properties": {
                "types": {
                  "$ref": "#/definitions/types",
                  "items": {
                    "type": "string",
                    "enum": ["created", "edited", "deleted"]
                  },
                  "default": ["created", "edited", "deleted"]
                }
              }
            },
            "fork": {
              "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/events-that-trigger-workflows#fork-event-fork",
              "$ref": "#/definitions/eventObject",
              "description": "Runs your workflow anytime when someone forks a repository, which triggers the fork event. For information about the REST API, see https://developer.github.com/v3/repos/forks/#create-a-fork."
            },
            "gollum": {
              "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/events-that-trigger-workflows#gollum-event-gollum",
              "$ref": "#/definitions/eventObject",
              "description": "Runs your workflow when someone creates or updates a Wiki page, which triggers the gollum event."
            },
            "issue_comment": {
              "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/events-that-trigger-workflows#issue-comment-event-issue_comment",
              "$ref": "#/definitions/eventObject",
              "description": "Runs your workflow anytime the issue_comment event occurs. More than one activity type triggers this event. For information about the REST API, see https://developer.github.com/v3/issues/comments/.",
              "properties": {
                "types": {
                  "$ref": "#/definitions/types",
                  "items": {
                    "type": "string",
                    "enum": ["created", "edited", "deleted"]
                  },
                  "default": ["created", "edited", "deleted"]
                }
              }
            },
            "issues": {
              "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/events-that-trigger-workflows#issues-event-issues",
              "$ref": "#/definitions/eventObject",
              "description": "Runs your workflow anytime the issues event occurs. More than one activity type triggers this event. For information about the REST API, see https://developer.github.com/v3/issues.",
              "properties": {
                "types": {
                  "$ref": "#/definitions/types",
                  "items": {
                    "type": "string",
                    "enum": [
                      "opened",
                      "edited",
                      "deleted",
                      "transferred",
                      "pinned",
                      "unpinned",
                      "closed",
                      "reopened",
                      "assigned",
                      "unassigned",
                      "labeled",
                      "unlabeled",
                      "locked",
                      "unlocked",
                      "milestoned",
                      "demilestoned"
                    ]
                  },
                  "default": [
                    "opened",
                    "edited",
                    "deleted",
                    "transferred",
                    "pinned",
                    "unpinned",
                    "closed",
                    "reopened",
                    "assigned",
                    "unassigned",
                    "labeled",
                    "unlabeled",
                    "locked",
                    "unlocked",
                    "milestoned",
                    "demilestoned"
                  ]
                }
              }
            },
            "label": {
              "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/events-that-trigger-workflows#label-event-label",
              "$ref": "#/definitions/eventObject",
              "description": "Runs your workflow anytime the label event occurs. More than one activity type triggers this event. For information about the REST API, see https://developer.github.com/v3/issues/labels/.",
              "properties": {
                "types": {
                  "$ref": "#/definitions/types",
                  "items": {
                    "type": "string",
                    "enum": ["created", "edited", "deleted"]
                  },
                  "default": ["created", "edited", "deleted"]
                }
              }
            },
            "merge_group": {
              "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/events-that-trigger-workflows#merge_group",
              "$ref": "#/definitions/eventObject",
              "description": "Runs your workflow when a pull request is added to a merge queue, which adds the pull request to a merge group. For information about the merge queue, see https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/incorporating-changes-from-a-pull-request/merging-a-pull-request-with-a-merge-queue .",
              "properties": {
                "types": {
                  "$ref": "#/definitions/types",
                  "items": {
                    "type": "string",
                    "enum": ["checks_requested"]
                  },
                  "default": ["checks_requested"]
                }
              }
            },
            "milestone": {
              "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/events-that-trigger-workflows#milestone-event-milestone",
              "$ref": "#/definitions/eventObject",
              "description": "Runs your workflow anytime the milestone event occurs. More than one activity type triggers this event. For information about the REST API, see https://developer.github.com/v3/issues/milestones/.",
              "properties": {
                "types": {
                  "$ref": "#/definitions/types",
                  "items": {
                    "type": "string",
                    "enum": ["created", "closed", "opened", "edited", "deleted"]
                  },
                  "default": [
                    "created",
                    "closed",
                    "opened",
                    "edited",
                    "deleted"
                  ]
                }
              }
            },
            "page_build": {
              "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/events-that-trigger-workflows#page-build-event-page_build",
              "$ref": "#/definitions/eventObject",
              "description": "Runs your workflow anytime someone pushes to a GitHub Pages-enabled branch, which triggers the page_build event. For information about the REST API, see https://developer.github.com/v3/repos/pages/."
            },
            "project": {
              "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/events-that-trigger-workflows#project-event-project",
              "$ref": "#/definitions/eventObject",
              "description": "Runs your workflow anytime the project event occurs. More than one activity type triggers this event. For information about the REST API, see https://developer.github.com/v3/projects/.",
              "properties": {
                "types": {
                  "$ref": "#/definitions/types",
                  "items": {
                    "type": "string",
                    "enum": [
                      "created",
                      "updated",
                      "closed",
                      "reopened",
                      "edited",
                      "deleted"
                    ]
                  },
                  "default": [
                    "created",
                    "updated",
                    "closed",
                    "reopened",
                    "edited",
                    "deleted"
                  ]
                }
              }
            },
            "project_card": {
              "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/events-that-trigger-workflows#project-card-event-project_card",
              "$ref": "#/definitions/eventObject",
              "description": "Runs your workflow anytime the project_card event occurs. More than one activity type triggers this event. For information about the REST API, see https://developer.github.com/v3/projects/cards.",
              "properties": {
                "types": {
                  "$ref": "#/definitions/types",
                  "items": {
                    "type": "string",
                    "enum": [
                      "created",
                      "moved",
                      "converted",
                      "edited",
                      "deleted"
                    ]
                  },
                  "default": [
                    "created",
                    "moved",
                    "converted",
                    "edited",
                    "deleted"
                  ]
                }
              }
            },
            "project_column": {
              "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/events-that-trigger-workflows#project-column-event-project_column",
              "$ref": "#/definitions/eventObject",
              "description": "Runs your workflow anytime the project_column event occurs. More than one activity type triggers this event. For information about the REST API, see https://developer.github.com/v3/projects/columns.",
              "properties": {
                "types": {
                  "$ref": "#/definitions/types",
                  "items": {
                    "type": "string",
                    "enum": ["created", "updated", "moved", "deleted"]
                  },
                  "default": ["created", "updated", "moved", "deleted"]
                }
              }
            },
            "public": {
              "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/events-that-trigger-workflows#public-event-public",
              "$ref": "#/definitions/eventObject",
              "description": "Runs your workflow anytime someone makes a private repository public, which triggers the public event. For information about the REST API, see https://developer.github.com/v3/repos/#edit."
            },
            "pull_request": {
              "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/events-that-trigger-workflows#pull-request-event-pull_request",
              "$ref": "#/definitions/ref",
              "description": "Runs your workflow anytime the pull_request event occurs. More than one activity type triggers this event. For information about the REST API, see https://developer.github.com/v3/pulls.\nNote: Workflows do not run on private base repositories when you open a pull request from a forked repository.\nWhen you create a pull request from a forked repository to the base repository, GitHub sends the pull_request event to the base repository and no pull request events occur on the forked repository.\nWorkflows don't run on forked repositories by default. You must enable GitHub Actions in the Actions tab of the forked repository.\nThe permissions for the GITHUB_TOKEN in forked repositories is read-only. For more information about the GITHUB_TOKEN, see https://help.github.com/en/articles/virtual-environments-for-github-actions.",
              "properties": {
                "types": {
                  "$ref": "#/definitions/types",
                  "items": {
                    "type": "string",
                    "enum": [
                      "assigned",
                      "unassigned",
                      "labeled",
                      "unlabeled",
                      "opened",
                      "edited",
                      "closed",
                      "reopened",
                      "synchronize",
                      "converted_to_draft",
                      "ready_for_review",
                      "locked",
                      "unlocked",
                      "milestoned",
                      "demilestoned",
                      "review_requested",
                      "review_request_removed",
                      "auto_merge_enabled",
                      "auto_merge_disabled",
                      "enqueued",
                      "dequeued"
                    ]
                  },
                  "default": ["opened", "synchronize", "reopened"]
                }
              },
              "patternProperties": {
                "^(branche|tag|path)s(-ignore)?$": {
                  "type": "array"
                }
              },
              "additionalProperties": false
            },
            "pull_request_review": {
              "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/events-that-trigger-workflows#pull-request-review-event-pull_request_review",
              "$ref": "#/definitions/eventObject",
              "description": "Runs your workflow anytime the pull_request_review event occurs. More than one activity type triggers this event. For information about the REST API, see https://developer.github.com/v3/pulls/reviews.\nNote: Workflows do not run on private base repositories when you open a pull request from a forked repository.\nWhen you create a pull request from a forked repository to the base repository, GitHub sends the pull_request event to the base repository and no pull request events occur on the forked repository.\nWorkflows don't run on forked repositories by default. You must enable GitHub Actions in the Actions tab of the forked repository.\nThe permissions for the GITHUB_TOKEN in forked repositories is read-only. For more information about the GITHUB_TOKEN, see https://help.github.com/en/articles/virtual-environments-for-github-actions.",
              "properties": {
                "types": {
                  "$ref": "#/definitions/types",
                  "items": {
                    "type": "string",
                    "enum": ["submitted", "edited", "dismissed"]
                  },
                  "default": ["submitted", "edited", "dismissed"]
                }
              }
            },
            "pull_request_review_comment": {
              "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/events-that-trigger-workflows#pull-request-review-comment-event-pull_request_review_comment",
              "$ref": "#/definitions/eventObject",
              "description": "Runs your workflow anytime a comment on a pull request's unified diff is modified, which triggers the pull_request_review_comment event. More than one activity type triggers this event. For information about the REST API, see https://developer.github.com/v3/pulls/comments.\nNote: Workflows do not run on private base repositories when you open a pull request from a forked repository.\nWhen you create a pull request from a forked repository to the base repository, GitHub sends the pull_request event to the base repository and no pull request events occur on the forked repository.\nWorkflows don't run on forked repositories by default. You must enable GitHub Actions in the Actions tab of the forked repository.\nThe permissions for the GITHUB_TOKEN in forked repositories is read-only. For more information about the GITHUB_TOKEN, see https://help.github.com/en/articles/virtual-environments-for-github-actions.",
              "properties": {
                "types": {
                  "$ref": "#/definitions/types",
                  "items": {
                    "type": "string",
                    "enum": ["created", "edited", "deleted"]
                  },
                  "default": ["created", "edited", "deleted"]
                }
              }
            },
            "pull_request_target": {
              "$comment": "https://docs.github.com/en/actions/reference/events-that-trigger-workflows#pull_request_target",
              "$ref": "#/definitions/ref",
              "description": "This event is similar to pull_request, except that it runs in the context of the base repository of the pull request, rather than in the merge commit. This means that you can more safely make your secrets available to the workflows triggered by the pull request, because only workflows defined in the commit on the base repository are run. For example, this event allows you to create workflows that label and comment on pull requests, based on the contents of the event payload.",
              "properties": {
                "types": {
                  "$ref": "#/definitions/types",
                  "items": {
                    "type": "string",
                    "enum": [
                      "assigned",
                      "unassigned",
                      "labeled",
                      "unlabeled",
                      "opened",
                      "edited",
                      "closed",
                      "reopened",
                      "synchronize",
                      "converted_to_draft",
                      "ready_for_review",
                      "locked",
                      "unlocked",
                      "review_requested",
                      "review_request_removed",
                      "auto_merge_enabled",
                      "auto_merge_disabled"
                    ]
                  },
                  "default": ["opened", "synchronize", "reopened"]
                }
              },
              "patternProperties": {
                "^(branche|tag|path)s(-ignore)?$": {}
              },
              "additionalProperties": false
            },
            "push": {
              "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/events-that-trigger-workflows#push-event-push",
              "$ref": "#/definitions/ref",
              "description": "Runs your workflow when someone pushes to a repository branch, which triggers the push event.\nNote: The webhook payload available to GitHub Actions does not include the added, removed, and modified attributes in the commit object. You can retrieve the full commit object using the REST API. For more information, see https://developer.github.com/v3/repos/commits/#get-a-single-commit.",
              "patternProperties": {
                "^(branche|tag|path)s(-ignore)?$": {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                }
              },
              "additionalProperties": false
            },
            "registry_package": {
              "$comment": "https://help.github.com/en/actions/reference/events-that-trigger-workflows#registry-package-event-registry_package",
              "$ref": "#/definitions/eventObject",
              "description": "Runs your workflow anytime a package is published or updated. For more information, see https://help.github.com/en/github/managing-packages-with-github-packages.",
              "properties": {
                "types": {
                  "$ref": "#/definitions/types",
                  "items": {
                    "type": "string",
                    "enum": ["published", "updated"]
                  },
                  "default": ["published", "updated"]
                }
              }
            },
            "release": {
              "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/events-that-trigger-workflows#release-event-release",
              "$ref": "#/definitions/eventObject",
              "description": "Runs your workflow anytime the release event occurs. More than one activity type triggers this event. For information about the REST API, see https://developer.github.com/v3/repos/releases/ in the GitHub Developer documentation.",
              "properties": {
                "types": {
                  "$ref": "#/definitions/types",
                  "items": {
                    "type": "string",
                    "enum": [
                      "published",
                      "unpublished",
                      "created",
                      "edited",
                      "deleted",
                      "prereleased",
                      "released"
                    ]
                  },
                  "default": [
                    "published",
                    "unpublished",
                    "created",
                    "edited",
                    "deleted",
                    "prereleased",
                    "released"
                  ]
                }
              }
            },
            "status": {
              "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/events-that-trigger-workflows#status-event-status",
              "$ref": "#/definitions/eventObject",
              "description": "Runs your workflow anytime the status of a Git commit changes, which triggers the status event. For information about the REST API, see https://developer.github.com/v3/repos/statuses/."
            },
            "watch": {
              "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/events-that-trigger-workflows#watch-event-watch",
              "$ref": "#/definitions/eventObject",
              "description": "Runs your workflow anytime the watch event occurs. More than one activity type triggers this event. For information about the REST API, see https://developer.github.com/v3/activity/starring/."
            },
            "workflow_call": {
              "$comment": "https://docs.github.com/en/actions/learn-github-actions/events-that-trigger-workflows#workflow_call",
              "description": "Allows workflows to be reused by other workflows.",
              "properties": {
                "inputs": {
                  "$comment": "https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#onworkflow_callinputs",
                  "description": "When using the workflow_call keyword, you can optionally specify inputs that are passed to the called workflow from the caller workflow.",
                  "type": "object",
                  "patternProperties": {
                    "^[_a-zA-Z][a-zA-Z0-9_-]*$": {
                      "$comment": "https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#inputsinput_id",
                      "description": "A string identifier to associate with the input. The value of <input_id> is a map of the input's metadata. The <input_id> must be a unique identifier within the inputs object. The <input_id> must start with a letter or _ and contain only alphanumeric characters, -, or _.",
                      "type": "object",
                      "properties": {
                        "description": {
                          "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/metadata-syntax-for-github-actions#inputsinput_iddescription",
                          "description": "A string description of the input parameter.",
                          "type": "string"
                        },
                        "deprecationMessage": {
                          "description": "A string shown to users using the deprecated input.",
                          "type": "string"
                        },
                        "required": {
                          "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/metadata-syntax-for-github-actions#inputsinput_idrequired",
                          "description": "A boolean to indicate whether the action requires the input parameter. Set to true when the parameter is required.",
                          "type": "boolean"
                        },
                        "type": {
                          "$comment": "https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#onworkflow_callinput_idtype",
                          "description": "Required if input is defined for the on.workflow_call keyword. The value of this parameter is a string specifying the data type of the input. This must be one of: boolean, number, or string.",
                          "type": "string",
                          "enum": ["boolean", "number", "string"]
                        },
                        "default": {
                          "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/metadata-syntax-for-github-actions#inputsinput_iddefault",
                          "description": "The default value is used when an input parameter isn't specified in a workflow file.",
                          "type": ["boolean", "number", "string"]
                        }
                      },
                      "required": ["type"],
                      "additionalProperties": false
                    }
                  },
                  "additionalProperties": false
                },
                "secrets": {
                  "$comment": "https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#onworkflow_callsecrets",
                  "description": "A map of the secrets that can be used in the called workflow. Within the called workflow, you can use the secrets context to refer to a secret.",
                  "patternProperties": {
                    "^[_a-zA-Z][a-zA-Z0-9_-]*$": {
                      "$comment": "https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#onworkflow_callsecretssecret_id",
                      "description": "A string identifier to associate with the secret.",
                      "properties": {
                        "description": {
                          "description": "A string description of the secret parameter.",
                          "type": "string"
                        },
                        "required": {
                          "$comment": "https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#onworkflow_callsecretssecret_idrequired",
                          "description": "A boolean specifying whether the secret must be supplied.",
                          "type": "boolean"
                        }
                      },
                      "required": ["required"],
                      "additionalProperties": false
                    }
                  },
                  "additionalProperties": false
                }
              }
            },
            "workflow_dispatch": {
              "$comment": "https://github.blog/changelog/2020-07-06-github-actions-manual-triggers-with-workflow_dispatch/",
              "description": "You can now create workflows that are manually triggered with the new workflow_dispatch event. You will then see a 'Run workflow' button on the Actions tab, enabling you to easily trigger a run.",
              "properties": {
                "inputs": {
                  "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/metadata-syntax-for-github-actions#inputs",
                  "description": "Input parameters allow you to specify data that the action expects to use during runtime. GitHub stores input parameters as environment variables. Input ids with uppercase letters are converted to lowercase during runtime. We recommended using lowercase input ids.",
                  "type": "object",
                  "patternProperties": {
                    "^[_a-zA-Z][a-zA-Z0-9_-]*$": {
                      "$ref": "#/definitions/workflowDispatchInput"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            "workflow_run": {
              "$comment": "https://docs.github.com/en/actions/reference/events-that-trigger-workflows#workflow_run",
              "$ref": "#/definitions/eventObject",
              "description": "This event occurs when a workflow run is requested or completed, and allows you to execute a workflow based on the finished result of another workflow. For example, if your pull_request workflow generates build artifacts, you can create a new workflow that uses workflow_run to analyze the results and add a comment to the original pull request.",
              "properties": {
                "types": {
                  "$ref": "#/definitions/types",
                  "items": {
                    "type": "string",
                    "enum": ["requested", "completed", "in_progress"]
                  },
                  "default": ["requested", "completed"]
                },
                "workflows": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "minItems": 1
                }
              },
              "patternProperties": {
                "^branches(-ignore)?$": {}
              }
            },
            "repository_dispatch": {
              "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/events-that-trigger-workflows#external-events-repository_dispatch",
              "$ref": "#/definitions/eventObject",
              "description": "You can use the GitHub API to trigger a webhook event called repository_dispatch when you want to trigger a workflow for activity that happens outside of GitHub. For more information, see https://developer.github.com/v3/repos/#create-a-repository-dispatch-event.\nTo trigger the custom repository_dispatch webhook event, you must send a POST request to a GitHub API endpoint and provide an event_type name to describe the activity type. To trigger a workflow run, you must also configure your workflow to use the repository_dispatch event."
            },
            "schedule": {
              "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/events-that-trigger-workflows#scheduled-events-schedule",
              "description": "You can schedule a workflow to run at specific UTC times using POSIX cron syntax (https://pubs.opengroup.org/onlinepubs/9699919799/utilities/crontab.html#tag_20_25_07). Scheduled workflows run on the latest commit on the default or base branch. The shortest interval you can run scheduled workflows is once every 5 minutes.\nNote: GitHub Actions does not support the non-standard syntax @yearly, @monthly, @weekly, @daily, @hourly, and @reboot.\nYou can use crontab guru (https://crontab.guru/). to help generate your cron syntax and confirm what time it will run. To help you get started, there is also a list of crontab guru examples (https://crontab.guru/examples.html).",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "cron": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              },
              "minItems": 1
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "env": {
      "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#env",
      "$ref": "#/definitions/env",
      "description": "A map of environment variables that are available to all jobs and steps in the workflow."
    },
    "defaults": {
      "$comment": "https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#defaults",
      "$ref": "#/definitions/defaults",
      "description": "A map of default settings that will apply to all jobs in the workflow."
    },
    "concurrency": {
      "$comment": "https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#concurrency",
      "description": "Concurrency ensures that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. The expression can use any context except for the secrets context. \nYou can also specify concurrency at the workflow level. \nWhen a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending. Any previously pending job or workflow in the concurrency group will be canceled. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true.",
      "oneOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/definitions/concurrency"
        }
      ]
    },
    "jobs": {
      "$comment": "https://help.github.com/en/github/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobs",
      "description": "A workflow run is made up of one or more jobs. Jobs run in parallel by default. To run jobs sequentially, you can define dependencies on other jobs using the jobs.<job_id>.needs keyword.\nEach job runs in a fresh instance of the virtual environment specified by runs-on.\nYou can run an unlimited number of jobs as long as you are within the workflow usage limits. For more information, see https://help.github.com/en/github/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#usage-limits.",
      "type": "object",
      "patternProperties": {
        "^[_a-zA-Z][a-zA-Z0-9_-]*$": {
          "oneOf": [
            {
              "$ref": "#/definitions/normalJob"
            },
            {
              "$ref": "#/definitions/reusableWorkflowCallJob"
            }
          ]
        }
      },
      "minProperties": 1,
      "additionalProperties": false
    },
    "run-name": {
      "$comment": "https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#run-name",
      "description": "The name for workflow runs generated from the workflow. GitHub displays the workflow run name in the list of workflow runs on your repository's 'Actions' tab.",
      "type": "string"
    },
    "permissions": {
      "$ref": "#/definitions/permissions"
    }
  },
  "required": ["on", "jobs"],
  "type": "object"
}
</file>

<file path="examples/github-workflow/github-workflow.schema.ncl">
# DO NOT EDIT
# This file was automatically generated using json-schema-to-nickel
let js2n = {
  Always
    | doc m%"
        A contract that always succeeds. The same as `Dyn`, but with a more JSON-schema name.

        # Examples

        ```nickel multiline
        "foo" | Always

        3 | Always
        ```
      "%
    = Dyn,
  Const
    | Dyn -> Dyn
    | doc m%"
        A more eager version of `std.contract.Equal`.

        # Examples

        ```nickel multiline
        5 | Const 5

        3 | Const 5
        # => error
        ```
      "%
    = fun expected =>
      std.contract.from_validator (fun value =>
        if value == expected then
          'Ok
        else
          'Error { message = "expected %{std.to_string expected}" }
      ),
  Enum
    | Array Dyn -> Dyn
    | doc m%"
        `Enum values x` succeeds if and only if `x` is equal to one of the elements of `values`.

        # Examples

        ```nickel multiline
        "no" | Enum [false, "false", "no", "off"]

        "yes" | Enum [false, "false", "no", "off"]
        # => error
        ```
      "%
    = fun variants =>
      std.contract.from_validator (fun value =>
        let check_equal = fun input variant =>
          (input == variant)
          || (
            (std.is_enum input)
            && (
              ((std.string.from_enum input) == variant)
                | Bool
            )
          )
        in
        if std.array.any (check_equal value) variants then
          'Ok
        else
          'Error {
            message = "expected one of %{std.serialize 'Json variants}"
          }
      ),
  IfThenElse
    | Dyn -> Dyn -> Dyn -> Dyn
    | doc m%"
        `IfThenElse iph zen els` checks the `iph` contract (eagerly). If that
        succeeds, it checks the `zen` contract and otherwise checks the `els`
        contract.

        Only the eager part of the `iph` contract is used to decide which of the
        other contracts is applied. The lazy part of the `iph` contract will be
        applied if the eager part succeeds.

        # Examples

        ```nickel multiline
        6 | IfThenElse Number (number.MultipleOf 2) String

        "hi" | IfThenElse Number (number.MultipleOf 2) String

        true | IfThenElse Number (number.MultipleOf 2) String
        # => error

        # The `zen` branch gets the value that was normalized by TagOrString
        "hi" | IfThenElse std.enum.TagOrString (std.contract.Equal 'hi) Number
        ```
      "%
    = fun iph zen els =>
      std.contract.custom (fun label value =>
        (match {
          'Ok v =>
            std.contract.check zen label v,
          'Error _ =>
            std.contract.check els label value,
        }
        ) (std.contract.check iph label value)
      ),
  Never
    | doc m%"
        A contract that always fails.

        # Examples

        ```nickel multiline
        "foo" | Never
        # => error

        3 | Never
        # => error
      "%
    = std.contract.from_predicate (fun _ => false),
  Null
    | doc m%"
        A contract asserting that a value is null.

        # Examples

        ```nickel multiline
        null | Null

        "foo" | Null
        # => error
      "%
    = std.contract.from_predicate ((fun x0 x1 => x0 == x1) null),
  Nullable
    : Dyn -> Dyn
    | doc m%"
        For a contract `C`, `Nullable C` returns a contract that allows either `C` or a null value.

        # Examples

        ```nickel multiline
        1 | Nullable Number

        null | Nullable Number

        "1" | Nullable Number
        # => error
        ```
      "%
    = fun Contract =>
      std.contract.custom (fun label value =>
        if value == null then
          'Ok value
        else
          std.contract.check Contract label value
      ),
  OneOf
    | Array Dyn -> Dyn
    | doc m%"
        Checks that exactly one of a list of contracts succeeds.

        # Examples

        ```nickel multiline
        "hi" | OneOf [Number, String, Bool]

        "hi" | OneOf [Number, String, std.enum.TagOrString]
        # => error: 2 of the contracts passed

        "hi" | OneOf [Number, std.enum.TagOrString]
        # => 'hi
        ```
      "%
    = fun contracts =>
      std.contract.custom (fun label value =>
        (match {
          'Count n =>
            'Error {
              message = "%{std.to_string
                            n} of the contracts passed, expected precisely one to pass"
            },
          'Ok v =>
            'Ok v,
        }
        ) (
          std.array.fold_right
            (fun ctr acc =>
              (match {
                'Ok val =>
                  (match {
                    'Count 0 =>
                      'Ok val,
                    'Count n =>
                      'Count (n + 1),
                    'Ok _ =>
                      'Count 2,
                  }
                  ) acc,
                'Error e =>
                  acc,
              }
              ) (std.contract.check ctr label value)
            )
            ('Count 0)
            contracts
        )
      ),
  array = {
    ArrayOf
      | Dyn -> Dyn
      | doc m%"
              An eager version of `Array`. `value | ArrayOf C` will succeed if `value` is an array and all of
              its elements satisfy the eager part of the contract `C`.

              # Examples

              ```nickel multiline
              [1, 2, 3] | ArrayOf Number
              # => [1, 2, 3]

              [1, 2, 3] | ArrayOf String
              # => error

              ["a", "b", "c"] | ArrayOf std.enum.TagOrString
              # => ['a, 'b, 'c]
              ```
            "%
      = fun ctr =>
        std.contract.custom (fun label value =>
          if !(std.is_array value) then
            'Error { message = "expected an array" }
          else
            std.array.try_fold_left
              (fun acc elt =>
                (match {
                  'Ok v =>
                    'Ok (acc @ [v]),
                  'Error e =>
                    'Error e,
                }
                ) (std.contract.check ctr label elt)
              )
              []
              value
        ),
    Contains
      | Dyn -> Dyn
      | doc m%"
              A contract checking that an array contains something satisfying another contract.

              For example, `Contains Number` is a contract checking that the value is an array
              and that it contains at least one number.

              This is an eager contract, and it assumes that the inputs are also eager.
              Any lazy parts of the inputs will be ignored.

              # Examples

              ```nickel multiline
              ["hi", true, 1] | Contains Bool
              # => ["hi", true, 1]

              ["hi", true, 1] | Contains (Array Bool)
              # => error

              # Lazy parts of the inner contract are ignored: "hi" does not get transformed
              # to 'hi.
              ["hi", true, 1] | Contains std.enum.TagOrString
              # => ["hi", true, 1]
              ```
            "%
      = fun contract =>
        std.contract.custom (fun label value =>
          if !(std.is_array value) then
            'Error { message = "expected an array" }
          else
            let good_elt = fun elt =>
              (match { 'Ok _ => true, 'Error _ => false, }) (std.contract.check contract label elt)
            in
            if std.array.any good_elt value then
              'Ok value
            else
              'Error { message = "no elements matched" }
        ),
    Items
      | Array Dyn -> Dyn -> Dyn
      | doc m%"
              A contract checking that the first few elements of an array satisfy
              specific contracts, and the remaining elements satisfy another contract.
              For example, `Items [C1 C2] C3` is a contract checking that the value is
              an array, that its first two elements (if present) satisfy `C1` and `C2`
              respectively, and that any other elements satisfy `C3`.

              # Examples

              ```nickel multiline
              [1, 2, "foo", "bar"] | Items [Number, Number] String

              # The value is allowed to be shorter than the list of contracts.
              [1] | Items [Number, Number] String

              [1, "foo", "bar"] | Items [Number, Number] String
              # => error

              # Inner contracts are propagated, but note that the overall `Items` contract
              # is eager if and only if all the contracts you pass in are eager.
              [1, { foo = "str"}, "foo", "bar"] | Items [Number, { foo | Number }] String
              # => error
              ```
            "%
      = fun elt_contracts rest =>
        std.contract.custom (fun label value =>
          if !(std.is_array value) then
            'Error { message = "expected an array" }
          else
            let length_to_check =
              std.number.min
                (std.array.length elt_contracts)
                (std.array.length value)
            in
            let { left, right, } = std.array.split_at length_to_check value
            in
            (match {
              'Error e =>
                'Error e,
              'Ok left_with_contracts =>
                std.array.try_fold_left
                  (fun acc elt =>
                    (match {
                      'Ok v =>
                        'Ok (acc @ [v]),
                      'Error e =>
                        'Error e,
                    }
                    ) (std.contract.check rest label elt)
                  )
                  left_with_contracts
                  right,
            }
            ) (
              std.array.try_fold_left
                (fun acc =>
                  match {
                    'Ok v =>
                      'Ok (acc @ [v]),
                    'Error e =>
                      'Error e,
                  }
                )
                []
                (
                  std.array.zip_with
                    (fun contract elt =>
                      std.contract.check contract label elt
                    )
                    elt_contracts
                    left
                )
            )
        ),
    MaxItems
      : Number -> Dyn
      | doc m%"
              A contract that checks whether an array has at most a certain number of items.

              # Examples

              ```nickel multiline
              [1, 2, 3] | MaxItems 3

              [1, 2, 3] | MaxItems 2
              # => error
            "%
      = fun n =>
        std.contract.from_predicate (fun arr =>
          (std.is_array arr)
          && ((std.array.length (arr | Array Dyn)) <= n)
        ),
    MinItems
      : Number -> Dyn
      | doc m%"
              A contract that checks whether an array has at least a certain number of items.

              # Examples

              ```nickel multiline
              [1, 2, 3] | MinItems 3

              [1, 2, 3] | MinItems 4
              # => error
              ```
            "%
      = fun n =>
        std.contract.from_predicate (fun arr =>
          (std.is_array arr)
          && ((std.array.length (arr | Array Dyn)) >= n)
        ),
    UniqueItems
      | doc m%"
              Checks that the elements of an array are pairwise distinct.

              # Examples

              ```nickel multiline
              [1, 2, "3"] | UniqueItems

              [1, 3, 2, 3] | UniqueItems
              # => error: duplicate found: 3
              ```
            "%
      =
        let find_duplicate
          : Array Dyn -> {
            has_duplicate : Bool,
            duplicate : Dyn,
            seen : { _ : Bool }
          }
          =
            std.array.fold_right
              (fun elt acc =>
                if acc.has_duplicate then
                  acc
                else
                  let index = std.serialize 'Json elt in
                  if std.record.has_field index acc.seen then
                    {
                      duplicate = elt,
                      has_duplicate = true,
                      seen = acc.seen
                    }
                  else
                    {
                      duplicate = null,
                      has_duplicate = false,
                      seen = std.record.insert index true acc.seen
                    }
              )
              { duplicate = null, has_duplicate = false, seen = {} }
        in
        std.contract.from_validator (fun x =>
          if !(std.is_array x) then
            'Error { message = "expected an array" }
          else
            let { has_duplicate, duplicate, .. } = find_duplicate x in
            if has_duplicate then
              'Error {
                message = "duplicate found: %{std.serialize
                                    'Json
                                    duplicate}"
              }
            else
              'Ok
        )
  },
  number =
    let from_predicate
      | (Number -> Bool) -> String -> Dyn
      = fun pred msg =>
        std.contract.from_validator (fun value =>
          if !(std.is_number value) then
            'Error { message = "expected a number" }
          else if pred (value | Number) then
            'Ok
          else
            'Error { message = msg }
        )
    in
    {
      ExclusiveMaximum
        | Number -> Dyn
        | doc m%"
                `ExclusiveMaximum n` is a contract checking that a number is at strictly less than `n`.

                # Examples

                ```nickel multiline
                5 | ExclusiveMaximum 5.1

                5 | ExclusiveMaximum 5
                # => error: expected an exclusive maximum of 5

                "5" | ExclusiveMaximum 5
                # => error: expected a number
                ```
              "%
        = fun limit =>
          from_predicate
            (fun x => x < limit)
            "expected an exclusive maximum of %{std.string.from_number
                      limit}",
      ExclusiveMinimum
        | Number -> Dyn
        | doc m%"
                `ExclusiveMinimum n` is a contract checking that a number is at strictly more than `n`.

                # Examples

                ```nickel multiline
                5 | ExclusiveMinimum 4.9

                5 | ExclusiveMinimum 5
                # => error: expected an exclusive minimum of 5

                "5" | ExclusiveMinimum 5
                # => error: expected a number
                ```
              "%
        = fun limit =>
          from_predicate
            (fun x => x > limit)
            "expected an exclusive minimum of %{std.string.from_number
                      limit}",
      Maximum
        | Number -> Dyn
        | doc m%"
                `Maximum n` is a contract checking that a number is at most `n`.

                # Examples

                ```nickel multiline
                5 | Maximum 5

                5 | Maximum 4
                # => error: expected a maximum of 4

                "5" | Maximum 5
                # => error: expected a number
                ```
              "%
        = fun limit =>
          from_predicate
            (fun x => x <= limit)
            "expected a maximum of %{std.string.from_number limit}",
      Minimum
        | Number -> Dyn
        | doc m%"
                `Minimum n` is a contract checking that a number is at least `n`.

                # Examples

                ```nickel multiline
                5 | Minimum 5

                5 | Minimum 6
                # => error: expected a minimum of 6

                "5" | Minimum 6
                # => error: expected a number
                ```
              "%
        = fun limit =>
          from_predicate
            (fun x => x >= limit)
            "expected a minimum of %{std.string.from_number limit}",
      MultipleOf
        | Number -> Dyn
        | doc m%"
                `MultipleOf n` is a contract checking whether a value is a multiple of `n`.

                # Examples

                ```nickel multiline
                4 | MultipleOf 2

                "4" | MultipleOf 2
                # => error: expected a number

                4 | MultipleOf 3
                # => error: expected a multiple of 3

                4 | MultipleOf 0
                # => error: expected a multiple of 0
                ```
              "%
        = fun n =>
          std.contract.from_validator (fun value =>
            if !(std.is_number value) then
              'Error { message = "expected a number" }
            else if n == 0 then
              'Error { message = "expected a multiple of 0" }
            else if std.number.is_integer (value / n) then
              'Ok
            else
              'Error {
                message = "expected a multiple of %{std.string.from_number
                                      n}"
              }
          )
    },
  record =
    let ErrData = {
      blame_location | Dyn | optional,
      message | String | optional,
      notes | Array String | optional
    }
    in
    {
      DependentContracts
        | { _ | Dyn } -> Dyn
        | doc m%"
                A contract for asserting that if some fields are present then the entire
                record satisfies a contract.

                Specifically, `DependentContracts { foo = C }` is a contract asserting that
                the value is a record, and if the value contains a field named `foo` then
                the entire record satisfies the contract `C`.

                `DependentContracts` calls `std.contract.check` for each of the provided
                contracts. In particular, if `C` is fully eager then so is
                `DependentContracts { foo = C }`.

                # Examples

                ```nickel multiline
                { foo = 1, bar = 2 } | DependentContracts { foo = { bar | Number, .. } }

                { foo = 1, bar = 2 } | DependentContracts { foo = { bar | Number } }
                # => error: extra field `foo`

                # This one doesn't fail: the inner contract never gets triggered because there's no `baz` field
                { foo = 1, bar = 2 } | DependentContracts { baz = { bar | Number } }

                1 | DependentContracts { baz = { bar | Number } }
                # => error: expected a record
                ```
              "%
        = fun deps =>
          std.contract.custom (fun label value =>
            if !(std.is_record value) then
              'Error { message = "expected a record" }
            else
              std.array.try_fold_left
                (fun acc { field, value = contract, } =>
                  if std.record.has_field field value then
                    std.contract.check contract label acc
                  else
                    'Ok acc
                )
                value
                (std.record.to_array deps)
          ),
      DependentFields
        | { _ | Array String } -> Dyn
        | doc m%"
                A contract for asserting that if some fields are present, other fields are
                also present.

                Specifically, `DependentFields { foo = ["bar", "baz"] }` is a contract
                asserting that if the field `foo` is present then the fields `bar` and
                `baz` are also present. This corresponds to the part of JSON schema's
                [dependencies](https://json-schema.org/draft-07/draft-handrews-json-schema-validation-01#rfc.section.6.5.7)
                keyword in which the values are arrays.

                This is an eager contract.

                ```nickel multiline
                { foo = 1, bar = 2 } | DependentFields { foo = ["bar"] }

                { foo = 1, baz = 2 } | DependentFields { foo = ["bar"] }
                # => error: expected field bar

                { baz = 2 } | DependentFields { foo = ["bar"] }
                ```
              "%
        = fun dependencies =>
          std.contract.from_validator (fun value =>
            if !(std.is_record value) then
              'Error { message = "expected a record" }
            else
              let must_have_fields
                : Array String -> { _ : Dyn } -> [| 'Ok, 'Error ErrData |]
                = fun fields x =>
                  std.array.fold_right
                    (fun field acc =>
                      if !(std.record.has_field field x) then
                        'Error (
                          { message = "expected field %{field}" }
                            | ErrData
                        )
                      else
                        acc
                    )
                    'Ok
                    fields
              in
              std.array.fold_right
                (fun { field, value = dependent_fields, } acc =>
                  if std.record.has_field field value then
                    (match {
                      'Ok =>
                        acc,
                      'Error e =>
                        'Error (
                          e
                          & {
                            notes = [
                              "because field %{field} was present"
                            ]
                          }
                        ),
                    }
                    ) (must_have_fields dependent_fields value)
                  else
                    acc
                )
                'Ok
                (std.record.to_array dependencies)
          ),
      MaxProperties
        | Number -> Dyn
        | doc m%"
                A contract that checks whether a record has at most a certain number of properties.

                # Examples

                ```nickel multiline
                { foo = 1, bar = 2 } | MaxProperties 2

                { foo = 1, bar = 2 } | MaxProperties 1
                # => error: expected a record with at most 1 fields
                ```
              "%
        = fun n =>
          std.contract.from_validator (fun value =>
            if !(std.is_record value) then
              'Error { message = "expected a record" }
            else if (std.record.length value) > n then
              'Error {
                message = "expected a record with at most %{std.string.from_number
                                    n} fields"
              }
            else
              'Ok
          ),
      MinProperties
        | Number -> Dyn
        | doc m%"
                A contract that checks whether a record has at least a certain number of properties.

                # Examples

                ```nickel multiline
                { foo = 1, bar = 2 } | MinProperties 2

                { foo = 1, bar = 2 } | MinProperties 3
                # => error: expected a record with at least 3 fields
                ```
              "%
        = fun n =>
          std.contract.from_validator (fun value =>
            if !(std.is_record value) then
              'Error { message = "expected a record" }
            else if (std.record.length value) < n then
              'Error {
                message = "expected a record with at least %{std.string.from_number
                                    n} fields"
              }
            else
              'Ok
          ),
      PropertyNames
        | Dyn -> Dyn
        | doc m%"
                `PropertyNames C` is a contract asserting that a value is a record and all of
                its field names satisfy the contract `C`.

                `PropertyNames C` is an eager contract for any `C`. Any lazy parts of `C` will
                be ignored.

                ```nickel multiline
                { foo = 1 } | PropertyNames std.string.NonEmpty

                { "1" = 1 } | PropertyNames std.string.NumberLiteral

                { foo = 1 } | PropertyNames std.string.NumberLiteral
                # => error: invalid number literal
                ```
              "%
        = fun contract =>
          std.contract.custom (fun label value =>
            if !(std.is_record value) then
              'Error { message = "expected a record" }
            else
              std.array.try_fold_left
                (fun acc field_name =>
                  (match {
                    'Ok _ =>
                      'Ok value,
                    'Error e =>
                      'Error e,
                  }
                  ) (std.contract.check contract label field_name)
                )
                ('Ok value)
                (std.record.fields value)
          ),
      Record
        | {
          additional | [| 'None, 'Some Dyn |],
          patterns | { _ | Dyn },
          properties | { _ | Dyn },
          required | { _ | Dyn }
        } -> Dyn
        | doc m%"
                A contract for checking JSON Schema object properties.

                In `Record { properties, required, patterns, additional }`, properties and patterns
                should be dicts containing contracts as values. These contracts will be
                applied to the appropriate fields of your record. `additional` can be
                `None` (in which case fields not matching `properties` or `patterns` are
                forbidden) or `Some contract` (in which case `contract` will be applied to
                every field not matched by `properties` and `patterns`).

                The contract returned by `Record` is sort of eager: it will call
                `std.contract.check` on the appropriate field values, and then it will
                propagate any lazy contracts returned by `std.contract.check`. This makes
                `Record` a little more eager than standard record contracts, and if all
                the contracts you provide are eager then `Record` will be fully eager.

                Cf. [https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-validation-01#section-6.5]

                # Examples

                ```nickel multiline
                { foo = 1 } | Record { properties = { foo = Number }, required = {}, patterns = {}, additional = 'None }
                # => { foo = 1 }

                # Properties aren't required to be present.
                { } | Record { properties = { foo = Number }, required = {}, patterns = {}, additional = 'None }
                # => { }

                # Properties aren't required to be present.
                { } | Record { properties = { foo = Number }, required = { foo = null }, patterns = {}, additional = 'None }
                # => error

                # If something in properties also matches a pattern, both contracts are applied.
                { foo = 1.1 } | Record { properties = { foo = Number }, required = {}, patterns = { "." = std.number.Integer }, additional = 'None }
                # => error: expected an integer

                # additional being 'None means that unmatched fields are forbidden
                { bar = 1 } | Record { properties = { foo = Number }, required = {}, patterns = {}, additional = 'None }
                # => error: extra fields

                # fields that are matched by a pattern don't count as "additional"
                { bar = 1 } | Record { properties = { foo = Number }, required = {}, patterns = { "." = Number }, additional = 'None }
                # => { bar = 1 }

                # additional being 'Some applies the extra contract to unmatched fields
                { bar = 1 } | Record { properties = { foo = Number }, required = {}, patterns = {}, additional = 'Some String }
                # => error

                # Inner contracts are propagated
                { foo = { bar = 1 }} | Record { properties = { foo = { bar | String } }, required = {}, patterns = {}, additional = 'None }
                # => error: contract broken by the value of `bar`

                # Inner contracts aren't evaluated eagerly
                ({ foo = { bar = 1 }, baz = 2} | Record { properties = { foo = { bar | String } }, required = {}, patterns = {}, additional = 'Some Dyn }).baz
                # => 2
                ```
              "%
        = fun { properties, required, patterns, additional, } =>
          std.contract.custom (fun label x =>
            if !(std.is_record x) then
              'Error { message = "expected a record" }
            else
              let x | { _ | Dyn } = x in
              let required | { _ | Dyn } = required in
              let checked_properties
                : [| 'Ok ({ _ | Dyn }), 'Error ErrData |]
                =
                  std.array.try_fold_left
                    (fun acc { field, value = contract, } =>
                      if !(std.record.has_field field x) then
                        if std.record.has_field field required then
                          'Error (
                            {
                              message = "missing required field `%{field}`"
                            }
                              | ErrData
                          )
                        else
                          'Ok acc
                      else
                        (match {
                          'Ok checked_value =>
                            'Ok (
                              std.record.insert
                                field
                                checked_value
                                acc
                            ),
                          'Error e =>
                            'Error e,
                        }
                        ) (
                          std.contract.check
                            contract
                            label
                            x."%{field}"
                        )
                    )
                    (
                      {}
                        | { _ | Dyn }
                    )
                    (std.record.to_array (properties | { _ : Dyn }))
              in
              let matching_fields
                : String -> { _ : Dyn }
                = fun pattern =>
                  let matcher = std.string.is_match pattern in
                  std.array.fold_left
                    (fun acc { field, value, } =>
                      if matcher field then
                        std.record.insert field value acc
                      else
                        acc
                    )
                    {}
                    (std.record.to_array x)
              in
              let checked_pattern_properties
                : [| 'Ok ({ _ | Dyn }), 'Error ErrData |]
                =
                  std.array.try_fold_left
                    (fun acc { field = pattern, value = contract, } =>
                      (match {
                        'Ok checked_dict =>
                          'Ok (
                            (acc & checked_dict)
                              | { _ | Dyn }
                          ),
                        'Error e =>
                          'Error e,
                      }
                      ) (
                        std.array.try_fold_left
                          (fun acc { field, value, } =>
                            (match {
                              'Ok checked_value =>
                                'Ok (
                                  std.record.insert
                                    field
                                    checked_value
                                    acc
                                ),
                              'Error e =>
                                'Error e,
                            }
                            ) (
                              std.contract.check
                                contract
                                label
                                value
                            )
                          )
                          (
                            {}
                              | { _ | Dyn }
                          )
                          (
                            std.record.to_array (matching_fields pattern)
                          )
                      )
                    )
                    (
                      {}
                        | { _ | Dyn }
                    )
                    (
                      std.record.to_array (
                        patterns
                          | { _ : Dyn }
                      )
                    )
              in
              (match {
                ['Error e, _] =>
                  'Error e,
                [_, 'Error e] =>
                  'Error e,
                [
                  'Ok checked_properties,
                  'Ok checked_pattern_properties
                ] =>
                  let remaining_fields
                    : { _ | Dyn }
                    =
                      std.array.fold_left
                        (fun acc field =>
                          if !(
                            std.record.has_field
                              field
                              acc
                          ) then
                            acc
                          else
                            std.record.remove field acc
                        )
                        x
                        (
                          (
                            std.record.fields (
                              checked_properties
                                | { _ : Dyn }
                            )
                          )
                          @ (
                            std.record.fields (
                              checked_pattern_properties
                                | { _ : Dyn }
                            )
                          )
                        )
                  in
                  let checked_additional
                    : [|
                      'Ok (
                        { _ | Dyn }
                      ),
                      'Error ErrData
                    |]
                    =
                      (match {
                        'None =>
                          if !(
                            std.record.is_empty remaining_fields
                          ) then
                            'Error (
                              {
                                message = "extra fields %{std.serialize
                                                          'Json
                                                          ((std.record.fields
                                                            remaining_fields)
                                                          | Dyn)}"
                              }
                                | ErrData
                            )
                          else
                            'Ok ({} | { _ | Dyn }),
                        'Some contract =>
                          std.array.try_fold_left
                            (fun acc { field, value, } =>
                              (match {
                                'Ok checked_value =>
                                  'Ok (
                                    std.record.insert
                                      field
                                      checked_value
                                      acc
                                  ),
                                'Error e =>
                                  'Error e,
                              }
                              ) (
                                std.contract.check
                                  contract
                                  label
                                  value
                              )
                            )
                            (
                              {}
                                | { _ | Dyn }
                            )
                            (
                              std.record.to_array remaining_fields
                            ),
                      }
                      ) (
                        additional
                          | [| 'None, 'Some Dyn |]
                      )
                  in
                  (match {
                    'Error e =>
                      'Error e,
                    'Ok checked_additional =>
                      'Ok (
                        (
                          checked_properties
                          & checked_pattern_properties
                        )
                        & checked_additional
                      ),
                  }
                  ) checked_additional,
              }
              ) [
                checked_properties,
                checked_pattern_properties
              ]
          ),
      Required
        | Array String -> Dyn
        | doc m%"
                A contract asserting that a record has certain fields.

                # Examples


                ```nickel multiline
                { foo = 1, bar = 2 } | Required [ "foo" ]
                # => { foo = 1, bar = 2 }

                { foo = 1, bar = 2 } | Required [ "baz" ]
                # => error: missing required field baz

                "baz" | Required [ "baz" ]
                # => error: expected a record
                ```
              "%
        = fun fields =>
          std.contract.from_validator (fun value =>
            if !(std.is_record value) then
              'Error { message = "expected a record" }
            else
              (match { 'Error e => 'Error e, 'Ok _ => 'Ok, }) (
                std.array.try_fold_left
                  (fun acc field =>
                    if !(std.record.has_field field value) then
                      'Error {
                        message = "missing required field %{field}"
                      }
                    else
                      'Ok acc
                  )
                  null
                  fields
              )
          )
    },
  string = {
    MaxLength
      | Number -> Dyn
      | doc m%"
              `MaxLength n` is a contract that checks for a string of length at most `n`.

              Here, the "length" of a string is the number of extended grapheme clusters in the string.
              This may not agree with the JSON schema semantics, which counts the number of Unicode
              code points.

              # Examples

              ```nickel multiline
              "Hello" | MaxLength 5

              # 15 bytes, 3 code points, 1 extended grapheme cluster
              "" | MaxLength 1

              "Hello" | MaxLength 4
              # => error
              ```
            "%
      = fun limit =>
        std.contract.from_validator (fun value =>
          if !(std.is_string value) then
            'Error { message = "expected a string" }
          else if (std.string.length value) <= limit then
            'Ok
          else
            'Error {
              message = "expected a string of length at most %{std.string.from_number
                                  limit}"
            }
        ),
    MinLength
      | Number -> Dyn
      | doc m%"
              `MinLength n` is a contract that checks for a string of length at least `n`.

              Here, the "length" of a string is the number of extended grapheme clusters in the string.
              This may not agree with the JSON schema semantics, which counts the number of Unicode
              code points.

              # Examples

              ```nickel multiline
              "Hello" | MinLength 5

              # 15 bytes, 3 code points, 1 extended grapheme cluster
              "" | MinLength 3
              # => error

              "Hello" | MinLength 6
              # => error
              ```
            "%
      = fun limit =>
        std.contract.from_validator (fun value =>
          if !(std.is_string value) then
            'Error { message = "expected a string" }
          else if (std.string.length value) >= limit then
            'Ok
          else
            'Error {
              message = "expected a string of length at least %{std.string.from_number
                                  limit}"
            }
        )
  }
}
in
let rec refs = {
  definitions.branch =
    std.contract.Sequence [refs.definitions.globs, Array Dyn ],
  definitions.concurrency = {
    cancel-in-progress
      | std.contract.any_of [
        Bool,
        std.contract.Sequence [refs.definitions.expressionSyntax, String ]
      ]
      | optional,
    group | String
  },
  definitions.configuration =
    std.contract.any_of [ String, Number, Bool, { _ | js2n.Always }, Array js2n.Always],
  definitions.container = {
    credentials
      | {
        password | String | optional,
        username | String | optional,
        ..
      }
      | optional,
    env | refs.definitions.env | optional,
    image | String,
    options | String | optional,
    ports
      | js2n.array.MinItems 1
      | Array (std.contract.any_of [ Number, String ])
      | optional,
    volumes
      | js2n.array.MinItems 1
      | Array (std.string.Matches "^[^:]+:[^:]+$")
      | optional
  },
  definitions.defaults =
    std.contract.Sequence [
      js2n.record.MinProperties 1,
      {
        run
          | js2n.record.MinProperties 1
          | {
            shell | refs.definitions.shell | String | optional,
            working-directory
              | refs.definitions.working-directory
              | String
              | optional
          }
          | optional
      }
    ],
  definitions.env =
    std.contract.any_of [
      { _ | std.contract.any_of [ Bool, Number, String ] },
      std.contract.Sequence [refs.definitions.stringContainingExpressionSyntax, String ]
    ],
  definitions.environment = { name | String, url | String | optional },
  definitions.event =
    std.contract.Sequence [
      std.enum.TagOrString,
      [|
        'repository_dispatch,
        'workflow_run,
        'workflow_dispatch,
        'workflow_call,
        'watch,
        'status,
        'release,
        'registry_package,
        'push,
        'pull_request_target,
        'pull_request_review_comment,
        'pull_request_review,
        'pull_request,
        'public,
        'project_column,
        'project_card,
        'project,
        'page_build,
        'milestone,
        'merge_group,
        'label,
        'issues,
        'issue_comment,
        'gollum,
        'fork,
        'discussion_comment,
        'discussion,
        'deployment_status,
        'deployment,
        'delete,
        'create,
        'check_suite,
        'check_run,
        'branch_protection_rule
      |]
    ],
  definitions.eventObject = js2n.Nullable { .. },
  definitions.expressionSyntax =
    std.string.Matches "^\\$\\{\\{(.|[\r\n])*\\}\\}$",
  definitions.globs =
    std.contract.Sequence [js2n.array.MinItems 1, Array (js2n.string.MinLength 1)],
  definitions.jobNeeds =
    std.contract.any_of [
      std.contract.Sequence [
        js2n.array.MinItems 1,
        Array (
          std.contract.Sequence [refs.definitions.name, String ]
        )
      ],
      std.contract.Sequence [refs.definitions.name, String ]
    ],
  definitions.matrix =
    std.contract.any_of [
      std.contract.Sequence [
        js2n.record.MinProperties 1,
        js2n.record.Record {
          properties = {
            exclude =
              std.contract.any_of [
                std.contract.Sequence [
                  refs.definitions.expressionSyntax,
                  String
                ],
                std.contract.Sequence [
                  js2n.array.MinItems 1,
                  Array (
                    { _ | refs.definitions.configuration }
                  )
                ]
              ],
            include =
              std.contract.any_of [
                std.contract.Sequence [
                  refs.definitions.expressionSyntax,
                  String
                ],
                std.contract.Sequence [
                  js2n.array.MinItems 1,
                  Array (
                    { _ | refs.definitions.configuration }
                  )
                ]
              ]
          },
          required = {},
          patterns = {},
          additional =
            'Some (
              std.contract.any_of [
                std.contract.Sequence [
                  js2n.array.MinItems 1,
                  Array refs.definitions.configuration
                ],
                std.contract.Sequence [refs.definitions.expressionSyntax, String ]
              ]
            )
        }
      ],
      std.contract.Sequence [refs.definitions.expressionSyntax, String ]
    ],
  definitions.name = std.string.Matches "^[_a-zA-Z][a-zA-Z0-9_-]*$",
  definitions.normalJob = {
    concurrency
      | std.contract.any_of [
        String,
        std.contract.Sequence [refs.definitions.concurrency, { _ | Dyn }]
      ]
      | optional,
    container
      | std.contract.any_of [
        String,
        std.contract.Sequence [refs.definitions.container, { _ | Dyn }]
      ]
      | optional,
    continue-on-error
      | std.contract.any_of [
        Bool,
        std.contract.Sequence [refs.definitions.expressionSyntax, String ]
      ]
      | optional,
    defaults | refs.definitions.defaults | { _ | Dyn } | optional,
    env | refs.definitions.env | optional,
    environment
      | std.contract.any_of [
        String,
        std.contract.Sequence [refs.definitions.environment, { _ | Dyn }]
      ]
      | optional,
    "if" | std.contract.any_of [ Bool, Number, String ] | optional,
    name | String | optional,
    needs | refs.definitions.jobNeeds | optional,
    outputs | js2n.record.MinProperties 1 | { _ | String } | optional,
    permissions | refs.definitions.permissions | optional,
    runs-on
      | std.contract.any_of [
        String,
        std.contract.Sequence [
          js2n.array.MinItems 1,
          js2n.array.Items [ String ] js2n.Always
        ],
        js2n.record.Record {
          properties = {
            group = String,
            labels =
              std.contract.any_of [ String, js2n.array.ArrayOf String ]
          },
          required = {},
          patterns = {},
          additional = 'Some Dyn
        },
        std.contract.Sequence [
          refs.definitions.stringContainingExpressionSyntax,
          String
        ],
        std.contract.Sequence [refs.definitions.expressionSyntax, String ]
      ],
    services
      | {
        _ | std.contract.Sequence [refs.definitions.container, { _ | Dyn }]
      }
      | optional,
    steps
      | js2n.array.MinItems 1
      | Array (
        std.contract.Sequence [refs.definitions.step, { _ | Dyn }]
      )
      | optional,
    strategy
      | {
        fail-fast | std.contract.any_of [ Bool, String ] | optional,
        matrix | refs.definitions.matrix,
        max-parallel | std.contract.any_of [ Number, String ] | optional
      }
      | optional,
    timeout-minutes
      | std.contract.any_of [
        Number,
        std.contract.Sequence [refs.definitions.expressionSyntax, String ]
      ]
      | optional
  },
  definitions.path =
    std.contract.Sequence [refs.definitions.globs, Array Dyn ],
  definitions.permissions =
    std.contract.any_of [
      std.contract.Sequence [std.enum.TagOrString, [| 'write-all, 'read-all |]],
      std.contract.Sequence [refs.definitions.permissions-event, { _ | Dyn }]
    ],
  definitions.permissions-event = {
    actions | refs.definitions.permissions-level | String | optional,
    attestations
      | refs.definitions.permissions-level
      | String
      | optional,
    checks | refs.definitions.permissions-level | String | optional,
    contents | refs.definitions.permissions-level | String | optional,
    deployments
      | refs.definitions.permissions-level
      | String
      | optional,
    discussions
      | refs.definitions.permissions-level
      | String
      | optional,
    id-token | refs.definitions.permissions-level | String | optional,
    issues | refs.definitions.permissions-level | String | optional,
    packages | refs.definitions.permissions-level | String | optional,
    pages | refs.definitions.permissions-level | String | optional,
    pull-requests
      | refs.definitions.permissions-level
      | String
      | optional,
    repository-projects
      | refs.definitions.permissions-level
      | String
      | optional,
    security-events
      | refs.definitions.permissions-level
      | String
      | optional,
    statuses | refs.definitions.permissions-level | String | optional
  },
  definitions.permissions-level =
    std.contract.Sequence [std.enum.TagOrString, [| 'none, 'write, 'read |]],
  definitions.ref =
    std.contract.Sequence [
      js2n.Nullable {
        branches | refs.definitions.branch | Array Dyn | optional,
        branches-ignore
          | refs.definitions.branch
          | Array Dyn
          | optional,
        paths | refs.definitions.path | Array Dyn | optional,
        paths-ignore | refs.definitions.path | Array Dyn | optional,
        tags | refs.definitions.branch | Array Dyn | optional,
        tags-ignore | refs.definitions.branch | Array Dyn | optional,
        ..
      },
      js2n.Nullable (
        std.contract.Sequence [
          std.contract.not (
            std.contract.any_of [
              js2n.Null,
              Bool,
              Number,
              String,
              js2n.record.Required ["branches", "branches-ignore"],
              Array Dyn
            ]
          ),
          std.contract.not (
            std.contract.any_of [
              js2n.Null,
              Bool,
              Number,
              String,
              js2n.record.Required ["tags", "tags-ignore"],
              Array Dyn
            ]
          ),
          std.contract.not (
            std.contract.any_of [
              js2n.Null,
              Bool,
              Number,
              String,
              js2n.record.Required ["paths", "paths-ignore"],
              Array Dyn
            ]
          ),
          { _ | Dyn }
        ]
      )
    ],
  definitions.reusableWorkflowCallJob = {
    concurrency
      | std.contract.any_of [
        String,
        std.contract.Sequence [refs.definitions.concurrency, { _ | Dyn }]
      ]
      | optional,
    "if" | std.contract.any_of [ Bool, Number, String ] | optional,
    name | String | optional,
    needs | refs.definitions.jobNeeds | optional,
    permissions | refs.definitions.permissions | optional,
    secrets
      | js2n.OneOf [
        refs.definitions.env,
        std.contract.Sequence [std.enum.TagOrString, [| 'inherit |]]
      ]
      | optional,
    strategy
      | {
        fail-fast | std.contract.any_of [ Bool, String ] | optional,
        matrix | refs.definitions.matrix,
        max-parallel | std.contract.any_of [ Number, String ] | optional
      }
      | optional,
    uses | std.string.Matches "^(.+\\/)+(.+)\\.(ya?ml)(@.+)?$",
    with | refs.definitions.env | optional
  },
  definitions.shell =
    std.contract.any_of [
      String,
      std.contract.Sequence [
        std.enum.TagOrString,
        [| 'powershell, 'cmd, 'sh, 'python, 'pwsh, 'bash |]
      ]
    ],
  definitions.step =
    std.contract.Sequence [
      js2n.record.DependentFields { shell = ["run"], working-directory = ["run"] },
      js2n.OneOf [
        std.contract.any_of [
          js2n.Null,
          Bool,
          Number,
          String,
          js2n.record.Required ["uses"],
          Array Dyn
        ],
        std.contract.any_of [
          js2n.Null,
          Bool,
          Number,
          String,
          js2n.record.Required ["run"],
          Array Dyn
        ]
      ],
      {
        continue-on-error
          | std.contract.any_of [
            Bool,
            std.contract.Sequence [refs.definitions.expressionSyntax, String ]
          ]
          | optional,
        env | refs.definitions.env | optional,
        id | String | optional,
        "if" | std.contract.any_of [ Bool, Number, String ] | optional,
        name | String | optional,
        run | String | optional,
        shell | refs.definitions.shell | String | optional,
        timeout-minutes
          | std.contract.any_of [
            Number,
            std.contract.Sequence [refs.definitions.expressionSyntax, String ]
          ]
          | optional,
        uses | String | optional,
        with
          | std.contract.any_of [
            js2n.Null,
            Bool,
            Number,
            String,
            {
              args | String | optional,
              entrypoint | String | optional,
              ..
            },
            Array Dyn
          ]
          | refs.definitions.env
          | optional,
        working-directory
          | refs.definitions.working-directory
          | String
          | optional
      }
    ],
  definitions.stringContainingExpressionSyntax =
    std.string.Matches "^.*\\$\\{\\{(.|[\r\n])*\\}\\}.*$",
  definitions.types = js2n.array.MinItems 1,
  definitions.workflowDispatchInput =
    std.contract.Sequence [
      js2n.IfThenElse
        (
          std.contract.any_of [
            js2n.Null,
            Bool,
            Number,
            String,
            js2n.record.Record {
              properties = { type = js2n.Const "string" },
              required = { type = true },
              patterns = {},
              additional = 'Some Dyn
            },
            Array Dyn
          ]
        )
        (
          std.contract.any_of [
            js2n.Null,
            Bool,
            Number,
            String,
            { "default" | String | optional, .. },
            Array Dyn
          ]
        )
        js2n.Always,
      js2n.IfThenElse
        (
          std.contract.any_of [
            js2n.Null,
            Bool,
            Number,
            String,
            js2n.record.Record {
              properties = { type = js2n.Const "boolean" },
              required = { type = true },
              patterns = {},
              additional = 'Some Dyn
            },
            Array Dyn
          ]
        )
        (
          std.contract.any_of [
            js2n.Null,
            Bool,
            Number,
            String,
            { "default" | Bool | optional, .. },
            Array Dyn
          ]
        )
        js2n.Always,
      js2n.IfThenElse
        (
          std.contract.any_of [
            js2n.Null,
            Bool,
            Number,
            String,
            js2n.record.Record {
              properties = { type = js2n.Const "number" },
              required = { type = true },
              patterns = {},
              additional = 'Some Dyn
            },
            Array Dyn
          ]
        )
        (
          std.contract.any_of [
            js2n.Null,
            Bool,
            Number,
            String,
            { "default" | Number | optional, .. },
            Array Dyn
          ]
        )
        js2n.Always,
      js2n.IfThenElse
        (
          std.contract.any_of [
            js2n.Null,
            Bool,
            Number,
            String,
            js2n.record.Record {
              properties = { type = js2n.Const "environment" },
              required = { type = true },
              patterns = {},
              additional = 'Some Dyn
            },
            Array Dyn
          ]
        )
        (
          std.contract.any_of [
            js2n.Null,
            Bool,
            Number,
            String,
            { "default" | String | optional, .. },
            Array Dyn
          ]
        )
        js2n.Always,
      js2n.IfThenElse
        (
          std.contract.any_of [
            js2n.Null,
            Bool,
            Number,
            String,
            js2n.record.Record {
              properties = { type = js2n.Const "choice" },
              required = { type = true },
              patterns = {},
              additional = 'Some Dyn
            },
            Array Dyn
          ]
        )
        (
          std.contract.any_of [
            js2n.Null,
            Bool,
            Number,
            String,
            js2n.record.Required ["options"],
            Array Dyn
          ]
        )
        js2n.Always,
      {
        "default"
          | std.contract.any_of [js2n.Null, Bool, Number, String, { _ | Dyn }, Array Dyn ]
          | optional,
        deprecationMessage | String | optional,
        description | String,
        options | js2n.array.MinItems 1 | Array String | optional,
        required | Bool | optional,
        type
          | std.enum.TagOrString
          | [| 'environment, 'number, 'boolean, 'choice, 'string |]
          | optional
      }
    ],
  definitions.working-directory = String
}
in
{
  concurrency
    | std.contract.any_of [ String, refs.definitions.concurrency]
    | optional,
  defaults | refs.definitions.defaults | { _ | Dyn } | optional,
  env | refs.definitions.env | optional,
  jobs
    | js2n.record.MinProperties 1
    | {
      _ | js2n.OneOf [
        refs.definitions.normalJob,
        refs.definitions.reusableWorkflowCallJob
      ]
    }
    | std.record.FieldsMatch "^[_a-zA-Z][a-zA-Z0-9_-]*$",
  name | String | optional,
  on
    | std.contract.any_of [
      refs.definitions.event,
      std.contract.Sequence [js2n.array.MinItems 1, Array refs.definitions.event],
      {
        branch_protection_rule
          | js2n.Nullable {
            types
              | Array (
                std.contract.Sequence [
                  std.enum.TagOrString,
                  [| 'deleted, 'edited, 'created |]
                ]
              )
              | refs.definitions.types
              | optional,
            ..
          }
          | refs.definitions.eventObject
          | optional,
        check_run
          | js2n.Nullable {
            types
              | Array (
                std.contract.Sequence [
                  std.enum.TagOrString,
                  [|
                    'requested_action,
                    'completed,
                    'rerequested,
                    'created
                  |]
                ]
              )
              | refs.definitions.types
              | optional,
            ..
          }
          | refs.definitions.eventObject
          | optional,
        check_suite
          | js2n.Nullable {
            types
              | Array (
                std.contract.Sequence [
                  std.enum.TagOrString,
                  [| 'rerequested, 'requested, 'completed |]
                ]
              )
              | refs.definitions.types
              | optional,
            ..
          }
          | refs.definitions.eventObject
          | optional,
        create | refs.definitions.eventObject | optional,
        delete | refs.definitions.eventObject | optional,
        deployment | refs.definitions.eventObject | optional,
        deployment_status | refs.definitions.eventObject | optional,
        discussion
          | js2n.Nullable {
            types
              | Array (
                std.contract.Sequence [
                  std.enum.TagOrString,
                  [|
                    'unanswered,
                    'answered,
                    'category_changed,
                    'unlocked,
                    'locked,
                    'unlabeled,
                    'labeled,
                    'unpinned,
                    'pinned,
                    'transferred,
                    'deleted,
                    'edited,
                    'created
                  |]
                ]
              )
              | refs.definitions.types
              | optional,
            ..
          }
          | refs.definitions.eventObject
          | optional,
        discussion_comment
          | js2n.Nullable {
            types
              | Array (
                std.contract.Sequence [
                  std.enum.TagOrString,
                  [| 'deleted, 'edited, 'created |]
                ]
              )
              | refs.definitions.types
              | optional,
            ..
          }
          | refs.definitions.eventObject
          | optional,
        fork | refs.definitions.eventObject | optional,
        gollum | refs.definitions.eventObject | optional,
        issue_comment
          | js2n.Nullable {
            types
              | Array (
                std.contract.Sequence [
                  std.enum.TagOrString,
                  [| 'deleted, 'edited, 'created |]
                ]
              )
              | refs.definitions.types
              | optional,
            ..
          }
          | refs.definitions.eventObject
          | optional,
        issues
          | js2n.Nullable {
            types
              | Array (
                std.contract.Sequence [
                  std.enum.TagOrString,
                  [|
                    'demilestoned,
                    'milestoned,
                    'unlocked,
                    'locked,
                    'unlabeled,
                    'labeled,
                    'unassigned,
                    'assigned,
                    'reopened,
                    'closed,
                    'unpinned,
                    'pinned,
                    'transferred,
                    'deleted,
                    'edited,
                    'opened
                  |]
                ]
              )
              | refs.definitions.types
              | optional,
            ..
          }
          | refs.definitions.eventObject
          | optional,
        label
          | js2n.Nullable {
            types
              | Array (
                std.contract.Sequence [
                  std.enum.TagOrString,
                  [| 'deleted, 'edited, 'created |]
                ]
              )
              | refs.definitions.types
              | optional,
            ..
          }
          | refs.definitions.eventObject
          | optional,
        merge_group
          | js2n.Nullable {
            types
              | Array (
                std.contract.Sequence [std.enum.TagOrString, [| 'checks_requested |]]
              )
              | refs.definitions.types
              | optional,
            ..
          }
          | refs.definitions.eventObject
          | optional,
        milestone
          | js2n.Nullable {
            types
              | Array (
                std.contract.Sequence [
                  std.enum.TagOrString,
                  [| 'deleted, 'edited, 'opened, 'closed, 'created |]
                ]
              )
              | refs.definitions.types
              | optional,
            ..
          }
          | refs.definitions.eventObject
          | optional,
        page_build | refs.definitions.eventObject | optional,
        project
          | js2n.Nullable {
            types
              | Array (
                std.contract.Sequence [
                  std.enum.TagOrString,
                  [|
                    'deleted,
                    'edited,
                    'reopened,
                    'closed,
                    'updated,
                    'created
                  |]
                ]
              )
              | refs.definitions.types
              | optional,
            ..
          }
          | refs.definitions.eventObject
          | optional,
        project_card
          | js2n.Nullable {
            types
              | Array (
                std.contract.Sequence [
                  std.enum.TagOrString,
                  [|
                    'deleted,
                    'edited,
                    'converted,
                    'moved,
                    'created
                  |]
                ]
              )
              | refs.definitions.types
              | optional,
            ..
          }
          | refs.definitions.eventObject
          | optional,
        project_column
          | js2n.Nullable {
            types
              | Array (
                std.contract.Sequence [
                  std.enum.TagOrString,
                  [| 'deleted, 'moved, 'updated, 'created |]
                ]
              )
              | refs.definitions.types
              | optional,
            ..
          }
          | refs.definitions.eventObject
          | optional,
        public | refs.definitions.eventObject | optional,
        pull_request
          | js2n.Nullable {
            branches | Array Dyn | optional,
            branches-ignore | Array Dyn | optional,
            paths | Array Dyn | optional,
            paths-ignore | Array Dyn | optional,
            tags | Array Dyn | optional,
            tags-ignore | Array Dyn | optional,
            types
              | Array (
                std.contract.Sequence [
                  std.enum.TagOrString,
                  [|
                    'dequeued,
                    'enqueued,
                    'auto_merge_disabled,
                    'auto_merge_enabled,
                    'review_request_removed,
                    'review_requested,
                    'demilestoned,
                    'milestoned,
                    'unlocked,
                    'locked,
                    'ready_for_review,
                    'converted_to_draft,
                    'synchronize,
                    'reopened,
                    'closed,
                    'edited,
                    'opened,
                    'unlabeled,
                    'labeled,
                    'unassigned,
                    'assigned
                  |]
                ]
              )
              | refs.definitions.types
              | optional
          }
          | refs.definitions.ref
          | optional,
        pull_request_review
          | js2n.Nullable {
            types
              | Array (
                std.contract.Sequence [
                  std.enum.TagOrString,
                  [| 'dismissed, 'edited, 'submitted |]
                ]
              )
              | refs.definitions.types
              | optional,
            ..
          }
          | refs.definitions.eventObject
          | optional,
        pull_request_review_comment
          | js2n.Nullable {
            types
              | Array (
                std.contract.Sequence [
                  std.enum.TagOrString,
                  [| 'deleted, 'edited, 'created |]
                ]
              )
              | refs.definitions.types
              | optional,
            ..
          }
          | refs.definitions.eventObject
          | optional,
        pull_request_target
          | js2n.Nullable {
            branches | js2n.Always | optional,
            branches-ignore | js2n.Always | optional,
            paths | js2n.Always | optional,
            paths-ignore | js2n.Always | optional,
            tags | js2n.Always | optional,
            tags-ignore | js2n.Always | optional,
            types
              | Array (
                std.contract.Sequence [
                  std.enum.TagOrString,
                  [|
                    'auto_merge_disabled,
                    'auto_merge_enabled,
                    'review_request_removed,
                    'review_requested,
                    'unlocked,
                    'locked,
                    'ready_for_review,
                    'converted_to_draft,
                    'synchronize,
                    'reopened,
                    'closed,
                    'edited,
                    'opened,
                    'unlabeled,
                    'labeled,
                    'unassigned,
                    'assigned
                  |]
                ]
              )
              | refs.definitions.types
              | optional
          }
          | refs.definitions.ref
          | optional,
        push
          | js2n.Nullable {
            branches | Array String | optional,
            branches-ignore | Array String | optional,
            paths | Array String | optional,
            paths-ignore | Array String | optional,
            tags | Array String | optional,
            tags-ignore | Array String | optional
          }
          | refs.definitions.ref
          | optional,
        registry_package
          | js2n.Nullable {
            types
              | Array (
                std.contract.Sequence [std.enum.TagOrString, [| 'updated, 'published |]]
              )
              | refs.definitions.types
              | optional,
            ..
          }
          | refs.definitions.eventObject
          | optional,
        release
          | js2n.Nullable {
            types
              | Array (
                std.contract.Sequence [
                  std.enum.TagOrString,
                  [|
                    'released,
                    'prereleased,
                    'deleted,
                    'edited,
                    'created,
                    'unpublished,
                    'published
                  |]
                ]
              )
              | refs.definitions.types
              | optional,
            ..
          }
          | refs.definitions.eventObject
          | optional,
        repository_dispatch | refs.definitions.eventObject | optional,
        schedule
          | js2n.array.MinItems 1
          | Array { cron | String | optional }
          | optional,
        status | refs.definitions.eventObject | optional,
        watch | refs.definitions.eventObject | optional,
        workflow_call
          | std.contract.any_of [
            js2n.Null,
            Bool,
            Number,
            String,
            {
              inputs
                | {
                  _ | {
                    "default"
                      | std.contract.any_of [ Bool, Number, String ]
                      | optional,
                    deprecationMessage | String | optional,
                    description | String | optional,
                    required | Bool | optional,
                    type
                      | std.enum.TagOrString
                      | [| 'string, 'number, 'boolean |]
                  }
                }
                | std.record.FieldsMatch "^[_a-zA-Z][a-zA-Z0-9_-]*$"
                | optional,
              secrets
                | std.contract.any_of [
                  js2n.Null,
                  Bool,
                  Number,
                  String,
                  std.contract.Sequence [
                    {
                      _ | std.contract.any_of [
                        js2n.Null,
                        Bool,
                        Number,
                        String,
                        {
                          description | String | optional,
                          required | Bool
                        },
                        Array Dyn
                      ]
                    },
                    std.record.FieldsMatch "^[_a-zA-Z][a-zA-Z0-9_-]*$"
                  ],
                  Array Dyn
                ]
                | optional,
              ..
            },
            Array Dyn
          ]
          | optional,
        workflow_dispatch
          | std.contract.any_of [
            js2n.Null,
            Bool,
            Number,
            String,
            {
              inputs
                | {
                  _ | std.contract.Sequence [
                    refs.definitions.workflowDispatchInput,
                    { _ | Dyn }
                  ]
                }
                | std.record.FieldsMatch "^[_a-zA-Z][a-zA-Z0-9_-]*$"
                | optional
            },
            Array Dyn
          ]
          | optional,
        workflow_run
          | js2n.Nullable {
            branches | js2n.Always | optional,
            branches-ignore | js2n.Always | optional,
            types
              | Array (
                std.contract.Sequence [
                  std.enum.TagOrString,
                  [| 'in_progress, 'completed, 'requested |]
                ]
              )
              | refs.definitions.types
              | optional,
            workflows | js2n.array.MinItems 1 | Array String | optional,
            ..
          }
          | refs.definitions.eventObject
          | optional
      }
    ],
  permissions | refs.definitions.permissions | optional,
  run-name | String | optional
}
</file>

<file path="examples/github-workflow/README.md">
# GitHub Workflow syntax validation

This is a small example of using a published JSON schema, namely the [GitHub
Workflow schema](https://json.schemastore.org/github-workflow.json). The top-
level configuration in `ci.ncl` is using some Nickel programming features to
generate a GitHub workflow specification. The result is then checked against the
JSON schema to ensure no typos have snuck in.

To generate the workflow file use `nickel export -f ci.ncl > ci.yaml`.
</file>

<file path="examples/simple-schema/README.md">
# Validating a Nickel configuration against a simple JSON schema

The JSON schema in `./test.schema.json` was converted into the Nickel file
`./test.schema.ncl` and can be used in `./schema-test.ncl` to validate a Nickel
configuration.
</file>

<file path="examples/simple-schema/schema-test.ncl">
let Schema = import "./test.schema.ncl" in
{
  my_bool = true,
  my_int = 7,
  four = 4,
  my_json_enum = "a string",
  my_object = {
    foo = "foo",
    bar = false,
  },
  my_nullable_enum = {
    StructVariant = {
      floats = [1, 2, 3]
    }
  },
} | Schema
</file>

<file path="examples/simple-schema/test.schema.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "MyStruct",
  "type": "object",
  "required": [
    "my_bool",
    "my_int",
    "my_object"
  ],
  "properties": {
    "my_bool": {
      "type": "boolean"
    },
    "my_int": {
      "type": "integer",
      "format": "int32"
    },
    "my_object": {
      "$ref": "#/definitions/MyObject"
    },
    "four": {
      "const": 4
    },
    "my_json_enum": {
      "enum": [
        1,
        42,
        "a string",
        null
      ]
    },
    "my_reasonable_enum": {
      "type": "string",
      "enum": [
        "foo",
        "bar",
        "baz"
      ]
    },
    "my_nullable_enum": {
      "anyOf": [
        {
          "$ref": "#/definitions/MyEnum"
        },
        {
          "type": "null"
        }
      ]
    }
  },
  "definitions": {
    "MyEnum": {
      "oneOf": [
        {
          "type": "object",
          "required": [
            "StringNewType"
          ],
          "properties": {
            "StringNewType": {
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "StructVariant"
          ],
          "properties": {
            "StructVariant": {
              "type": "object",
              "required": [
                "floats"
              ],
              "properties": {
                "floats": {
                  "type": "array",
                  "items": {
                    "type": "number",
                    "format": "float"
                  }
                }
              }
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "MyObject": {
      "type": "object",
      "required": ["bar"],
      "properties": {
        "foo": {
          "type": "string"
        },
        "bar": {
          "type": "boolean"
        }
      },
      "additionalProperties": false
    }
  }
}
</file>

<file path="examples/simple-schema/test.schema.ncl">
# DO NOT EDIT
# This file was automatically generated using json-schema-to-nickel
let js2n = {
  Always
    | doc m%"
        A contract that always succeeds. The same as `Dyn`, but with a more JSON-schema name.

        # Examples

        ```nickel multiline
        "foo" | Always

        3 | Always
        ```
      "%
    = Dyn,
  Const
    | Dyn -> Dyn
    | doc m%"
        A more eager version of `std.contract.Equal`.

        # Examples

        ```nickel multiline
        5 | Const 5

        3 | Const 5
        # => error
        ```
      "%
    = fun expected =>
      std.contract.from_validator (fun value =>
        if value == expected then
          'Ok
        else
          'Error { message = "expected %{std.to_string expected}" }
      ),
  Enum
    | Array Dyn -> Dyn
    | doc m%"
        `Enum values x` succeeds if and only if `x` is equal to one of the elements of `values`.

        # Examples

        ```nickel multiline
        "no" | Enum [false, "false", "no", "off"]

        "yes" | Enum [false, "false", "no", "off"]
        # => error
        ```
      "%
    = fun variants =>
      std.contract.from_validator (fun value =>
        let check_equal = fun input variant =>
          (input == variant)
          || (
            (std.is_enum input)
            && (
              ((std.string.from_enum input) == variant)
                | Bool
            )
          )
        in
        if std.array.any (check_equal value) variants then
          'Ok
        else
          'Error {
            message = "expected one of %{std.serialize 'Json variants}"
          }
      ),
  IfThenElse
    | Dyn -> Dyn -> Dyn -> Dyn
    | doc m%"
        `IfThenElse iph zen els` checks the `iph` contract (eagerly). If that
        succeeds, it checks the `zen` contract and otherwise checks the `els`
        contract.

        Only the eager part of the `iph` contract is used to decide which of the
        other contracts is applied. The lazy part of the `iph` contract will be
        applied if the eager part succeeds.

        # Examples

        ```nickel multiline
        6 | IfThenElse Number (number.MultipleOf 2) String

        "hi" | IfThenElse Number (number.MultipleOf 2) String

        true | IfThenElse Number (number.MultipleOf 2) String
        # => error

        # The `zen` branch gets the value that was normalized by TagOrString
        "hi" | IfThenElse std.enum.TagOrString (std.contract.Equal 'hi) Number
        ```
      "%
    = fun iph zen els =>
      std.contract.custom (fun label value =>
        (match {
          'Ok v =>
            std.contract.check zen label v,
          'Error _ =>
            std.contract.check els label value,
        }
        ) (std.contract.check iph label value)
      ),
  Never
    | doc m%"
        A contract that always fails.

        # Examples

        ```nickel multiline
        "foo" | Never
        # => error

        3 | Never
        # => error
      "%
    = std.contract.from_predicate (fun _ => false),
  Null
    | doc m%"
        A contract asserting that a value is null.

        # Examples

        ```nickel multiline
        null | Null

        "foo" | Null
        # => error
      "%
    = std.contract.from_predicate ((fun x0 x1 => x0 == x1) null),
  Nullable
    : Dyn -> Dyn
    | doc m%"
        For a contract `C`, `Nullable C` returns a contract that allows either `C` or a null value.

        # Examples

        ```nickel multiline
        1 | Nullable Number

        null | Nullable Number

        "1" | Nullable Number
        # => error
        ```
      "%
    = fun Contract =>
      std.contract.custom (fun label value =>
        if value == null then
          'Ok value
        else
          std.contract.check Contract label value
      ),
  OneOf
    | Array Dyn -> Dyn
    | doc m%"
        Checks that exactly one of a list of contracts succeeds.

        # Examples

        ```nickel multiline
        "hi" | OneOf [Number, String, Bool]

        "hi" | OneOf [Number, String, std.enum.TagOrString]
        # => error: 2 of the contracts passed

        "hi" | OneOf [Number, std.enum.TagOrString]
        # => 'hi
        ```
      "%
    = fun contracts =>
      std.contract.custom (fun label value =>
        (match {
          'Count n =>
            'Error {
              message = "%{std.to_string
                            n} of the contracts passed, expected precisely one to pass"
            },
          'Ok v =>
            'Ok v,
        }
        ) (
          std.array.fold_right
            (fun ctr acc =>
              (match {
                'Ok val =>
                  (match {
                    'Count 0 =>
                      'Ok val,
                    'Count n =>
                      'Count (n + 1),
                    'Ok _ =>
                      'Count 2,
                  }
                  ) acc,
                'Error e =>
                  acc,
              }
              ) (std.contract.check ctr label value)
            )
            ('Count 0)
            contracts
        )
      ),
  array = {
    ArrayOf
      | Dyn -> Dyn
      | doc m%"
              An eager version of `Array`. `value | ArrayOf C` will succeed if `value` is an array and all of
              its elements satisfy the eager part of the contract `C`.

              # Examples

              ```nickel multiline
              [1, 2, 3] | ArrayOf Number
              # => [1, 2, 3]

              [1, 2, 3] | ArrayOf String
              # => error

              ["a", "b", "c"] | ArrayOf std.enum.TagOrString
              # => ['a, 'b, 'c]
              ```
            "%
      = fun ctr =>
        std.contract.custom (fun label value =>
          if !(std.is_array value) then
            'Error { message = "expected an array" }
          else
            std.array.try_fold_left
              (fun acc elt =>
                (match {
                  'Ok v =>
                    'Ok (acc @ [v]),
                  'Error e =>
                    'Error e,
                }
                ) (std.contract.check ctr label elt)
              )
              []
              value
        ),
    Contains
      | Dyn -> Dyn
      | doc m%"
              A contract checking that an array contains something satisfying another contract.

              For example, `Contains Number` is a contract checking that the value is an array
              and that it contains at least one number.

              This is an eager contract, and it assumes that the inputs are also eager.
              Any lazy parts of the inputs will be ignored.

              # Examples

              ```nickel multiline
              ["hi", true, 1] | Contains Bool
              # => ["hi", true, 1]

              ["hi", true, 1] | Contains (Array Bool)
              # => error

              # Lazy parts of the inner contract are ignored: "hi" does not get transformed
              # to 'hi.
              ["hi", true, 1] | Contains std.enum.TagOrString
              # => ["hi", true, 1]
              ```
            "%
      = fun contract =>
        std.contract.custom (fun label value =>
          if !(std.is_array value) then
            'Error { message = "expected an array" }
          else
            let good_elt = fun elt =>
              (match { 'Ok _ => true, 'Error _ => false, }) (std.contract.check contract label elt)
            in
            if std.array.any good_elt value then
              'Ok value
            else
              'Error { message = "no elements matched" }
        ),
    Items
      | Array Dyn -> Dyn -> Dyn
      | doc m%"
              A contract checking that the first few elements of an array satisfy
              specific contracts, and the remaining elements satisfy another contract.
              For example, `Items [C1 C2] C3` is a contract checking that the value is
              an array, that its first two elements (if present) satisfy `C1` and `C2`
              respectively, and that any other elements satisfy `C3`.

              # Examples

              ```nickel multiline
              [1, 2, "foo", "bar"] | Items [Number, Number] String

              # The value is allowed to be shorter than the list of contracts.
              [1] | Items [Number, Number] String

              [1, "foo", "bar"] | Items [Number, Number] String
              # => error

              # Inner contracts are propagated, but note that the overall `Items` contract
              # is eager if and only if all the contracts you pass in are eager.
              [1, { foo = "str"}, "foo", "bar"] | Items [Number, { foo | Number }] String
              # => error
              ```
            "%
      = fun elt_contracts rest =>
        std.contract.custom (fun label value =>
          if !(std.is_array value) then
            'Error { message = "expected an array" }
          else
            let length_to_check =
              std.number.min
                (std.array.length elt_contracts)
                (std.array.length value)
            in
            let { left, right, } = std.array.split_at length_to_check value
            in
            (match {
              'Error e =>
                'Error e,
              'Ok left_with_contracts =>
                std.array.try_fold_left
                  (fun acc elt =>
                    (match {
                      'Ok v =>
                        'Ok (acc @ [v]),
                      'Error e =>
                        'Error e,
                    }
                    ) (std.contract.check rest label elt)
                  )
                  left_with_contracts
                  right,
            }
            ) (
              std.array.try_fold_left
                (fun acc =>
                  match {
                    'Ok v =>
                      'Ok (acc @ [v]),
                    'Error e =>
                      'Error e,
                  }
                )
                []
                (
                  std.array.zip_with
                    (fun contract elt =>
                      std.contract.check contract label elt
                    )
                    elt_contracts
                    left
                )
            )
        ),
    MaxItems
      : Number -> Dyn
      | doc m%"
              A contract that checks whether an array has at most a certain number of items.

              # Examples

              ```nickel multiline
              [1, 2, 3] | MaxItems 3

              [1, 2, 3] | MaxItems 2
              # => error
            "%
      = fun n =>
        std.contract.from_predicate (fun arr =>
          (std.is_array arr)
          && ((std.array.length (arr | Array Dyn)) <= n)
        ),
    MinItems
      : Number -> Dyn
      | doc m%"
              A contract that checks whether an array has at least a certain number of items.

              # Examples

              ```nickel multiline
              [1, 2, 3] | MinItems 3

              [1, 2, 3] | MinItems 4
              # => error
              ```
            "%
      = fun n =>
        std.contract.from_predicate (fun arr =>
          (std.is_array arr)
          && ((std.array.length (arr | Array Dyn)) >= n)
        ),
    UniqueItems
      | doc m%"
              Checks that the elements of an array are pairwise distinct.

              # Examples

              ```nickel multiline
              [1, 2, "3"] | UniqueItems

              [1, 3, 2, 3] | UniqueItems
              # => error: duplicate found: 3
              ```
            "%
      =
        let find_duplicate
          : Array Dyn -> {
            has_duplicate : Bool,
            duplicate : Dyn,
            seen : { _ : Bool }
          }
          =
            std.array.fold_right
              (fun elt acc =>
                if acc.has_duplicate then
                  acc
                else
                  let index = std.serialize 'Json elt in
                  if std.record.has_field index acc.seen then
                    {
                      duplicate = elt,
                      has_duplicate = true,
                      seen = acc.seen
                    }
                  else
                    {
                      duplicate = null,
                      has_duplicate = false,
                      seen = std.record.insert index true acc.seen
                    }
              )
              { duplicate = null, has_duplicate = false, seen = {} }
        in
        std.contract.from_validator (fun x =>
          if !(std.is_array x) then
            'Error { message = "expected an array" }
          else
            let { has_duplicate, duplicate, .. } = find_duplicate x in
            if has_duplicate then
              'Error {
                message = "duplicate found: %{std.serialize
                                    'Json
                                    duplicate}"
              }
            else
              'Ok
        )
  },
  number =
    let from_predicate
      | (Number -> Bool) -> String -> Dyn
      = fun pred msg =>
        std.contract.from_validator (fun value =>
          if !(std.is_number value) then
            'Error { message = "expected a number" }
          else if pred (value | Number) then
            'Ok
          else
            'Error { message = msg }
        )
    in
    {
      ExclusiveMaximum
        | Number -> Dyn
        | doc m%"
                `ExclusiveMaximum n` is a contract checking that a number is at strictly less than `n`.

                # Examples

                ```nickel multiline
                5 | ExclusiveMaximum 5.1

                5 | ExclusiveMaximum 5
                # => error: expected an exclusive maximum of 5

                "5" | ExclusiveMaximum 5
                # => error: expected a number
                ```
              "%
        = fun limit =>
          from_predicate
            (fun x => x < limit)
            "expected an exclusive maximum of %{std.string.from_number
                      limit}",
      ExclusiveMinimum
        | Number -> Dyn
        | doc m%"
                `ExclusiveMinimum n` is a contract checking that a number is at strictly more than `n`.

                # Examples

                ```nickel multiline
                5 | ExclusiveMinimum 4.9

                5 | ExclusiveMinimum 5
                # => error: expected an exclusive minimum of 5

                "5" | ExclusiveMinimum 5
                # => error: expected a number
                ```
              "%
        = fun limit =>
          from_predicate
            (fun x => x > limit)
            "expected an exclusive minimum of %{std.string.from_number
                      limit}",
      Maximum
        | Number -> Dyn
        | doc m%"
                `Maximum n` is a contract checking that a number is at most `n`.

                # Examples

                ```nickel multiline
                5 | Maximum 5

                5 | Maximum 4
                # => error: expected a maximum of 4

                "5" | Maximum 5
                # => error: expected a number
                ```
              "%
        = fun limit =>
          from_predicate
            (fun x => x <= limit)
            "expected a maximum of %{std.string.from_number limit}",
      Minimum
        | Number -> Dyn
        | doc m%"
                `Minimum n` is a contract checking that a number is at least `n`.

                # Examples

                ```nickel multiline
                5 | Minimum 5

                5 | Minimum 6
                # => error: expected a minimum of 6

                "5" | Minimum 6
                # => error: expected a number
                ```
              "%
        = fun limit =>
          from_predicate
            (fun x => x >= limit)
            "expected a minimum of %{std.string.from_number limit}",
      MultipleOf
        | Number -> Dyn
        | doc m%"
                `MultipleOf n` is a contract checking whether a value is a multiple of `n`.

                # Examples

                ```nickel multiline
                4 | MultipleOf 2

                "4" | MultipleOf 2
                # => error: expected a number

                4 | MultipleOf 3
                # => error: expected a multiple of 3

                4 | MultipleOf 0
                # => error: expected a multiple of 0
                ```
              "%
        = fun n =>
          std.contract.from_validator (fun value =>
            if !(std.is_number value) then
              'Error { message = "expected a number" }
            else if n == 0 then
              'Error { message = "expected a multiple of 0" }
            else if std.number.is_integer (value / n) then
              'Ok
            else
              'Error {
                message = "expected a multiple of %{std.string.from_number
                                      n}"
              }
          )
    },
  record =
    let ErrData = {
      blame_location | Dyn | optional,
      message | String | optional,
      notes | Array String | optional
    }
    in
    {
      DependentContracts
        | { _ | Dyn } -> Dyn
        | doc m%"
                A contract for asserting that if some fields are present then the entire
                record satisfies a contract.

                Specifically, `DependentContracts { foo = C }` is a contract asserting that
                the value is a record, and if the value contains a field named `foo` then
                the entire record satisfies the contract `C`.

                `DependentContracts` calls `std.contract.check` for each of the provided
                contracts. In particular, if `C` is fully eager then so is
                `DependentContracts { foo = C }`.

                # Examples

                ```nickel multiline
                { foo = 1, bar = 2 } | DependentContracts { foo = { bar | Number, .. } }

                { foo = 1, bar = 2 } | DependentContracts { foo = { bar | Number } }
                # => error: extra field `foo`

                # This one doesn't fail: the inner contract never gets triggered because there's no `baz` field
                { foo = 1, bar = 2 } | DependentContracts { baz = { bar | Number } }

                1 | DependentContracts { baz = { bar | Number } }
                # => error: expected a record
                ```
              "%
        = fun deps =>
          std.contract.custom (fun label value =>
            if !(std.is_record value) then
              'Error { message = "expected a record" }
            else
              std.array.try_fold_left
                (fun acc { field, value = contract, } =>
                  if std.record.has_field field value then
                    std.contract.check contract label acc
                  else
                    'Ok acc
                )
                value
                (std.record.to_array deps)
          ),
      DependentFields
        | { _ | Array String } -> Dyn
        | doc m%"
                A contract for asserting that if some fields are present, other fields are
                also present.

                Specifically, `DependentFields { foo = ["bar", "baz"] }` is a contract
                asserting that if the field `foo` is present then the fields `bar` and
                `baz` are also present. This corresponds to the part of JSON schema's
                [dependencies](https://json-schema.org/draft-07/draft-handrews-json-schema-validation-01#rfc.section.6.5.7)
                keyword in which the values are arrays.

                This is an eager contract.

                ```nickel multiline
                { foo = 1, bar = 2 } | DependentFields { foo = ["bar"] }

                { foo = 1, baz = 2 } | DependentFields { foo = ["bar"] }
                # => error: expected field bar

                { baz = 2 } | DependentFields { foo = ["bar"] }
                ```
              "%
        = fun dependencies =>
          std.contract.from_validator (fun value =>
            if !(std.is_record value) then
              'Error { message = "expected a record" }
            else
              let must_have_fields
                : Array String -> { _ : Dyn } -> [| 'Ok, 'Error ErrData |]
                = fun fields x =>
                  std.array.fold_right
                    (fun field acc =>
                      if !(std.record.has_field field x) then
                        'Error (
                          { message = "expected field %{field}" }
                            | ErrData
                        )
                      else
                        acc
                    )
                    'Ok
                    fields
              in
              std.array.fold_right
                (fun { field, value = dependent_fields, } acc =>
                  if std.record.has_field field value then
                    (match {
                      'Ok =>
                        acc,
                      'Error e =>
                        'Error (
                          e
                          & {
                            notes = [
                              "because field %{field} was present"
                            ]
                          }
                        ),
                    }
                    ) (must_have_fields dependent_fields value)
                  else
                    acc
                )
                'Ok
                (std.record.to_array dependencies)
          ),
      MaxProperties
        | Number -> Dyn
        | doc m%"
                A contract that checks whether a record has at most a certain number of properties.

                # Examples

                ```nickel multiline
                { foo = 1, bar = 2 } | MaxProperties 2

                { foo = 1, bar = 2 } | MaxProperties 1
                # => error: expected a record with at most 1 fields
                ```
              "%
        = fun n =>
          std.contract.from_validator (fun value =>
            if !(std.is_record value) then
              'Error { message = "expected a record" }
            else if (std.record.length value) > n then
              'Error {
                message = "expected a record with at most %{std.string.from_number
                                    n} fields"
              }
            else
              'Ok
          ),
      MinProperties
        | Number -> Dyn
        | doc m%"
                A contract that checks whether a record has at least a certain number of properties.

                # Examples

                ```nickel multiline
                { foo = 1, bar = 2 } | MinProperties 2

                { foo = 1, bar = 2 } | MinProperties 3
                # => error: expected a record with at least 3 fields
                ```
              "%
        = fun n =>
          std.contract.from_validator (fun value =>
            if !(std.is_record value) then
              'Error { message = "expected a record" }
            else if (std.record.length value) < n then
              'Error {
                message = "expected a record with at least %{std.string.from_number
                                    n} fields"
              }
            else
              'Ok
          ),
      PropertyNames
        | Dyn -> Dyn
        | doc m%"
                `PropertyNames C` is a contract asserting that a value is a record and all of
                its field names satisfy the contract `C`.

                `PropertyNames C` is an eager contract for any `C`. Any lazy parts of `C` will
                be ignored.

                ```nickel multiline
                { foo = 1 } | PropertyNames std.string.NonEmpty

                { "1" = 1 } | PropertyNames std.string.NumberLiteral

                { foo = 1 } | PropertyNames std.string.NumberLiteral
                # => error: invalid number literal
                ```
              "%
        = fun contract =>
          std.contract.custom (fun label value =>
            if !(std.is_record value) then
              'Error { message = "expected a record" }
            else
              std.array.try_fold_left
                (fun acc field_name =>
                  (match {
                    'Ok _ =>
                      'Ok value,
                    'Error e =>
                      'Error e,
                  }
                  ) (std.contract.check contract label field_name)
                )
                ('Ok value)
                (std.record.fields value)
          ),
      Record
        | {
          additional | [| 'None, 'Some Dyn |],
          patterns | { _ | Dyn },
          properties | { _ | Dyn },
          required | { _ | Dyn }
        } -> Dyn
        | doc m%"
                A contract for checking JSON Schema object properties.

                In `Record { properties, required, patterns, additional }`, properties and patterns
                should be dicts containing contracts as values. These contracts will be
                applied to the appropriate fields of your record. `additional` can be
                `None` (in which case fields not matching `properties` or `patterns` are
                forbidden) or `Some contract` (in which case `contract` will be applied to
                every field not matched by `properties` and `patterns`).

                The contract returned by `Record` is sort of eager: it will call
                `std.contract.check` on the appropriate field values, and then it will
                propagate any lazy contracts returned by `std.contract.check`. This makes
                `Record` a little more eager than standard record contracts, and if all
                the contracts you provide are eager then `Record` will be fully eager.

                Cf. [https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-validation-01#section-6.5]

                # Examples

                ```nickel multiline
                { foo = 1 } | Record { properties = { foo = Number }, required = {}, patterns = {}, additional = 'None }
                # => { foo = 1 }

                # Properties aren't required to be present.
                { } | Record { properties = { foo = Number }, required = {}, patterns = {}, additional = 'None }
                # => { }

                # Properties aren't required to be present.
                { } | Record { properties = { foo = Number }, required = { foo = null }, patterns = {}, additional = 'None }
                # => error

                # If something in properties also matches a pattern, both contracts are applied.
                { foo = 1.1 } | Record { properties = { foo = Number }, required = {}, patterns = { "." = std.number.Integer }, additional = 'None }
                # => error: expected an integer

                # additional being 'None means that unmatched fields are forbidden
                { bar = 1 } | Record { properties = { foo = Number }, required = {}, patterns = {}, additional = 'None }
                # => error: extra fields

                # fields that are matched by a pattern don't count as "additional"
                { bar = 1 } | Record { properties = { foo = Number }, required = {}, patterns = { "." = Number }, additional = 'None }
                # => { bar = 1 }

                # additional being 'Some applies the extra contract to unmatched fields
                { bar = 1 } | Record { properties = { foo = Number }, required = {}, patterns = {}, additional = 'Some String }
                # => error

                # Inner contracts are propagated
                { foo = { bar = 1 }} | Record { properties = { foo = { bar | String } }, required = {}, patterns = {}, additional = 'None }
                # => error: contract broken by the value of `bar`

                # Inner contracts aren't evaluated eagerly
                ({ foo = { bar = 1 }, baz = 2} | Record { properties = { foo = { bar | String } }, required = {}, patterns = {}, additional = 'Some Dyn }).baz
                # => 2
                ```
              "%
        = fun { properties, required, patterns, additional, } =>
          std.contract.custom (fun label x =>
            if !(std.is_record x) then
              'Error { message = "expected a record" }
            else
              let x | { _ | Dyn } = x in
              let required | { _ | Dyn } = required in
              let checked_properties
                : [| 'Ok ({ _ | Dyn }), 'Error ErrData |]
                =
                  std.array.try_fold_left
                    (fun acc { field, value = contract, } =>
                      if !(std.record.has_field field x) then
                        if std.record.has_field field required then
                          'Error (
                            {
                              message = "missing required field `%{field}`"
                            }
                              | ErrData
                          )
                        else
                          'Ok acc
                      else
                        (match {
                          'Ok checked_value =>
                            'Ok (
                              std.record.insert
                                field
                                checked_value
                                acc
                            ),
                          'Error e =>
                            'Error e,
                        }
                        ) (
                          std.contract.check
                            contract
                            label
                            x."%{field}"
                        )
                    )
                    (
                      {}
                        | { _ | Dyn }
                    )
                    (std.record.to_array (properties | { _ : Dyn }))
              in
              let matching_fields
                : String -> { _ : Dyn }
                = fun pattern =>
                  let matcher = std.string.is_match pattern in
                  std.array.fold_left
                    (fun acc { field, value, } =>
                      if matcher field then
                        std.record.insert field value acc
                      else
                        acc
                    )
                    {}
                    (std.record.to_array x)
              in
              let checked_pattern_properties
                : [| 'Ok ({ _ | Dyn }), 'Error ErrData |]
                =
                  std.array.try_fold_left
                    (fun acc { field = pattern, value = contract, } =>
                      (match {
                        'Ok checked_dict =>
                          'Ok (
                            (acc & checked_dict)
                              | { _ | Dyn }
                          ),
                        'Error e =>
                          'Error e,
                      }
                      ) (
                        std.array.try_fold_left
                          (fun acc { field, value, } =>
                            (match {
                              'Ok checked_value =>
                                'Ok (
                                  std.record.insert
                                    field
                                    checked_value
                                    acc
                                ),
                              'Error e =>
                                'Error e,
                            }
                            ) (
                              std.contract.check
                                contract
                                label
                                value
                            )
                          )
                          (
                            {}
                              | { _ | Dyn }
                          )
                          (
                            std.record.to_array (matching_fields pattern)
                          )
                      )
                    )
                    (
                      {}
                        | { _ | Dyn }
                    )
                    (
                      std.record.to_array (
                        patterns
                          | { _ : Dyn }
                      )
                    )
              in
              (match {
                ['Error e, _] =>
                  'Error e,
                [_, 'Error e] =>
                  'Error e,
                [
                  'Ok checked_properties,
                  'Ok checked_pattern_properties
                ] =>
                  let remaining_fields
                    : { _ | Dyn }
                    =
                      std.array.fold_left
                        (fun acc field =>
                          if !(
                            std.record.has_field
                              field
                              acc
                          ) then
                            acc
                          else
                            std.record.remove field acc
                        )
                        x
                        (
                          (
                            std.record.fields (
                              checked_properties
                                | { _ : Dyn }
                            )
                          )
                          @ (
                            std.record.fields (
                              checked_pattern_properties
                                | { _ : Dyn }
                            )
                          )
                        )
                  in
                  let checked_additional
                    : [|
                      'Ok (
                        { _ | Dyn }
                      ),
                      'Error ErrData
                    |]
                    =
                      (match {
                        'None =>
                          if !(
                            std.record.is_empty remaining_fields
                          ) then
                            'Error (
                              {
                                message = "extra fields %{std.serialize
                                                          'Json
                                                          ((std.record.fields
                                                            remaining_fields)
                                                          | Dyn)}"
                              }
                                | ErrData
                            )
                          else
                            'Ok ({} | { _ | Dyn }),
                        'Some contract =>
                          std.array.try_fold_left
                            (fun acc { field, value, } =>
                              (match {
                                'Ok checked_value =>
                                  'Ok (
                                    std.record.insert
                                      field
                                      checked_value
                                      acc
                                  ),
                                'Error e =>
                                  'Error e,
                              }
                              ) (
                                std.contract.check
                                  contract
                                  label
                                  value
                              )
                            )
                            (
                              {}
                                | { _ | Dyn }
                            )
                            (
                              std.record.to_array remaining_fields
                            ),
                      }
                      ) (
                        additional
                          | [| 'None, 'Some Dyn |]
                      )
                  in
                  (match {
                    'Error e =>
                      'Error e,
                    'Ok checked_additional =>
                      'Ok (
                        (
                          checked_properties
                          & checked_pattern_properties
                        )
                        & checked_additional
                      ),
                  }
                  ) checked_additional,
              }
              ) [
                checked_properties,
                checked_pattern_properties
              ]
          ),
      Required
        | Array String -> Dyn
        | doc m%"
                A contract asserting that a record has certain fields.

                # Examples


                ```nickel multiline
                { foo = 1, bar = 2 } | Required [ "foo" ]
                # => { foo = 1, bar = 2 }

                { foo = 1, bar = 2 } | Required [ "baz" ]
                # => error: missing required field baz

                "baz" | Required [ "baz" ]
                # => error: expected a record
                ```
              "%
        = fun fields =>
          std.contract.from_validator (fun value =>
            if !(std.is_record value) then
              'Error { message = "expected a record" }
            else
              (match { 'Error e => 'Error e, 'Ok _ => 'Ok, }) (
                std.array.try_fold_left
                  (fun acc field =>
                    if !(std.record.has_field field value) then
                      'Error {
                        message = "missing required field %{field}"
                      }
                    else
                      'Ok acc
                  )
                  null
                  fields
              )
          )
    },
  string = {
    MaxLength
      | Number -> Dyn
      | doc m%"
              `MaxLength n` is a contract that checks for a string of length at most `n`.

              Here, the "length" of a string is the number of extended grapheme clusters in the string.
              This may not agree with the JSON schema semantics, which counts the number of Unicode
              code points.

              # Examples

              ```nickel multiline
              "Hello" | MaxLength 5

              # 15 bytes, 3 code points, 1 extended grapheme cluster
              "" | MaxLength 1

              "Hello" | MaxLength 4
              # => error
              ```
            "%
      = fun limit =>
        std.contract.from_validator (fun value =>
          if !(std.is_string value) then
            'Error { message = "expected a string" }
          else if (std.string.length value) <= limit then
            'Ok
          else
            'Error {
              message = "expected a string of length at most %{std.string.from_number
                                  limit}"
            }
        ),
    MinLength
      | Number -> Dyn
      | doc m%"
              `MinLength n` is a contract that checks for a string of length at least `n`.

              Here, the "length" of a string is the number of extended grapheme clusters in the string.
              This may not agree with the JSON schema semantics, which counts the number of Unicode
              code points.

              # Examples

              ```nickel multiline
              "Hello" | MinLength 5

              # 15 bytes, 3 code points, 1 extended grapheme cluster
              "" | MinLength 3
              # => error

              "Hello" | MinLength 6
              # => error
              ```
            "%
      = fun limit =>
        std.contract.from_validator (fun value =>
          if !(std.is_string value) then
            'Error { message = "expected a string" }
          else if (std.string.length value) >= limit then
            'Ok
          else
            'Error {
              message = "expected a string of length at least %{std.string.from_number
                                  limit}"
            }
        )
  }
}
in
let rec refs = {
  definitions.MyEnum =
    js2n.OneOf [
      js2n.record.Record {
        properties = { StringNewType = String },
        required = { StringNewType = true },
        patterns = {},
        additional = 'None
      },
      js2n.record.Record {
        properties = {
          StructVariant =
            js2n.record.Record {
              properties = { floats = js2n.array.ArrayOf Number },
              required = { floats = true },
              patterns = {},
              additional = 'Some Dyn
            }
        },
        required = { StructVariant = true },
        patterns = {},
        additional = 'None
      }
    ],
  definitions.MyObject = { bar | Bool, foo | String | optional }
}
in
{
  four | std.contract.Equal 4 | optional,
  my_bool | Bool,
  my_int | std.number.Integer,
  my_json_enum | js2n.Enum [1, 42, "a string", null ] | optional,
  my_nullable_enum | js2n.Nullable refs.definitions.MyEnum | optional,
  my_object | refs.definitions.MyObject,
  my_reasonable_enum
    | std.enum.TagOrString
    | [| 'baz, 'bar, 'foo |]
    | optional,
  ..
}
</file>

<file path="lib/arrays.ncl">
{
  ArrayOf
    | Dyn -> Dyn
    | doc m%"
      An eager version of `Array`. `value | ArrayOf C` will succeed if `value` is an array and all of
      its elements satisfy the eager part of the contract `C`.

      # Examples

      ```nickel multiline
      [1, 2, 3] | ArrayOf Number
      # => [1, 2, 3]

      [1, 2, 3] | ArrayOf String
      # => error

      ["a", "b", "c"] | ArrayOf std.enum.TagOrString
      # => ['a, 'b, 'c]
      ```
    "%
    = fun ctr =>
      std.contract.custom (fun label value =>
        if !std.is_array value then
          'Error { message = "expected an array" }
        else
          value
          |> std.array.try_fold_left
            (fun acc elt =>
              std.contract.check ctr label elt
              |> match {
                'Ok v => 'Ok (acc @ [v]),
                'Error e => 'Error e
              }
            )
            []
      ),

  Contains
    | Dyn -> Dyn
    | doc m%"
      A contract checking that an array contains something satisfying another contract.

      For example, `Contains Number` is a contract checking that the value is an array
      and that it contains at least one number.

      This is an eager contract, and it assumes that the inputs are also eager.
      Any lazy parts of the inputs will be ignored.

      # Examples

      ```nickel multiline
      ["hi", true, 1] | Contains Bool
      # => ["hi", true, 1]

      ["hi", true, 1] | Contains (Array Bool)
      # => error

      # Lazy parts of the inner contract are ignored: "hi" does not get transformed
      # to 'hi.
      ["hi", true, 1] | Contains std.enum.TagOrString
      # => ["hi", true, 1]
      ```
    "%
    = fun contract =>
      std.contract.custom (fun label value =>
        if !std.is_array value then
          'Error { message = "expected an array" }
        else
          let good_elt = (fun elt => std.contract.check contract label elt |> match { 'Ok _ => true, 'Error _ => false }) in
          if value |> std.array.any good_elt then
            'Ok value
          else
            'Error { message = "no elements matched" }
      ),

  Items
    | Array Dyn -> Dyn -> Dyn
    | doc m%"
      A contract checking that the first few elements of an array satisfy
      specific contracts, and the remaining elements satisfy another contract.
      For example, `Items [C1 C2] C3` is a contract checking that the value is
      an array, that its first two elements (if present) satisfy `C1` and `C2`
      respectively, and that any other elements satisfy `C3`.

      # Examples

      ```nickel multiline
      [1, 2, "foo", "bar"] | Items [Number, Number] String

      # The value is allowed to be shorter than the list of contracts.
      [1] | Items [Number, Number] String

      [1, "foo", "bar"] | Items [Number, Number] String
      # => error

      # Inner contracts are propagated, but note that the overall `Items` contract
      # is eager if and only if all the contracts you pass in are eager.
      [1, { foo = "str"}, "foo", "bar"] | Items [Number, { foo | Number }] String
      # => error
      ```
    "%
    = fun elt_contracts rest =>
      std.contract.custom (fun label value =>
        if !std.is_array value then
          'Error { message = "expected an array" }
        else
          let length_to_check = std.number.min (std.array.length elt_contracts) (std.array.length value) in
          let { left, right } = std.array.split_at length_to_check value in
          std.array.zip_with (fun contract elt => std.contract.check contract label elt) elt_contracts left
          |> std.array.try_fold_left
            (fun acc =>
              match {
                'Ok v => 'Ok (acc @ [v]),
                'Error e => 'Error e
              }
            )
            []
          |> match {
            'Error e => 'Error e,
            'Ok left_with_contracts =>
              # The individual elements succeeded. If there's anything left in the array, check the `rest` contract.
              right
              |> std.array.try_fold_left
                (fun acc elt =>
                  std.contract.check rest label elt
                  |> match {
                    'Ok v => 'Ok (acc @ [v]),
                    'Error e => 'Error e
                  }
                )
                left_with_contracts
          }
      ),

  UniqueItems
    | doc m%"
      Checks that the elements of an array are pairwise distinct.

      # Examples

      ```nickel multiline
      [1, 2, "3"] | UniqueItems

      [1, 3, 2, 3] | UniqueItems
      # => error: duplicate found: 3
      ```
    "%
    =
      let find_duplicate
        : Array Dyn -> { has_duplicate : Bool, duplicate : Dyn, seen : { _ : Bool } }
        | doc m%"
            Try to find a duplicate in an array of Nickel values. For
            efficiency, this function uses JSON serialization to index into
            a Nickel record. Consequently all values in the array must be
            serializable to JSON.
          "%
        =
          std.array.fold_right
            (fun elt acc =>
              if acc.has_duplicate then
                acc
              else
                let index = std.serialize 'Json elt in
                if std.record.has_field index acc.seen then
                  { has_duplicate = true, duplicate = elt, seen = acc.seen }
                else
                  { has_duplicate = false, duplicate = null, seen = std.record.insert index true acc.seen }
            )
            { has_duplicate = false, duplicate = null, seen = {} }
      in
      std.contract.from_validator (fun x =>
        if !std.is_array x then
          'Error { message = "expected an array" }
        else
          let { has_duplicate, duplicate, .. } = find_duplicate x
          in
          if has_duplicate then
            'Error { message = "duplicate found: %{std.serialize 'Json duplicate}" }
          else
            'Ok
      ),

  MinItems
    : Number -> Dyn
    | doc m%"
        A contract that checks whether an array has at least a certain number of items.

        # Examples

        ```nickel multiline
        [1, 2, 3] | MinItems 3

        [1, 2, 3] | MinItems 4
        # => error
        ```
      "%
    = fun n =>
      std.contract.from_predicate (fun arr => std.is_array arr && std.array.length (arr | Array Dyn) >= n),

  MaxItems
    : Number -> Dyn
    | doc m%"
        A contract that checks whether an array has at most a certain number of items.

        # Examples

        ```nickel multiline
        [1, 2, 3] | MaxItems 3

        [1, 2, 3] | MaxItems 2
        # => error
      "%
    = fun n =>
      std.contract.from_predicate (fun arr => std.is_array arr && std.array.length (arr | Array Dyn) <= n),
}
</file>

<file path="lib/main.ncl">
{
  Always
    | doc m%"
      A contract that always succeeds. The same as `Dyn`, but with a more JSON-schema name.

      # Examples

      ```nickel multiline
      "foo" | Always

      3 | Always
      ```
    "%
    = Dyn,

  Never
    | doc m%"
     A contract that always fails.

     # Examples

     ```nickel multiline
     "foo" | Never
     # => error

     3 | Never
     # => error
   "%
    = std.contract.from_predicate (fun _ => false),

  Null
    | doc m%"
      A contract asserting that a value is null.

      # Examples

      ```nickel multiline
      null | Null

      "foo" | Null
      # => error
   "%
    = std.contract.from_predicate ((==) null),

  Const
    | Dyn -> Dyn
    | doc m%"
      A more eager version of `std.contract.Equal`.

      # Examples

      ```nickel multiline
      5 | Const 5

      3 | Const 5
      # => error
      ```
    "%
    = fun expected =>
      std.contract.from_validator (fun value =>
        if value == expected then
          'Ok
        else
          'Error {
            message = "expected %{std.to_string expected}"
          }
      ),

  OneOf
    | Array Dyn -> Dyn
    | doc m%"
      Checks that exactly one of a list of contracts succeeds.

      # Examples

      ```nickel multiline
      "hi" | OneOf [Number, String, Bool]

      "hi" | OneOf [Number, String, std.enum.TagOrString]
      # => error: 2 of the contracts passed

      "hi" | OneOf [Number, std.enum.TagOrString]
      # => 'hi
      ```
    "%
    = fun contracts =>
      std.contract.custom (fun label value =>
        contracts
        |> std.array.fold_right
        # The accumulator is either `'Count n`, where `n != 1` is the number of contract
        # checks that succeeded, or it's `'Ok v`, where `v` is the value propagated by
        # the successful contract.
          (fun ctr acc =>
            std.contract.check ctr label value
            |> match {
              'Ok val =>
                acc
                |> match {
                  'Count 0 => 'Ok val,
                  'Count n => 'Count (n + 1),
                  'Ok _ => 'Count 2,
                },
              'Error e => acc
            }
          )
          ('Count 0)
        |> match {
          'Count n => 'Error { message = "%{std.to_string n} of the contracts passed, expected precisely one to pass" },
          'Ok v => 'Ok v
        }
      ),

  IfThenElse
    | Dyn -> Dyn -> Dyn -> Dyn
    | doc m%"
      `IfThenElse iph zen els` checks the `iph` contract (eagerly). If that
      succeeds, it checks the `zen` contract and otherwise checks the `els`
      contract.

      Only the eager part of the `iph` contract is used to decide which of the
      other contracts is applied. The lazy part of the `iph` contract will be
      applied if the eager part succeeds.

      # Examples

      ```nickel multiline
      6 | IfThenElse Number (number.MultipleOf 2) String

      "hi" | IfThenElse Number (number.MultipleOf 2) String

      true | IfThenElse Number (number.MultipleOf 2) String
      # => error

      # The `zen` branch gets the value that was normalized by TagOrString
      "hi" | IfThenElse std.enum.TagOrString (std.contract.Equal 'hi) Number
      ```
    "%
    = fun iph zen els =>
      std.contract.custom (fun label value =>
        std.contract.check iph label value
        |> match {
          'Ok v => std.contract.check zen label v,
          'Error _ => std.contract.check els label value,
        }
      ),

  Enum
    | Array Dyn -> Dyn
    | doc m%"
      `Enum values x` succeeds if and only if `x` is equal to one of the elements of `values`.

      # Examples

      ```nickel multiline
      "no" | Enum [false, "false", "no", "off"]

      "yes" | Enum [false, "false", "no", "off"]
      # => error
      ```
    "%
    = fun variants =>
      std.contract.from_validator (fun value =>
        let check_equal = fun input variant =>
          input == variant || (std.is_enum input && (std.string.from_enum input == variant | Bool))
        in
        if std.array.any (check_equal value) variants then
          'Ok
        else
          'Error { message = "expected one of %{std.serialize 'Json variants}" }
      ),

  Nullable
    : Dyn -> Dyn
    | doc m%"
      For a contract `C`, `Nullable C` returns a contract that allows either `C` or a null value.

      # Examples

      ```nickel multiline
      1 | Nullable Number

      null | Nullable Number

      "1" | Nullable Number
      # => error
      ```
    "%
    = fun Contract =>
      std.contract.custom (fun label value =>
        if value == null then
          'Ok value
        else
          std.contract.check Contract label value
      ),

  array = import "./arrays.ncl",
  record = import "./records.ncl",
  number = import "./numbers.ncl",
  string = import "./strings.ncl",
}
</file>

<file path="lib/Nickel-pkg.ncl">
{
  name = "json-schema-lib",
  description = "A library of predicates for JSON schema",
  minimal_nickel_version = "1.14.0",
  version = "0.1.0",
  authors = ["The json-schema-to-nickel authors"],
} | std.package.Manifest
</file>

<file path="lib/numbers.ncl">
let from_predicate | (Number -> Bool) -> String -> Dyn = fun pred msg =>
  std.contract.from_validator (fun value =>
    if !std.is_number value then
      'Error { message = "expected a number" }
    else if pred (value | Number) then
      'Ok
    else
      'Error { message = msg }
  )
in
{
  MultipleOf
    | Number -> Dyn
    | doc m%"
      `MultipleOf n` is a contract checking whether a value is a multiple of `n`.

      # Examples

      ```nickel multiline
      4 | MultipleOf 2

      "4" | MultipleOf 2
      # => error: expected a number

      4 | MultipleOf 3
      # => error: expected a multiple of 3

      4 | MultipleOf 0
      # => error: expected a multiple of 0
      ```
    "%
    = fun n =>
      std.contract.from_validator (fun value =>
        if !std.is_number value then
          'Error { message = "expected a number" }
        else if n == 0 then
          'Error { message = "expected a multiple of 0" }
        else if std.number.is_integer (value / n) then
          'Ok
        else
          'Error { message = "expected a multiple of %{std.string.from_number n}" }
      ),

  Maximum
    | Number -> Dyn
    | doc m%"
      `Maximum n` is a contract checking that a number is at most `n`.

      # Examples

      ```nickel multiline
      5 | Maximum 5

      5 | Maximum 4
      # => error: expected a maximum of 4

      "5" | Maximum 5
      # => error: expected a number
      ```
    "%
    = fun limit => from_predicate (fun x => x <= limit) "expected a maximum of %{std.string.from_number limit}",

  ExclusiveMaximum
    | Number -> Dyn
    | doc m%"
      `ExclusiveMaximum n` is a contract checking that a number is at strictly less than `n`.

      # Examples

      ```nickel multiline
      5 | ExclusiveMaximum 5.1

      5 | ExclusiveMaximum 5
      # => error: expected an exclusive maximum of 5

      "5" | ExclusiveMaximum 5
      # => error: expected a number
      ```
    "%
    = fun limit => from_predicate (fun x => x < limit) "expected an exclusive maximum of %{std.string.from_number limit}",

  Minimum
    | Number -> Dyn
    | doc m%"
      `Minimum n` is a contract checking that a number is at least `n`.

      # Examples

      ```nickel multiline
      5 | Minimum 5

      5 | Minimum 6
      # => error: expected a minimum of 6

      "5" | Minimum 6
      # => error: expected a number
      ```
    "%
    = fun limit => from_predicate (fun x => x >= limit) "expected a minimum of %{std.string.from_number limit}",

  ExclusiveMinimum
    | Number -> Dyn
    | doc m%"
      `ExclusiveMinimum n` is a contract checking that a number is at strictly more than `n`.

      # Examples

      ```nickel multiline
      5 | ExclusiveMinimum 4.9

      5 | ExclusiveMinimum 5
      # => error: expected an exclusive minimum of 5

      "5" | ExclusiveMinimum 5
      # => error: expected a number
      ```
    "%
    = fun limit => from_predicate (fun x => x > limit) "expected an exclusive minimum of %{std.string.from_number limit}",
}
</file>

<file path="lib/records.ncl">
let ErrData = { message | optional | String, notes | optional | Array String, blame_location | optional | Dyn } in
{
  MaxProperties
    | Number -> Dyn
    | doc m%"
      A contract that checks whether a record has at most a certain number of properties.

      # Examples

      ```nickel multiline
      { foo = 1, bar = 2 } | MaxProperties 2

      { foo = 1, bar = 2 } | MaxProperties 1
      # => error: expected a record with at most 1 fields
      ```
    "%
    = fun n =>
      std.contract.from_validator (fun value =>
        if !std.is_record value then
          'Error { message = "expected a record" }
        else if std.record.length value > n then
          'Error { message = "expected a record with at most %{std.string.from_number n} fields" }
        else
          'Ok
      ),

  MinProperties
    | Number -> Dyn
    | doc m%"
      A contract that checks whether a record has at least a certain number of properties.

      # Examples

      ```nickel multiline
      { foo = 1, bar = 2 } | MinProperties 2

      { foo = 1, bar = 2 } | MinProperties 3
      # => error: expected a record with at least 3 fields
      ```
    "%
    = fun n =>
      std.contract.from_validator (fun value =>
        if !std.is_record value then
          'Error { message = "expected a record" }
        else if std.record.length value < n then
          'Error { message = "expected a record with at least %{std.string.from_number n} fields" }
        else
          'Ok
      ),

  Required
    | Array String -> Dyn
    | doc m%"
      A contract asserting that a record has certain fields.

      # Examples


      ```nickel multiline
      { foo = 1, bar = 2 } | Required [ "foo" ]
      # => { foo = 1, bar = 2 }

      { foo = 1, bar = 2 } | Required [ "baz" ]
      # => error: missing required field baz

      "baz" | Required [ "baz" ]
      # => error: expected a record
      ```
    "%
    = fun fields =>
      std.contract.from_validator (fun value =>
        if !std.is_record value then
          'Error { message = "expected a record" }
        else
          fields
          |> std.array.try_fold_left
            (fun acc field =>
              if !std.record.has_field field value then
                'Error { message = "missing required field %{field}" }
              else
                'Ok acc
            )
            null
          |> match {
            'Error e => 'Error e,
            'Ok _ => 'Ok
          }
      ),

  Record
    | { properties | { _ | Dyn }, required | { _ | Dyn }, patterns | { _ | Dyn }, additional | [| 'None, 'Some Dyn |] } -> Dyn
    | doc m%"
      A contract for checking JSON Schema object properties.

      In `Record { properties, required, patterns, additional }`, properties and patterns
      should be dicts containing contracts as values. These contracts will be
      applied to the appropriate fields of your record. `additional` can be
      `None` (in which case fields not matching `properties` or `patterns` are
      forbidden) or `Some contract` (in which case `contract` will be applied to
      every field not matched by `properties` and `patterns`).

      The contract returned by `Record` is sort of eager: it will call
      `std.contract.check` on the appropriate field values, and then it will
      propagate any lazy contracts returned by `std.contract.check`. This makes
      `Record` a little more eager than standard record contracts, and if all
      the contracts you provide are eager then `Record` will be fully eager.

      Cf. [https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-validation-01#section-6.5]

      # Examples

      ```nickel multiline
      { foo = 1 } | Record { properties = { foo = Number }, required = {}, patterns = {}, additional = 'None }
      # => { foo = 1 }

      # Properties aren't required to be present.
      { } | Record { properties = { foo = Number }, required = {}, patterns = {}, additional = 'None }
      # => { }

      # Properties aren't required to be present.
      { } | Record { properties = { foo = Number }, required = { foo = null }, patterns = {}, additional = 'None }
      # => error

      # If something in properties also matches a pattern, both contracts are applied.
      { foo = 1.1 } | Record { properties = { foo = Number }, required = {}, patterns = { "." = std.number.Integer }, additional = 'None }
      # => error: expected an integer

      # additional being 'None means that unmatched fields are forbidden
      { bar = 1 } | Record { properties = { foo = Number }, required = {}, patterns = {}, additional = 'None }
      # => error: extra fields

      # fields that are matched by a pattern don't count as "additional"
      { bar = 1 } | Record { properties = { foo = Number }, required = {}, patterns = { "." = Number }, additional = 'None }
      # => { bar = 1 }

      # additional being 'Some applies the extra contract to unmatched fields
      { bar = 1 } | Record { properties = { foo = Number }, required = {}, patterns = {}, additional = 'Some String }
      # => error

      # Inner contracts are propagated
      { foo = { bar = 1 }} | Record { properties = { foo = { bar | String } }, required = {}, patterns = {}, additional = 'None }
      # => error: contract broken by the value of `bar`

      # Inner contracts aren't evaluated eagerly
      ({ foo = { bar = 1 }, baz = 2} | Record { properties = { foo = { bar | String } }, required = {}, patterns = {}, additional = 'Some Dyn }).baz
      # => 2
      ```
    "%
    = fun { properties, required, patterns, additional } =>
      std.contract.custom (fun label x =>
        if !std.is_record x then
          'Error { message = "expected a record" }
        else
          let x = x | { _ | Dyn } in
          let required = required | { _ | Dyn } in
          # Build a dict of everything checked by "properties". The field values
          # in this dict have any inner contracts applied.
          let checked_properties
            : [| 'Ok { _ | Dyn }, 'Error ErrData |]
            =
              std.record.to_array (properties | { _ : Dyn })
              |> std.array.try_fold_left
                (fun acc { field, value = contract } =>
                  if !std.record.has_field field x then
                    if std.record.has_field field required then
                      'Error ({ message = "missing required field `%{field}`" } | ErrData)
                    else
                      'Ok acc
                  else
                    std.contract.check contract label x."%{field}"
                    |> match {
                      'Ok checked_value => 'Ok (std.record.insert field checked_value acc),
                      'Error e => 'Error e,
                    }
                )
                ({} | { _ | Dyn })
          in
          let matching_fields : String -> { _ : Dyn } = fun pattern =>
            let matcher = std.string.is_match pattern
            in
            std.record.to_array x
            |> std.array.fold_left
              (fun acc { field, value } =>
                if matcher field then
                  std.record.insert field value acc
                else
                  acc
              )
              {}
          in
          # Build a dict of everything checked by "patterns". The field values
          # in this dict have any inner contracts applied. This can have overlap
          # with "checked_properties"; they'll get merged together later.
          let checked_pattern_properties
            : [| 'Ok { _ | Dyn }, 'Error ErrData |]
            =
              std.record.to_array (patterns | { _ : Dyn })
              |> std.array.try_fold_left
                (fun acc { field = pattern, value = contract } =>
                  matching_fields pattern
                  |> std.record.to_array
                  |> std.array.try_fold_left
                    (fun acc { field, value } =>
                      std.contract.check contract label value
                      |> match {
                        'Ok checked_value => 'Ok (std.record.insert field checked_value acc),
                        'Error e => 'Error e,
                      }
                    )
                    ({} | { _ | Dyn })
                  |> match {
                    'Ok checked_dict => 'Ok ((acc & checked_dict) | { _ | Dyn }),
                    'Error e => 'Error e,
                  }
                )
                ({} | { _ | Dyn })
          in
          [checked_properties, checked_pattern_properties]
          |> match {
            ['Error e, _] => 'Error e,
            [_, 'Error e] => 'Error e,
            ['Ok checked_properties, 'Ok checked_pattern_properties] =>
              let remaining_fields : { _ | Dyn } =
                (std.record.fields (checked_properties | { _ : Dyn }) @ std.record.fields (checked_pattern_properties | { _ : Dyn }))
                |> std.array.fold_left
                  (fun acc field =>
                    if !std.record.has_field field acc then
                      acc
                    else
                      std.record.remove field acc
                  )
                  x
              in
              let checked_additional
                : [| 'Ok { _ | Dyn }, 'Error ErrData |]
                =
                  (additional | [| 'None, 'Some Dyn |])
                  |> match {
                    'None =>
                      if !std.record.is_empty remaining_fields then
                        'Error ({ message = "extra fields %{std.serialize 'Json (std.record.fields remaining_fields | Dyn)}" } | ErrData)
                      else
                        'Ok ({} | { _ | Dyn }),
                    'Some contract =>
                      std.record.to_array remaining_fields
                      |> std.array.try_fold_left
                        (fun acc { field, value } =>
                          std.contract.check contract label value
                          |> match {
                            'Ok checked_value => 'Ok (std.record.insert field checked_value acc),
                            'Error e => 'Error e,
                          }
                        )
                        ({} | { _ | Dyn })
                  }
              in
              checked_additional
              |> match {
                'Error e => 'Error e,
                'Ok checked_additional => 'Ok (checked_properties & checked_pattern_properties & checked_additional)
              }
          }
      ),

  DependentFields
    | { _ | Array String } -> Dyn
    | doc m%"
      A contract for asserting that if some fields are present, other fields are
      also present.

      Specifically, `DependentFields { foo = ["bar", "baz"] }` is a contract
      asserting that if the field `foo` is present then the fields `bar` and
      `baz` are also present. This corresponds to the part of JSON schema's
      [dependencies](https://json-schema.org/draft-07/draft-handrews-json-schema-validation-01#rfc.section.6.5.7)
      keyword in which the values are arrays.

      This is an eager contract.

      ```nickel multiline
      { foo = 1, bar = 2 } | DependentFields { foo = ["bar"] }

      { foo = 1, baz = 2 } | DependentFields { foo = ["bar"] }
      # => error: expected field bar

      { baz = 2 } | DependentFields { foo = ["bar"] }
      ```
    "%
    = fun dependencies =>
      std.contract.from_validator (fun value =>
        if !std.is_record value then
          'Error { message = "expected a record" }
        else
          let must_have_fields : Array String -> { _ : Dyn } -> [| 'Ok, 'Error ErrData |] = fun fields x =>
            fields
            |> std.array.fold_right
              (fun field acc =>
                if !std.record.has_field field x then
                  'Error ({ message = "expected field %{field}" } | ErrData)
                else
                  acc
              )
              'Ok
          in
          dependencies
          |> std.record.to_array
          |> std.array.fold_right
            (fun { field, value = dependent_fields } acc =>
              if std.record.has_field field value then
                must_have_fields dependent_fields value
                |> match {
                  'Ok => acc,
                  'Error e => 'Error (e & { notes = ["because field %{field} was present"] }),
                }
              else
                acc
            )
            'Ok
      ),

  DependentContracts
    | { _ | Dyn } -> Dyn
    | doc m%"
      A contract for asserting that if some fields are present then the entire
      record satisfies a contract.

      Specifically, `DependentContracts { foo = C }` is a contract asserting that
      the value is a record, and if the value contains a field named `foo` then
      the entire record satisfies the contract `C`.

      `DependentContracts` calls `std.contract.check` for each of the provided
      contracts. In particular, if `C` is fully eager then so is
      `DependentContracts { foo = C }`.

      # Examples

      ```nickel multiline
      { foo = 1, bar = 2 } | DependentContracts { foo = { bar | Number, .. } }

      { foo = 1, bar = 2 } | DependentContracts { foo = { bar | Number } }
      # => error: extra field `foo`

      # This one doesn't fail: the inner contract never gets triggered because there's no `baz` field
      { foo = 1, bar = 2 } | DependentContracts { baz = { bar | Number } }

      1 | DependentContracts { baz = { bar | Number } }
      # => error: expected a record
      ```
    "%
    = fun deps =>
      std.contract.custom (fun label value =>
        if !std.is_record value then
          'Error { message = "expected a record" }
        else
          deps
          |> std.record.to_array
          # In this fold, the accumulator is `value` wrapped with whatever delayed
          # checks the dependent contracts have applied so far.
          |> std.array.try_fold_left
            (fun acc { field, value = contract } =>
              if std.record.has_field field value then
                std.contract.check contract label acc
              else
                'Ok acc
            )
            value
      ),

  PropertyNames
    | Dyn -> Dyn
    | doc m%"
      `PropertyNames C` is a contract asserting that a value is a record and all of
      its field names satisfy the contract `C`.

      `PropertyNames C` is an eager contract for any `C`. Any lazy parts of `C` will
      be ignored.

      ```nickel multiline
      { foo = 1 } | PropertyNames std.string.NonEmpty

      { "1" = 1 } | PropertyNames std.string.NumberLiteral

      { foo = 1 } | PropertyNames std.string.NumberLiteral
      # => error: invalid number literal
      ```
    "%
    = fun contract =>
      std.contract.custom (fun label value =>
        if !std.is_record value then
          'Error { message = "expected a record" }
        else
          std.record.fields value
          |> std.array.try_fold_left
            (fun acc field_name =>
              std.contract.check contract label field_name
              |> match {
                'Ok _ => 'Ok value,
                'Error e => 'Error e,
              }
            )
            ('Ok value)
      ),
}
</file>

<file path="lib/strings.ncl">
{
  MaxLength
    | Number -> Dyn
    | doc m%"
      `MaxLength n` is a contract that checks for a string of length at most `n`.

      Here, the "length" of a string is the number of extended grapheme clusters in the string.
      This may not agree with the JSON schema semantics, which counts the number of Unicode
      code points.

      # Examples

      ```nickel multiline
      "Hello" | MaxLength 5

      # 15 bytes, 3 code points, 1 extended grapheme cluster
      "" | MaxLength 1

      "Hello" | MaxLength 4
      # => error
      ```
    "%
    = fun limit =>
      std.contract.from_validator (fun value =>
        if !std.is_string value then
          'Error { message = "expected a string" }
        else if std.string.length value <= limit then
          'Ok
        else
          'Error {
            message = "expected a string of length at most %{std.string.from_number limit}",
          }
      ),

  MinLength
    | Number -> Dyn
    | doc m%"
      `MinLength n` is a contract that checks for a string of length at least `n`.

      Here, the "length" of a string is the number of extended grapheme clusters in the string.
      This may not agree with the JSON schema semantics, which counts the number of Unicode
      code points.

      # Examples

      ```nickel multiline
      "Hello" | MinLength 5

      # 15 bytes, 3 code points, 1 extended grapheme cluster
      "" | MinLength 3
      # => error

      "Hello" | MinLength 6
      # => error
      ```
    "%
    = fun limit =>
      std.contract.from_validator (fun value =>
        if !std.is_string value then
          'Error { message = "expected a string" }
        else if std.string.length value >= limit then
          'Ok
        else
          'Error {
            message = "expected a string of length at least %{std.string.from_number limit}",
          }
      ),
}
</file>

<file path="src/contract.rs">
use std::{
    cell::RefCell,
    collections::{BTreeMap, BTreeSet},
};

use nickel_lang_core::{
    bytecode::ast::{
        record::{FieldDef, FieldPathElem},
        Ast, AstAlloc, Node,
    },
    term::Number,
};

use crate::{references::AcyclicReferences, utils::static_access};

/// The owned part of a [`ContractContext`].
///
/// Keeps track of which json-schema refs were followed, so that the final
/// generated Nickel can ignore things that it doesn't need.
pub struct ContractContextData<'a, 'ast, 'refs> {
    /// All available json-schema refs.
    refs: &'a AcyclicReferences<'refs>,
    /// The name that generated contracts should use to refer to the json-schema
    /// lib. This name will be chosen in advance so that it is guaranteed never
    /// to be shadowed by any name in the generated contracts.
    lib_name: &'a str,
    /// The name that generated contracts should use to refer to the standard library.
    /// This name will be chosen in advance so that it is guaranteed never
    /// to be shadowed by any name in the generated contracts.
    std_name: &'a str,
    /// The name that generated contracts should use to refer to the record
    /// containing all the json-schema refs. Guaranteed not to be shadowed.
    ///
    /// For example, the json-schema ref "#/definitions/glob" can be found at
    /// the Nickel path `<refs_name>.definitions.glob`.
    refs_name: &'a str,
    /// In general, a json-schema reference might be followed in an eager context
    /// *and* in a lazy context, and so we'll have to generate both the lazy and
    /// eager versions of the contract that the reference points to. We can avoid
    /// this when the reference points to a schema that's always eager.
    always_eager_refs: BTreeMap<&'a str, bool>,
    /// The set of refs that were accessed, and for each one whether it was
    /// accessed in an eager context.
    accessed_refs: RefCell<BTreeSet<(String, bool)>>,
    /// An allocator for Nickel AST nodes.
    alloc: &'ast AstAlloc,
}

/// Maintains the context used while translating schemas to nickel contracts.
#[derive(Clone, Copy)]
pub struct ContractContext<'a, 'ast, 'refs> {
    /// Is the contract we're translating forced to be eager?
    eager: bool,
    inner: &'a ContractContextData<'a, 'ast, 'refs>,
}

impl<'a, 'ast, 'refs> ContractContextData<'a, 'ast, 'refs> {
    pub fn new(
        refs: &'a AcyclicReferences<'refs>,
        lib_name: &'a str,
        std_name: &'a str,
        refs_name: &'a str,
        alloc: &'ast AstAlloc,
    ) -> Self {
        let always_eager = refs
            .iter()
            .map(|(name, schema)| (name, schema.is_always_eager(refs)))
            .collect();
        Self {
            refs,
            lib_name,
            std_name,
            refs_name,
            alloc,
            always_eager_refs: always_eager,
            accessed_refs: RefCell::new(BTreeSet::new()),
        }
    }

    pub fn ctx(&'a self) -> ContractContext<'a, 'ast, 'refs> {
        ContractContext {
            eager: false,
            inner: self,
        }
    }
}

impl<'ast, 'refs> ContractContext<'_, 'ast, 'refs> {
    /// Returns a Nickel term pointing to a path in our contracts library.
    pub fn js2n(&self, path: &str) -> Ast<'ast> {
        static_access(self.inner.alloc, self.inner.lib_name, path.split('.'))
    }

    /// Returns a Nickel term pointing to a path in the standard library.
    pub fn std(&self, path: &str) -> Ast<'ast> {
        static_access(self.inner.alloc, self.inner.std_name, path.split('.'))
    }

    /// Splits a json-schema ref name into its path components.
    ///
    /// "#/definitions/glob" becomes `["definitions", "glob"]`
    /// (or `["eager", "definitions", "glob"]` if it's eager).
    pub fn ref_name<'b>(
        &'b self,
        name: &'b str,
        eager: bool,
    ) -> impl DoubleEndedIterator<Item = &'b str> {
        let trimmed_name = name.trim_start_matches(['#', '/']);
        eager
            .then_some("eager")
            .into_iter()
            .chain(trimmed_name.split('/'))
    }

    /// Returns a Nickel term pointing to a contract for the json-schema reference `name`.
    pub fn ref_term(&self, name: &str) -> Ast<'ast> {
        let eager = self.eager && !self.inner.always_eager_refs.get(name).unwrap_or(&true);
        let names = self.ref_name(name, eager);

        if self.inner.refs.get(name).is_some() {
            self.inner
                .accessed_refs
                .borrow_mut()
                .insert((name.to_owned(), eager));
            static_access(self.inner.alloc, self.inner.refs_name, names)
        } else {
            // TODO: warn here, because ideally we trim missing references early on.
            static_access(self.inner.alloc, self.inner.lib_name, ["Always"])
        }
    }

    /// Returns the name that the generated contracts use to refer to our
    /// contracts library.
    ///
    /// This is probably something like "js2n", but it might be modified to
    /// avoid name collisions.
    pub fn lib_name(&self) -> &str {
        self.inner.lib_name
    }

    /// Returns the name that the generated contracts use to refer to the
    /// standard library.
    ///
    /// This is probably just "std", but it might be modified to
    /// avoid name collisions.
    pub fn std_name(&self) -> &str {
        self.inner.std_name
    }

    /// Returns the name that the generated contracts use to refer to our
    /// collection of reference targets.
    ///
    /// This is probably something like "refs", but it might be modified to
    /// avoid name collisions.
    pub fn refs_name(&self) -> &str {
        self.inner.refs_name
    }

    /// Returns all the schema references we know about.
    pub fn refs(&self) -> &AcyclicReferences<'refs> {
        self.inner.refs
    }

    /// Returns a new context that forces an eager contract.
    pub fn eager(self) -> Self {
        Self {
            eager: true,
            ..self
        }
    }

    /// Returns a new context that forces a lazy contract.
    pub fn lazy(self) -> Self {
        Self {
            eager: false,
            ..self
        }
    }

    /// In this context, do we need to provide an eager contract?
    pub fn is_eager(&self) -> bool {
        self.eager
    }

    /// Returns a set of all json-schema references that were accessed (through
    /// calls to `ref_term`) since this method was last called.
    ///
    /// Along with each reference name, returns a bool indicating whether it was
    /// accessed in an eager context.
    pub fn take_accessed_refs(&self) -> BTreeSet<(String, bool)> {
        std::mem::take(&mut self.inner.accessed_refs.borrow_mut())
    }

    /// Returns an allocator for Nickel ASTs.
    pub fn alloc(&self) -> &'ast AstAlloc {
        self.inner.alloc
    }

    /// Turns a collection of contracts into a single contract.
    pub fn sequence(&self, mut contracts: Vec<Ast<'ast>>) -> Ast<'ast> {
        if contracts.len() == 1 {
            contracts.pop().unwrap()
        } else {
            self.alloc()
                .app(
                    static_access(self.alloc(), "std", ["contract", "Sequence"]),
                    [self.alloc().array(contracts).into()],
                )
                .into()
        }
    }

    pub fn num(&self, x: &Number) -> Ast<'ast> {
        self.alloc().number(x.clone()).into()
    }

    pub fn from_json(&self, val: &serde_json::Value) -> Ast<'ast> {
        let node = match val {
            serde_json::Value::Null => Node::Null,
            serde_json::Value::Bool(b) => Node::Bool(*b),
            serde_json::Value::Number(number) => {
                if let Some(n) = number.as_f64() {
                    // unwrap: JSON has no infinities or NaNs, so the conversion to
                    // rational will succeed
                    self.alloc().number(n.try_into().unwrap())
                } else if let Some(n) = number.as_i128() {
                    self.alloc().number(n.into())
                } else {
                    // serde_json doesn't give us a way to exhaustively match, but
                    // at least for now we've covered all cases
                    unimplemented!()
                }
            }
            serde_json::Value::String(s) => self.alloc().string(s),
            serde_json::Value::Array(xs) => {
                self.alloc().array(xs.iter().map(|x| self.from_json(x)))
            }
            serde_json::Value::Object(map) => {
                let field_defs = map.iter().map(|(k, v)| FieldDef {
                    path: self.alloc().alloc_many([FieldPathElem::Ident(k.into())]),
                    metadata: Default::default(),
                    value: Some(self.from_json(v)),
                    pos: Default::default(),
                });
                Node::Record(self.alloc().record_data([], field_defs, false))
            }
        };
        node.into()
    }
}
</file>

<file path="src/extract.rs">
//! Conversion from JSON to our `Schema` intermediate representation
//!
//! The main public API of this module is the
//! `TryFrom<serde_json::Value> for Schema` implementation, which tries
//! to interpret a JSON value as a draft 7 JSON Schema.
//!
//! This conversion doesn't handle references: there may be parts of the
//! JSON value that are referenced by the schema but aren't directly part of it
//! (typically, children of the top-level "references" property). As a consequence,
//! you should keep the JSON value around for resolving references, and then
//! you can call `try_from` on those reference pointees.
//!
//! The error handing here could be improved, most notably by including source
//! locations. `miette` is capable of producing nice error messages that embed
//! source locations, but serde is currently stripping those locations out.

use std::collections::{BTreeMap, BTreeSet};

use miette::miette;
use nickel_lang_core::term::Number;
use serde_json::{Map, Value};

use crate::{
    object::{Obj, ObjectProperties, Property},
    schema::{Array, Num, Schema, Str},
    typ::{InstanceType, InstanceTypeSet},
};

impl<'a> TryFrom<&'a serde_json::Value> for Schema {
    type Error = miette::Report;

    fn try_from(value: &'a serde_json::Value) -> Result<Self, Self::Error> {
        if let Some(b) = value.as_bool() {
            return if b {
                Ok(Schema::Always)
            } else {
                Ok(Schema::Never)
            };
        }

        let obj = value
            .as_object()
            .ok_or_else(|| miette!("schema must be an object"))?;

        if obj.is_empty() {
            return Ok(Schema::Always);
        }

        // Get all the declared types. We have some special handling for num_schemas here,
        // because in JSON Schema "integer" is a type but for us "integer" is a schema on
        // the "number" type.
        let mut num_schemas = Vec::new();
        let types = match obj.get("type") {
            Some(tys) => {
                if let Some(s) = tys.as_str() {
                    if s == "integer" {
                        num_schemas.push(Schema::Number(Num::Integer));
                    }
                    InstanceTypeSet::singleton(s.parse()?)
                } else if let Some(a) = tys.as_array() {
                    if a.iter().any(|v| v.as_str() == Some("integer")) {
                        num_schemas.push(Schema::Number(Num::Integer));
                    }

                    a.iter()
                        .map(|value| {
                            value
                                .as_str()
                                .ok_or_else(|| miette!("instance type element must be a string"))?
                                .parse()
                        })
                        .collect::<miette::Result<InstanceTypeSet>>()?
                } else {
                    miette::bail!("instance type must be a string or an array");
                }
            }
            None => InstanceTypeSet::FULL,
        };

        // We build up the schema as an "and" of "or"s. JSON Schema validators
        // are implicitly "and"ed together, but the way we handle the different
        // typed validators means there's an implicit "or" also. For example,
        // if a JSON Schema has `properties`, `pattern`, and `allOf`, it means
        //
        // if it's an object then it must have some properties
        // and
        // if it's a string then it must match the pattern
        // and
        // ... all the stuff in the `allOf`.
        //
        // Since we prefer not to have so many if-thens, we represent this as
        //
        //   (it's an object with some properties
        //    or
        //    it's a string matching the pattern)
        // and
        // ... all the stuff in the `allOf`.
        //
        // That first "or" is the "implicit or", and its members go here:
        let mut or_schemas = Vec::new();

        if types.contains(InstanceType::Null) {
            or_schemas.push(Schema::Null);
        }

        if types.contains(InstanceType::Boolean) {
            or_schemas.push(Schema::Boolean);
        }

        if types.contains(InstanceType::Number) {
            num_schemas.extend(extract_number_schemas(obj)?);
            if !num_schemas.iter().any(|s| matches!(s, Schema::Number(_))) {
                num_schemas.push(Schema::Number(Num::Any));
            }

            or_schemas.push(Schema::AllOf(num_schemas));
        }

        if types.contains(InstanceType::String) {
            let mut str_schemas = extract_string_schemas(obj)?;
            if str_schemas.is_empty() {
                str_schemas.push(Schema::String(Str::Any));
            }

            or_schemas.push(Schema::AllOf(str_schemas));
        }

        if types.contains(InstanceType::Object) {
            let mut obj_schemas = extract_object_schemas(obj)?;
            if obj_schemas.is_empty() {
                obj_schemas.push(Schema::Object(Obj::Any));
            }

            or_schemas.push(Schema::AllOf(obj_schemas));
        }

        if types.contains(InstanceType::Array) {
            let mut arr_schemas = extract_array_schemas(obj)?;
            if arr_schemas.is_empty() {
                arr_schemas.push(Schema::Array(Array::Any));
            }

            or_schemas.push(Schema::AllOf(arr_schemas));
        }

        // Now we collect the or-ed schemas with everything else
        // into a big "and".
        let mut and_schemas = Vec::new();
        if !or_schemas.is_empty() {
            and_schemas.push(Schema::AnyOf(or_schemas));
        }

        if let Some(any_of) = get_non_empty_array(obj, "anyOf")? {
            let mut any_of_schemas = Vec::new();
            for value in any_of {
                any_of_schemas.push(value.try_into()?);
            }
            and_schemas.push(Schema::AnyOf(any_of_schemas));
        }

        if let Some(one_of) = get_non_empty_array(obj, "oneOf")? {
            let mut one_of_schemas = Vec::new();
            for value in one_of {
                one_of_schemas.push(value.try_into()?);
            }

            and_schemas.push(Schema::OneOf(one_of_schemas));
        }

        if let Some(all_of) = get_non_empty_array(obj, "allOf")? {
            for value in all_of {
                and_schemas.push(value.try_into()?);
            }
        }

        if let Some(iph) = obj.get("if") {
            let iph = Schema::try_from(iph)?;
            let then = match obj.get("then") {
                Some(then_obj) => then_obj.try_into()?,
                None => Schema::Always,
            };
            let els = match obj.get("else") {
                Some(els_obj) => els_obj.try_into()?,
                None => Schema::Always,
            };

            and_schemas.push(Schema::IfThenElse {
                iph: Box::new(iph),
                then: Box::new(then),
                els: Box::new(els),
            });
        }

        if let Some(not) = obj.get("not") {
            and_schemas.push(Schema::Not(Box::new(not.try_into()?)));
        }

        if let Some(konst) = obj.get("const") {
            and_schemas.push(Schema::Const(konst.clone()));
        }

        // It SHOULD be a non-empty array, and that's easier to handle for now.
        if let Some(inum) = get_non_empty_array(obj, "enum")? {
            and_schemas.push(Schema::Enum(inum.clone()));
        }

        if let Some(reff) = get_string(obj, "$ref")? {
            and_schemas.push(Schema::Ref(reff.to_owned()));
        }

        Ok(Schema::AllOf(and_schemas))
    }
}

/// Retrieve a number value from a map.
///
/// Returns `Ok(None)` if the field is missing, but an error if it's present and not a number.
fn get_number(obj: &Map<String, Value>, field: &str) -> miette::Result<Option<Number>> {
    if let Some(val) = obj.get(field) {
        match val.as_number() {
            Some(n) => Ok(Some(if let Some(f) = n.as_f64() {
                Number::try_from(f).unwrap()
            } else if let Some(n) = n.as_u128() {
                Number::from(n)
            } else if let Some(n) = n.as_i128() {
                Number::from(n)
            } else {
                // As of this writing, serde_json doesn't support any other numbers. But
                // it also doesn't allow exhaustive matching...
                miette::bail!("{field} was a weird number")
            })),
            None => miette::bail!("{field} must be a number"),
        }
    } else {
        Ok(None)
    }
}

/// Retrieve a string value from a map.
///
/// Returns `Ok(None)` if the field is missing, but an error if it's present and not a string.
fn get_string(obj: &Map<String, Value>, field: &str) -> miette::Result<Option<String>> {
    if let Some(val) = obj.get(field) {
        match val.as_str() {
            Some(s) => Ok(Some(s.to_owned())),
            None => miette::bail!("{field} must be a string"),
        }
    } else {
        Ok(None)
    }
}

fn get_non_empty_array<'a>(
    obj: &'a Map<String, Value>,
    field: &str,
) -> miette::Result<Option<&'a Vec<Value>>> {
    if let Some(arr) = get_array(obj, field)? {
        if arr.is_empty() {
            miette::bail!("{field} can't be empty")
        } else {
            Ok(Some(arr))
        }
    } else {
        Ok(None)
    }
}

/// Retrieve an array value from a map.
///
/// Returns `Ok(None)` if the field is missing, but an error if it's present and not an array.
pub fn get_array<'a>(
    obj: &'a Map<String, Value>,
    field: &str,
) -> miette::Result<Option<&'a Vec<Value>>> {
    if let Some(val) = obj.get(field) {
        match val.as_array() {
            Some(arr) => Ok(Some(arr)),
            None => miette::bail!("{field} must be an array"),
        }
    } else {
        Ok(None)
    }
}

/// Retrieve an object value from a map.
///
/// Returns `Ok(None)` if the field is missing, but an error if it's present and not an object.
pub fn get_object<'a>(
    obj: &'a Map<String, Value>,
    field: &str,
) -> miette::Result<Option<&'a Map<String, Value>>> {
    if let Some(val) = obj.get(field) {
        match val.as_object() {
            Some(obj) => Ok(Some(obj)),
            None => miette::bail!("{field} must be an object"),
        }
    } else {
        Ok(None)
    }
}

/// Extract and return all the string validation schemas from this schema object.
fn extract_string_schemas(obj: &Map<String, Value>) -> miette::Result<Vec<Schema>> {
    let mut ret = Vec::new();

    if let Some(max) = get_number(obj, "maxLength")? {
        ret.push(Schema::String(Str::MaxLength(max)));
    }

    if let Some(min) = get_number(obj, "minLength")? {
        ret.push(Schema::String(Str::MinLength(min)));
    }

    if let Some(pattern) = get_string(obj, "pattern")? {
        ret.push(Schema::String(Str::Pattern(pattern)));
    }

    Ok(ret)
}

/// Extract and return all the number validation schemas from this schema object.
fn extract_number_schemas(obj: &Map<String, Value>) -> miette::Result<Vec<Schema>> {
    let mut ret = Vec::new();

    if let Some(mult) = get_number(obj, "multipleOf")? {
        ret.push(Schema::Number(Num::MultipleOf(mult)));
    }
    if let Some(max) = get_number(obj, "maximum")? {
        ret.push(Schema::Number(Num::Maximum(max)));
    }
    if let Some(min) = get_number(obj, "minimum")? {
        ret.push(Schema::Number(Num::Minimum(min)));
    }
    if let Some(ex_max) = get_number(obj, "exclusiveMaximum")? {
        ret.push(Schema::Number(Num::ExclusiveMaximum(ex_max)));
    }
    if let Some(ex_min) = get_number(obj, "exclusiveMinimum")? {
        ret.push(Schema::Number(Num::ExclusiveMinimum(ex_min)));
    }

    Ok(ret)
}

/// Extract and return all the object validation schemas from this schema object.
fn extract_object_schemas(obj: &Map<String, Value>) -> miette::Result<Vec<Schema>> {
    let mut ret = Vec::new();

    if let Some(max) = get_number(obj, "maxProperties")? {
        ret.push(Schema::Object(Obj::MaxProperties(max)));
    }
    if let Some(min) = get_number(obj, "minProperties")? {
        ret.push(Schema::Object(Obj::MinProperties(min)));
    }
    if let Some(req) = get_array(obj, "required")? {
        if !req.is_empty() {
            let req: BTreeSet<String> = req
                .iter()
                .map(|name| {
                    name.as_str()
                        .ok_or_else(|| miette!("elements of \"required\" must be strings"))
                        .map(str::to_owned)
                })
                .collect::<miette::Result<_>>()?;
            ret.push(Schema::Object(Obj::Required(req)));
        }
    }
    if let Some(names) = obj.get("propertyNames") {
        ret.push(Schema::Object(Obj::PropertyNames(Box::new(
            names.try_into()?,
        ))));
    }
    if let Some(deps) = get_object(obj, "dependencies")? {
        let mut dep_fields = BTreeMap::new();
        let mut dep_schemas = BTreeMap::new();
        for (field, val) in deps {
            if let Some(arr) = val.as_array() {
                let names = arr
                    .iter()
                    .map(|v| {
                        v.as_str()
                            .ok_or_else(|| miette!("elements of dependency array must be strings"))
                            .map(str::to_owned)
                    })
                    .collect::<miette::Result<_>>()?;
                dep_fields.insert(field.to_owned(), names);
            } else {
                dep_schemas.insert(field.to_owned(), val.try_into()?);
            }
        }

        if !dep_fields.is_empty() {
            ret.push(Schema::Object(Obj::DependentFields(dep_fields)));
        }
        if !dep_schemas.is_empty() {
            ret.push(Schema::Object(Obj::DependentSchemas(dep_schemas)));
        }
    }

    let mut properties = ObjectProperties {
        properties: BTreeMap::new(),
        pattern_properties: BTreeMap::new(),
        additional_properties: None,
    };
    if let Some(props) = get_object(obj, "properties")? {
        properties.properties = props
            .iter()
            .map(|(k, v)| {
                let schema = Schema::try_from(v)?;
                let mut prop = Property::from(schema);

                if let Some(doc) = v
                    .as_object()
                    .and_then(|obj| obj.get("description"))
                    .and_then(|desc| desc.as_str())
                {
                    prop.doc = Some(doc.to_owned());
                }
                Ok((k.to_owned(), prop))
            })
            .collect::<miette::Result<_>>()?;
    };
    if let Some(pats) = get_object(obj, "patternProperties")? {
        properties.pattern_properties = pats
            .iter()
            .map(|(k, v)| Ok((k.to_owned(), v.try_into()?)))
            .collect::<miette::Result<_>>()?;
    }
    if let Some(adds) = obj.get("additionalProperties") {
        properties.additional_properties = Some(Box::new(adds.try_into()?));
    }

    if !properties.properties.is_empty()
        || !properties.pattern_properties.is_empty()
        || properties.additional_properties.is_some()
    {
        ret.push(Schema::Object(Obj::Properties(properties)));
    }

    Ok(ret)
}

/// Extract and return all the array validation schemas from this schema object.
fn extract_array_schemas(obj: &Map<String, Value>) -> miette::Result<Vec<Schema>> {
    let mut ret = Vec::new();

    if let Some(max) = get_number(obj, "maxItems")? {
        ret.push(Schema::Array(Array::MaxItems(max)));
    }
    if let Some(min) = get_number(obj, "minItems")? {
        ret.push(Schema::Array(Array::MinItems(min)));
    }
    if let Some(unique) = obj.get("uniqueItems") {
        if let Some(unique) = unique.as_bool() {
            if unique {
                ret.push(Schema::Array(Array::UniqueItems));
            }
        } else {
            miette::bail!("\"uniqueItems\" must be a boolean");
        }
    }
    if let Some(contains) = obj.get("contains") {
        ret.push(Schema::Array(Array::Contains(Box::new(
            contains.try_into()?,
        ))));
    }

    if let Some(items) = obj.get("items") {
        if let Some(arr) = items.as_array() {
            let initial: Vec<_> = arr
                .iter()
                .map(Schema::try_from)
                .collect::<miette::Result<_>>()?;

            let rest = match obj.get("additionalItems") {
                Some(add) => add.try_into()?,
                None => Schema::Always,
            };
            ret.push(Schema::Array(Array::PerItem {
                initial,
                rest: Box::new(rest),
            }));
        } else {
            // If items is a single item, we ignore additionalItems.
            ret.push(Schema::Array(Array::AllItems(Box::new(items.try_into()?))));
        }
    }

    Ok(ret)
}
</file>

<file path="src/lib.rs">
//! # Convert JSON schemas to Nickel contracts and predicates
//!
//! JSON schema can be considered as a DSL for writing predicates on JSON
//! documents. That is, a JSON schema encodes a function taking in a JSON
//! document and returning either "success" or an error message. Such predicates
//! can be turned into Nickel contracts.
//!
//! Converting JSON schemas into lazy Nickel contracts is not always possible,
//! because JSON schema keywords like `anyOf` and `oneOf` require eager
//! evaluation. We attempt to create idiomatic lazy Nickel contracts, falling
//! back to eager contracts when we are unable to do so.

pub mod contract;
pub mod extract;
pub mod object;
pub mod references;
pub mod schema;
pub mod transform;
pub mod traverse;
pub mod typ;
pub(crate) mod utils;

use nickel_lang_core::{
    bytecode::ast::{Ast, AstAlloc},
    cache::{CacheHub, SourcePath},
    parser::{grammar::TermParser, lexer::Lexer, ErrorTolerantParser},
};
use references::{resolve_all, AcyclicReferences};
use schema::Schema;

pub fn inline_lib(alloc: &AstAlloc) -> Ast<'_> {
    let lib_ncl = include_bytes!(concat!(env!("OUT_DIR"), "/main.ncl"));
    let lib_ncl = String::from_utf8_lossy(lib_ncl);

    let mut cache = CacheHub::new();
    let parser = TermParser::new();
    let file_id = cache.sources.add_string(
        SourcePath::Generated("main.ncl".to_owned()),
        lib_ncl.to_string(),
    );
    let lexer = Lexer::new(cache.sources.source(file_id));
    parser.parse_strict(alloc, file_id, lexer).unwrap()
}

/// Create a Nickel contract from a JSON value containing a JSON Schema.
///
/// `lib_import` is a term that imports the json-schema library.
pub fn convert<'ast>(
    val: &serde_json::Value,
    lib_import: Ast<'ast>,
    alloc: &'ast AstAlloc,
) -> miette::Result<Ast<'ast>> {
    let schema: Schema = val.try_into()?;
    let all_refs = resolve_all(val, &schema);
    let refs = AcyclicReferences::new(&all_refs);
    let simple_refs = all_refs
        .iter()
        .map(|(k, v)| (k.clone(), transform::simplify(v.clone(), &refs)))
        .collect();
    let refs = AcyclicReferences::new(&simple_refs);
    let schema = transform::inline_refs(schema, &refs);
    let schema = transform::simplify(schema, &refs);

    Ok(transform::schema_to_nickel(
        &schema, &refs, lib_import, alloc,
    ))
}
</file>

<file path="src/main.rs">
use std::{
    error::Error,
    ffi::OsString,
    fs::File,
    io::{stdout, Read},
};

use clap::Parser;
use json_schema_to_nickel::{convert, inline_lib};
use nickel_lang_core::{
    bytecode::ast::{AstAlloc, Import, Node},
    pretty::*,
};
use terminal_size::{terminal_size, Width};

#[derive(Parser)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// Path to a JSON schema file. If omitted, the schema file will be read from stdin.
    schema: Option<String>,

    /// Generate a contract that will import the json-schema-to-nickel Nickel library from the
    /// given path. The path must point to the entry point of the library, currently
    /// `predicates.ncl`.
    ///
    /// By default, when no library path is specified, json-schema-to-nickel will inline this
    /// library inside the contract to make it standalone. However, when converting many schemas
    /// and distributing them together, this inlining leads to a lot of code duplication. Using
    /// this argument avoids the duplication, although it makes you responsible of making the
    /// json-schema-to-nickel library available at the right place.
    #[clap(long)]
    library_path: Option<OsString>,

    /// Generate a contract that will import the json-schema-to-nickel Nickel library from a
    /// package with the given name.
    ///
    /// For example, if you provide `--library-pkg=js2n` then the generated contract will
    /// attempt to import the json-schema-to-nickel library using the syntax `import js2n`.
    /// This argument does not generate a `Nickel-pkg.ncl` package manifest; you will need
    /// to provide one that defines the `js2n` package.
    #[clap(long, conflicts_with = "library_path")]
    library_pkg: Option<String>,
}

fn main() -> Result<(), Box<dyn Error>> {
    let args = Args::parse();
    let f: Box<dyn Read> = if let Some(path) = args.schema {
        Box::new(File::open(path)?)
    } else {
        Box::new(std::io::stdin())
    };
    let alloc = AstAlloc::new();
    let lib_term = if let Some(path) = args.library_path.as_ref() {
        Node::Import(Import::Path {
            path,
            format: nickel_lang_core::cache::InputFormat::Nickel,
        })
        .into()
    } else if let Some(lib) = args.library_pkg {
        Node::Import(Import::Package { id: lib.into() }).into()
    } else {
        inline_lib(&alloc)
    };

    let val: serde_json::Value = serde_json::from_reader(f)?;
    let contract = convert(&val, lib_term, &alloc)?;

    let size = terminal_size()
        .map(|(Width(w), _)| w as usize)
        .unwrap_or(80);
    let pretty_alloc = nickel_lang_core::bytecode::pretty::Allocator::default();
    let types: DocBuilder<'_, _, ()> = contract.pretty(&pretty_alloc);

    println!("# DO NOT EDIT\n# This file was automatically generated using json-schema-to-nickel");
    types.render(size, &mut stdout())?;

    Ok(())
}
</file>

<file path="src/object.rs">
//! Object schemas
//!
//! The schemas in the module correspond fairly closely to the ones documented
//! [here](https://json-schema.org/draft-07/draft-handrews-json-schema-validation-01#rfc.section.6.5)

use std::collections::{BTreeMap, BTreeSet};

use nickel_lang_core::{
    bytecode::ast::{builder, record::FieldMetadata, Ast, Node},
    term::Number,
    typ::{DictTypeFlavour, TypeF},
};
use serde::Serialize;

use crate::{contract::ContractContext, schema::Schema, utils::type_contract};

/// A schema for validating objects.
///
/// Unlike in JSON Schema, all of these schemas assert that the value is an
/// object; in JSON Schema, the object validation keywords all assert that *if*
/// the value is an object then it satisfies some additional properties.
#[derive(Clone, Debug, Serialize, PartialEq, Eq, Hash)]
pub enum Obj {
    /// Asserts that the value is an object, and nothing else.
    Any,
    /// Validates the object's properties against sub-schemas.
    Properties(ObjectProperties),
    /// Asserts an upper bound on the number of properties.
    MaxProperties(Number),
    /// Asserts a lower bound on the number of properties.
    MinProperties(Number),
    /// Asserts that the object contains certain properties.
    ///
    /// TODO: maybe we can get rid of this by representing it with `Properties`
    Required(BTreeSet<String>),
    /// Asserts that the names of all properties in the object satisfy
    /// a schema.
    ///
    /// This could be simplified maybe, because we're guaranteed that this will
    /// only need to validate strings.
    PropertyNames(Box<Schema>),
    /// Asserts that if some properties are present then other properties
    /// are also present.
    ///
    /// Specifically, if the map contains `(key, values)` and the object
    /// contains the property named `key` then it must also contain all
    /// the properties whose names are in `values`.
    ///
    /// TODO: consider simplifying the representation to contain only a
    /// single `(key, values)` pair instead of a map. The general case can be
    /// represented by wrapping the simplified cases in an `AllOf`.
    DependentFields(BTreeMap<String, Vec<String>>),
    /// Asserts that if some properties are present then the entire object
    /// satisfies some schema.
    ///
    /// Specifically, if the map contains `(key, schema)` and the object
    /// contains the property named `key` then it must also satisfy `schema`.
    ///
    /// TODO: consider the same simplification as `DependentFields`.
    DependentSchemas(BTreeMap<String, Schema>),
}

/// The value in a JSON Schema "properties" object.
///
/// This would be most faithfully represented as just a `Schema`, but we
/// track some additional data.
#[derive(Clone, Debug, Serialize, PartialEq, Eq, Hash)]
pub struct Property {
    /// A description of this property.
    pub doc: Option<String>,
    /// The schema that applies to the property's value.
    pub schema: Schema,
    /// Whether the property is optional.
    ///
    /// In JSON Schema "properties", all properties are optional; non-optional
    /// properties are handled by the orthogonal "required" schema. To generate
    /// better Nickel contracts, we support explicit optionality here. This is
    /// always `true` when we first convert from JSON Schema, but transformations
    /// might set it to `false`.
    pub optional: bool,
}

impl From<Schema> for Property {
    fn from(s: Schema) -> Self {
        Property {
            doc: None,
            schema: s,
            optional: true,
        }
    }
}

/// Schemas for validating properties of an object.
///
/// This is a combination of the "properties", "patternProperties", and
/// "additionalProperties" keywords in JSON Schema.
#[derive(Clone, Debug, Serialize, PartialEq, Eq, Hash)]
pub struct ObjectProperties {
    /// Schemas for named properties of this object.
    pub properties: BTreeMap<String, Property>,
    /// Schemas for properties of this object whose names match regular
    /// expressions.
    ///
    /// A property can get matched by more than one regular expression; all of
    /// the matching schemas will be checked. Similarly, a property that already
    /// matched a name in `properties` can get matched by a pattern here.
    pub pattern_properties: BTreeMap<String, Schema>,
    /// A schema that's applied to all properties of this object that
    /// were not matched by any names in `properties` or any patterns in
    /// `pattern_properties`.
    pub additional_properties: Option<Box<Schema>>,
}

impl Obj {
    /// Converts this object schema to a Nickel contract.
    ///
    /// Can return multiple contracts that should be applied in sequence.
    pub fn to_contract<'ast>(&self, ctx: ContractContext<'_, 'ast, '_>) -> Vec<Ast<'ast>> {
        match self {
            Obj::Any => vec![type_contract(
                ctx.alloc(),
                TypeF::Dict {
                    type_fields: ctx.alloc().type_data(TypeF::Dyn, Default::default()),
                    flavour: nickel_lang_core::typ::DictTypeFlavour::Contract,
                },
            )],
            Obj::Properties(op) => op.to_special_contract(ctx).unwrap_or_else(|| {
                let additional = match op.additional_properties.as_deref() {
                    Some(Schema::Never) => Node::EnumVariant {
                        tag: "None".into(),
                        arg: None,
                    },
                    Some(s) => Node::EnumVariant {
                        tag: "Some".into(),
                        arg: Some(ctx.alloc().alloc(ctx.sequence(s.to_contract(ctx)))),
                    },
                    None => Node::EnumVariant {
                        tag: "Some".into(),
                        arg: Some(ctx.alloc().alloc(type_contract(ctx.alloc(), TypeF::Dyn))),
                    },
                };
                let properties = builder::Record::new()
                    .fields(
                        ctx.alloc(),
                        op.properties.iter().map(|(k, v)| {
                            builder::Field::name(k).value(ctx.sequence(v.schema.to_contract(ctx)))
                        }),
                    )
                    .build(ctx.alloc());
                let required = builder::Record::new()
                    .fields(
                        ctx.alloc(),
                        op.properties.iter().filter_map(|(k, v)| {
                            if !v.optional {
                                Some(builder::Field::name(k).value(Node::Bool(true)))
                            } else {
                                None
                            }
                        }),
                    )
                    .build(ctx.alloc());
                let patterns = builder::Record::new()
                    .fields(
                        ctx.alloc(),
                        op.pattern_properties.iter().map(|(k, v)| {
                            builder::Field::name(k).value(ctx.sequence(v.to_contract(ctx)))
                        }),
                    )
                    .build(ctx.alloc());

                vec![ctx
                    .alloc()
                    .app(
                        ctx.js2n("record.Record"),
                        [builder::Record::new()
                            .fields(
                                ctx.alloc(),
                                [
                                    builder::Field::name("properties").value(properties),
                                    builder::Field::name("required").value(required),
                                    builder::Field::name("patterns").value(patterns),
                                    builder::Field::name("additional").value(additional),
                                ],
                            )
                            .build(ctx.alloc())],
                    )
                    .into()]
            }),
            Obj::MaxProperties(n) => {
                vec![ctx
                    .alloc()
                    .app(ctx.js2n("record.MaxProperties"), [ctx.num(n)])
                    .into()]
            }
            Obj::MinProperties(n) => {
                vec![ctx
                    .alloc()
                    .app(ctx.js2n("record.MinProperties"), [ctx.num(n)])
                    .into()]
            }
            Obj::Required(names) => {
                vec![ctx
                    .alloc()
                    .app(
                        ctx.js2n("record.Required"),
                        [ctx.alloc()
                            .array(names.iter().map(|s| ctx.alloc().string(s).into()))
                            .into()],
                    )
                    .into()]
            }
            Obj::PropertyNames(schema) => {
                vec![ctx
                    .alloc()
                    .app(
                        ctx.js2n("record.PropertyNames"),
                        [ctx.sequence(schema.to_contract(ctx))],
                    )
                    .into()]
            }
            Obj::DependentFields(deps) => {
                vec![ctx
                    .alloc()
                    .app(
                        ctx.js2n("record.DependentFields"),
                        [builder::Record::new()
                            .fields(
                                ctx.alloc(),
                                deps.iter().map(|(key, value)| {
                                    let arr = ctx
                                        .alloc()
                                        .array(value.iter().map(|s| ctx.alloc().string(s).into()));
                                    builder::Field::name(key).value(arr)
                                }),
                            )
                            .build(ctx.alloc())],
                    )
                    .into()]
            }
            Obj::DependentSchemas(deps) => {
                vec![ctx
                    .alloc()
                    .app(
                        ctx.js2n("record.DependentContracts"),
                        [builder::Record::new()
                            .fields(
                                ctx.alloc(),
                                deps.iter().map(|(key, schema)| {
                                    let contract = ctx.sequence(schema.to_contract(ctx));
                                    builder::Field::name(key).value(contract)
                                }),
                            )
                            .build(ctx.alloc())],
                    )
                    .into()]
            }
        }
    }
}

impl ObjectProperties {
    /// Attempts to produce idiomatic Nickel record contracts from this schema.
    ///
    /// Our js2n contracts library contains functions for creating Nickel contracts
    /// from arbitrary `ObjectProperties`, but the contracts it creates are not
    /// record contracts and so they miss things like field documentation. This
    /// method attempts to create a better contract, but it's allowed to fail.
    pub fn to_special_contract<'ast>(
        &self,
        ctx: ContractContext<'_, 'ast, '_>,
    ) -> Option<Vec<Ast<'ast>>> {
        let trivial_additional = matches!(
            self.additional_properties.as_deref(),
            None | Some(Schema::Always) | Some(Schema::Never)
        );
        let no_additional = self.additional_properties.as_deref() == Some(&Schema::Never);
        if self.pattern_properties.is_empty() && trivial_additional && !ctx.is_eager() {
            // A normal record contract, which may or may not be open. If all the element contracts
            // are trivial, this will even be an eager contract.
            let open = matches!(
                self.additional_properties.as_deref(),
                None | Some(Schema::Always)
            );

            let fields = self.properties.iter().map(|(name, prop)| {
                let contracts = prop
                    .schema
                    .to_contract(ctx)
                    .into_iter()
                    .map(|c| TypeF::Contract(ctx.alloc().alloc(c)).into());
                builder::Field::name(name)
                    .metadata(FieldMetadata {
                        doc: prop.doc.as_ref().map(|s| ctx.alloc().alloc_str(s)),
                        opt: prop.optional,
                        ..Default::default()
                    })
                    .contracts(contracts)
                    .no_value()
            });

            Some(vec![builder::Record::new()
                .fields(ctx.alloc(), fields)
                .set_open(open)
                .build(ctx.alloc())])
        } else if self.properties.is_empty()
            && self.pattern_properties.is_empty()
            && (!ctx.is_eager() || trivial_additional)
        {
            // No properties were specified, just a contract on the additional
            // properties. We mostly treat this as a dict, but if additional
            // properties are forbidden we treat it as an empty record.
            if no_additional {
                Some(vec![builder::Record::new().build(ctx.alloc())])
            } else {
                let additional_properties = self
                    .additional_properties
                    .as_deref()
                    .unwrap_or(&Schema::Always);
                Some(vec![dict_contract(additional_properties, ctx)])
            }
        } else if self.properties.is_empty()
            && self.pattern_properties.len() == 1
            && no_additional
            && (!ctx.is_eager()
                || self
                    .pattern_properties
                    .values()
                    .all(|s| s == &Schema::Always))
        {
            // unwrap: we checked for length 1
            let (pattern, schema) = self.pattern_properties.iter().next().unwrap();
            let dict = dict_contract(schema, ctx);
            let names = ctx.alloc().app(
                ctx.std("record.FieldsMatch"),
                [ctx.alloc().string(pattern).into()],
            );
            Some(vec![dict, names.into()])
        } else {
            None
        }
    }
}

fn dict_contract<'ast>(elt_schema: &Schema, ctx: ContractContext<'_, 'ast, '_>) -> Ast<'ast> {
    let elt_contract = elt_schema.to_contract(ctx);

    type_contract(
        ctx.alloc(),
        TypeF::Dict {
            type_fields: ctx.alloc().type_data(
                TypeF::Contract(ctx.alloc().alloc(ctx.sequence(elt_contract))),
                Default::default(),
            ),
            flavour: DictTypeFlavour::Contract,
        },
    )
}
</file>

<file path="src/references.rs">
//! Reference handling for JSON schema
//!
//! JSON schemas can reference other schemas at essentially arbitrary points through the special
//! [`$ref`](https://json-schema.org/draft/2020-12/json-schema-core#name-direct-references-with-ref)
//! attribute. Those references are very general: they are URI, which can point to a remote
//! resource of the network. The fragment of the URI is a [JSON
//! pointer](https://discord.com/channels/1174731094726295632/1179430745727586407/1225453786529660938),
//! which is a path within the JSON schema to a specific attribute (note that it's not JSON-schema
//! specific, but rather a general mechanism to index into a JSON value).
//!
//! We don't want to support the general case, at least for now, as it comes with its lot of
//! complexity. However, we want to at least be capable of resolving all local references (i.e.
//! reference to the current file).
//!
//! There are two different kinds of references:
//!
//! - references to top-level definitions in a schema. JSON schemas can contain a set of
//!   definitions at the top level and reference them from other parts of the schema.
//! - references to other properties of the schema.
//!
//! In both cases, in order to resolve references, we might need either the contract or the
//! predicate version of the converted schemas (both the predicate and the contract) for each
//! definition and property, as we don't know yet if their usage will require the predicate form or
//! the contract form. During conversion, we simply suppose that they are accessible through
//! special values that are introduced at the top level by json-schema-to-nickel, e.g.
//! `___nickel_defs` or `___nickel_props_preds`. Thus, we can refer to them with a statically known
//! field path. We record along the way which properties or definitions are used, and if they are
//! used as a contract or as a predicate.
//!
//! At the end, we can elaborate the required special values like `___nickel_defs` and only include
//! the actually used in the final contract, to avoid bloating the result.
use std::{
    cell::RefCell,
    collections::{BTreeMap, HashSet},
};

use fluent_uri;
use miette::miette;

use nickel_lang_core::bytecode::ast::{Ast, AstAlloc};
use serde_json::Value;

use crate::{
    extract::{get_array, get_object},
    schema::Schema,
    traverse::Traverse as _,
    utils::{decode_json_ptr_part, static_access},
};

/// A representation of a field path in the final generated contract.
///
/// # Invariants
///
/// The path is guaranteed to be non-empty by construction. Do not directly mutate the underlying
/// path at the risk of making it empty.
#[derive(Hash, Clone, Debug, Default)]
pub struct FieldPath {
    path: Vec<String>,
}

pub struct EmptyFieldPath;

impl TryFrom<Vec<String>> for FieldPath {
    type Error = EmptyFieldPath;

    fn try_from(path: Vec<String>) -> Result<Self, Self::Error> {
        if path.is_empty() {
            return Err(EmptyFieldPath);
        }

        Ok(Self { path })
    }
}

impl FieldPath {
    pub fn to_ast<'ast>(&self, alloc: &'ast AstAlloc) -> Ast<'ast> {
        // unwrap(): the `FieldPath` struct guarantees that the path is non-empty by construction.
        static_access(alloc, self.path.first().unwrap(), self.path.iter().skip(1))
    }
}

/// A representation of a [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901) inside a
/// JSON Schema. This type is more structured that a generic JSON pointer, as it matches the
/// specific and constrained structure of a JSON Schema.
///
/// For example, a JSON Schema reference `#/properties/foo/contains/items/0/allOf/5` will be parsed
/// as a [SchemaPointer] of the form `[Properties("foo"), Contains, Items(0), allOf(5)]`.
#[derive(Hash, Clone, Debug, Default, Eq, PartialEq)]
pub struct SchemaPointer {
    pub path: Vec<SchemaPointerElt>,
}

impl SchemaPointer {
    /// Parse a string representation of a JSON pointer as a schema pointer.
    pub fn parse(json_ptr: &str) -> Result<Self, SchemaPointerParseError> {
        fn parse_array_idx(
            keyword: String,
            index_str: Option<String>,
        ) -> Result<usize, SchemaPointerParseError> {
            let index_str =
                index_str.ok_or_else(|| SchemaPointerParseError::MissingIndex(keyword.clone()))?;

            let index: usize =
                index_str
                    .parse()
                    .map_err(|_| SchemaPointerParseError::InvalidArrayIndex {
                        keyword,
                        index: index_str,
                    })?;

            Ok(index)
        }

        let mut path = Vec::new();
        let mut it = json_ptr.split('/').map(decode_json_ptr_part).peekable();

        while let Some(keyword) = it.next() {
            match keyword.as_ref() {
                "definitions" => path.push(SchemaPointerElt::Definitions(
                    it.next()
                        .ok_or(SchemaPointerParseError::MissingIndex(keyword))?,
                )),
                "properties" => path.push(SchemaPointerElt::Properties(
                    it.next()
                        .ok_or(SchemaPointerParseError::MissingIndex(keyword))?,
                )),
                "additionalProperties" => {
                    path.push(SchemaPointerElt::AdditionalProperties);
                }
                "items" => {
                    if let Ok(index) = parse_array_idx(keyword, it.peek().cloned()) {
                        // Actually consume the token we've peeked at
                        it.next();
                        path.push(SchemaPointerElt::ItemsIndexed(index));
                    } else {
                        path.push(SchemaPointerElt::ItemsSingle);
                    }
                }
                "contains" => {
                    path.push(SchemaPointerElt::Contains);
                }
                "allOf" => {
                    path.push(SchemaPointerElt::AllOf(parse_array_idx(
                        keyword,
                        it.next(),
                    )?));
                }
                "anyOf" => {
                    path.push(SchemaPointerElt::AnyOf(parse_array_idx(
                        keyword,
                        it.next(),
                    )?));
                }
                "oneOf" => {
                    path.push(SchemaPointerElt::OneOf(parse_array_idx(
                        keyword,
                        it.next(),
                    )?));
                }
                "not" => {
                    path.push(SchemaPointerElt::Not);
                }
                "then" => {
                    path.push(SchemaPointerElt::Then);
                }
                "else" => {
                    path.push(SchemaPointerElt::Else);
                }
                _ => return Err(SchemaPointerParseError::UnsupportedKeyword(keyword)),
            }
        }

        Ok(SchemaPointer { path })
    }

    /// Takes a schema pointer whose path is comprised only of properties and returns the
    /// corresponding path in the final generated contract, that is the sequence of property's
    /// names with all the intermediate `/properties` stripped.
    ///
    /// # Example
    ///
    /// Running [Self::try_as_field_path] on a schema pointer `/properties/foo/properties/bar` will
    /// return the field path `["foo", "bar"]`.
    ///
    /// # Return values
    ///
    /// If the path is empty or isn't composed only of properties, this method returns `None`.
    pub fn try_as_field_path(&self) -> Option<FieldPath> {
        let stripped: Option<Vec<_>> = self
            .path
            .iter()
            .map(|elt| match elt {
                SchemaPointerElt::Properties(name) => Some(name.clone()),
                _ => None,
            })
            .collect();

        FieldPath::try_from(stripped?).ok()
    }

    /// Returns `true` if the path is composed only of properties.
    pub fn is_only_props(&self) -> bool {
        self.path
            .iter()
            .all(|elt| matches!(elt, SchemaPointerElt::Properties(_)))
    }

    /// Returns the JSON value pointed to by `self` relative to `root`.
    pub fn resolve_in<'a>(&self, root: &'a Value) -> miette::Result<&'a Value> {
        let mut val = root;
        for elt in self.path.iter() {
            match elt {
                SchemaPointerElt::Definitions(name) => {
                    let Some(obj) = val.as_object() else {
                        miette::bail!("cannot look up definitions in a non-object");
                    };
                    val = get_object(obj, "definitions")?
                        .ok_or_else(|| miette!("no definitions"))?
                        .get(name)
                        .ok_or_else(|| miette!("missing {name}"))?;
                }
                SchemaPointerElt::Properties(name) => {
                    let Some(obj) = val.as_object() else {
                        miette::bail!("cannot look up {} in a non-object", elt.name());
                    };
                    let Some(props) = get_object(obj, "properties")? else {
                        miette::bail!("no \"properties\" field");
                    };
                    val = props
                        .get(name)
                        .ok_or_else(|| miette!("field {name} not found"))?;
                }
                SchemaPointerElt::ItemsIndexed(i)
                | SchemaPointerElt::AllOf(i)
                | SchemaPointerElt::AnyOf(i)
                | SchemaPointerElt::OneOf(i) => {
                    let Some(obj) = val.as_object() else {
                        miette::bail!("cannot look up {} in a non-object", elt.name());
                    };

                    let field = get_array(obj, elt.name())?
                        .ok_or_else(|| miette!("field {} not found", elt.name()))?;

                    val = field
                        .get(*i)
                        .ok_or_else(|| miette!("array has no index {i}"))?;
                }
                SchemaPointerElt::ItemsSingle
                | SchemaPointerElt::Contains
                | SchemaPointerElt::AdditionalProperties
                | SchemaPointerElt::Not
                | SchemaPointerElt::Then
                | SchemaPointerElt::Else => {
                    let Some(obj) = val.as_object() else {
                        miette::bail!("cannot look up {} in a non-object", elt.name());
                    };

                    val = obj
                        .get(elt.name())
                        .ok_or(miette!("field {} not found", elt.name()))?;
                }
            };
        }
        Ok(val)
    }
}

impl std::fmt::Display for SchemaPointer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        for elt in self.path.iter() {
            write!(f, "/{elt}")?;
        }

        Ok(())
    }
}

/// Element of a JSON pointer supported by json-schema-to-nickel. A JSON Pointer is parsed as a
/// sequence of [SchemaPointerElt] which locates a subschema within a JSON Schema. Each variant
/// corresponds to a JSON schema keyword.
///
/// Keywords containing a single schema (such as `contains`) don't need any additional data.
/// Keywords storing objects carries a string indicating which property of the object should be
/// accessed (e.g. `properties/foo`). Keywords storing arrays carries the index of the array to
/// access (e.g. `items/0`).
///
/// `prefixItems` is a JSON Schema keyword that could be supported as well but it's unfortunately
/// not supported by `schemars` so we haven't yet added support.
// TODO: now that we are no longer using schemars, support `prefixItems`.
#[derive(Hash, Clone, Debug, Eq, PartialEq)]
pub enum SchemaPointerElt {
    Definitions(String),
    Properties(String),
    AdditionalProperties,
    /// An `items` followed by an array index.
    ///
    /// In a JSON Schema, `items` might be either a single schema or an array of schemas. In the
    /// single schema case, it doesn't need to be indexed in a json pointer, as in
    /// `#/items/properties/foo`. In the array case, an `items` must be followed by a natural
    /// number. As we want to parse schema pointer independently of the schema, whether an `items`
    /// is parsed as [Self::ItemsIndexed] or [Self::Items] depends on the next element of the path
    /// being a valid array index or not.
    ItemsIndexed(usize),
    /// An `items` not followed by a valid array index.
    ItemsSingle,
    Contains,
    AllOf(usize),
    AnyOf(usize),
    OneOf(usize),
    Not,
    Then,
    Else,
}

impl SchemaPointerElt {
    pub fn name(&self) -> &str {
        match self {
            SchemaPointerElt::Definitions(_) => "definitions",
            SchemaPointerElt::Properties(_) => "properties",
            SchemaPointerElt::AdditionalProperties => "additionalProperties",
            SchemaPointerElt::ItemsIndexed(_) => "items",
            SchemaPointerElt::ItemsSingle => "items",
            SchemaPointerElt::Contains => "contains",
            SchemaPointerElt::AllOf(_) => "allOf",
            SchemaPointerElt::AnyOf(_) => "anyOf",
            SchemaPointerElt::OneOf(_) => "oneOf",
            SchemaPointerElt::Not => "not",
            SchemaPointerElt::Then => "then",
            SchemaPointerElt::Else => "else",
        }
    }
}

impl std::fmt::Display for SchemaPointerElt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SchemaPointerElt::Definitions(name) => write!(f, "definitions/{name}"),
            SchemaPointerElt::Properties(name) => write!(f, "properties/{name}"),
            SchemaPointerElt::AdditionalProperties => write!(f, "additionalProperties"),
            SchemaPointerElt::ItemsIndexed(index) => write!(f, "items/{index}"),
            SchemaPointerElt::ItemsSingle => write!(f, "items"),
            SchemaPointerElt::Contains => write!(f, "contains"),
            SchemaPointerElt::AllOf(index) => write!(f, "allOf/{index}"),
            SchemaPointerElt::AnyOf(index) => write!(f, "anyOf/{index}"),
            SchemaPointerElt::OneOf(index) => write!(f, "oneOf/{index}"),
            SchemaPointerElt::Not => write!(f, "not"),
            SchemaPointerElt::Then => write!(f, "then"),
            SchemaPointerElt::Else => write!(f, "else"),
        }
    }
}

#[derive(Clone, Debug)]
pub enum SchemaPointerParseError {
    /// An element of a JSON pointer, supposedly referring to a JSON Schema keyword, isn't
    /// supported at the moment by json-schema-to-nickel (supported keyword are the variants of
    /// [SchemaPointerElt]). As the standard of JSON Schema is evolving, we don't make a difference
    /// between an unsupported keyword and an invalid one.
    UnsupportedKeyword(String),
    /// A JSON pointer keyword isn't properly followed by an index or a property name. For example
    /// `#/properties/foo/items` or `#/items/0/property` are invalid (they are incomplete).
    MissingIndex(String),
    /// An index into an array is not a valid number. For example, `#/items/foo`.
    InvalidArrayIndex { keyword: String, index: String },
}

impl std::fmt::Display for SchemaPointerParseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SchemaPointerParseError::UnsupportedKeyword(keyword) => {
                write!(f, "Unsupported JSON schema keyword `{keyword}`")
            }
            SchemaPointerParseError::MissingIndex(keyword) => {
                write!(
                    f,
                    "`{keyword}` isn't properly followed by an index or the name of a property"
                )
            }
            SchemaPointerParseError::InvalidArrayIndex { keyword, index } => {
                write!(f, "`{keyword}` is an array which must be indexed by a number but is followed by `{index}`")
            }
        }
    }
}

/// Parses a JSON reference string, like `"#/properties/foo"`, or returns `None`
/// if it's a format we don't support.
pub fn parse_ptr(reference: &str) -> Option<SchemaPointer> {
    let Ok(uri) = fluent_uri::Uri::parse(reference) else {
        eprintln!(
            "Warning: skipping reference `{reference}` (replaced by an always succeeding \
                contract). Failed to parse it as valid URI."
        );

        return None;
    };

    // If the URI has anything else than a fragment, we bail out.
    if uri.scheme().is_some()
        || uri.authority().is_some()
        || !uri.path().as_str().is_empty()
        || uri.query().is_some()
    {
        eprintln!(
            "Warning: skipping external reference `{reference}` (replaced by an always \
                succeeding contract). The current version of json-schema-to-nickel only supports \
                internal references"
        );

        return None;
    }

    // We don't support (yet) relative fragments.
    let Some(fragment) = uri
        .fragment()
        .map(|fragment| fragment.decode().into_string_lossy())
    else {
        eprintln!(
            "Warning: skipping reference `{reference}` (replaced by an always succeeding \
                contract). The URI doesn't have a fragment"
        );

        return None;
    };

    let Some(stripped) = fragment.strip_prefix('/') else {
        eprintln!(
            "Warning: skipping reference `{reference}` (replaced by an always succeeding \
                contract). json-schema-to-nickel doesn't handle references to element ids."
        );

        return None;
    };

    match SchemaPointer::parse(stripped) {
        Ok(ptr) => Some(ptr),
        Err(err) => {
            eprintln!(
                "Warning: skipping reference `{reference}` (replaced by an always \
                    succeeding contract). {err}"
            );

            None
        }
    }
}

/// A reference map that avoids looping on cyclic references.
pub struct AcyclicReferences<'a> {
    inner: &'a BTreeMap<String, Schema>,
    blackholed: RefCell<HashSet<&'a str>>,
}

impl<'a> AcyclicReferences<'a> {
    /// Wrap a map of references to protect from cyclic lookups.
    pub fn new(inner: &'a BTreeMap<String, Schema>) -> Self {
        AcyclicReferences {
            inner,
            blackholed: RefCell::new(HashSet::new()),
        }
    }

    /// Look up a reference by name, but protected against cyclic lookups.
    ///
    /// The return value is a guard, and until the guard is dropped any future
    /// lookups for the same name will return `None`.
    pub fn get<'b>(&'b self, name: &'b str) -> Option<RefGuard<'b, 'a>> {
        if self.blackholed.borrow().contains(name) {
            None
        } else {
            self.inner.get_key_value(name).map(|(stored_name, s)| {
                self.blackholed.borrow_mut().insert(stored_name);
                RefGuard {
                    refs: self,
                    name,
                    schema: s,
                }
            })
        }
    }

    /// Iterate over all name/schema pairs.
    pub fn iter(&self) -> impl Iterator<Item = (&str, &Schema)> {
        self.inner
            .iter()
            .map(|(name, schema)| (name.as_str(), schema))
    }

    /// Iterate over all schemas.
    pub fn schemas(&self) -> impl Iterator<Item = &Schema> {
        self.inner.values()
    }
}

/// A reference guard that protects from acyclic name lookups.
pub struct RefGuard<'b, 'a: 'b> {
    refs: &'b AcyclicReferences<'a>,
    name: &'b str,
    schema: &'b Schema,
}

impl<'b, 'a: 'b> Drop for RefGuard<'b, 'a> {
    fn drop(&mut self) {
        self.refs.blackholed.borrow_mut().remove(self.name);
    }
}

impl<'b, 'a: 'b> std::ops::Deref for RefGuard<'b, 'a> {
    type Target = Schema;

    fn deref(&self) -> &Self::Target {
        self.schema
    }
}

fn resolve_references_one(value: &Value, schema: &Schema) -> BTreeMap<String, Schema> {
    let mut refs = BTreeMap::new();
    let mut record_ref = |schema: &Schema| {
        if let Schema::Ref(s) = schema {
            if !refs.contains_key(s) {
                match parse_ptr(s) {
                    None => {
                        eprintln!("Warning: skipping unparseable pointer \"{s}\"");
                    }
                    Some(ptr) => match ptr.resolve_in(value) {
                        Ok(val) => match Schema::try_from(val) {
                            Ok(v) => {
                                refs.insert(s.clone(), v);
                            }
                            Err(e) => {
                                eprintln!("Warning: skipping pointer \"{s}\" because we failed to convert the pointee: {e}");
                            }
                        },
                        Err(e) => {
                            eprintln!("Warning: skipping pointer \"{s}\" because it failed to resolve: {e}");
                        }
                    },
                }
            }
        }
    };

    schema.traverse_ref(&mut record_ref);
    refs
}

/// Resolves all references in `schema`, returning a map of reference name to
/// the converted reference pointee.
///
/// The reference names in the map are the raw strings from the json, so they'll
/// typically look something like "#/definitions/foo".
///
/// `value` is the json that was used to generate `schema`. It's needed here
/// because references could point to things in `value` that aren't in `schema`.
/// For example, everything in "#/definitions" won't be in `schema`. Technically,
/// we could take only `value` as an argument and generate `schema` from it.
///
/// All references we find are resolved recursively, so that if the main schema
/// contains a reference to "#/definitions/foo" and the "#/definitions/foo"
/// schema contains a reference to "#/definitions/bar" then the returned map
/// will contain both.
pub fn resolve_all(value: &Value, schema: &Schema) -> BTreeMap<String, Schema> {
    let mut refs = resolve_references_one(value, schema);
    let mut seen_refs: HashSet<_> = refs.keys().cloned().collect();
    let mut unfollowed_refs = seen_refs.clone();

    while !unfollowed_refs.is_empty() {
        let mut next_refs = HashSet::new();
        for name in unfollowed_refs {
            // unwrap: refs is always a superset of unfollowed_refs
            let new_refs = resolve_references_one(value, &refs[&name]);

            next_refs.extend(new_refs.keys().cloned());
            refs.extend(new_refs);
        }
        unfollowed_refs = next_refs.difference(&seen_refs).cloned().collect();
        seen_refs.extend(next_refs);
    }

    refs
}
</file>

<file path="src/schema.rs">
//! Our internal representation of schemas.
//!
//! This representation is quite close to JSON Schema, but a little lower-level.
//! For example, JSON Schema has (with a few exceptions, like "properties" and
//! "additionalProperties') an implicit "and" between all fields of a schema; rather
//! than do that, our representation always makes boolean operations explicit.

use nickel_lang_core::{
    bytecode::ast::{
        typ::{EnumRows, EnumRowsUnr},
        Ast,
    },
    identifier::Ident,
    typ::{EnumRowF, EnumRowsF, TypeF},
};
use serde::Serialize;
use serde_json::Value;

use crate::{
    contract::ContractContext,
    object::Obj,
    references::AcyclicReferences,
    typ::{InstanceType, InstanceTypeSet},
};

use nickel_lang_core::term::Number;

/// A schema.
#[derive(Clone, Debug, Serialize, Hash, PartialEq, Eq)]
pub enum Schema {
    /// Always succeeds.
    Always,
    /// Always fails.
    Never,
    /// Asserts that the value equals `null`.
    Null,
    /// Asserts that the value is a boolean.
    Boolean,
    /// Asserts that the value is equal to a specific constant.
    Const(Value),
    /// Asserts that the value is equal to one of a number of constants.
    Enum(Vec<Value>),
    /// Asserts that the value is an object, possibly with some additional constraints.
    Object(Obj),
    /// Asserts that the value is a string, possibly with some additional constraints.
    String(Str),
    /// Asserts that the value is a number, possibly with some additional constraints.
    Number(Num),
    /// Asserts that the value is an array, possibly with some additional constraints.
    Array(Array),
    /// A reference to another schema.
    ///
    /// The string is a JSON-schema path, like "#/definitions/foo" or "#/properties/bar".
    Ref(String),
    /// Asserts that at least one of the contained schemas succeeds.
    AnyOf(Vec<Schema>),
    /// Asserts that exactly one of the contained schemas succeeds.
    OneOf(Vec<Schema>),
    /// Asserts that all of the contained schemas succeed.
    AllOf(Vec<Schema>),
    /// If `iph` succeeds, asserts that `then` does also. Otherwise, asserts that `els` succeeds.
    IfThenElse {
        iph: Box<Schema>,
        then: Box<Schema>,
        els: Box<Schema>,
    },
    /// Asserts that the contained schema fails.
    Not(Box<Schema>),
}

/// Schemas that apply to strings.
#[derive(Clone, Debug, Serialize, PartialEq, Eq, Hash)]
pub enum Str {
    /// Any string is ok.
    Any,
    /// Asserts that a string isn't too long.
    MaxLength(Number),
    /// Asserts that a string isn't too short.
    MinLength(Number),
    /// Asserts that a string matches a regular expression.
    Pattern(String),
}

/// Schemas that apply to numbers.
#[derive(Clone, Debug, Serialize, PartialEq, Eq, Hash)]
pub enum Num {
    /// Any number is ok.
    Any,
    /// Asserts that a number is an integer multiple of something.
    ///
    /// We use exact arithmetic when the "something" is a non-integer; JSON-schema
    /// isn't precise about the requirements in that case.
    MultipleOf(Number),
    /// Asserts that a number is at most some value.
    Maximum(Number),
    /// Asserts that a number is at least some value.
    Minimum(Number),
    /// Asserts that a number is strictly less than some value.
    ExclusiveMinimum(Number),
    /// Asserts that a number is strictly greater than some value.
    ExclusiveMaximum(Number),
    /// Asserts that a number is an integer.
    Integer,
}

/// Schemas that apply to arrays.
#[derive(Clone, Debug, Serialize, PartialEq, Eq, Hash)]
pub enum Array {
    /// Any array is ok.
    Any,
    /// Asserts that all items in this array satisfy a schema.
    AllItems(Box<Schema>),
    /// Asserts that the first several items in this array satisfy individual
    /// schemas, and the remaining items satisfy the `rest` schema.
    PerItem {
        initial: Vec<Schema>,
        rest: Box<Schema>,
    },
    /// Asserts that this array has at most a certain number of elements.
    MaxItems(Number),
    /// Asserts that this array has at least.
    MinItems(Number),
    /// Asserts that all items in this array are distinct.
    UniqueItems,
    /// Asserts that this array contains at least one value satisfying the given schema.
    Contains(Box<Schema>),
}

fn apparent_type(value: &Value) -> InstanceType {
    match value {
        Value::Null => InstanceType::Null,
        Value::Bool(_) => InstanceType::Boolean,
        Value::Number(_) => InstanceType::Number,
        Value::String(_) => InstanceType::String,
        Value::Array(_) => InstanceType::Array,
        Value::Object(_) => InstanceType::Object,
    }
}

fn apparent_types<'a>(values: impl IntoIterator<Item = &'a Value>) -> InstanceTypeSet {
    values.into_iter().map(apparent_type).collect()
}

impl Schema {
    /// Does this schema match just a single type of object? If so, return that type.
    ///
    /// This is best-effort: it may return `None` even when the schema does in fact
    /// match a single type. Unlike [`Schema::just_type`], this method doesn't insist
    /// that the schema is *only* a type-check. For example, if the schema is an
    /// object schema with some properties then we will return `Some(InstanceType::Object)`.
    pub fn simple_type(&self, refs: &AcyclicReferences) -> Option<InstanceType> {
        fn simple_type_rec<'s>(
            slf: &'s Schema,
            refs: &'s AcyclicReferences,
        ) -> Option<InstanceType> {
            match slf {
                Schema::Always => None,
                Schema::Never => None,
                Schema::Null => Some(InstanceType::Null),
                Schema::Boolean => Some(InstanceType::Boolean),
                Schema::Const(v) => Some(apparent_type(v)),
                Schema::Enum(vs) => {
                    if let Some(ty) = vs.first().map(apparent_type) {
                        vs.iter().map(apparent_type).all(|u| u == ty).then_some(ty)
                    } else {
                        None
                    }
                }
                Schema::Object(_) => Some(InstanceType::Object),
                Schema::String(_) => Some(InstanceType::String),
                Schema::Number(_) => Some(InstanceType::Number),
                Schema::Array(_) => Some(InstanceType::Array),
                Schema::Ref(r) => refs.get(r).and_then(|s| simple_type_rec(&s, refs)),
                Schema::AnyOf(_) => None,
                Schema::OneOf(_) => None,
                Schema::AllOf(schemas) => {
                    let mut intersection = InstanceTypeSet::FULL;
                    for s in schemas {
                        intersection = intersection.intersect(s.allowed_types_shallow(refs));
                    }
                    intersection.to_singleton()
                }
                Schema::IfThenElse { .. } => None,
                Schema::Not(_) => None,
            }
        }

        simple_type_rec(self, refs)
    }

    /// Is this schema just a single type with no other constraints?
    ///
    /// If so, return that type.
    pub fn just_type(&self) -> Option<InstanceType> {
        match self {
            Schema::Null => Some(InstanceType::Null),
            Schema::Boolean => Some(InstanceType::Boolean),
            Schema::Object(Obj::Any) => Some(InstanceType::Object),
            Schema::Array(Array::Any) => Some(InstanceType::Array),
            Schema::String(Str::Any) => Some(InstanceType::String),
            Schema::Number(Num::Any) => Some(InstanceType::Number),
            _ => None,
        }
    }

    /// Is this schema just a set of types with no other constraints?
    ///
    /// If so, return that set.
    pub fn just_type_set(&self) -> Option<InstanceTypeSet> {
        if let Some(ty) = self.just_type() {
            Some(InstanceTypeSet::singleton(ty))
        } else if let Schema::AnyOf(schemas) = self {
            schemas.iter().map(|s| s.just_type()).collect()
        } else {
            None
        }
    }

    /// Returns a set of types that might be accepted by this schema.
    ///
    /// The returned set is conservative, in the sense that it might be larger
    /// than necessary. Unlike `Self::allowed_types`, we don't recurse into
    /// sub-schemas. Instead, we're just extra-conservative.
    pub fn allowed_types_shallow(&self, refs: &AcyclicReferences) -> InstanceTypeSet {
        match self {
            Schema::Always => InstanceTypeSet::FULL,
            Schema::Never => InstanceTypeSet::EMPTY,
            Schema::Null => InstanceTypeSet::singleton(InstanceType::Null),
            Schema::Boolean => InstanceTypeSet::singleton(InstanceType::Boolean),
            Schema::Const(v) => InstanceTypeSet::singleton(apparent_type(v)),
            Schema::Enum(vs) => apparent_types(vs),
            Schema::Object(_) => InstanceTypeSet::singleton(InstanceType::Object),
            Schema::String(_) => InstanceTypeSet::singleton(InstanceType::String),
            Schema::Number(_) => InstanceTypeSet::singleton(InstanceType::Number),
            Schema::Array(_) => InstanceTypeSet::singleton(InstanceType::Array),
            Schema::Ref(name) => refs
                .get(name)
                .map(|s| s.allowed_types_shallow(refs))
                .unwrap_or(InstanceTypeSet::FULL),
            Schema::AnyOf(vec) => vec
                .iter()
                .map(|s| s.simple_type(refs))
                .collect::<Option<InstanceTypeSet>>()
                .unwrap_or(InstanceTypeSet::FULL),
            Schema::OneOf(_) => InstanceTypeSet::FULL,
            Schema::AllOf(_) => InstanceTypeSet::FULL,
            Schema::IfThenElse { .. } => InstanceTypeSet::FULL,
            Schema::Not(_) => InstanceTypeSet::FULL,
        }
    }

    /// Returns a set of types that might be accepted by this schema.
    ///
    /// The returned set is conservative, in the sense that it might be larger
    /// than necessary. Unlike `Self::allowed_types_shallow`, we recurse into
    /// subschemas to try and gain some extra precision. As a result, this could
    /// be slow (linear in the size of `self`).
    ///
    /// If this becomes a performance issue, it should be possible to memoize
    /// the allowed types of subschemas.
    pub fn allowed_types(&self, refs: &AcyclicReferences) -> InstanceTypeSet {
        match self {
            Schema::Always => InstanceTypeSet::FULL,
            Schema::Never => InstanceTypeSet::EMPTY,
            Schema::Null => InstanceTypeSet::singleton(InstanceType::Null),
            Schema::Boolean => InstanceTypeSet::singleton(InstanceType::Boolean),
            Schema::Const(v) => InstanceTypeSet::singleton(apparent_type(v)),
            Schema::Enum(vs) => apparent_types(vs),
            Schema::Object(_) => InstanceTypeSet::singleton(InstanceType::Object),
            Schema::String(_) => InstanceTypeSet::singleton(InstanceType::String),
            Schema::Number(_) => InstanceTypeSet::singleton(InstanceType::Number),
            Schema::Array(_) => InstanceTypeSet::singleton(InstanceType::Array),
            Schema::Ref(name) => refs
                .get(name)
                .map(|s| s.allowed_types(refs))
                .unwrap_or(InstanceTypeSet::FULL),
            Schema::AnyOf(vec) => vec
                .iter()
                .map(|s| s.simple_type(refs))
                .collect::<Option<InstanceTypeSet>>()
                .unwrap_or(InstanceTypeSet::FULL),
            Schema::OneOf(_) => InstanceTypeSet::FULL,
            Schema::AllOf(vec) => {
                let mut intersection = InstanceTypeSet::FULL;
                for s in vec {
                    intersection = intersection.intersect(s.allowed_types(refs));
                }
                intersection
            }
            Schema::IfThenElse { .. } => InstanceTypeSet::FULL,
            Schema::Not(_) => InstanceTypeSet::FULL,
        }
    }

    /// Is the most idiomatic Nickel contract for this schema an eager contract?
    ///
    /// For example, if this is an object schema with some properties then the
    /// most idiomatic Nickel contract would be a record contract (which is not
    /// eager). On the other hand, shallower schemas (like number schemas) are
    /// typically eager.
    pub fn is_always_eager(&self, refs: &AcyclicReferences) -> bool {
        match self {
            Schema::Always
            | Schema::Never
            | Schema::Null
            | Schema::Boolean
            | Schema::Const(_)
            | Schema::Enum(_)
            | Schema::String(_)
            | Schema::Number(_) => true,
            Schema::Ref(r) => refs.get(r).is_none_or(|s| s.is_always_eager(refs)),
            Schema::Object(obj) => match obj {
                Obj::Any
                | Obj::MaxProperties(_)
                | Obj::MinProperties(_)
                | Obj::Required(_)
                | Obj::PropertyNames(_)
                | Obj::DependentFields(_) => true,
                Obj::Properties(props) => {
                    props
                        .properties
                        .values()
                        .all(|p| p.schema.is_always_eager(refs))
                        && props
                            .pattern_properties
                            .values()
                            .all(|s| s.is_always_eager(refs))
                        && props
                            .additional_properties
                            .as_ref()
                            .is_none_or(|s| s.is_always_eager(refs))
                }
                Obj::DependentSchemas(deps) => deps.values().all(|s| s.is_always_eager(refs)),
            },
            Schema::Array(arr) => match arr {
                Array::Any
                | Array::MaxItems(_)
                | Array::MinItems(_)
                | Array::UniqueItems
                | Array::Contains(_) => true,
                Array::AllItems(schema) => schema.is_always_eager(refs),
                Array::PerItem { initial, rest } => {
                    initial.iter().all(|s| s.is_always_eager(refs)) && rest.is_always_eager(refs)
                }
            },
            Schema::AnyOf(vec) | Schema::OneOf(vec) | Schema::AllOf(vec) => {
                vec.iter().all(|s| s.is_always_eager(refs))
            }
            Schema::IfThenElse { iph, then, els } => {
                iph.is_always_eager(refs) && then.is_always_eager(refs) && els.is_always_eager(refs)
            }
            Schema::Not(schema) => schema.is_always_eager(refs),
        }
    }

    /// Converts this schema into a collection of Nickel contracts.
    ///
    /// This returns a collection of Nickel contracts, and you need to apply them all
    /// (or combine them using `std.contract.Sequence`). The reason we return a
    /// collection instead of combining them for you is so that if you're applying
    /// these contracts to a record field then you can apply them individually.
    pub fn to_contract<'ast>(&self, ctx: ContractContext<'_, 'ast, '_>) -> Vec<Ast<'ast>> {
        match self {
            Schema::Always => vec![ctx.js2n("Always")],
            Schema::Never => vec![ctx.js2n("Never")],
            Schema::Null => vec![ctx.js2n("Null")],
            Schema::Boolean => vec![ctx.alloc().typ(TypeF::Bool.into()).into()],
            Schema::Const(val) => {
                let nickel_val: Ast = ctx.from_json(val);
                if ctx.is_eager() {
                    vec![ctx.alloc().app(ctx.js2n("Const"), [nickel_val]).into()]
                } else {
                    vec![ctx
                        .alloc()
                        .app(ctx.std("contract.Equal"), [nickel_val])
                        .into()]
                }
            }
            Schema::Enum(vec) => {
                if let Some(strings) = vec.iter().map(|v| v.as_str()).collect::<Option<Vec<_>>>() {
                    let enum_rows: EnumRowsUnr = strings.iter().fold(EnumRowsF::Empty, |acc, s| {
                        let row = EnumRowF {
                            id: Ident::new(s).into(),
                            typ: None,
                        };

                        EnumRowsF::Extend {
                            row,
                            tail: ctx.alloc().enum_rows(acc),
                        }
                    });

                    vec![
                        ctx.std("enum.TagOrString"),
                        ctx.alloc()
                            .typ(TypeF::Enum(EnumRows(enum_rows)).into())
                            .into(),
                    ]
                } else {
                    vec![ctx
                        .alloc()
                        .app(
                            ctx.js2n("Enum"),
                            [ctx.alloc()
                                .array(vec.iter().map(|val| ctx.from_json(val)))
                                .into()],
                        )
                        .into()]
                }
            }
            Schema::Object(obj) => obj.to_contract(ctx),
            Schema::String(s) => vec![s.to_contract(ctx)],
            Schema::Number(num) => vec![num.to_contract(ctx)],
            Schema::Array(arr) => vec![arr.to_contract(ctx)],
            Schema::Ref(s) => vec![ctx.ref_term(s)],
            Schema::AnyOf(vec) => match vec.as_slice() {
                [Schema::Null, other] | [other, Schema::Null] => {
                    vec![ctx
                        .alloc()
                        .app(ctx.js2n("Nullable"), [ctx.sequence(other.to_contract(ctx))])
                        .into()]
                }
                _ => {
                    let eager = ctx.is_eager() || !eagerly_disjoint(vec.iter(), ctx.refs());
                    let ctx = if eager { ctx.eager() } else { ctx.lazy() };
                    let contracts = vec.iter().map(|s| ctx.sequence(s.to_contract(ctx)));
                    vec![ctx
                        .alloc()
                        .app(
                            ctx.std("contract.any_of"),
                            [ctx.alloc().array(contracts).into()],
                        )
                        .into()]
                }
            },
            Schema::OneOf(vec) => {
                let contracts = vec.iter().map(|s| ctx.sequence(s.to_contract(ctx.eager())));
                vec![ctx
                    .alloc()
                    .app(ctx.js2n("OneOf"), [ctx.alloc().array(contracts).into()])
                    .into()]
            }
            Schema::AllOf(vec) => vec.iter().flat_map(|s| s.to_contract(ctx)).collect(),
            Schema::IfThenElse { iph, then, els } => {
                // The "if" contract always needs to be checked eagerly.
                let iph = ctx.sequence(iph.to_contract(ctx.eager()));
                let then = ctx.sequence(then.to_contract(ctx));
                let els = ctx.sequence(els.to_contract(ctx));
                vec![ctx
                    .alloc()
                    .app(ctx.js2n("IfThenElse"), [iph, then, els])
                    .into()]
            }
            Schema::Not(schema) => {
                vec![ctx
                    .alloc()
                    .app(
                        ctx.std("contract.not"),
                        [ctx.sequence(schema.to_contract(ctx.eager()))],
                    )
                    .into()]
            }
        }
    }
}

impl Str {
    pub fn to_contract<'ast>(&self, ctx: ContractContext<'_, 'ast, '_>) -> Ast<'ast> {
        let node = match self {
            Str::Any => ctx.alloc().typ(TypeF::String.into()),
            Str::MaxLength(n) => ctx.alloc().app(ctx.js2n("string.MaxLength"), [ctx.num(n)]),
            Str::MinLength(n) => ctx.alloc().app(ctx.js2n("string.MinLength"), [ctx.num(n)]),
            Str::Pattern(s) => ctx
                .alloc()
                .app(ctx.std("string.Matches"), [ctx.alloc().string(s).into()]),
        };
        node.into()
    }
}

impl Num {
    pub fn to_contract<'ast>(&self, ctx: ContractContext<'_, 'ast, '_>) -> Ast<'ast> {
        let node = match self {
            Num::Any => ctx.alloc().typ(TypeF::Number.into()),
            Num::MultipleOf(x) => ctx.alloc().app(ctx.js2n("number.MultipleOf"), [ctx.num(x)]),
            Num::Maximum(x) => ctx.alloc().app(ctx.js2n("number.Maximum"), [ctx.num(x)]),
            Num::Minimum(x) => ctx.alloc().app(ctx.js2n("number.Minimum"), [ctx.num(x)]),
            Num::ExclusiveMinimum(x) => ctx
                .alloc()
                .app(ctx.js2n("number.ExclusiveMinimum"), [ctx.num(x)]),
            Num::ExclusiveMaximum(x) => ctx
                .alloc()
                .app(ctx.js2n("number.ExclusiveMaximum"), [ctx.num(x)]),
            Num::Integer => ctx.std("number.Integer").node,
        };
        node.into()
    }
}

impl Array {
    pub fn to_contract<'ast>(&self, ctx: ContractContext<'_, 'ast, '_>) -> Ast<'ast> {
        let node = match self {
            Array::Any => ctx
                .alloc()
                .typ(TypeF::Array(ctx.alloc().type_data(TypeF::Dyn, Default::default())).into()),
            Array::AllItems(schema) => {
                if ctx.is_eager() {
                    ctx.alloc().app(
                        ctx.js2n("array.ArrayOf"),
                        [ctx.sequence(schema.to_contract(ctx))],
                    )
                } else {
                    let elt = ctx.alloc().alloc(
                        TypeF::Contract(ctx.alloc().alloc(ctx.sequence(schema.to_contract(ctx))))
                            .into(),
                    );
                    ctx.alloc().typ(TypeF::Array(elt).into())
                }
            }
            Array::PerItem { initial, rest } => {
                let initial = initial.iter().map(|s| ctx.sequence(s.to_contract(ctx)));
                let rest = ctx.sequence(rest.to_contract(ctx));
                ctx.alloc().app(
                    ctx.js2n("array.Items"),
                    [ctx.alloc().array(initial).into(), rest],
                )
            }
            Array::MaxItems(n) => ctx.alloc().app(ctx.js2n("array.MaxItems"), [ctx.num(n)]),
            Array::MinItems(n) => ctx.alloc().app(ctx.js2n("array.MinItems"), [ctx.num(n)]),
            Array::UniqueItems => ctx.js2n("array.UniqueItems").node,
            Array::Contains(schema) => {
                let contract = ctx.sequence(schema.to_contract(ctx.eager()));
                ctx.alloc().app(ctx.js2n("array.Contains"), [contract])
            }
        };
        node.into()
    }
}

fn eagerly_disjoint<'a>(
    schemas: impl Iterator<Item = &'a Schema>,
    refs: &AcyclicReferences,
) -> bool {
    let mut seen_types = InstanceTypeSet::EMPTY;

    for s in schemas {
        let Some(ty) = s.simple_type(refs) else {
            return false;
        };

        if seen_types.contains(ty) {
            return false;
        }

        seen_types.insert(ty);
    }
    true
}
</file>

<file path="src/transform.rs">
//! Schema transforms
//!
//! When we first create our intermediate representation from a JSON Schema, it
//! can be verbose and redundant. The transforms in this module preserve the
//! semantics of the IR but simplify it.

// TODO;
// - in the github example, why doesn't the {_ | Dyn} in services get removed?
// - simplify types in if/then expressions without an else

use std::collections::{BTreeMap, BTreeSet, HashSet};

use nickel_lang_core::{
    bytecode::ast::{
        pattern::Pattern,
        record::{FieldDef, FieldPathElem},
        Ast, AstAlloc, LetBinding, Node,
    },
    position::TermPos,
};

use crate::{
    contract::ContractContextData,
    object::{Obj, ObjectProperties},
    references::AcyclicReferences,
    schema::Schema,
    traverse::Traverse,
    typ::InstanceTypeSet,
    utils::{distinct, sequence},
};

/// Simplifies a schema by repeatedly applying transformations until we hit a
/// fixed point.
///
/// This could be slow: every iteration through the fixed-point-finding loop is
/// linear in the schema size.
pub fn simplify(mut schema: Schema, refs: &AcyclicReferences) -> Schema {
    loop {
        let prev = schema.clone();
        schema = flatten_logical_ops(schema);
        schema = one_to_any(schema, refs);
        schema = intersect_types(schema, refs);
        schema = merge_required_properties(schema);
        schema = enumerate_regex_properties(schema, 8);

        if schema == prev {
            return schema;
        }
    }
}

/// Merges nested `AllOf`s and `AnyOf`s.
///
/// For example, `AllOf(a, b, AllOf(c, d))` becomes `AllOf(a, b, c, d)`.
///
/// This transform also simplifies empty and singleton `AllOf`s and `AnyOf`s.
pub fn flatten_logical_ops(schema: Schema) -> Schema {
    fn flatten_one(schema: Schema) -> Schema {
        match schema {
            Schema::AnyOf(vec) | Schema::OneOf(vec) if vec.is_empty() => Schema::Never,
            Schema::AllOf(vec) if vec.is_empty() => Schema::Always,

            Schema::AnyOf(mut vec) | Schema::AllOf(mut vec) | Schema::OneOf(mut vec)
                if vec.len() == 1 =>
            {
                vec.pop().unwrap()
            }

            Schema::AllOf(vec) => {
                // This is a perfect application of Vec::extract_if, if it were stable.
                let mut new_vec = Vec::new();
                for elt in vec {
                    match elt {
                        Schema::AllOf(e) => new_vec.extend(e),
                        Schema::Always => {}
                        Schema::Never => {
                            return Schema::Never;
                        }
                        e => new_vec.push(e),
                    }
                }
                Schema::AllOf(new_vec)
            }

            Schema::AnyOf(vec) => {
                // This is a perfect application of Vec::extract_if, if it were stable.
                let mut new_vec = Vec::new();
                for elt in vec {
                    match elt {
                        Schema::AnyOf(e) => new_vec.extend(e),
                        Schema::Always => {
                            return Schema::Always;
                        }
                        Schema::Never => {}
                        e => new_vec.push(e),
                    }
                }
                Schema::AnyOf(new_vec)
            }
            s => s,
        }
    }

    schema.traverse(&mut flatten_one)
}

/// Attempts to convert `OneOf` to `AnyOf`, by detecting whether
/// the alternatives are mutually exclusive.
pub fn one_to_any(schema: Schema, refs: &AcyclicReferences) -> Schema {
    fn distinct_types(s: &[Schema], refs: &AcyclicReferences) -> bool {
        let simple_types = s
            .iter()
            .map(|s| s.simple_type(refs))
            .collect::<Option<Vec<_>>>();

        matches!(simple_types, Some(tys) if distinct(tys.iter()))
    }

    let mut one_to_any_one = |schema: Schema| -> Schema {
        match schema {
            Schema::OneOf(vec) if distinct_types(&vec, refs) => Schema::AnyOf(vec),
            s => s,
        }
    };

    schema.traverse(&mut one_to_any_one)
}

/// Inlines some references to the schemas that reference them.
///
/// As a motivating example from the github-workflow schema, they
/// factor out some type definitions in "eventObject": the definition
/// looks like
///
/// ```json
///    "eventObject": {
///      "oneOf": [
///        {
///          "type": "object"
///        },
///        {
///          "type": "null"
///        }
///      ],
///      "additionalProperties": true
///    },
/// ```
///
/// and gets used like
///
/// ```json
///    "branch_protection_rule": {
///      "$ref": "#/definitions/eventObject",
///      "properties": {
///        // ...
///      }
///    },
/// ```
///
/// In particular, the schema using the ref doesn't have its own "type"
/// annotation, which is annoying for our analysis. Inlining the definition
/// fixes this annoyance.
pub fn inline_refs(schema: Schema, refs: &AcyclicReferences) -> Schema {
    let mut inline_one = |schema: Schema| -> Schema {
        match schema {
            Schema::Ref(s) => match refs.get(&s).as_deref() {
                // The ref-inlining heuristic could use some work. We probably
                // want to avoid inlining large schemas, and we probably want to
                // prioritize inlining things that can lead to further simplication.
                Some(resolved @ Schema::AnyOf(tys))
                    if tys.iter().all(|ty| ty.just_type().is_some()) =>
                {
                    resolved.clone()
                }
                Some(_) => Schema::Ref(s.clone()),
                None => Schema::Always,
            },
            s => s,
        }
    };

    schema.traverse(&mut inline_one)
}

/// Attempts to merge "required" and "properties" schemas.
///
/// In JSON Schema, "required" and "properties" are two orthogonal checks,
/// but in Nickel we like to have optionality annotations on the properties.
/// When this transform encounters
///
/// ```text
/// AllOf([
///   Required(["foo"]),
///   Properties({
///     foo -> ...
///     bar -> ...
///   })
/// ])
/// ```
///
/// it removes the "Required" and marks the "foo" in "Properties"
/// as being non-optional.
pub fn merge_required_properties(schema: Schema) -> Schema {
    let mut merge_one = |schema: Schema| -> Schema {
        match schema {
            Schema::AllOf(vec) => {
                let mut required = BTreeSet::new();
                let mut props = Vec::new();
                let mut new_vec = Vec::new();

                for s in vec {
                    match s {
                        Schema::Object(Obj::Required(strings)) => {
                            required.extend(strings.into_iter())
                        }
                        Schema::Object(Obj::Properties(p)) => props.push(p),
                        s => new_vec.push(s),
                    }
                }

                let mut unused_required = required.clone();

                for mut p in props {
                    for (name, prop) in p.properties.iter_mut() {
                        if required.contains(name) {
                            unused_required.remove(name);
                            prop.optional = false;
                        }
                    }
                    new_vec.push(Schema::Object(Obj::Properties(p)));
                }

                if !unused_required.is_empty() {
                    new_vec.push(Schema::Object(Obj::Required(unused_required)))
                }
                Schema::AllOf(new_vec)
            }
            s => s,
        }
    };

    schema.traverse(&mut merge_one)
}

/// When encountering an `AllOf` in which different elements have different
/// sets of allowed types, propagates the intersection of the type sets to all
/// elements.
pub fn intersect_types(schema: Schema, refs: &AcyclicReferences) -> Schema {
    let mut intersect_one = |schema: Schema| -> Schema {
        match schema {
            Schema::AllOf(mut vec) => {
                // The set of allowed types is the intersection, over all elements of `vec`,
                // of that schema's set of allowed types.
                let mut allowed_types = InstanceTypeSet::FULL;

                for s in &vec {
                    allowed_types = allowed_types.intersect(s.allowed_types(refs));
                }

                vec.retain_mut(|s| {
                    if s.just_type_set().is_some() {
                        // We filter out all the elements that are just type restrictions, since
                        // there could be repeats. Then we'll add back in one if necessary.
                        false
                    } else if let Schema::AnyOf(schemas) = s {
                        schemas.retain(|s| {
                            s.simple_type(refs)
                                .is_none_or(|ty| allowed_types.contains(ty))
                        });
                        true
                    } else {
                        s.simple_type(refs)
                            .is_none_or(|ty| allowed_types.contains(ty))
                    }
                });

                if !vec
                    .iter()
                    .any(|s| s.allowed_types_shallow(refs) == allowed_types)
                {
                    vec.push(allowed_types.to_schema());
                }

                Schema::AllOf(vec)
            }
            s => s,
        }
    };

    schema.traverse(&mut intersect_one)
}

/// If the regex in `s` only matches a small number of strings, list them all out.
fn enumerate_regex(s: &str, max_expansion: usize) -> Option<Vec<String>> {
    use regex_syntax::hir::{Hir, HirKind, Look};
    // TODO: maybe we should signal an error (probably while constructing the schema) if
    // there's a regex we can't parse?
    let hir = regex_syntax::parse(s).ok()?.into_kind();

    // We're only interested in anchored regexes (starting with ^, ending with $), so
    // check that that's the case. Then strip the anchors in preparation for recursion.
    let HirKind::Concat(mut elems) = hir else {
        return None;
    };
    let Some(HirKind::Look(Look::Start)) = elems.first().map(|h| h.kind()) else {
        return None;
    };

    let Some(HirKind::Look(Look::End)) = elems.last().map(|h| h.kind()) else {
        return None;
    };
    elems.remove(0);
    elems.pop();
    let hir = Hir::concat(elems);

    fn enumerate_rec(hir: regex_syntax::hir::Hir, max_expansion: usize) -> Option<Vec<String>> {
        match hir.into_kind() {
            HirKind::Empty => Some(vec![String::new()]),
            HirKind::Literal(literal) => Some(vec![String::from_utf8(literal.0.to_vec()).ok()?]),
            HirKind::Class(_) | HirKind::Look(_) => None,
            HirKind::Repetition(repetition) => {
                let max = repetition.max? as usize;
                let min = repetition.min as usize;
                let inner = enumerate_rec(*repetition.sub, max_expansion)?;
                if inner.len().checked_mul(max - min)? <= max_expansion {
                    let mut ret = Vec::new();
                    for i in min..=max {
                        for s in &inner {
                            ret.push(s.repeat(i));
                        }
                    }
                    Some(ret)
                } else {
                    None
                }
            }
            HirKind::Capture(capture) => enumerate_rec(*capture.sub, max_expansion),
            HirKind::Concat(vec) => {
                let mut options = vec![String::new()];
                for sub in vec {
                    let sub_options = enumerate_rec(sub, max_expansion)?;
                    if sub_options.len() * options.len() > max_expansion {
                        return None;
                    }

                    options = options
                        .iter()
                        .flat_map(|prev| {
                            sub_options.iter().map(|next| {
                                let mut new = prev.to_owned();
                                new.push_str(next);
                                new
                            })
                        })
                        .collect();
                }

                Some(options)
            }
            HirKind::Alternation(vec) => {
                let mut options = Vec::new();
                for sub in vec {
                    options.extend(enumerate_rec(sub, max_expansion - options.len())?);
                    if options.len() > max_expansion {
                        return None;
                    }
                }
                Some(options)
            }
        }
    }

    let mut ret = enumerate_rec(hir, max_expansion)?;
    ret.sort();
    Some(ret)
}

/// If a "patternProperties" has a regex that only matches a small set of strings, turns
/// it into a "properties" schema that enumerates the strings.
///
/// Some real-world schemas use "patternProperties" just to save some repetition; for example,
/// `github-workflow.json` has
///
/// ```json
///   "patternProperties": {
///     "^(branche|tag|path)s(-ignore)?$": {
///       "type": "array"
///     }
///   },
/// ```
///
/// We'd prefer to list out all the properties here, because then we can make a proper record
/// contract.
pub fn enumerate_regex_properties(schema: Schema, max_expansion: usize) -> Schema {
    fn try_expand_props(
        props: &ObjectProperties,
        max_expansion: usize,
    ) -> Option<ObjectProperties> {
        let mut new_props = ObjectProperties {
            properties: props.properties.clone(),
            pattern_properties: BTreeMap::new(),
            additional_properties: props.additional_properties.clone(),
        };

        for (s, schema) in &props.pattern_properties {
            let expanded = enumerate_regex(s, max_expansion)?;
            for name in expanded {
                if new_props
                    .properties
                    .insert(name, schema.clone().into())
                    .is_some()
                {
                    // Abort if there's any overlap between properties (either between
                    // existing properties and regex properties, or between multiple
                    // regex properties). In principle, I think it's also ok to combine
                    // overlaps using allOf.
                    return None;
                }
            }
        }

        Some(new_props)
    }

    let mut enumerate_one = |schema: Schema| -> Schema {
        match schema {
            Schema::Object(Obj::Properties(props)) => Schema::Object(Obj::Properties(
                try_expand_props(&props, max_expansion).unwrap_or(props),
            )),
            s => s,
        }
    };

    schema.traverse(&mut enumerate_one)
}

/// Collect (recursively) all the names of properties in this schema.
///
/// The Nickel contracts might create record contracts with these names; if
/// we find a name that isn't in this collection, it's guaranteed not to be
/// shadowed by any name in a generated contract.
fn all_names(s: &Schema) -> HashSet<String> {
    let mut ret = HashSet::new();
    let mut shadowed = |s: &Schema| {
        if let Schema::Object(Obj::Properties(props)) = s {
            ret.extend(props.properties.keys().cloned());
        }
    };

    s.traverse_ref(&mut shadowed);
    ret
}

/// Create a variant of `prefix` that doesn't collide with any other names.
fn no_collisions_name(taken_names: &HashSet<String>, prefix: &str) -> String {
    let mut ret = prefix.to_owned();
    while taken_names.contains(&ret) {
        ret.push('_');
    }
    ret
}

/// Convert a schema to a nickel contract.
///
/// `lib_import` is a term that imports the json-schema library.
pub fn schema_to_nickel<'ast>(
    s: &Schema,
    refs: &AcyclicReferences<'_>,
    lib_import: Ast<'ast>,
    alloc: &'ast AstAlloc,
) -> Ast<'ast> {
    let mut shadowed_names = all_names(s);
    shadowed_names.extend(refs.schemas().flat_map(all_names));

    let refs_name = no_collisions_name(&shadowed_names, "refs");
    let lib_name = no_collisions_name(&shadowed_names, "js2n");
    let std_name = no_collisions_name(&shadowed_names, "std");

    let ctx_data = ContractContextData::new(refs, &lib_name, &std_name, &refs_name, alloc);
    let ctx = ctx_data.ctx();
    let main_contract = s.to_contract(ctx);

    // Make contracts from the references also, and continue doing so until there are
    // no unconverted references.
    let mut accessed = ctx.take_accessed_refs();
    // TODO: see if IndexMap would be faster
    let mut refs_env = BTreeMap::new();
    let mut unfollowed_refs = accessed.clone();
    while !unfollowed_refs.is_empty() {
        for (name, eager) in unfollowed_refs {
            let path: Vec<_> = ctx.ref_name(&name, eager).map(|s| s.to_owned()).collect();
            // unwrap: the context shouldn't collect missing references
            refs_env.insert(
                path,
                sequence(alloc, refs.get(&name).unwrap().to_contract(ctx)),
            );
        }

        let newly_accessed = ctx.take_accessed_refs();
        unfollowed_refs = newly_accessed.difference(&accessed).cloned().collect();
        accessed.extend(newly_accessed);
    }

    let refs_dict = Node::Record(alloc.record_data(
        [],
        refs_env.into_iter().map(|(path, value)| FieldDef {
            path: alloc.alloc_many(path.into_iter().map(|s| FieldPathElem::Ident(s.into()))),
            metadata: Default::default(),
            value: Some(value),
            pos: TermPos::None,
        }),
        false,
    ));

    let binding = |name: &str, value| LetBinding {
        pattern: Pattern::any(name.into()),
        metadata: Default::default(),
        value,
    };

    let mut bindings = vec![binding(ctx.lib_name(), lib_import)];
    if ctx.std_name() != "std" {
        bindings.push(binding(ctx.std_name(), Node::Var("std".into()).into()));
    }
    alloc
        .let_block(
            bindings,
            alloc
                .let_block(
                    [binding(ctx.refs_name(), refs_dict.into())],
                    sequence(alloc, main_contract),
                    true,
                )
                .into(),
            false,
        )
        .into()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn regex_expansion() {
        assert_eq!(
            enumerate_regex("^(foo|bar)$", 2),
            Some(vec!["bar".to_owned(), "foo".to_owned()])
        );

        assert_eq!(enumerate_regex("^(foo|bar)$", 1), None);

        assert_eq!(
            enumerate_regex("^(foo|bar)s?$", 4),
            Some(vec![
                "bar".to_owned(),
                "bars".to_owned(),
                "foo".to_owned(),
                "foos".to_owned()
            ])
        );
    }
}
</file>

<file path="src/traverse.rs">
//! By-value and by-reference traversals of the schema tree.

use std::collections::BTreeMap;

use crate::{
    object::{Obj, ObjectProperties, Property},
    schema::{Array, Schema},
};

/// A trait for traversing a generic structure.
///
/// Currently, we only ever have `T = Schema`, and all of the traversals are
/// bottom-up.
pub trait Traverse<T>: Sized {
    /// Traverse by value, contructing a new tree.
    fn traverse<F>(self, f: &mut F) -> Self
    where
        F: FnMut(T) -> T;

    /// Traverse by reference.
    fn traverse_ref<F>(&self, f: &mut F)
    where
        F: FnMut(&T);
}

impl Traverse<Schema> for Schema {
    fn traverse<F>(self, f: &mut F) -> Self
    where
        F: FnMut(Schema) -> Schema,
    {
        let val = match self {
            Schema::Always
            | Schema::Never
            | Schema::Null
            | Schema::Boolean
            | Schema::Const(_)
            | Schema::Enum(_)
            | Schema::Number(_)
            | Schema::String(_)
            | Schema::Ref(_) => self,
            Schema::Object(obj) => Schema::Object(obj.traverse(f)),
            Schema::Array(arr) => Schema::Array(arr.traverse(f)),
            Schema::AnyOf(vec) => Schema::AnyOf(vec.traverse(f)),
            Schema::OneOf(vec) => Schema::OneOf(vec.traverse(f)),
            Schema::AllOf(vec) => Schema::AllOf(vec.traverse(f)),
            Schema::IfThenElse { iph, then, els } => Schema::IfThenElse {
                iph: iph.traverse(f),
                then: then.traverse(f),
                els: els.traverse(f),
            },
            Schema::Not(schema) => Schema::Not(schema.traverse(f)),
        };

        f(val)
    }

    fn traverse_ref<F>(&self, f: &mut F)
    where
        F: FnMut(&Schema),
    {
        match self {
            Schema::Always
            | Schema::Never
            | Schema::Null
            | Schema::Boolean
            | Schema::Const(_)
            | Schema::Enum(_)
            | Schema::Number(_)
            | Schema::String(_)
            | Schema::Ref(_) => {}
            Schema::Object(obj) => obj.traverse_ref(f),
            Schema::Array(arr) => arr.traverse_ref(f),
            Schema::AnyOf(vec) => vec.traverse_ref(f),
            Schema::OneOf(vec) => vec.traverse_ref(f),
            Schema::AllOf(vec) => vec.traverse_ref(f),
            Schema::IfThenElse { iph, then, els } => {
                iph.traverse_ref(f);
                then.traverse_ref(f);
                els.traverse_ref(f);
            }
            Schema::Not(schema) => {
                schema.traverse_ref(f);
            }
        }
        f(self)
    }
}

impl<S, T: Traverse<S>> Traverse<S> for Box<T> {
    fn traverse<F>(self, f: &mut F) -> Self
    where
        F: FnMut(S) -> S,
    {
        Box::new((*self).traverse(f))
    }

    fn traverse_ref<F>(&self, f: &mut F)
    where
        F: FnMut(&S),
    {
        (**self).traverse_ref(f);
    }
}

impl<S, T: Traverse<S>> Traverse<S> for Option<T> {
    fn traverse<F>(self, f: &mut F) -> Self
    where
        F: FnMut(S) -> S,
    {
        self.map(|v| v.traverse(f))
    }

    fn traverse_ref<F>(&self, f: &mut F)
    where
        F: FnMut(&S),
    {
        if let Some(slf) = self.as_ref() {
            slf.traverse_ref(f);
        }
    }
}

impl<S, T: Traverse<S>> Traverse<S> for Vec<T> {
    fn traverse<F>(self, f: &mut F) -> Self
    where
        F: FnMut(S) -> S,
    {
        self.into_iter().map(|x| x.traverse(f)).collect()
    }

    fn traverse_ref<F>(&self, f: &mut F)
    where
        F: FnMut(&S),
    {
        for s in self {
            s.traverse_ref(f);
        }
    }
}

impl<K: Ord + Eq, S, T: Traverse<S>> Traverse<S> for BTreeMap<K, T> {
    fn traverse<F>(self, f: &mut F) -> Self
    where
        F: FnMut(S) -> S,
    {
        self.into_iter().map(|(k, v)| (k, v.traverse(f))).collect()
    }

    fn traverse_ref<F>(&self, f: &mut F)
    where
        F: FnMut(&S),
    {
        for s in self.values() {
            s.traverse_ref(f);
        }
    }
}

impl Traverse<Schema> for Property {
    fn traverse<F>(self, f: &mut F) -> Self
    where
        F: FnMut(Schema) -> Schema,
    {
        Property {
            doc: self.doc,
            optional: self.optional,
            schema: self.schema.traverse(f),
        }
    }

    fn traverse_ref<F>(&self, f: &mut F)
    where
        F: FnMut(&Schema),
    {
        self.schema.traverse_ref(f);
    }
}

impl Traverse<Schema> for Obj {
    fn traverse<F>(self, f: &mut F) -> Self
    where
        F: FnMut(Schema) -> Schema,
    {
        match self {
            Obj::Any
            | Obj::MaxProperties(_)
            | Obj::MinProperties(_)
            | Obj::Required(_)
            | Obj::DependentFields(_) => self,
            Obj::PropertyNames(schema) => Obj::PropertyNames(schema.traverse(f)),
            Obj::DependentSchemas(deps) => Obj::DependentSchemas(deps.traverse(f)),
            Obj::Properties(props) => Obj::Properties(ObjectProperties {
                properties: props.properties.traverse(f),
                pattern_properties: props.pattern_properties.traverse(f),
                additional_properties: props.additional_properties.traverse(f),
            }),
        }
    }

    fn traverse_ref<F>(&self, f: &mut F)
    where
        F: FnMut(&Schema),
    {
        match self {
            Obj::Any
            | Obj::MaxProperties(_)
            | Obj::MinProperties(_)
            | Obj::Required(_)
            | Obj::DependentFields(_) => {}
            Obj::PropertyNames(schema) => schema.traverse_ref(f),
            Obj::DependentSchemas(deps) => deps.traverse_ref(f),
            Obj::Properties(props) => {
                props.properties.traverse_ref(f);
                props.pattern_properties.traverse_ref(f);
                props.additional_properties.traverse_ref(f);
            }
        }
    }
}

impl Traverse<Schema> for Array {
    fn traverse<F>(self, f: &mut F) -> Self
    where
        F: FnMut(Schema) -> Schema,
    {
        match self {
            Array::Any | Array::MaxItems(_) | Array::MinItems(_) | Array::UniqueItems => self,
            Array::AllItems(schema) => Array::AllItems(schema.traverse(f)),
            Array::PerItem { initial, rest } => Array::PerItem {
                initial: initial.traverse(f),
                rest: rest.traverse(f),
            },
            Array::Contains(schema) => Array::Contains(schema.traverse(f)),
        }
    }

    fn traverse_ref<F>(&self, f: &mut F)
    where
        F: FnMut(&Schema),
    {
        match self {
            Array::Any | Array::MaxItems(_) | Array::MinItems(_) | Array::UniqueItems => {}
            Array::AllItems(schema) => schema.traverse_ref(f),
            Array::PerItem { initial, rest } => {
                initial.traverse_ref(f);
                rest.traverse_ref(f);
            }
            Array::Contains(schema) => schema.traverse_ref(f),
        }
    }
}
</file>

<file path="src/typ.rs">
//! JSON types

use std::str::FromStr;

use crate::object::Obj;
use crate::schema::{Array, Num, Schema, Str};

/// The six types in JSON.
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(u8)]
pub enum InstanceType {
    Null = 0,
    Boolean,
    Object,
    Array,
    Number,
    String,
}

impl InstanceType {
    /// Returns an array of all JSON types.
    pub fn all() -> [InstanceType; 6] {
        use InstanceType::*;
        [Null, Boolean, Object, Array, Number, String]
    }

    /// Returns a schema that checks a type and nothing else.
    pub fn to_schema(self) -> Schema {
        match self {
            InstanceType::Null => Schema::Null,
            InstanceType::Boolean => Schema::Boolean,
            InstanceType::Object => Schema::Object(Obj::Any),
            InstanceType::Array => Schema::Array(Array::Any),
            InstanceType::Number => Schema::Number(Num::Any),
            InstanceType::String => Schema::String(Str::Any),
        }
    }
}

impl FromStr for InstanceType {
    type Err = miette::Report;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let ty = match s {
            "null" => InstanceType::Null,
            "boolean" => InstanceType::Boolean,
            "object" => InstanceType::Object,
            "array" => InstanceType::Array,
            "integer" => InstanceType::Number,
            "number" => InstanceType::Number,
            "string" => InstanceType::String,
            s => miette::bail!("unknown instance type `{s}`"),
        };
        Ok(ty)
    }
}

/// A set of JSON types.
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct InstanceTypeSet {
    /// There are only six types, so we represent a set of them using a
    /// bitfield.
    inner: u8,
}

impl InstanceTypeSet {
    /// The set of all types.
    pub const FULL: InstanceTypeSet = InstanceTypeSet { inner: 0b0011_1111 };
    /// The set of no types.
    pub const EMPTY: InstanceTypeSet = InstanceTypeSet { inner: 0b0000_0000 };

    /// Constructs a set with one type in it.
    pub fn singleton(ty: InstanceType) -> Self {
        Self {
            inner: 1 << ty as u8,
        }
    }

    /// Inserts a type into this set.
    pub fn insert(&mut self, ty: InstanceType) {
        self.inner |= 1 << ty as u8;
    }

    /// Does this set contain `ty`?
    pub fn contains(self, ty: InstanceType) -> bool {
        self.inner & (1 << ty as u8) != 0
    }

    /// Intersects this set with another one, returning the intersection.
    pub fn intersect(self, other: InstanceTypeSet) -> InstanceTypeSet {
        InstanceTypeSet {
            inner: self.inner & other.inner,
        }
    }

    /// Creates a schema that validates whether a value belongs to any of the
    /// types in this type set.
    pub fn to_schema(self) -> Schema {
        let types: Vec<_> = InstanceType::all()
            .into_iter()
            .filter(|ty| self.contains(*ty))
            .collect();

        match types.as_slice() {
            [] => Schema::Never,
            [ty] => ty.to_schema(),
            _ => Schema::AnyOf(types.into_iter().map(InstanceType::to_schema).collect()),
        }
    }

    /// If this set is a singleton, returns the single type that it contains.
    pub fn to_singleton(self) -> Option<InstanceType> {
        if self.inner.count_ones() == 1 {
            InstanceType::all()
                .iter()
                .find(|ty| self.contains(**ty))
                .copied()
        } else {
            None
        }
    }
}

impl FromIterator<InstanceType> for InstanceTypeSet {
    fn from_iter<T: IntoIterator<Item = InstanceType>>(iter: T) -> Self {
        let mut ret = InstanceTypeSet::EMPTY;
        for ty in iter.into_iter() {
            ret.insert(ty);
        }
        ret
    }
}
</file>

<file path="src/utils.rs">
use std::collections::HashSet;

use nickel_lang_core::{
    bytecode::ast::{primop::PrimOp, typ::TypeUnr, Ast, AstAlloc, Node},
    identifier::LocIdent,
};

pub fn static_access<I, S>(alloc: &AstAlloc, record: S, fields: I) -> Ast<'_>
where
    I: IntoIterator<Item = S>,
    I::IntoIter: DoubleEndedIterator,
    S: Into<LocIdent>,
{
    let mut ast = Node::Var(record.into()).into();
    for f in fields.into_iter() {
        ast = alloc
            .prim_op(PrimOp::RecordStatAccess(f.into()), [ast])
            .into();
    }
    ast
}

/// Replace special escaping sequences by the actual character within one element of a JSON pointer
/// path. See the [JSON pointer syntax](https://datatracker.ietf.org/doc/html/rfc6901#section-3).
/// Currently, this just amounts to replace `~0` by `~` and `~1` by `/`.
pub fn decode_json_ptr_part(part: &str) -> String {
    part.replace("~0", "~").replace("~1", "/")
}

/// Returns `true` if all the items in `items` are distinct.
pub fn distinct<T: std::hash::Hash + Eq>(items: impl Iterator<Item = T>) -> bool {
    let mut seen = HashSet::new();
    for item in items {
        if !seen.insert(item) {
            return false;
        }
    }
    true
}

/// Creates a contract that for checking a Nickel type.
pub fn type_contract<'a>(alloc: &'a AstAlloc, ty: TypeUnr<'a>) -> Ast<'a> {
    alloc.typ(ty.into()).into()
}

/// Turns a collection of contracts into a single contract.
pub fn sequence<'a>(alloc: &'a AstAlloc, mut contracts: Vec<Ast<'a>>) -> Ast<'a> {
    if contracts.len() == 1 {
        contracts.pop().unwrap()
    } else {
        alloc
            .app(
                static_access(alloc, "std", ["contract", "Sequence"]),
                [alloc.array(contracts).into()],
            )
            .into()
    }
}
</file>

<file path="tests/integration/inputs/record_contract.json">
{
  "$comment": "basic record contract",
  "type": "object",
  "properties": {
    "foo": {
      "type": "number"
    }
  }
}
</file>

<file path="tests/integration/inputs/shadowing.json">
{
  "$comment": "important names should never be shadowed",
  "type": "object",
  "definitions": {
    "foo": {
      "properties": {
        "foo": {
          "type": "number"
        }
      }
    }
  },
  "properties": {
    "std": {
      "$ref": "#/definitions/foo"
    },
    "js2n": {
      "type": "number"
    },
    "refs": {
      "type": "number"
    },
    "refs_": {
      "type": "number"
    }
  }
}
</file>

<file path="tests/snapshots/integration__tests__integration__inputs__record_contract.json.snap">
---
source: tests/integration.rs
expression: out
---
let js2n = FAKE_JS2N_LIB in let rec refs = {} in { foo | Number | optional, .. }
</file>

<file path="tests/snapshots/integration__tests__integration__inputs__shadowing.json.snap">
---
source: tests/integration.rs
expression: out
---
let js2n_ = FAKE_JS2N_LIB, std_ = std in
let rec refs__
    = {
      definitions.foo =
        std_.contract.any_of
            [
              js2n_.Null,
              Bool,
              Number,
              String,
              { foo | Number | optional, .. },
              Array Dyn
            ]
    }
    in
  {
      js2n | Number | optional,
      refs | Number | optional,
      refs_ | Number | optional,
      std | refs__.definitions.foo | optional,
      ..
    }
</file>

<file path="tests/snapshots/transforms__tests__transforms__inputs__inline_defs.json.snap">
---
source: tests/transforms.rs
expression: schema
---
Object(Properties(ObjectProperties(
  properties: {
    "my_object": Property(
      doc: None,
      schema: AnyOf([
        String(Any),
        Object(Properties(ObjectProperties(
          properties: {
            "foo": Property(
              doc: None,
              schema: Number(Any),
              optional: true,
            ),
          },
          pattern_properties: {},
          additional_properties: None,
        ))),
      ]),
      optional: true,
    ),
  },
  pattern_properties: {},
  additional_properties: None,
)))
</file>

<file path="tests/snapshots/transforms__tests__transforms__inputs__nested_all_of.json.snap">
---
source: tests/transforms.rs
expression: schema
---
Object(Properties(ObjectProperties(
  properties: {
    "my_object": Property(
      doc: None,
      schema: AllOf([
        Number(Minimum(Rational(
          s: true,
          n: "0x3",
          d: "0x1",
        ))),
        Number(Maximum(Rational(
          s: true,
          n: "0x5",
          d: "0x1",
        ))),
      ]),
      optional: true,
    ),
  },
  pattern_properties: {},
  additional_properties: None,
)))
</file>

<file path="tests/transforms/inputs/inline_defs.json">
{
  "$comment": "#/definitions/MyType should get inlined",
  "type": "object",
  "properties": {
    "my_object": {
      "$ref": "#/definitions/MyType",
      "properties": {
        "foo": { "type": "number" }
      }
    }
  },
  "definitions": {
    "MyType": {
      "oneOf": [
        {
          "type": "object"
        },
        {
          "type": "string"
        }
      ]
    }
  }
}
</file>

<file path="tests/transforms/inputs/nested_all_of.json">
{
  "$comment": "nested allOf should get flattened",
  "type": "object",
  "properties": {
    "my_object": {
      "allOf": [
        {
          "type": "number"
        },
        {
          "allOf": [
            { "minimum": 3 },
            { "maximum": 5 }
          ]
        }
      ]
    }
  }
}
</file>

<file path="tests/integration.rs">
use insta::assert_snapshot;
use json_schema_to_nickel::convert;
use libtest_mimic::{Arguments, Trial};
use nickel_lang_core::{bytecode::ast::AstAlloc, pretty::*};
use pretty::DocBuilder;
use std::{path::Path, process::ExitCode};

pub fn main() -> ExitCode {
    let args = Arguments::from_args();
    let root = env!("CARGO_MANIFEST_DIR");

    let manifest_glob = glob::glob(&format!("{root}/tests/integration/inputs/**/*.json")).unwrap();

    let tests: Vec<_> = manifest_glob
        .map(|p| {
            let path = p.unwrap();
            let name = path.strip_prefix(root).unwrap().to_owned();
            Trial::test(name.display().to_string(), move || {
                generate(&path, name.to_str().unwrap());
                Ok(())
            })
        })
        .collect();

    libtest_mimic::run(&args, tests).exit_code()
}

fn generate(path: &Path, name: &str) {
    let file = std::fs::read_to_string(path).unwrap();
    let val: serde_json::Value = serde_json::from_str(&file).unwrap();

    let lib_term = nickel_lang_core::bytecode::ast::Node::Var("FAKE_JS2N_LIB".into()).into();
    let alloc = AstAlloc::new();
    let contract = convert(&val, lib_term, &alloc).unwrap();

    let pretty_alloc = nickel_lang_core::bytecode::pretty::Allocator::default();
    let types: DocBuilder<'_, _, ()> = contract.pretty(&pretty_alloc);

    let mut out = Vec::new();
    types.render(80, &mut out).unwrap();
    let out = String::from_utf8(out).unwrap();

    assert_snapshot!(name, out);
}
</file>

<file path="tests/json_schema_test_suite_test.rs">
use std::{io::stderr, path::Path, process::ExitCode};

use json_schema_to_nickel::inline_lib;
use libtest_mimic::{Arguments, Trial};
use nickel_lang_core::{
    bytecode::ast::AstAlloc,
    error::{report, Error, EvalError, NullReporter},
    eval::cache::lazy::CBNCache,
    program::Program,
    term::RichTerm,
};
use regex::Regex;
use stringreader::StringReader;

#[derive(serde::Deserialize)]
#[serde(transparent)]
struct TestFile {
    schema_tests: Vec<SchemaTest>,
}

#[derive(serde::Deserialize)]
struct SchemaTest {
    schema: serde_json::Value,
    tests: Vec<Example>,
}

#[derive(serde::Deserialize)]
struct Example {
    data: serde_json::Value,
    valid: bool,
}

pub fn main() -> ExitCode {
    let args = Arguments::from_args();
    let root = env!("CARGO_MANIFEST_DIR");
    let test_dir = format!("{root}/vendor/JSON-Schema-Test-Suite/tests/draft7");

    let test_glob = glob::glob(&format!("{test_dir}/**/*.json")).unwrap();

    let ignore_regex = Regex::new(&SKIP_TESTS.join("|")).unwrap();
    assert!(ignore_regex.is_match("optional/format/date_0_12"));

    let tests: Vec<_> = test_glob
        .flat_map(|p| {
            let path = p.unwrap();
            let name = path
                .strip_prefix(&test_dir)
                .unwrap()
                .to_owned()
                .display()
                .to_string()
                .strip_suffix(".json")
                .unwrap()
                .to_owned();
            gather_tests(name, &path, &ignore_regex)
        })
        .collect();

    libtest_mimic::run(&args, tests).exit_code()
}

fn gather_tests(name: String, path: &Path, ignore_regex: &Regex) -> Vec<Trial> {
    let contents = std::fs::read_to_string(path).unwrap();
    let test_file: TestFile = serde_json::from_str(&contents).unwrap();

    test_file
        .schema_tests
        .into_iter()
        .enumerate()
        .flat_map(|(schema_idx, schema_test)| {
            let name = name.clone();
            schema_test
                .tests
                .into_iter()
                .enumerate()
                .map(move |(test_idx, test)| {
                    let name = format!("{name}_{schema_idx}_{test_idx}");
                    let schema = schema_test.schema.clone();
                    let ignore = ignore_regex.is_match(&name);
                    Trial::test(name, move || {
                        translation_typecheck_test(schema, test.data, test.valid);
                        Ok(())
                    })
                    .with_ignored_flag(ignore)
                })
        })
        .collect()
}

const SKIP_TESTS: &[&str] = &[
    "optional\\/format.*",
    // contains an external reference (remote URI)
    "definitions_0_1.*",
    "id_.*",
    // schemars doesn't accept floats as the value of `maxItems`
    "maxItems_1_.*",
    // schemars doesn't accept floats as the value of `maxLength`
    "maxLength_1_.*",
    // schemars doesn't accept floats as the value of `maxProperties`
    "maxProperties_1_.*",
    // schemars doesn't accept floats as the value of `minItems`
    "minItems_1_.*",
    // schemars doesn't accept floats as the value of `minLength`
    "minLength_1_.*",
    // schemars doesn't accept floats as the value of `minProperties`
    "minProperties_1_.*",
    "optional/bignum.*",
    "optional/content.*",
    "optional/cross-draft.*",
    "optional/ecmascript-regex.*",
    // no.
    "refRemote_.*",
    // TODO: make reference handling robust
    // The following are references that aren't yet handled by js2n (remote URIs, local files
    // and non-top level definitions)

    // reference to the whole schema `#` not yet supported
    "ref_0_3.*",
    // reference to bare URI `node` (no fragment, no leading slash). Should fail
    // because invalid, but js2n replace that by a `Dyn` contract
    "ref_12_1.*",
    // reference to an anchor "#foo" not yet supported
    "ref_14_1.*",
    // anchor + remote URI
    "ref_15_1.*",
    // external reference (remote URI)
    "ref_16_1.*",
    // reference to a local definition ("#/definitions/inner" but the definition
    // isn't at the top-level? I'm not even sure how it should be handled in all
    // generality) + absolute local URI
    "ref_18_0.*",
    // Same as ref_18_0
    "ref_18_1.*",
    // external reference (local file URI)
    "ref_18_2.*",
    // external reference (local file URI),
    "ref_19_2.*",
    // Same as refs_18_0
    "ref_19_0.*",
    // Same as refs_18_0
    "ref_19_1.*",
    // external reference (remote URI)
    "ref_20_1.*",
    // urn:uuid URI scheme not supported
    "ref_21_1.*",
    // urn:uuid URI scheme not supported
    "ref_26_1.*",
    // urn:uuid URI scheme not supported,
    "ref_27_1.*",
    // external reference (remote URI)
    "ref_28_0.*",
    // external reference (remote URI)
    "ref_29_0.*",
    // external reference (remote URI)
    "ref_30_0.*",
    // external reference (absolute path /absref/foobar.json)
    "ref_31_1.*",
    // not related to external ref, but js2n doesn't properly ignore other components
    // when the `ref` field is used
    "ref_5_1.*",
    // reference to a local file (foo.json)
    "ref_6_0.*",
    // external reference (remote URI)
    "ref_7_1.*",
    // we don't handle `$id` at all, yet
    "unknownKeyword_.*",
];

fn translation_typecheck_test(
    schema: serde_json::Value,
    test_case: serde_json::Value,
    is_valid: bool,
) {
    let alloc = AstAlloc::new();
    let contract = json_schema_to_nickel::convert(&schema, inline_lib(&alloc), &alloc).unwrap();

    let instance: RichTerm = serde_json::from_value(test_case).unwrap();

    let program = format!("{instance} | ({contract})");
    eprintln!("{instance}");

    let mut prog = Program::<CBNCache>::new_from_source(
        StringReader::new(&program),
        "test",
        stderr(),
        NullReporter {},
    )
    .unwrap();
    let actual = prog.eval_full();

    match (is_valid, actual) {
        (true, Ok(_)) => {}
        (true, Err(e)) => {
            report::report(
                &mut prog.files(),
                e,
                report::ErrorFormat::Text,
                Default::default(),
            );
            panic!("expected success, got evaluation error");
        }
        // For now, experience shows that a contract failure can be one of those three errors:
        // field missing, missing field def, or generic contract error (blame error)
        (false, Err(Error::EvalError(EvalError::BlameError { .. })))
        | (false, Err(Error::EvalError(EvalError::MissingFieldDef { .. })))
        | (false, Err(Error::EvalError(EvalError::FieldMissing { .. }))) => {}
        (false, Ok(_)) => panic!("expected blame error, got success"),
        (false, Err(e)) => panic!("expected blame error, got different error {e:#?}"),
    }
}
</file>

<file path="tests/transforms.rs">
use insta::assert_ron_snapshot;
use json_schema_to_nickel::{
    references::{self, AcyclicReferences},
    schema::Schema,
    transform::{inline_refs, simplify},
};
use libtest_mimic::{Arguments, Trial};
use std::{path::Path, process::ExitCode};

pub fn main() -> ExitCode {
    let args = Arguments::from_args();
    let root = env!("CARGO_MANIFEST_DIR");

    let manifest_glob = glob::glob(&format!("{root}/tests/transforms/inputs/**/*.json")).unwrap();

    let tests: Vec<_> = manifest_glob
        .map(|p| {
            let path = p.unwrap();
            let name = path.strip_prefix(root).unwrap().to_owned();
            Trial::test(name.display().to_string(), move || {
                snapshot_ir(&path, name.to_str().unwrap());
                Ok(())
            })
        })
        .collect();

    libtest_mimic::run(&args, tests).exit_code()
}

fn snapshot_ir(path: &Path, name: &str) {
    // TODO: allow the test input to customize the transforms that get applied
    let file = std::fs::read_to_string(path).unwrap();
    let val: serde_json::Value = serde_json::from_str(&file).unwrap();
    let schema: Schema = (&val).try_into().unwrap();

    let all_refs = references::resolve_all(&val, &schema);
    let refs = AcyclicReferences::new(&all_refs);
    let simple_refs = all_refs
        .iter()
        .map(|(k, v)| (k.clone(), simplify(v.clone(), &refs)))
        .collect();
    let refs = AcyclicReferences::new(&simple_refs);
    let schema = inline_refs(schema, &refs);
    let schema = simplify(schema, &refs);

    assert_ron_snapshot!(name, schema);
}
</file>

<file path=".envrc">
use flake
</file>

<file path=".gitattributes">
/flake.lock -diff
/Cargo.lock -diff
</file>

<file path=".gitignore">
/result
/target

.direnv/
.helix/
</file>

<file path="build.rs">
use std::{
    env,
    error::Error,
    ffi::OsString,
    fs,
    path::{Path, PathBuf},
};

use nickel_lang_core::{
    cache::InputFormat,
    error::{report::report_as_str, NullReporter},
    eval::cache::CacheImpl,
    match_sharedterm,
    program::Program,
    term::{Import, RichTerm, Term},
    traverse::{Traverse, TraverseOrder},
};

// Currently nickel does not have a package management system. Until there's
// an idiomatic way to refer to the library we've defined, we're just going to
// inline it into the generated nickel code.
//
// Problem: We can't do that naively because we have `import` statements.
// Solution: Inline all the imports
//
// Problem: We don't even know where the library will be, or if it will even be
//          available, at json_schema_to_nickel runtime.
// Solution: We grab the contents of the file at json_schema_to_nickel compile
//           time, and make it available through the build script. If we didn't
//           have the nickel imports we could just use `include_bytes!` directly
//
// Problem: The resulting RichTerm cannot be serialized into the
//          json_schema_to_nickel binary, because it contains allocated fields.
// Solution: We do a little dance where we pretty print it into a string at
//           build time, and re-parse it at runtime. We will then pretty-print
//           it *again* at runtime.

/// parses the nickel file at `path` and substitues any manually performs import
/// resolution, splicing the files imported inline into the AST
fn inline_imports(path: impl Into<OsString>) -> Result<RichTerm, Box<dyn Error>> {
    let path = &path.into();
    let mut program: Program<CacheImpl> =
        Program::new_from_file(path.clone(), std::io::stderr(), NullReporter {})?;
    let rt = program
        .parse()
        .map_err(|e| report_as_str(&mut program.files(), e, Default::default()))?;

    rt.traverse::<_, Box<dyn Error>>(
        &mut |subterm: RichTerm| {
            match_sharedterm!(match (subterm.term) {
                Term::Import(Import::Path {
                    path: import_path_rel,
                    format: InputFormat::Nickel,
                }) => {
                    let mut import_path_abs: PathBuf = path.into();
                    import_path_abs.set_file_name(import_path_rel);
                    inline_imports(import_path_abs)
                }
                _ => Ok(subterm),
            })
        },
        TraverseOrder::BottomUp,
    )
}

fn main() -> Result<(), Box<dyn Error>> {
    let lib = inline_imports("./lib/main.ncl")?;

    let out_dir = env::var_os("OUT_DIR").ok_or("environment variable OUT_DIR doesn't exist")?;
    let gen_lib_path = Path::new(&out_dir).join("main.ncl");
    fs::write(gen_lib_path, format!("{lib}"))?;
    Ok(())
}
</file>

<file path="Cargo.toml">
[package]
name = "json-schema-to-nickel"
version = "0.1.0"
edition = "2021"
authors = ["Matthew Toohey <contact@mtoohey.com>", "Viktor Kleen <viktor.kleen@tweag.io>"]
description = "Convert JSON schemas into Nickel contracts."
readme = "README.md"
homepage = "https://github.com/mtoohey31/json-schema-to-nickel"
repository = "https://github.com/mtoohey31/json-schema-to-nickel"
license = "MIT OR Apache-2.0"

[dependencies]
clap = { version = "^4.3", features = ["derive"] }
fluent-uri = "0.1.4"
miette = "7.5.0"
nickel-lang-core = { version = "0.14.0", default-features = false }

pretty = "0.12"
regex-syntax = "0.8.5"
serde = { version = "1.0.218", features = ["derive"] }
serde_json = "^1.0"
terminal_size = "^0.2"

[build-dependencies]
# TODO: make this definitionally the same as the non-build dependency
nickel-lang-core = { version = "0.14.0", default-features = false }

[dev-dependencies]
glob = "0.3.2"
insta = { version = "1.42.2", features = ["serde", "ron"] }
lazy_static = "^1.4"
libtest-mimic = "0.8.1"
regex = "1.11.1"
serde_json = "^1.0"
stringreader = "^0.1"

[[test]]
name = "transforms"
path = "tests/transforms.rs"
harness = false

[[test]]
name = "integration"
path = "tests/integration.rs"
harness = false

[[test]]
name = "json_schema_test_suite"
path = "tests/json_schema_test_suite_test.rs"
harness = false
</file>

<file path="flake.lock">
{
  "nodes": {
    "advisory-db": {
      "flake": false,
      "locked": {
        "lastModified": 1759226657,
        "narHash": "sha256-msIjIH46R32kIF72PbU0+Hxqeu6yQFo8FsANKgs/iP0=",
        "owner": "rustsec",
        "repo": "advisory-db",
        "rev": "f71b77f025d1c2afcd2b07a32e7127a5d138ef4a",
        "type": "github"
      },
      "original": {
        "owner": "rustsec",
        "repo": "advisory-db",
        "type": "github"
      }
    },
    "crane": {
      "locked": {
        "lastModified": 1759893430,
        "narHash": "sha256-yAy4otLYm9iZ+NtQwTMEbqHwswSFUbhn7x826RR6djw=",
        "owner": "ipetkov",
        "repo": "crane",
        "rev": "1979a2524cb8c801520bd94c38bb3d5692419d93",
        "type": "github"
      },
      "original": {
        "owner": "ipetkov",
        "repo": "crane",
        "type": "github"
      }
    },
    "crane_2": {
      "locked": {
        "lastModified": 1759511609,
        "narHash": "sha256-uU6Dq5OUgI9pEiMDwZZhvsoxYD+36xKIkYyFXDr//6A=",
        "owner": "ipetkov",
        "repo": "crane",
        "rev": "c5b48a59ccd5179ea626f47b05d2828c37fb31b7",
        "type": "github"
      },
      "original": {
        "owner": "ipetkov",
        "repo": "crane",
        "type": "github"
      }
    },
    "crane_3": {
      "locked": {
        "lastModified": 1758758545,
        "narHash": "sha256-NU5WaEdfwF6i8faJ2Yh+jcK9vVFrofLcwlD/mP65JrI=",
        "owner": "ipetkov",
        "repo": "crane",
        "rev": "95d528a5f54eaba0d12102249ce42f4d01f4e364",
        "type": "github"
      },
      "original": {
        "owner": "ipetkov",
        "repo": "crane",
        "type": "github"
      }
    },
    "fenix": {
      "inputs": {
        "nixpkgs": [
          "nixpkgs"
        ],
        "rust-analyzer-src": "rust-analyzer-src"
      },
      "locked": {
        "lastModified": 1759732757,
        "narHash": "sha256-RUR2yXYbKSoDvI/JdH0AvojFjhCfxBXOA/BtGUpaoR0=",
        "owner": "nix-community",
        "repo": "fenix",
        "rev": "1d3600dda5c27ddbc9c424bb4edae744bdb9b14d",
        "type": "github"
      },
      "original": {
        "owner": "nix-community",
        "repo": "fenix",
        "type": "github"
      }
    },
    "flake-compat": {
      "flake": false,
      "locked": {
        "lastModified": 1747046372,
        "narHash": "sha256-CIVLLkVgvHYbgI2UpXvIIBJ12HWgX+fjA8Xf8PUmqCY=",
        "owner": "edolstra",
        "repo": "flake-compat",
        "rev": "9100a0f413b0c601e0533d1d94ffd501ce2e7885",
        "type": "github"
      },
      "original": {
        "owner": "edolstra",
        "repo": "flake-compat",
        "type": "github"
      }
    },
    "flake-utils": {
      "inputs": {
        "systems": "systems"
      },
      "locked": {
        "lastModified": 1731533236,
        "narHash": "sha256-l0KFg5HjrsfsO/JpG+r7fRrqm12kzFHyUHqHCVpMMbI=",
        "owner": "numtide",
        "repo": "flake-utils",
        "rev": "11707dc2f618dd54ca8739b309ec4fc024de578b",
        "type": "github"
      },
      "original": {
        "owner": "numtide",
        "repo": "flake-utils",
        "type": "github"
      }
    },
    "gitignore": {
      "inputs": {
        "nixpkgs": [
          "nickel",
          "pre-commit-hooks",
          "nixpkgs"
        ]
      },
      "locked": {
        "lastModified": 1709087332,
        "narHash": "sha256-HG2cCnktfHsKV0s4XW83gU3F57gaTljL9KNSuG6bnQs=",
        "owner": "hercules-ci",
        "repo": "gitignore.nix",
        "rev": "637db329424fd7e46cf4185293b9cc8c88c95394",
        "type": "github"
      },
      "original": {
        "owner": "hercules-ci",
        "repo": "gitignore.nix",
        "type": "github"
      }
    },
    "nickel": {
      "inputs": {
        "crane": "crane_2",
        "flake-utils": "flake-utils",
        "nixpkgs": "nixpkgs",
        "pre-commit-hooks": "pre-commit-hooks",
        "rust-overlay": "rust-overlay"
      },
      "locked": {
        "lastModified": 1759939352,
        "narHash": "sha256-OTRfoEc6/gcUe+vrW22NgiVe6XNvX/YZzqw+OraFaeo=",
        "owner": "tweag",
        "repo": "nickel",
        "rev": "026ffb3c91eb9454c6f9f81bf9b22da0bb774675",
        "type": "github"
      },
      "original": {
        "owner": "tweag",
        "repo": "nickel",
        "type": "github"
      }
    },
    "nixpkgs": {
      "locked": {
        "lastModified": 1759381078,
        "narHash": "sha256-gTrEEp5gEspIcCOx9PD8kMaF1iEmfBcTbO0Jag2QhQs=",
        "owner": "nixos",
        "repo": "nixpkgs",
        "rev": "7df7ff7d8e00218376575f0acdcc5d66741351ee",
        "type": "github"
      },
      "original": {
        "owner": "nixos",
        "ref": "nixos-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "nixpkgs_2": {
      "locked": {
        "lastModified": 1759826507,
        "narHash": "sha256-vwXL9H5zDHEQA0oFpww2one0/hkwnPAjc47LRph6d0I=",
        "owner": "nixos",
        "repo": "nixpkgs",
        "rev": "bce5fe2bb998488d8e7e7856315f90496723793c",
        "type": "github"
      },
      "original": {
        "owner": "nixos",
        "ref": "nixpkgs-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "nixpkgs_3": {
      "locked": {
        "lastModified": 1759070547,
        "narHash": "sha256-JVZl8NaVRYb0+381nl7LvPE+A774/dRpif01FKLrYFQ=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "647e5c14cbd5067f44ac86b74f014962df460840",
        "type": "github"
      },
      "original": {
        "owner": "NixOS",
        "ref": "nixpkgs-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "nixpkgs_4": {
      "locked": {
        "lastModified": 1744536153,
        "narHash": "sha256-awS2zRgF4uTwrOKwwiJcByDzDOdo3Q1rPZbiHQg/N38=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "18dd725c29603f582cf1900e0d25f9f1063dbf11",
        "type": "github"
      },
      "original": {
        "owner": "NixOS",
        "ref": "nixpkgs-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "pre-commit-hooks": {
      "inputs": {
        "flake-compat": "flake-compat",
        "gitignore": "gitignore",
        "nixpkgs": [
          "nickel",
          "nixpkgs"
        ]
      },
      "locked": {
        "lastModified": 1759523803,
        "narHash": "sha256-PTod9NG+i3XbbnBKMl/e5uHDBYpwIWivQ3gOWSEuIEM=",
        "owner": "cachix",
        "repo": "pre-commit-hooks.nix",
        "rev": "cfc9f7bb163ad8542029d303e599c0f7eee09835",
        "type": "github"
      },
      "original": {
        "owner": "cachix",
        "repo": "pre-commit-hooks.nix",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "crane": "crane",
        "fenix": "fenix",
        "nickel": "nickel",
        "nixpkgs": "nixpkgs_2",
        "topiary": "topiary"
      }
    },
    "rust-analyzer-src": {
      "flake": false,
      "locked": {
        "lastModified": 1759691178,
        "narHash": "sha256-O11yp/in47Ef1jLsEgNACXuziuRSSV4RAuxIWTdKI9w=",
        "owner": "rust-lang",
        "repo": "rust-analyzer",
        "rev": "f0b496cbc774f589de0d46bb9c291ff7ff0329da",
        "type": "github"
      },
      "original": {
        "owner": "rust-lang",
        "ref": "nightly",
        "repo": "rust-analyzer",
        "type": "github"
      }
    },
    "rust-overlay": {
      "inputs": {
        "nixpkgs": [
          "nickel",
          "nixpkgs"
        ]
      },
      "locked": {
        "lastModified": 1759544920,
        "narHash": "sha256-yQwP0JOHi3Icq09GG5ufGuGrq2zIijglVFj3kkF2MHA=",
        "owner": "oxalica",
        "repo": "rust-overlay",
        "rev": "bd3a63bbff2c4cb3cd48e9d49f54c2ccad457f70",
        "type": "github"
      },
      "original": {
        "owner": "oxalica",
        "repo": "rust-overlay",
        "type": "github"
      }
    },
    "rust-overlay_2": {
      "inputs": {
        "nixpkgs": "nixpkgs_4"
      },
      "locked": {
        "lastModified": 1759286284,
        "narHash": "sha256-JLdGGc4XDutzSD1L65Ni6Ye+oTm8kWfm0KTPMcyl7Y4=",
        "owner": "oxalica",
        "repo": "rust-overlay",
        "rev": "f6f2da475176bb7cff51faae8b3fe879cd393545",
        "type": "github"
      },
      "original": {
        "owner": "oxalica",
        "repo": "rust-overlay",
        "type": "github"
      }
    },
    "systems": {
      "locked": {
        "lastModified": 1681028828,
        "narHash": "sha256-Vy1rq5AaRuLzOxct8nz4T6wlgyUR7zLU309k9mBC768=",
        "owner": "nix-systems",
        "repo": "default",
        "rev": "da67096a3b9bf56a91d16901293e51ba5b49a27e",
        "type": "github"
      },
      "original": {
        "owner": "nix-systems",
        "repo": "default",
        "type": "github"
      }
    },
    "topiary": {
      "inputs": {
        "advisory-db": "advisory-db",
        "crane": "crane_3",
        "nixpkgs": "nixpkgs_3",
        "rust-overlay": "rust-overlay_2"
      },
      "locked": {
        "lastModified": 1759933706,
        "narHash": "sha256-DtIH+GdsOz7r3oksWeSBK2qIbqaJEeQVQEU3/6zvD0Q=",
        "owner": "tweag",
        "repo": "topiary",
        "rev": "3c9f9c058fad5ad970098355de40812237fe36c0",
        "type": "github"
      },
      "original": {
        "owner": "tweag",
        "repo": "topiary",
        "type": "github"
      }
    }
  },
  "root": "root",
  "version": 7
}
</file>

<file path="flake.nix">
{
  description = "json-schema-to-nickel";

  inputs = {
    nixpkgs.url = "github:nixos/nixpkgs/nixpkgs-unstable";
    crane.url = "github:ipetkov/crane";
    fenix = {
      url = "github:nix-community/fenix";
      inputs.nixpkgs.follows = "nixpkgs";
    };

    nickel.url = "github:tweag/nickel";

    topiary.url = "github:tweag/topiary";
  };

  # use cached nickel
  nixConfig = {
    extra-substituters = [ "https://tweag-nickel.cachix.org" ];
    extra-trusted-public-keys = [ "tweag-nickel.cachix.org-1:GIthuiK4LRgnW64ALYEoioVUQBWs0jexyoYVeLDBwRA=" ];
  };

  outputs = inputs:
    let
      SYSTEMS = [
        "aarch64-darwin"
        "aarch64-linux"
        "x86_64-darwin"
        "x86_64-linux"
      ];

      lib = inputs.nixpkgs.lib;
      foreach = xs: f: with lib; foldr recursiveUpdate { } (map f xs);
      forSystems = systems: f: foreach systems (system: f system inputs.nixpkgs.legacyPackages.${system});
    in
    forSystems SYSTEMS (system: pkgs:
      let
        rust = inputs.fenix.packages.${system}.stable;
        craneLib = (inputs.crane.mkLib pkgs).overrideToolchain rust.toolchain;

        missingSysPkgs =
          if pkgs.stdenv.isDarwin then
            [
              pkgs.darwin.libiconv
            ]
          else
            [ ];


        src =
          let
            mkFilter = regexp: path: _type: builtins.match regexp path != null;
          in
          lib.cleanSourceWith {
            src = lib.cleanSource (craneLib.path ./.);
            filter = path: type:
              builtins.any (filter: filter path type) [
                (mkFilter ".*/vendor/JSON-Schema-Test-Suite/tests/.*json$")
                (mkFilter ".*ncl$")
                craneLib.filterCargoSources
              ];
          };

        commonArgs = {
          inherit src;
          # Rust 1.90 defaults to the lld linker on x86_64-linux, but
          # something seems to be wrong with the version packaged in fenix: see
          # https://github.com/nix-community/fenix/issues/206. As a workaround,
          # we use the one from llvmPackages.bintools instead.
          nativeBuildInputs = missingSysPkgs ++ lib.optionals (system == "x86_64-linux") [ pkgs.llvmPackages.bintools ];

          env = lib.optionalAttrs (system == "x86_64-linux") {
            RUSTFLAGS = "-C linker-features=-lld";
          };
        };

        cargoArtifacts = craneLib.buildDepsOnly commonArgs;
        json-schema-to-nickel = craneLib.buildPackage (commonArgs // {
          inherit cargoArtifacts;
        });
        nickel = inputs.nickel.packages.${system}.default;
        generate-ci = pkgs.writeShellScriptBin "generate-ci" ''
          REPO_ROOT=$(${pkgs.git}/bin/git rev-parse --show-toplevel)

          echo "# This file is autogenerated. Edit the nickel source instead." > "$REPO_ROOT/.github/workflows/continuous-integration.yml"
          ${nickel}/bin/nickel export --format yaml "$REPO_ROOT/.github/workflows/continuous-integration.ncl" >> "$REPO_ROOT/.github/workflows/continuous-integration.yml"
        '';
      in
      {
        checks.${system} = {
          json-schema-to-nickel-clippy = craneLib.cargoClippy (commonArgs // {
            inherit cargoArtifacts;
            cargoClippyExtraArgs = "--all-targets -- --deny warnings";
          });

          json-schema-to-nickel-fmt = craneLib.cargoFmt commonArgs;

          json-schema-to-nickel-test = craneLib.cargoTest (commonArgs // {
            inherit cargoArtifacts;
          });

          inherit (inputs.self.packages.${system}) json-schema-to-nickel;
        };

        packages.${system} = rec {
          inherit json-schema-to-nickel;
          default = json-schema-to-nickel;
          inherit generate-ci;
        };

        devShells.${system}.default = pkgs.mkShell {
          inputsFrom = lib.attrValues inputs.self.checks.${system};
          packages = [
            pkgs.cargo-insta
            pkgs.cargo-nextest
            rust.rust-analyzer
            inputs.topiary.packages.${system}.default
            inputs.nickel.packages.${system}.default
          ];
        };
      });
}
</file>

<file path="LICENSE-APACHE">
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright 2023 Matthew Toohey and Modus Create LLC

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
</file>

<file path="LICENSE-MIT">
MIT License

Copyright (c) 2023 Matthew Toohey and Modus Create LLC

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="README.md">
# json-schema-to-nickel

A tool to convert [JSON schema](https://json-schema.org) into [Nickel](https://www.nickel-lang.org) contracts.

## How to use it?

`json-schema-to-nickel` is a standalone binary that reads a JSON schema file and
outputs a Nickel contract. You can run it from source using `cargo` by running

```shell
cargo run -- <path to your schema.json>
```

in a checkout of this repository. Alternatively, you can use `nix`:

```shell
nix run github:nickel-lang/json-schema-to-nickel -- <path to your schema.json>
```

anywhere. This will retrieve the latest revision from GitHub, build
`json-schema-to-nickel` and run the resulting binary on your JSON schema.

Either invocation will print the generated Nickel contract to standard
output. It can get rather large, so it's recommended to redirect the output into
a file, for example by using

```shell
cargo run -- schema.json > contract.ncl
```

Once you have a output of `json-schema-to-nickel` in a file, say `contract.ncl`,
you can check a Nickel configuration against it by importing the file by its
path, e.g.

```nickel
let
  SchemaContract = import "./contract.ncl"
in {
  foo = "bar"
} | SchemaContract
```

## How it works

A JSON schema encodes a predicate on JSON objects, that is, a function from
JSON objects returning `true` or `false`. Such a function can always be written
as a Nickel contract and a big part of `json-schema-to-nickel` is mechanically
generating such a contract using a [Nickel library](./lib/main.ncl).
General JSON schema predicates cannot be converted to idiomatic Nickel contracts
because JSON schema assumes eager evaluation (especially because of the
[`anyOf`][union-contracts] and similar keywords) and most Nickel contracts are
lazy. The second major part of `json-schema-to-nickel` is figuring out when a
JSON schema can be represented as a lazy Nickel contract, and generating this
contract when it makes sense.

Lazy record contracts, when they can be produced, are much more
useful for code inspection tools. For example, the Nickel language server can
offer completion information based on record contracts and `nickel doc` can
extract structured documentation. When only a predicate check can be generated
these niceties are lost.

Our approach for generating record contracts is certainly not optimal, yet.
There are JSON schema predicates that we could reasonably convert into lazy
contracts which we're currently missing. But the end goal is to convert JSON
schema into contracts that are as lazy and inspectable for the LSP as possible,
and fall back to a strict predicate check only when absolutely necessary.

## Limitations

- JSON schema comes in many dialects. We currently support draft 7, which is the
  most widely used version. For example, it is the one supported by
  [SchemaStore][schemastore].
- The `format` keyword of JSON schema is currently ignored, [#24][i24]
- Error reporting in contracts converted from predicates can be a bit hit or miss, [#27][i27]
- The generated contracts might be more eager than expected. This chiefly
  depends on whether our heuristics are able to produce a proper Nickel record
  contract or not. If they do, the top level contract will be as lazy as
  expected in Nickel, otherwise the result will just be a validation function.
  Similar reasoning applies to each field of a record contract if one can be
  generated.
- Related to the last point, if our contract heuristics produce a proper record
  contract, completion using the Nickel language server will work as expected.
  Otherwise, the generated contract will be opaque to the language server.
  One approach to improve this situation could be to generate record contracts
  that are more tolerant than the JSON schema specifies and then refine those
  contracts with an accurate predicate check, [i25]

[i24]: https://github.com/nickel-lang/json-schema-to-nickel/issues/24
[i25]: https://github.com/nickel-lang/json-schema-to-nickel/issues/25
[i27]: https://github.com/nickel-lang/json-schema-to-nickel/issues/27
[schemastore]: https://github.com/SchemaStore/schemastore
[union-contracts]: https://www.tweag.io/blog/2022-04-28-union-intersection-contracts/
</file>

</files>
