This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    auto-merge.yaml
    test.yml
    update-vendor-hash.yml
    upgrade-flakes.yml
  dependabot.yml
checks/
  darwin.nix
  home-manager.nix
  nixos-test.nix
dev/
  private/
    flake.lock
    flake.nix
  private.narHash
modules/
  home-manager/
    sops.nix
    templates.nix
  nix-darwin/
    secrets-for-users/
      default.nix
    templates/
      default.nix
    default.nix
    manifest-for.nix
    with-environment.nix
  sops/
    secrets-for-users/
      default.nix
    templates/
      default.nix
    default.nix
    manifest-for.nix
    with-environment.nix
pkgs/
  sops-import-keys-hook/
    test-assets/
      keys/
        key-with-subkeys.asc
        key.asc
        key.gpg
      existing-key.gpg
      shell.nix
    default.nix
    hook_test.go
    sops-import-keys-hook.bash
  sops-init-gpg-key/
    default.nix
    sops-init-gpg-key
  sops-install-secrets/
    sshkeys/
      convert.go
    test-assets/
      gnupghome/
        private-keys-v1.d/
          289B6199193DE765808658DA7A0B892D914345FC.key
        pubring.kbx
        trustdb.gpg
      age-keys.txt
      key.asc
      secrets.bin
      secrets.env
      secrets.ini
      secrets.json
      secrets.yaml
      sops-edit
      ssh-ed25519-key
      ssh-ed25519-key.pub
      ssh-key
      ssh-key.asc
      ssh-key.pub
    .envrc
    darwin.go
    default.nix
    linux.go
    main_test.go
    main.go
    shell.nix
  sops-pgp-hook/
    test-assets/
      keys/
        key-with-subkeys.asc
        key.asc
        key.gpg
      existing-key.gpg
      shell.nix
    default.nix
    hook_test.go
    sops-pgp-hook.bash
  cross-build.nix
  lint.nix
  sops-pgp-hook-test.nix
  unit-tests.nix
scripts/
  update-vendor-hash.sh
.envrc
.gitignore
.golangci.yml
default.nix
flake.lock
flake.nix
go.mod
LICENSE
README.md
shell.nix
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/auto-merge.yaml">
name: Auto Merge Dependency Updates
on:
  - pull_request_target
jobs:
  auto-merge-dependency-updates:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    concurrency:
      group: "auto-merge:${{ github.head_ref }}"
      cancel-in-progress: true
    steps:
      - uses: Mic92/auto-merge@main
</file>

<file path=".github/workflows/test.yml">
name: "Test"
on:
  pull_request:
  push:
    branches:
      - master
  schedule:
    - cron:  '51 2 * * *'
jobs:
  tests:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v5
    - uses: cachix/install-nix-action@v31
    - name: Add keys group (needed for go tests)
      run: sudo groupadd keys
    - name: Run unit tests
      run: nix develop .#unit-tests --command "true"
</file>

<file path=".github/workflows/update-vendor-hash.yml">
name: Update vendorHash
on: pull_request
jobs:
  dependabot:
    runs-on: ubuntu-latest
    if: ${{ github.actor == 'dependabot[bot]' }}
    steps:
      - uses: actions/create-github-app-token@v2
        id: app-token
        with:
          app-id: ${{ vars.CI_APP_ID }}
          private-key: ${{ secrets.CI_APP_PRIVATE_KEY }}
      - uses: actions/checkout@v5
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0
          token: ${{ steps.app-token.outputs.token }}
      - name: Install Nix
        uses: cachix/install-nix-action@v31
        with:
          github_access_token: ${{ secrets.GITHUB_TOKEN }}
          nix_path: nixpkgs=channel:nixos-unstable
      - name: Update checksum
        run: |
          ./scripts/update-vendor-hash.sh
          # git push if we have a diff
          if [[ -n $(git diff) ]]; then
            git add default.nix
            git config --global user.email "<49699333+dependabot[bot]@users.noreply.github.com>"
            git config --global user.name "dependabot[bot]"
            git commit -m "update vendorHash"
            git push origin HEAD:${{ github.head_ref }}
          fi
</file>

<file path=".github/workflows/upgrade-flakes.yml">
name: "Update flakes"
on:
  repository_dispatch:
  workflow_dispatch:
  schedule:
    - cron:  '51 2 * * 0'

jobs:
  createPullRequest:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
      - name: Install Nix
        uses: cachix/install-nix-action@v31
        with:
          extra_nix_config: |
            access-tokens = github.com=${{ secrets.GITHUB_TOKEN }}
      - uses: actions/create-github-app-token@v2
        id: app-token
        with:
          app-id: ${{ vars.CI_APP_ID }}
          private-key: ${{ secrets.CI_APP_PRIVATE_KEY }}
      - name: Update flakes
        run: |
           nix flake update
           pushd dev/private
           nix flake update
           popd
           nix run .#update-dev-private-narHash
      - name: Create Pull Request
        uses: peter-evans/create-pull-request@v7
        with:
          title: Update flakes
          token: ${{ steps.app-token.outputs.token }}
          labels: |
            auto-merge
</file>

<file path=".github/dependabot.yml">
version: 2
updates:
  - package-ecosystem: "github-actions"
    directory: "/"
    schedule:
      interval: "weekly"
  - package-ecosystem: "gomod"
    directory: "/"
    # otherwise auto-merge without merge-queue might break checksums
    open-pull-requests-limit: 1
    schedule:
      interval: "weekly"
</file>

<file path="checks/darwin.nix">
{
  config,
  ...
}:
{
  imports = [
    ../modules/nix-darwin/default.nix
  ];
  documentation.enable = false;
  sops.secrets.test_key = { };
  sops.templates."template.toml" = {
    content = ''
      password = "${config.sops.placeholder.test_key}";
    '';
  };
  sops.templates."template-with-uid.toml" = {
    content = ''
      password = "${config.sops.placeholder.test_key}";
    '';
    uid = 1000;
  };
  sops.templates."template-with-gid.toml" = {
    content = ''
      password = "${config.sops.placeholder.test_key}";
    '';
    gid = 1000;
  };
  sops.defaultSopsFile = ../pkgs/sops-install-secrets/test-assets/secrets.yaml;
  sops.age.generateKey = true;
  system.stateVersion = 5;
}
</file>

<file path="checks/home-manager.nix">
{ config, ... }:
{
  imports = [
    ../modules/home-manager/sops.nix
  ];
  home.stateVersion = "25.05";
  home.username = "sops-user";
  home.homeDirectory = "/home/sops-user";
  home.enableNixpkgsReleaseCheck = false;

  sops.age.generateKey = true;
  sops.age.keyFile = "${config.home.homeDirectory}/.age-key.txt";
  sops.secrets.test_key = { };
  sops.templates."template.toml".content = ''
    password = "${config.sops.placeholder.test_key}";
  '';
  sops.defaultSopsFile = ../pkgs/sops-install-secrets/test-assets/secrets.yaml;
}
</file>

<file path="checks/nixos-test.nix">
{ lib, testers }:
let
  testAssets = ../pkgs/sops-install-secrets/test-assets;

  userPasswordTest =
    name: extraConfig:
    testers.runNixOSTest {
      inherit name;
      nodes.machine =
        { config, lib, ... }:
        {
          imports = [
            ../modules/sops
            extraConfig
          ];
          sops = {
            age.keyFile = "/run/age-keys.txt";
            defaultSopsFile = testAssets + "/secrets.yaml";
            secrets.test_key.neededForUsers = true;
            secrets."nested/test/file".owner = "example-user";
          };
          system.switch.enable = true;

          users.users.example-user = lib.mkMerge [
            (lib.mkIf (!config.systemd.sysusers.enable) {
              isNormalUser = true;
              hashedPasswordFile = config.sops.secrets.test_key.path;
            })
            (lib.mkIf config.systemd.sysusers.enable {
              isSystemUser = true;
              group = "users";
              hashedPasswordFile = config.sops.secrets.test_key.path;
            })
          ];
        };

      testScript =
        ''
          start_all()
          machine.wait_for_unit("multi-user.target")

          machine.succeed("getent shadow example-user | grep -q :test_value:")  # password was set
          machine.succeed("cat /run/secrets/nested/test/file | grep -q 'another value'")  # regular secrets work...
          user = machine.succeed("stat -c%U /run/secrets/nested/test/file").strip()  # ...and are owned...
          assert user == "example-user", f"Expected 'example-user', got '{user}'"
          machine.succeed("cat /run/secrets-for-users/test_key | grep -q 'test_value'")  # the user password still exists

          # BUG in nixos's overlayfs... systemd crashes on switch-to-configuration test
        ''
        + lib.optionalString (!(extraConfig ? system.etc.overlay.enable)) ''
          machine.succeed("/run/current-system/bin/switch-to-configuration test")
          machine.succeed("cat /run/secrets/nested/test/file | grep -q 'another value'")  # the regular secrets still work after a switch
          machine.succeed("cat /run/secrets-for-users/test_key | grep -q 'test_value'")  # the user password is still present after a switch
        '';
    };
in
{
  ssh-keys = testers.runNixOSTest {
    name = "sops-ssh-keys";
    nodes.server =
      { ... }:
      {
        imports = [ ../modules/sops ];
        services.openssh.enable = true;
        services.openssh.hostKeys = [
          {
            type = "rsa";
            bits = 4096;
            path = testAssets + "/ssh-key";
          }
        ];
        sops.defaultSopsFile = testAssets + "/secrets.yaml";
        sops.secrets.test_key = { };
      };

    testScript = ''
      start_all()
      server.succeed("cat /run/secrets/test_key | grep -q test_value")
    '';
  };

  pruning = testers.runNixOSTest {
    name = "sops-pruning";
    nodes.machine =
      { lib, ... }:
      {
        imports = [ ../modules/sops ];
        sops = {
          age.keyFile = "/run/age-keys.txt";
          defaultSopsFile = testAssets + "/secrets.yaml";
          secrets.test_key = { };
          keepGenerations = lib.mkDefault 0;
        };

        # must run before sops sets up keys
        boot.initrd.postDeviceCommands = ''
          cp -r ${testAssets + "/age-keys.txt"} /run/age-keys.txt
          chmod -R 700 /run/age-keys.txt
        '';

        specialisation.pruning.configuration.sops.keepGenerations = 10;
      };

    testScript = ''
      # Force us to generation 100
      machine.succeed("mkdir /run/secrets.d/{2..99} /run/secrets.d/non-numeric")
      machine.succeed("ln -fsn /run/secrets.d/99 /run/secrets")
      machine.succeed("/run/current-system/activate")
      machine.succeed("test -d /run/secrets.d/100")

      # Ensure nothing is pruned, these are just random numbers
      machine.succeed("test -d /run/secrets.d/1")
      machine.succeed("test -d /run/secrets.d/90")
      machine.succeed("test -d /run/secrets.d/non-numeric")

      machine.succeed("/run/current-system/specialisation/pruning/bin/switch-to-configuration test")
      print(machine.succeed("ls -la /run/secrets.d/"))

      # Ensure stuff was properly pruned.
      # We are now at generation 101 so 92 must exist when we keep 10 generations
      # and 91 must not.
      machine.fail("test -d /run/secrets.d/91")
      machine.succeed("test -d /run/secrets.d/92")
      machine.succeed("test -d /run/secrets.d/non-numeric")
    '';
  };

  age-keys = testers.runNixOSTest {
    name = "sops-age-keys";
    nodes.machine =
      { config, ... }:
      {
        imports = [ ../modules/sops ];
        sops = {
          age.keyFile = "/run/age-keys.txt";
          defaultSopsFile = testAssets + "/secrets.yaml";
          secrets = {
            test_key = { };

            test_key_someuser_somegroup = {
              uid = config.users.users."someuser".uid;
              gid = config.users.groups."somegroup".gid;
              key = "test_key";
            };
            test_key_someuser_root = {
              uid = config.users.users."someuser".uid;
              key = "test_key";
            };
            test_key_root_root = {
              key = "test_key";
            };
            test_key_1001_1001 = {
              uid = 1001;
              gid = 1001;
              key = "test_key";
            };
          };
        };

        users.users."someuser" = {
          uid = 1000;
          group = "somegroup";
          isNormalUser = true;
        };
        users.groups."somegroup" = {
          gid = 1000;
        };

        # must run before sops sets up keys
        boot.initrd.postDeviceCommands = ''
          cp -r ${testAssets + "/age-keys.txt"} /run/age-keys.txt
          chmod -R 700 /run/age-keys.txt

          # if the directory exists, sops-nix should replace it with a symlink
          mkdir /run/secrets
        '';
      };

    testScript = ''
      start_all()
      machine.succeed("cat /run/secrets/test_key | grep -q test_value")

      with subtest("test ownership"):
         machine.succeed("[ $(stat -c%u /run/secrets/test_key_someuser_somegroup) = '1000' ]")
         machine.succeed("[ $(stat -c%g /run/secrets/test_key_someuser_somegroup) = '1000' ]")
         machine.succeed("[ $(stat -c%U /run/secrets/test_key_someuser_somegroup) = 'someuser' ]")
         machine.succeed("[ $(stat -c%G /run/secrets/test_key_someuser_somegroup) = 'somegroup' ]")

         machine.succeed("[ $(stat -c%u /run/secrets/test_key_someuser_root) = '1000' ]")
         machine.succeed("[ $(stat -c%g /run/secrets/test_key_someuser_root) = '0' ]")
         machine.succeed("[ $(stat -c%U /run/secrets/test_key_someuser_root) = 'someuser' ]")
         machine.succeed("[ $(stat -c%G /run/secrets/test_key_someuser_root) = 'root' ]")

         machine.succeed("[ $(stat -c%u /run/secrets/test_key_1001_1001) = '1001' ]")
         machine.succeed("[ $(stat -c%g /run/secrets/test_key_1001_1001) = '1001' ]")
         machine.succeed("[ $(stat -c%U /run/secrets/test_key_1001_1001) = 'UNKNOWN' ]")
         machine.succeed("[ $(stat -c%G /run/secrets/test_key_1001_1001) = 'UNKNOWN' ]")
    '';
  };

  age-ssh-keys = testers.runNixOSTest {
    name = "sops-age-ssh-keys";
    nodes.machine = {
      imports = [ ../modules/sops ];
      services.openssh.enable = true;
      services.openssh.hostKeys = [
        {
          type = "ed25519";
          path = testAssets + "/ssh-ed25519-key";
        }
      ];

      sops = {
        defaultSopsFile = testAssets + "/secrets.yaml";
        secrets.test_key = { };
        # Generate a key and append it to make sure it appending doesn't break anything
        age = {
          keyFile = "/tmp/testkey";
          generateKey = true;
        };
      };
    };

    testScript = ''
      start_all()
      machine.succeed("cat /run/secrets/test_key | grep -q test_value")
    '';
  };

  pgp-keys = testers.runNixOSTest {
    name = "sops-pgp-keys";
    nodes.server =
      { lib, config, ... }:
      {
        imports = [ ../modules/sops ];

        users.users.someuser = {
          isSystemUser = true;
          group = "nogroup";
        };

        sops.gnupg.home = "/run/gpghome";
        sops.defaultSopsFile = testAssets + "/secrets.yaml";
        sops.secrets.test_key.owner = config.users.users.someuser.name;
        sops.secrets."nested/test/file".owner = config.users.users.someuser.name;
        sops.secrets.existing-file = {
          key = "test_key";
          path = "/run/existing-file";
        };
        # must run before sops
        system.activationScripts.gnupghome = lib.stringAfter [ "etc" ] ''
          cp -r ${testAssets + "/gnupghome"} /run/gpghome
          chmod -R 700 /run/gpghome

          touch /run/existing-file
        '';
        # Useful for debugging
        #environment.systemPackages = [ pkgs.gnupg pkgs.sops ];
        #environment.variables = {
        #  GNUPGHOME = "/run/gpghome";
        #  SOPS_GPG_EXEC="${pkgs.gnupg}/bin/gpg";
        #  SOPSFILE = "${testAssets + "/secrets.yaml"}";
        #};
      };
    testScript = ''
      def assertEqual(exp: str, act: str) -> None:
          if exp != act:
              raise Exception(f"{exp!r} != {act!r}")


      start_all()

      value = server.succeed("cat /run/secrets/test_key")
      assertEqual("test_value", value)

      server.succeed("runuser -u someuser -- cat /run/secrets/test_key >&2")
      value = server.succeed("cat /run/secrets/nested/test/file")
      assertEqual(value, "another value")

      target = server.succeed("readlink -f /run/existing-file")
      assertEqual("/run/secrets.d/1/existing-file", target.strip())
    '';
  };

  templates = testers.runNixOSTest {
    name = "sops-templates";
    nodes.machine =
      { config, ... }:
      {
        imports = [ ../modules/sops ];
        sops = {
          age.keyFile = "/run/age-keys.txt";
          defaultSopsFile = testAssets + "/secrets.yaml";
          secrets.test_key = { };

          # Verify that things work even with `neededForUsers` secrets. See
          # <https://github.com/Mic92/sops-nix/issues/659>.
          secrets."nested/test/file".neededForUsers = true;
        };

        # must run before sops sets up keys
        boot.initrd.postDeviceCommands = ''
          cp -r ${testAssets + "/age-keys.txt"} /run/age-keys.txt
          chmod -R 700 /run/age-keys.txt
        '';

        sops.templates.test_template = {
          content = ''
            This line is not modified.
            The next value will be replaced by ${config.sops.placeholder.test_key}
            This line is also not modified.
          '';
          mode = "0400";
          owner = "someuser";
          group = "somegroup";
        };
        sops.templates.test_default = {
          content = ''
            Test value: ${config.sops.placeholder.test_key}
          '';
          path = "/etc/externally/linked";
        };

        sops.templates.test_uid_gid = {
          uid = 420;
          gid = 420;
          content = ''
            Test value: ${config.sops.placeholder.test_key}
          '';
        };

        users.groups.somegroup = { };
        users.users.someuser = {
          isSystemUser = true;
          group = "somegroup";
        };
      };

    testScript = ''
      def assertEqual(exp: str, act: str) -> None:
          if exp != act:
              raise Exception(f"{exp!r} != {act!r}")


      start_all()
      machine.succeed("[ $(stat -c%U /run/secrets/rendered/test_template) = 'someuser' ]")
      machine.succeed("[ $(stat -c%G /run/secrets/rendered/test_template) = 'somegroup' ]")
      machine.succeed("[ $(stat -c%U /run/secrets/rendered/test_default) = 'root' ]")
      machine.succeed("[ $(stat -c%G /run/secrets/rendered/test_default) = 'root' ]")
      machine.succeed("[ $(stat -c%u /run/secrets/rendered/test_uid_gid) = '420' ]")
      machine.succeed("[ $(stat -c%g /run/secrets/rendered/test_uid_gid) = '420' ]")

      expected = """\
      This line is not modified.
      The next value will be replaced by test_value
      This line is also not modified.
      """
      rendered = machine.succeed("cat /run/secrets/rendered/test_template")

      expected_default = """\
      Test value: test_value
      """
      rendered_default = machine.succeed("cat /run/secrets/rendered/test_default")

      assertEqual(expected, rendered)
      assertEqual(expected_default, rendered_default)

      # Confirm that `test_default` was symlinked to the appropriate place.
      realpath = machine.succeed("realpath /etc/externally/linked").strip()
      assertEqual(realpath, "/run/secrets.d/1/rendered/test_default")
    '';
  };

  restart-and-reload = testers.runNixOSTest {
    name = "sops-restart-and-reload";
    nodes.machine =
      { config, ... }:
      {
        imports = [ ../modules/sops ];

        sops = {
          age.keyFile = "/run/age-keys.txt";
          defaultSopsFile = testAssets + "/secrets.yaml";
          secrets.test_key = {
            restartUnits = [
              "restart-unit.service"
              "reload-unit.service"
            ];
            reloadUnits = [ "reload-trigger.service" ];
          };

          templates.test_template = {
            content = ''
              this is a template with
              a secret: ${config.sops.placeholder.test_key}
            '';
            restartUnits = [
              "restart-unit.service"
              "reload-unit.service"
            ];
            reloadUnits = [ "reload-trigger.service" ];
          };
        };
        system.switch.enable = true;

        # must run before sops sets up keys
        boot.initrd.postDeviceCommands = ''
          cp -r ${testAssets + "/age-keys.txt"} /run/age-keys.txt
          chmod -R 700 /run/age-keys.txt
        '';

        systemd.services."restart-unit" = {
          description = "Restart unit";
          # not started on boot
          serviceConfig = {
            ExecStart = "/bin/sh -c 'echo ok > /restarted'";
          };
        };
        systemd.services."reload-unit" = {
          description = "Reload unit";
          wantedBy = [ "multi-user.target" ];
          reloadIfChanged = true;
          serviceConfig = {
            Type = "oneshot";
            RemainAfterExit = true;
            ExecStart = "/bin/sh -c true";
            ExecReload = "/bin/sh -c 'echo ok > /reloaded'";
          };
        };
        systemd.services."reload-trigger" = {
          description = "Reload trigger unit";
          wantedBy = [ "multi-user.target" ];
          serviceConfig = {
            Type = "oneshot";
            RemainAfterExit = true;
            ExecStart = "/bin/sh -c true";
            ExecReload = "/bin/sh -c 'echo ok > /reloaded'";
          };
        };

      };
    testScript = ''
      def assertOutput(output, *expected_lines):
        expected_lines = list(expected_lines)

        # Remove unrelated fluff that shows up in the output of `switch-to-configuration`.
        prefix = "setting up /etc...\n"
        if output.startswith(prefix):
          output = output.removeprefix(prefix)

        actual_lines = output.splitlines(keepends=False)

        if actual_lines != expected_lines:
          raise Exception(f"{actual_lines} != {expected_lines}")

      machine.wait_for_unit("multi-user.target")
      machine.fail("test -f /restarted")
      machine.fail("test -f /reloaded")

      # Nothing is to be restarted after boot
      machine.fail("ls /run/nixos/*-list")

      # Nothing happens when the secret is not changed
      machine.succeed("/run/current-system/bin/switch-to-configuration test")
      machine.fail("test -f /restarted")
      machine.fail("test -f /reloaded")

      # Ensure the secret is changed
      machine.succeed(": > /run/secrets/test_key")

      # The secret is changed, now something should happen
      machine.succeed("/run/current-system/bin/switch-to-configuration test")

      # Ensure something happened
      machine.succeed("test -f /restarted")
      machine.succeed("test -f /reloaded")

      # Cleanup the marker files.
      machine.succeed("rm /restarted /reloaded")

      # Ensure the template is changed
      machine.succeed(": > /run/secrets/rendered/test_template")

      # The template is changed, now something should happen
      machine.succeed("/run/current-system/bin/switch-to-configuration test")

      # Ensure something happened
      machine.succeed("test -f /restarted")
      machine.succeed("test -f /reloaded")

      # Cleanup the marker files.
      machine.succeed("rm /restarted /reloaded")

      with subtest("change detection"):
        machine.succeed("rm /run/secrets/test_key")
        machine.succeed("rm /run/secrets/rendered/test_template")
        out = machine.succeed("/run/current-system/bin/switch-to-configuration test")
        assertOutput(
          out,
          "adding secret: test_key",
          "adding rendered secret: test_template",
        )

        machine.succeed(": > /run/secrets/test_key")
        machine.succeed(": > /run/secrets/rendered/test_template")
        out = machine.succeed("/run/current-system/bin/switch-to-configuration test")
        assertOutput(
          out,
          "modifying secret: test_key",
          "modifying rendered secret: test_template",
        )

        machine.succeed(": > /run/secrets/another_key")
        machine.succeed(": > /run/secrets/rendered/another_template")
        out = machine.succeed("/run/current-system/bin/switch-to-configuration test")
        assertOutput(
          out,
          "removing secret: another_key",
          "removing rendered secret: another_template",
        )

      with subtest("dry activation"):
        machine.succeed("rm /run/secrets/test_key")
        machine.succeed("rm /run/secrets/rendered/test_template")
        machine.succeed(": > /run/secrets/another_key")
        machine.succeed(": > /run/secrets/rendered/another_template")
        out = machine.succeed("/run/current-system/bin/switch-to-configuration dry-activate")
        assertOutput(
          out,
          "would add secret: test_key",
          "would remove secret: another_key",
          "would add rendered secret: test_template",
          "would remove rendered secret: another_template",
        )

        # Verify that we did not actually activate the new configuration.
        machine.fail("test -f /run/secrets/test_key")
        machine.fail("test -f /run/secrets/rendered/test_template")
        machine.succeed("test -f /run/secrets/another_key")
        machine.succeed("test -f /run/secrets/rendered/another_template")

        # Now actually activate and sanity check the resulting secrets.
        machine.succeed("/run/current-system/bin/switch-to-configuration test")
        machine.succeed("test -f /run/secrets/test_key")
        machine.succeed("test -f /run/secrets/rendered/test_template")
        machine.fail("test -f /run/secrets/another_key")
        machine.fail("test -f /run/secrets/rendered/another_template")

        # Remove the restarted/reloaded indicators so we can confirm a
        # dry-activate doesn't trigger systemd units.
        machine.succeed("rm /restarted /reloaded")

        machine.succeed(": > /run/secrets/test_key")
        out = machine.succeed("/run/current-system/bin/switch-to-configuration dry-activate")
        assertOutput(
          out,
          "would modify secret: test_key",
        )
        machine.succeed("[ $(cat /run/secrets/test_key | wc -c) = 0 ]")

        machine.fail("test -f /restarted")  # not done in dry mode
        machine.fail("test -f /reloaded")  # not done in dry mode
    '';
  };

  user-passwords = userPasswordTest "sops-user-passwords" {
    # must run before sops sets up keys
    boot.initrd.postDeviceCommands = ''
      cp -r ${testAssets + "/age-keys.txt"} /run/age-keys.txt
      chmod -R 700 /run/age-keys.txt
    '';
  };

  user-passwords-sysusers = userPasswordTest "sops-user-passwords-sysusers" (
    { pkgs, ... }:
    {
      systemd.sysusers.enable = true;
      users.mutableUsers = true;
      system.etc.overlay.enable = true;
      boot.initrd.systemd.enable = true;
      boot.kernelPackages = pkgs.linuxPackages_latest;

      # must run before sops sets up keys
      systemd.services."sops-install-secrets-for-users".preStart = ''
        printf '${builtins.readFile (testAssets + "/age-keys.txt")}' > /run/age-keys.txt
        chmod -R 700 /run/age-keys.txt
      '';
    }
  );

  user-passwords-userborn = userPasswordTest "sops-user-passwords-userborn" (
    { pkgs, ... }:
    {
      services.userborn.enable = true;
      users.mutableUsers = false;
      system.etc.overlay.enable = true;
      boot.initrd.systemd.enable = true;
      boot.kernelPackages = pkgs.linuxPackages_latest;

      # must run before sops sets up keys
      systemd.services."sops-install-secrets-for-users".preStart = ''
        printf '${builtins.readFile (testAssets + "/age-keys.txt")}' > /run/age-keys.txt
        chmod -R 700 /run/age-keys.txt
      '';
    }
  );
}
</file>

<file path="dev/private/flake.lock">
{
  "nodes": {
    "home-manager": {
      "inputs": {
        "nixpkgs": [
          "nixpkgs-unstable"
        ]
      },
      "locked": {
        "lastModified": 1760809591,
        "narHash": "sha256-OxGcFcQdfOK8veZkPdQuqXIotFYiy4sBQB58dMNLeHY=",
        "owner": "nix-community",
        "repo": "home-manager",
        "rev": "870883ba11ba1c84f756c0c1f9fa74cdb2a16c1e",
        "type": "github"
      },
      "original": {
        "owner": "nix-community",
        "repo": "home-manager",
        "type": "github"
      }
    },
    "nix-darwin": {
      "inputs": {
        "nixpkgs": [
          "nixpkgs-unstable"
        ]
      },
      "locked": {
        "lastModified": 1760721282,
        "narHash": "sha256-aAHphQbU9t/b2RRy2Eb8oMv+I08isXv2KUGFAFn7nCo=",
        "owner": "LnL7",
        "repo": "nix-darwin",
        "rev": "c3211fcd0c56c11ff110d346d4487b18f7365168",
        "type": "github"
      },
      "original": {
        "owner": "LnL7",
        "repo": "nix-darwin",
        "type": "github"
      }
    },
    "nixpkgs-stable": {
      "locked": {
        "lastModified": 1760580664,
        "narHash": "sha256-/YdfibIrnqXAL8p5kqCU345mzpHoOtuVIkMiI2pF4Dc=",
        "ref": "nixos-25.05",
        "rev": "98ff3f9af2684f6136c24beef08f5e2033fc5389",
        "shallow": true,
        "type": "git",
        "url": "https://github.com/NixOS/nixpkgs"
      },
      "original": {
        "ref": "nixos-25.05",
        "shallow": true,
        "type": "git",
        "url": "https://github.com/NixOS/nixpkgs"
      }
    },
    "nixpkgs-unstable": {
      "locked": {
        "lastModified": 1760596604,
        "narHash": "sha256-J/i5K6AAz/y5dBePHQOuzC7MbhyTOKsd/GLezSbEFiM=",
        "ref": "nixpkgs-unstable",
        "rev": "3cbe716e2346710d6e1f7c559363d14e11c32a43",
        "shallow": true,
        "type": "git",
        "url": "https://github.com/NixOS/nixpkgs"
      },
      "original": {
        "ref": "nixpkgs-unstable",
        "shallow": true,
        "type": "git",
        "url": "https://github.com/NixOS/nixpkgs"
      }
    },
    "root": {
      "inputs": {
        "home-manager": "home-manager",
        "nix-darwin": "nix-darwin",
        "nixpkgs-stable": "nixpkgs-stable",
        "nixpkgs-unstable": "nixpkgs-unstable",
        "treefmt-nix": "treefmt-nix"
      }
    },
    "treefmt-nix": {
      "inputs": {
        "nixpkgs": [
          "nixpkgs-unstable"
        ]
      },
      "locked": {
        "lastModified": 1760802554,
        "narHash": "sha256-5YkOYOCF8/XNw89/ABKFB0c/P78U2EVuKRDGTql6+kA=",
        "owner": "numtide",
        "repo": "treefmt-nix",
        "rev": "296ebf0c3668ebceb3b0bfee55298f112b4b5754",
        "type": "github"
      },
      "original": {
        "owner": "numtide",
        "repo": "treefmt-nix",
        "type": "github"
      }
    }
  },
  "root": "root",
  "version": 7
}
</file>

<file path="dev/private/flake.nix">
{
  description = "private inputs";

  inputs.nixpkgs-stable.url = "git+https://github.com/NixOS/nixpkgs?shallow=1&ref=nixos-25.05";

  inputs.nixpkgs-unstable.url = "git+https://github.com/NixOS/nixpkgs?shallow=1&ref=nixpkgs-unstable";

  inputs.treefmt-nix.url = "github:numtide/treefmt-nix";
  inputs.treefmt-nix.inputs.nixpkgs.follows = "nixpkgs-unstable";

  inputs.nix-darwin.url = "github:LnL7/nix-darwin";
  inputs.nix-darwin.inputs.nixpkgs.follows = "nixpkgs-unstable";

  inputs.home-manager.url = "github:nix-community/home-manager";
  inputs.home-manager.inputs.nixpkgs.follows = "nixpkgs-unstable";

  outputs = _: { };
}
</file>

<file path="dev/private.narHash">
sha256-KlDClY1afk97bkyVoolHE0WlJ4Hoj2kd45+4xAWN9vI=
</file>

<file path="modules/home-manager/sops.nix">
{
  config,
  lib,
  pkgs,
  ...
}:

let
  cfg = config.sops;
  sops-install-secrets = cfg.package;
  secretType = lib.types.submodule (
    { name, ... }:
    {
      options = {
        name = lib.mkOption {
          type = lib.types.str;
          default = name;
          description = ''
            Name of the file used in /run/user/*/secrets
          '';
        };

        key = lib.mkOption {
          type = lib.types.str;
          default = if cfg.defaultSopsKey != null then cfg.defaultSopsKey else name;
          description = ''
            Key used to lookup in the sops file.
            No tested data structures are supported right now.
            This option is ignored if format is binary.
            "" means whole file.
          '';
        };

        path = lib.mkOption {
          type = lib.types.str;
          default = "${cfg.defaultSymlinkPath}/${name}";
          description = ''
            Path where secrets are symlinked to.
            If the default is kept no other symlink is created.
            `%r` is replaced by $XDG_RUNTIME_DIR on linux or `getconf
            DARWIN_USER_TEMP_DIR` on darwin.
          '';
        };

        format = lib.mkOption {
          type = lib.types.enum [
            "yaml"
            "json"
            "binary"
            "ini"
            "dotenv"
          ];
          default = cfg.defaultSopsFormat;
          description = ''
            File format used to decrypt the sops secret.
            Binary files are written to the target file as is.
          '';
        };

        mode = lib.mkOption {
          type = lib.types.str;
          default = "0400";
          description = ''
            Permissions mode of the in octal.
          '';
        };

        sopsFile = lib.mkOption {
          type = lib.types.path;
          default = cfg.defaultSopsFile;
          defaultText = lib.literalExpression "\${config.sops.defaultSopsFile}";
          description = ''
            Sops file the secret is loaded from.
          '';
        };
      };
    }
  );

  pathNotInStore = lib.mkOptionType {
    name = "pathNotInStore";
    description = "path not in the Nix store";
    descriptionClass = "noun";
    check = x: !lib.path.hasStorePathPrefix (/. + x);
    merge = lib.mergeEqualOption;
  };

  manifestFor =
    suffix: secrets: templates:
    pkgs.writeTextFile {
      name = "manifest${suffix}.json";
      text = builtins.toJSON {
        secrets = builtins.attrValues secrets;
        templates = builtins.attrValues templates;
        secretsMountPoint = cfg.defaultSecretsMountPoint;
        symlinkPath = cfg.defaultSymlinkPath;
        keepGenerations = cfg.keepGenerations;
        gnupgHome = cfg.gnupg.home;
        sshKeyPaths = cfg.gnupg.sshKeyPaths;
        ageKeyFile = cfg.age.keyFile;
        ageSshKeyPaths = cfg.age.sshKeyPaths;
        placeholderBySecretName = cfg.placeholder;
        userMode = true;
        logging = {
          keyImport = builtins.elem "keyImport" cfg.log;
          secretChanges = builtins.elem "secretChanges" cfg.log;
        };
      };
      checkPhase = ''
        ${sops-install-secrets}/bin/sops-install-secrets -check-mode=${
          if cfg.validateSopsFiles then "sopsfile" else "manifest"
        } "$out"
      '';
    };

  manifest = manifestFor "" cfg.secrets cfg.templates;

  escapedAgeKeyFile = lib.escapeShellArg cfg.age.keyFile;

  script = toString (
    pkgs.writeShellScript "sops-nix-user" (
      lib.optionalString cfg.age.generateKey ''
        if [[ ! -f ${escapedAgeKeyFile} ]]; then
          echo generating machine-specific age key...
          ${pkgs.coreutils}/bin/mkdir -p $(${pkgs.coreutils}/bin/dirname ${escapedAgeKeyFile})
          # age-keygen sets 0600 by default, no need to chmod.
          ${pkgs.age}/bin/age-keygen -o ${escapedAgeKeyFile}
        fi
      ''
      + ''
        ${sops-install-secrets}/bin/sops-install-secrets -ignore-passwd ${manifest}
      ''
    )
  );
in
{
  imports = [
    ./templates.nix
  ];

  options.sops = {
    secrets = lib.mkOption {
      type = lib.types.attrsOf secretType;
      default = { };
      description = ''
        Secrets to decrypt.
      '';
    };

    defaultSopsFile = lib.mkOption {
      type = lib.types.path;
      description = ''
        Default sops file used for all secrets.
      '';
    };

    defaultSopsFormat = lib.mkOption {
      type = lib.types.str;
      default = "yaml";
      description = ''
        Default sops format used for all secrets.
      '';
    };

    defaultSopsKey = lib.mkOption {
      type = lib.types.nullOr lib.types.str;
      default = null;
      description = ''
        Default key used to lookup in all secrets.
        This option is ignored if format is binary.
        "" means whole file.
      '';
    };

    validateSopsFiles = lib.mkOption {
      type = lib.types.bool;
      default = true;
      description = ''
        Check all sops files at evaluation time.
        This requires sops files to be added to the nix store.
      '';
    };

    defaultSymlinkPath = lib.mkOption {
      type = lib.types.str;
      default = "${config.xdg.configHome}/sops-nix/secrets";
      description = ''
        Default place where the latest generation of decrypt secrets
        can be found.
      '';
    };

    defaultSecretsMountPoint = lib.mkOption {
      type = lib.types.str;
      default = "%r/secrets.d";
      description = ''
        Default place where generations of decrypted secrets are stored.
      '';
    };

    keepGenerations = lib.mkOption {
      type = lib.types.ints.unsigned;
      default = 1;
      description = ''
        Number of secrets generations to keep. Setting this to 0 disables pruning.
      '';
    };

    log = lib.mkOption {
      type = lib.types.listOf (
        lib.types.enum [
          "keyImport"
          "secretChanges"
        ]
      );
      default = [
        "keyImport"
        "secretChanges"
      ];
      description = "What to log";
    };

    environment = lib.mkOption {
      type = lib.types.attrsOf (lib.types.either lib.types.str lib.types.path);
      default = { };
      description = ''
        Environment variables to set before calling sops-install-secrets.

        To properly quote strings with quotes use lib.escapeShellArg.
      '';
    };

    package = lib.mkOption {
      type = lib.types.package;
      default = (pkgs.callPackage ../.. { }).sops-install-secrets;
      defaultText = lib.literalExpression "(pkgs.callPackage ../.. {}).sops-install-secrets";
      description = ''
        sops-install-secrets package to use.
      '';
    };

    age = {
      keyFile = lib.mkOption {
        type = lib.types.nullOr pathNotInStore;
        default = null;
        example = "/home/someuser/.age-key.txt";
        description = ''
          Path to age key file used for sops decryption.
        '';
      };

      generateKey = lib.mkOption {
        type = lib.types.bool;
        default = false;
        description = ''
          Whether or not to generate the age key. If this
          option is set to false, the key must already be
          present at the specified location.
        '';
      };

      sshKeyPaths = lib.mkOption {
        type = lib.types.listOf lib.types.path;
        default = [ ];
        description = ''
          Paths to ssh keys added as age keys during sops description.
        '';
      };
    };

    gnupg = {
      home = lib.mkOption {
        type = lib.types.nullOr lib.types.str;
        default = null;
        example = "/home/someuser/.gnupg";
        description = ''
          Path to gnupg database directory containing the key for decrypting the sops file.
        '';
      };

      qubes-split-gpg = {
        enable = lib.mkEnableOption "Enable support for Qubes Split GPG feature: https://www.qubes-os.org/doc/split-gpg";

        domain = lib.mkOption {
          type = lib.types.nullOr lib.types.str;
          default = null;
          example = "vault-gpg";
          description = ''
            It tells Qubes OS which secure Qube holds your GPG keys for isolated cryptographic operations.
          '';
        };
      };

      sshKeyPaths = lib.mkOption {
        type = lib.types.listOf lib.types.path;
        default = [ ];
        description = ''
          Path to ssh keys added as GPG keys during sops description.
          This option must be explicitly unset if <literal>config.sops.gnupg.sshKeyPaths</literal> is set.
        '';
      };
    };
  };

  config = lib.mkIf (cfg.secrets != { }) {
    assertions = [
      {
        assertion =
          cfg.gnupg.home != null
          || cfg.gnupg.sshKeyPaths != [ ]
          || cfg.gnupg.qubes-split-gpg.enable == true
          || cfg.age.keyFile != null
          || cfg.age.sshKeyPaths != [ ];
        message = "No key source configured for sops. Either set services.openssh.enable or set sops.age.keyFile or sops.gnupg.home or sops.gnupg.qubes-split-gpg.enable";
      }
      {
        assertion =
          !(cfg.gnupg.home != null && cfg.gnupg.sshKeyPaths != [ ])
          && !(cfg.gnupg.home != null && cfg.gnupg.qubes-split-gpg.enable == true)
          && !(cfg.gnupg.sshKeyPaths != [ ] && cfg.gnupg.qubes-split-gpg.enable == true);
        message = "Exactly one of sops.gnupg.home, sops.gnupg.qubes-split-gpg.enable and sops.gnupg.sshKeyPaths must be set";
      }
      {
        assertion =
          cfg.gnupg.qubes-split-gpg.enable == false
          || (
            cfg.gnupg.qubes-split-gpg.enable == true
            && cfg.gnupg.qubes-split-gpg.domain != null
            && cfg.gnupg.qubes-split-gpg.domain != ""
          );
        message = "sops.gnupg.qubes-split-gpg.domain is required when sops.gnupg.qubes-split-gpg.enable is set to true";
      }
    ];

    home.sessionVariables = lib.mkIf cfg.gnupg.qubes-split-gpg.enable {
      # TODO: Add this package to nixpkgs and use it from the store
      # https://github.com/QubesOS/qubes-app-linux-split-gpg
      SOPS_GPG_EXEC = "qubes-gpg-client-wrapper";
    };

    sops.environment = {
      SOPS_GPG_EXEC = lib.mkMerge [
        (lib.mkIf (cfg.gnupg.home != null || cfg.gnupg.sshKeyPaths != [ ]) (
          lib.mkDefault "${pkgs.gnupg}/bin/gpg"
        ))
        (lib.mkIf cfg.gnupg.qubes-split-gpg.enable (
          lib.mkDefault config.home.sessionVariables.SOPS_GPG_EXEC
        ))
      ];

      QUBES_GPG_DOMAIN = lib.mkIf cfg.gnupg.qubes-split-gpg.enable (
        lib.mkDefault cfg.gnupg.qubes-split-gpg.domain
      );
    };

    systemd.user.services.sops-nix = lib.mkIf pkgs.stdenv.hostPlatform.isLinux {
      Unit = {
        Description = "sops-nix activation";
      };
      Service = {
        Type = "oneshot";
        Environment = builtins.concatStringsSep " " (
          lib.mapAttrsToList (name: value: "'${name}=${value}'") cfg.environment
        );
        ExecStart = script;
      };
      Install.WantedBy =
        if cfg.gnupg.home != null then [ "graphical-session-pre.target" ] else [ "default.target" ];
    };

    # Darwin: load secrets once on login
    launchd.agents.sops-nix = {
      enable = true;
      config = {
        Program = script;
        EnvironmentVariables = cfg.environment;
        KeepAlive = false;
        RunAtLoad = true;
        StandardOutPath = "${config.home.homeDirectory}/Library/Logs/SopsNix/stdout";
        StandardErrorPath = "${config.home.homeDirectory}/Library/Logs/SopsNix/stderr";
      };
    };

    # [re]load secrets on home-manager activation
    home.activation =
      let
        darwin =
          let
            domain-target = "gui/$(id -u ${config.home.username})";
          in
          ''
            /bin/launchctl bootout ${domain-target}/org.nix-community.home.sops-nix && true
            /bin/launchctl bootstrap ${domain-target} ${config.home.homeDirectory}/Library/LaunchAgents/org.nix-community.home.sops-nix.plist
          '';

        linux =
          let
            systemctl = config.systemd.user.systemctlPath;
          in
          ''
            systemdStatus=$(${systemctl} --user is-system-running 2>&1 || true)

            if [[ $systemdStatus == 'running' || $systemdStatus == 'degraded' ]]; then
              ${systemctl} restart --user sops-nix
            else
              echo "User systemd daemon not running. Probably executed on boot where no manual start/reload is needed."
            fi

            unset systemdStatus
          '';

      in
      {
        sops-nix = if pkgs.stdenv.isLinux then linux else darwin;
      };
  };
}
</file>

<file path="modules/home-manager/templates.nix">
{
  config,
  pkgs,
  lib,
  options,
  ...
}:
let
  inherit (lib)
    mkOption
    mkDefault
    mapAttrs
    types
    ;

  hmConfig = config;
in
{
  options.sops = {
    templates = mkOption {
      description = "Templates for secret files";
      type = types.attrsOf (
        types.submodule (
          { config, ... }:
          {
            options = {
              name = mkOption {
                type = types.singleLineStr;
                default = config._module.args.name;
                description = ''
                  Name of the file used in /run/secrets/rendered
                '';
              };
              path = mkOption {
                description = "Path where the rendered file will be placed";
                type = types.singleLineStr;
                # Keep this in sync with `RenderedSubdir` in `pkgs/sops-install-secrets/main.go`
                default = "${hmConfig.xdg.configHome}/sops-nix/secrets/rendered/${config.name}";
              };
              content = mkOption {
                type = types.lines;
                default = "";
                description = ''
                  Content of the file
                '';
              };
              mode = mkOption {
                type = types.singleLineStr;
                default = "0400";
                description = ''
                  Permissions mode of the rendered secret file in octal.
                '';
              };
              file = mkOption {
                type = types.path;
                default = pkgs.writeText config.name config.content;
                defaultText = lib.literalExpression ''pkgs.writeText config.name config.content'';
                example = "./configuration-template.conf";
                description = ''
                  File used as the template. When this value is specified, `sops.templates.<name>.content` is ignored.
                '';
              };
            };
          }
        )
      );
      default = { };
    };
    placeholder = mkOption {
      type = types.attrsOf (
        types.mkOptionType {
          name = "coercibleToString";
          description = "value that can be coerced to string";
          check = lib.strings.isConvertibleWithToString;
          merge = lib.mergeEqualOption;
        }
      );
      default = { };
      visible = false;
    };
  };

  config = lib.optionalAttrs (options ? sops.secrets) (
    lib.mkIf (hmConfig.sops.templates != { }) {
      sops.placeholder = mapAttrs (
        name: _: mkDefault "<SOPS:${builtins.hashString "sha256" name}:PLACEHOLDER>"
      ) hmConfig.sops.secrets;
    }
  );
}
</file>

<file path="modules/nix-darwin/secrets-for-users/default.nix">
{
  lib,
  config,
  pkgs,
  ...
}:
let
  cfg = config.sops;
  secretsForUsers = lib.filterAttrs (_: v: v.neededForUsers) cfg.secrets;
  templatesForUsers = { }; # We do not currently support `neededForUsers` for templates.
  manifestFor = pkgs.callPackage ../manifest-for.nix {
    inherit cfg;
    inherit (pkgs) writeTextFile;
  };
  withEnvironment = import ../with-environment.nix {
    inherit cfg lib;
  };
  manifestForUsers = manifestFor "-for-users" secretsForUsers templatesForUsers {
    secretsMountPoint = "/run/secrets-for-users.d";
    symlinkPath = "/run/secrets-for-users";
  };

  installScript = ''
    echo "Setting up secrets for users"
    ${withEnvironment "${cfg.package}/bin/sops-install-secrets -ignore-passwd ${manifestForUsers}"}
  '';
in
{

  assertions = [
    {
      assertion =
        (lib.filterAttrs (
          _: v: (v.uid != 0 && v.owner != "root") || (v.gid != 0 && v.group != "root")
        ) secretsForUsers) == { };
      message = "neededForUsers cannot be used for secrets that are not root-owned";
    }
  ];

  system.activationScripts = lib.mkIf (secretsForUsers != { }) {
    postActivation.text = lib.mkAfter installScript;
  };

  launchd.daemons.sops-install-secrets-for-users = lib.mkIf (secretsForUsers != { }) {
    command = "sh -c ${lib.escapeShellArg installScript}";
    serviceConfig = {
      RunAtLoad = true;
      KeepAlive = false;
    };
  };

  system.build.sops-nix-users-manifest = manifestForUsers;
}
</file>

<file path="modules/nix-darwin/templates/default.nix">
{
  config,
  pkgs,
  lib,
  options,
  ...
}:
let
  inherit (lib)
    mkOption
    mkDefault
    mapAttrs
    types
    ;
in
{
  options.sops = {
    templates = mkOption {
      description = "Templates for secret files";
      type = types.attrsOf (
        types.submodule (
          { config, ... }:
          {
            options = {
              name = mkOption {
                type = types.singleLineStr;
                default = config._module.args.name;
                description = ''
                  Name of the file used in /run/secrets/rendered
                '';
              };
              path = mkOption {
                description = "Path where the rendered file will be placed";
                type = types.singleLineStr;
                default = "/run/secrets/rendered/${config.name}";
              };
              content = mkOption {
                type = types.lines;
                default = "";
                description = ''
                  Content of the file
                '';
              };
              mode = mkOption {
                type = types.singleLineStr;
                default = "0400";
                description = ''
                  Permissions mode of the rendered secret file in octal.
                '';
              };
              owner = mkOption {
                type = with lib.types; nullOr singleLineStr;
                default = null;
                description = ''
                  User of the file. Can only be set if uid is 0;
                '';
              };
              uid = mkOption {
                type = with lib.types; nullOr int;
                default = 0;
                description = ''
                  UID of the template, only applied with owner is null. the UID will be applied even if the corresponding user doesn't exist.
                '';
              };
              group = mkOption {
                type = with lib.types; nullOr singleLineStr;
                default = if config.owner != null then "staff" else null;
                defaultText = "staff";
                description = ''
                  Group of the file. Can only be set if gid is 0. Default on darwin to 'staff'
                '';
              };
              gid = mkOption {
                type = with lib.types; nullOr int;
                default = 0;
                description = ''
                  GID of the template, only applied when group is null. The GID will be applied even if the corresponding group doesn't exist.
                '';
              };
              file = mkOption {
                type = types.path;
                default = pkgs.writeText config.name config.content;
                defaultText = lib.literalExpression ''pkgs.writeText config.name config.content'';
                example = "./configuration-template.conf";
                description = ''
                  File used as the template. When this value is specified, `sops.templates.<name>.content` is ignored.
                '';
              };
            };
          }
        )
      );
      default = { };
    };
    placeholder = mkOption {
      type = types.attrsOf (
        types.mkOptionType {
          name = "coercibleToString";
          description = "value that can be coerced to string";
          check = lib.strings.isConvertibleWithToString;
          merge = lib.mergeEqualOption;
        }
      );
      default = { };
      visible = false;
    };
  };

  config = lib.optionalAttrs (options ? sops.secrets) (
    lib.mkIf (config.sops.templates != { }) {
      sops.placeholder = mapAttrs (
        name: _: mkDefault "<SOPS:${builtins.hashString "sha256" name}:PLACEHOLDER>"
      ) config.sops.secrets;

      assertions =
        lib.mapAttrsToList (name: cfg: {
          assertion = !(cfg.owner != null && cfg.uid != 0);
          message = ''
            Assertion failed for `sops.templates.${name}`:
            Both `owner` and `uid` cannot be defined at the same time. Use either `owner` or leave `uid` as 0.
            owner: ${cfg.owner}
            uid: ${toString cfg.uid}
          '';
        }) config.sops.templates
        ++ lib.mapAttrsToList (name: cfg: {
          assertion = !(cfg.group != null && cfg.gid != 0);
          message = ''
            Assertion failed for `sops.templates.${name}`:
            Both `group` and `gid` cannot be defined at the same time. Use either `group` or leave `gid` as 0.
            owner: ${cfg.group}
            uid: ${toString cfg.gid}
          '';
        }) config.sops.templates;
    }
  );
}
</file>

<file path="modules/nix-darwin/default.nix">
{
  config,
  lib,
  pkgs,
  ...
}:

let
  cfg = config.sops;
  sops-install-secrets = cfg.package;
  manifestFor = pkgs.callPackage ./manifest-for.nix {
    inherit cfg;
    inherit (pkgs) writeTextFile;
  };
  manifest = manifestFor "" regularSecrets regularTemplates { };

  # Currently, all templates are "regular" (there's no support for `neededForUsers` for templates.)
  regularTemplates = cfg.templates;

  pathNotInStore = lib.mkOptionType {
    name = "pathNotInStore";
    description = "path not in the Nix store";
    descriptionClass = "noun";
    check = x: !lib.path.hasStorePathPrefix (/. + x);
    merge = lib.mergeEqualOption;
  };

  regularSecrets = lib.filterAttrs (_: v: !v.neededForUsers) cfg.secrets;

  withEnvironment = import ./with-environment.nix {
    inherit cfg lib;
  };
  secretType = lib.types.submodule (
    { config, ... }:
    {
      config = {
        sopsFile = lib.mkOptionDefault cfg.defaultSopsFile;
        sopsFileHash = lib.mkOptionDefault (
          lib.optionalString cfg.validateSopsFiles "${builtins.hashFile "sha256" config.sopsFile}"
        );
      };
      options = {
        name = lib.mkOption {
          type = lib.types.str;
          default = config._module.args.name;
          description = ''
            Name of the file used in /run/secrets
          '';
        };
        key = lib.mkOption {
          type = lib.types.str;
          default = config._module.args.name;
          description = ''
            Key used to lookup in the sops file.
            No tested data structures are supported right now.
            This option is ignored if format is binary.
          '';
        };
        path = lib.mkOption {
          type = lib.types.str;
          default =
            if config.neededForUsers then
              "/run/secrets-for-users/${config.name}"
            else
              "/run/secrets/${config.name}";
          defaultText = "/run/secrets-for-users/$name when neededForUsers is set, /run/secrets/$name when otherwise.";
          description = ''
            Path where secrets are symlinked to.
            If the default is kept no symlink is created.
          '';
        };
        format = lib.mkOption {
          type = lib.types.enum [
            "yaml"
            "json"
            "binary"
            "dotenv"
            "ini"
          ];
          default = cfg.defaultSopsFormat;
          description = ''
            File format used to decrypt the sops secret.
            Binary files are written to the target file as is.
          '';
        };
        mode = lib.mkOption {
          type = lib.types.str;
          default = "0400";
          description = ''
            Permissions mode of the in octal.
          '';
        };
        owner = lib.mkOption {
          type = with lib.types; nullOr str;
          default = "root";
          description = ''
            User of the file. Can only be set if uid is 0.
          '';
        };
        uid = lib.mkOption {
          type = with lib.types; nullOr int;
          default = 0;
          description = ''
            UID of the file, only applied when owner is null. The UID will be applied even if the corresponding user doesn't exist.
          '';
        };
        group = lib.mkOption {
          type = with lib.types; nullOr str;
          default = "staff";
          defaultText = "staff";
          description = ''
            Group of the file. Can only be set if gid is 0.
          '';
        };
        gid = lib.mkOption {
          type = with lib.types; nullOr int;
          default = 0;
          description = ''
            GID of the file, only applied when group is null. The GID will be applied even if the corresponding group doesn't exist.
          '';
        };
        sopsFile = lib.mkOption {
          type = lib.types.path;
          defaultText = lib.literalExpression "\${config.sops.defaultSopsFile}";
          description = ''
            Sops file the secret is loaded from.
          '';
        };
        sopsFileHash = lib.mkOption {
          type = lib.types.str;
          readOnly = true;
          description = ''
            Hash of the sops file.
          '';
        };
        neededForUsers = lib.mkOption {
          type = lib.types.bool;
          default = false;
          description = ''
             **Warning** This option doesn't have any effect on macOS, as nix-darwin cannot manage user passwords on macOS.
            This can be used to retrieve user's passwords from sops-nix.
            Setting this option moves the secret to /run/secrets-for-users and disallows setting owner and group to anything else than root.
          '';
        };
      };
    }
  );

  darwinSSHKeys = [
    {
      type = "rsa";
      path = "/etc/ssh/ssh_host_rsa_key";
    }
    {
      type = "ed25519";
      path = "/etc/ssh/ssh_host_ed25519_key";
    }
  ];

  escapedKeyFile = lib.escapeShellArg cfg.age.keyFile;
  # Skip ssh keys deployed with sops to avoid a catch 22
  defaultImportKeys =
    algo:
    map (e: e.path) (
      lib.filter (e: e.type == algo && !(lib.hasPrefix "/run/secrets" e.path)) darwinSSHKeys
    );

  installScript = ''
    ${
      if cfg.age.generateKey then
        ''
          if [[ ! -f ${escapedKeyFile} ]]; then
            echo generating machine-specific age key...
            mkdir -p "$(dirname ${escapedKeyFile})"
            # age-keygen sets 0600 by default, no need to chmod.
            ${pkgs.age}/bin/age-keygen -o ${escapedKeyFile}
          fi
        ''
      else
        ""
    }
    echo "Setting up secrets..."
    ${withEnvironment "${sops-install-secrets}/bin/sops-install-secrets ${manifest}"}
  '';

in
{
  options.sops = {
    secrets = lib.mkOption {
      type = lib.types.attrsOf secretType;
      default = { };
      description = ''
        Path where the latest secrets are mounted to.
      '';
    };

    defaultSopsFile = lib.mkOption {
      type = lib.types.path;
      description = ''
        Default sops file used for all secrets.
      '';
    };

    defaultSopsFormat = lib.mkOption {
      type = lib.types.str;
      default = "yaml";
      description = ''
        Default sops format used for all secrets.
      '';
    };

    validateSopsFiles = lib.mkOption {
      type = lib.types.bool;
      default = true;
      description = ''
        Check all sops files at evaluation time.
        This requires sops files to be added to the nix store.
      '';
    };

    keepGenerations = lib.mkOption {
      type = lib.types.ints.unsigned;
      default = 1;
      description = ''
        Number of secrets generations to keep. Setting this to 0 disables pruning.
      '';
    };

    log = lib.mkOption {
      type = lib.types.listOf (
        lib.types.enum [
          "keyImport"
          "secretChanges"
        ]
      );
      default = [
        "keyImport"
        "secretChanges"
      ];
      description = "What to log";
    };

    environment = lib.mkOption {
      type = lib.types.attrsOf (lib.types.either lib.types.str lib.types.path);
      default = { };
      description = ''
        Environment variables to set before calling sops-install-secrets.

        The values are placed in single quotes and not escaped any further to
        allow usage of command substitutions for more flexibility. To properly quote
        strings with quotes use lib.escapeShellArg.

        This will be evaluated twice when using secrets that use neededForUsers but
        in a subshell each time so the environment variables don't collide.
      '';
    };

    package = lib.mkOption {
      type = lib.types.package;
      default = (pkgs.callPackage ../.. { }).sops-install-secrets;
      defaultText = lib.literalExpression "(pkgs.callPackage ../.. {}).sops-install-secrets";
      description = ''
        sops-install-secrets package to use.
      '';
    };

    validationPackage = lib.mkOption {
      type = lib.types.package;
      default =
        if pkgs.stdenv.buildPlatform == pkgs.stdenv.hostPlatform then
          sops-install-secrets
        else
          (pkgs.pkgsBuildHost.callPackage ../.. { }).sops-install-secrets;
      defaultText = lib.literalExpression "config.sops.package";

      description = ''
        sops-install-secrets package to use when validating configuration.

        Defaults to sops.package if building natively, and a native version of sops-install-secrets if cross compiling.
      '';
    };

    age = {
      keyFile = lib.mkOption {
        type = lib.types.nullOr pathNotInStore;
        default = null;
        example = "/var/lib/sops-nix/key.txt";
        description = ''
          Path to age key file used for sops decryption.
        '';
      };

      generateKey = lib.mkOption {
        type = lib.types.bool;
        default = false;
        description = ''
          Whether or not to generate the age key. If this
          option is set to false, the key must already be
          present at the specified location.
        '';
      };

      sshKeyPaths = lib.mkOption {
        type = lib.types.listOf lib.types.path;
        default = defaultImportKeys "ed25519";
        defaultText = lib.literalMD "The ed25519 keys from {option}`config.services.openssh.hostKeys`";
        description = ''
          Paths to ssh keys added as age keys during sops description.
        '';
      };
    };

    gnupg = {
      home = lib.mkOption {
        type = lib.types.nullOr lib.types.str;
        default = null;
        example = "/root/.gnupg";
        description = ''
          Path to gnupg database directory containing the key for decrypting the sops file.
        '';
      };

      sshKeyPaths = lib.mkOption {
        type = lib.types.listOf lib.types.path;
        default = defaultImportKeys "rsa";
        defaultText = lib.literalMD "The rsa keys from {option}`config.services.openssh.hostKeys`";
        description = ''
          Path to ssh keys added as GPG keys during sops description.
          This option must be explicitly unset if <literal>config.sops.gnupg.home</literal> is set.
        '';
      };
    };
  };
  imports = [
    ./templates
    ./secrets-for-users
  ];

  config = lib.mkMerge [
    (lib.mkIf (cfg.secrets != { }) {
      assertions =
        [
          {
            assertion =
              cfg.gnupg.home != null
              || cfg.gnupg.sshKeyPaths != [ ]
              || cfg.age.keyFile != null
              || cfg.age.sshKeyPaths != [ ];
            message = "No key source configured for sops. Either set services.openssh.enable or set sops.age.keyFile or sops.gnupg.home";
          }
          {
            assertion = !(cfg.gnupg.home != null && cfg.gnupg.sshKeyPaths != [ ]);
            message = "Exactly one of sops.gnupg.home and sops.gnupg.sshKeyPaths must be set";
          }
        ]
        ++ lib.optionals cfg.validateSopsFiles (
          lib.concatLists (
            lib.mapAttrsToList (name: secret: [
              {
                assertion = secret.uid != null && secret.uid != 0 -> secret.owner == null;
                message = "In ${secret.name} exactly one of sops.owner and sops.uid must be set";
              }
              {
                assertion = secret.gid != null && secret.gid != 0 -> secret.group == null;
                message = "In ${secret.name} exactly one of sops.group and sops.gid must be set";
              }
            ]) cfg.secrets
          )
        );

      system.build.sops-nix-manifest = manifest;
      system.activationScripts = {
        postActivation.text = lib.mkAfter installScript;
      };

      launchd.daemons.sops-install-secrets = {
        command = "sh -c ${lib.escapeShellArg installScript}";
        serviceConfig = {
          RunAtLoad = true;
          KeepAlive = false;
        };
      };
    })

    {
      sops.environment.SOPS_GPG_EXEC = lib.mkIf (cfg.gnupg.home != null || cfg.gnupg.sshKeyPaths != [ ]) (
        lib.mkDefault "${pkgs.gnupg}/bin/gpg"
      );
    }
  ];
}
</file>

<file path="modules/nix-darwin/manifest-for.nix">
{ writeTextFile, cfg }:

suffix: secrets: templates: extraJson:

writeTextFile {
  name = "manifest${suffix}.json";
  text = builtins.toJSON (
    {
      secrets = builtins.attrValues secrets;
      templates = builtins.attrValues templates;
      # Does this need to be configurable?
      secretsMountPoint = "/run/secrets.d";
      symlinkPath = "/run/secrets";
      keepGenerations = cfg.keepGenerations;
      gnupgHome = cfg.gnupg.home;
      sshKeyPaths = cfg.gnupg.sshKeyPaths;
      ageKeyFile = cfg.age.keyFile;
      ageSshKeyPaths = cfg.age.sshKeyPaths;
      useTmpfs = false;
      placeholderBySecretName = cfg.placeholder;
      userMode = false;
      logging = {
        keyImport = builtins.elem "keyImport" cfg.log;
        secretChanges = builtins.elem "secretChanges" cfg.log;
      };
    }
    // extraJson
  );
  checkPhase = ''
    ${cfg.validationPackage}/bin/sops-install-secrets -check-mode=${
      if cfg.validateSopsFiles then "sopsfile" else "manifest"
    } "$out"
  '';
}
</file>

<file path="modules/nix-darwin/with-environment.nix">
{ cfg, lib }:

sopsCall:

if cfg.environment == { } then
  sopsCall
else
  ''
    (
    # shellcheck disable=SC2030,SC2031
    ${lib.concatStringsSep "\n" (lib.mapAttrsToList (n: v: "  export ${n}='${v}'") cfg.environment)}
      ${sopsCall}
    )
  ''
</file>

<file path="modules/sops/secrets-for-users/default.nix">
{
  lib,
  options,
  config,
  pkgs,
  ...
}:
let
  cfg = config.sops;
  secretsForUsers = lib.filterAttrs (_: v: v.neededForUsers) cfg.secrets;
  templatesForUsers = { }; # We do not currently support `neededForUsers` for templates.
  manifestFor = pkgs.callPackage ../manifest-for.nix {
    inherit cfg;
    inherit (pkgs) writeTextFile;
  };
  withEnvironment = import ../with-environment.nix {
    # See also the default NixOS module.
    cfg = lib.recursiveUpdate cfg {
      environment.HOME = "/var/empty";
    };
    inherit lib;
  };
  manifestForUsers = manifestFor "-for-users" secretsForUsers templatesForUsers {
    secretsMountPoint = "/run/secrets-for-users.d";
    symlinkPath = "/run/secrets-for-users";
  };
  sysusersEnabled = options.systemd ? sysusers && config.systemd.sysusers.enable;
  useSystemdActivation =
    sysusersEnabled || (options.services ? userborn && config.services.userborn.enable);
in
{
  systemd.services.sops-install-secrets-for-users =
    lib.mkIf (secretsForUsers != { } && useSystemdActivation)
      {
        wantedBy = [ "systemd-sysusers.service" ];
        before = [ "systemd-sysusers.service" ];
        environment = cfg.environment;
        unitConfig.DefaultDependencies = "no";

        serviceConfig = {
          Type = "oneshot";
          ExecStart = [ "${cfg.package}/bin/sops-install-secrets -ignore-passwd ${manifestForUsers}" ];
          RemainAfterExit = true;
        };
      };

  system.activationScripts = lib.mkIf (secretsForUsers != { } && !useSystemdActivation) {
    setupSecretsForUsers =
      lib.stringAfter ([ "specialfs" ] ++ lib.optional cfg.age.generateKey "generate-age-key") ''
        [ -e /run/current-system ] || echo setting up secrets for users...
        ${withEnvironment "${cfg.package}/bin/sops-install-secrets -ignore-passwd ${manifestForUsers}"}
      ''
      // lib.optionalAttrs (config.system ? dryActivationScript) {
        supportsDryActivation = true;
      };

    users.deps = [ "setupSecretsForUsers" ];
  };

  assertions = [
    {
      assertion =
        (lib.filterAttrs (
          _: v: (v.uid != 0 && v.owner != "root") || (v.gid != 0 && v.group != "root")
        ) secretsForUsers) == { };
      message = "neededForUsers cannot be used for secrets that are not root-owned";
    }
    {
      assertion = secretsForUsers != { } && sysusersEnabled -> config.users.mutableUsers;
      message = ''
        systemd.sysusers.enable in combination with sops.secrets.<name>.neededForUsers can only work with config.users.mutableUsers enabled.
        See https://github.com/Mic92/sops-nix/issues/475
      '';
    }
  ];

  system.build.sops-nix-users-manifest = manifestForUsers;
}
</file>

<file path="modules/sops/templates/default.nix">
{
  config,
  pkgs,
  lib,
  options,
  ...
}:
let
  inherit (lib)
    mkOption
    mkDefault
    mapAttrs
    types
    ;

  users = config.users.users;
in
{
  options.sops = {
    templates = mkOption {
      description = "Templates for secret files";
      type = types.attrsOf (
        types.submodule (
          { config, ... }:
          {
            options = {
              name = mkOption {
                type = types.singleLineStr;
                default = config._module.args.name;
                description = ''
                  Name of the file used in /run/secrets/rendered
                '';
              };
              path = mkOption {
                description = "Path where the rendered file will be placed";
                type = types.singleLineStr;
                # Keep this in sync with `RenderedSubdir` in `pkgs/sops-install-secrets/main.go`
                default = "/run/secrets/rendered/${config.name}";
              };
              content = mkOption {
                type = types.lines;
                default = "";
                description = ''
                  Content of the file
                '';
              };
              mode = mkOption {
                type = types.singleLineStr;
                default = "0400";
                description = ''
                  Permissions mode of the rendered secret file in octal.
                '';
              };
              owner = mkOption {
                type = with lib.types; nullOr singleLineStr;
                default = null;
                description = ''
                  User of the file. Can only be set if uid is 0;
                '';
              };
              uid = mkOption {
                type = with lib.types; nullOr int;
                default = 0;
                description = ''
                  UID of the template, only applied with owner is null. the UID will be applied even if the corresponding user doesn't exist.
                '';
              };
              group = mkOption {
                type = with lib.types; nullOr singleLineStr;
                default = if config.owner != null then users.${config.owner}.group else null;
                defaultText = lib.literalExpression ''config.users.users.''${cfg.owner}.group'';
                description = ''
                  Group of the file. Can only be set if gid is 0.
                '';
              };
              gid = mkOption {
                type = with lib.types; nullOr int;
                default = 0;
                description = ''
                  GID of the template, only applied when group is null. The GID will be applied even if the corresponding group doesn't exist.
                '';
              };
              file = mkOption {
                type = types.path;
                default = pkgs.writeText config.name config.content;
                defaultText = lib.literalExpression ''pkgs.writeText config.name config.content'';
                example = "./configuration-template.conf";
                description = ''
                  File used as the template. When this value is specified, `sops.templates.<name>.content` is ignored.
                '';
              };
              restartUnits = lib.mkOption {
                type = lib.types.listOf lib.types.str;
                default = [ ];
                example = [ "sshd.service" ];
                description = ''
                  Names of units that should be restarted when the rendered template changes.
                  This works the same way as <xref linkend="opt-systemd.services._name_.restartTriggers" />.
                '';
              };
              reloadUnits = lib.mkOption {
                type = lib.types.listOf lib.types.str;
                default = [ ];
                example = [ "sshd.service" ];
                description = ''
                  Names of units that should be reloaded when the rendered template changes.
                  This works the same way as <xref linkend="opt-systemd.services._name_.reloadTriggers" />.
                '';
              };
            };
          }
        )
      );
      default = { };
    };
    placeholder = mkOption {
      type = types.attrsOf (
        types.mkOptionType {
          name = "coercibleToString";
          description = "value that can be coerced to string";
          check = lib.strings.isConvertibleWithToString;
          merge = lib.mergeEqualOption;
        }
      );
      default = { };
      visible = false;
    };
  };

  config = lib.optionalAttrs (options ? sops.secrets) (
    lib.mkIf (config.sops.templates != { }) {
      sops.placeholder = mapAttrs (
        name: _: mkDefault "<SOPS:${builtins.hashString "sha256" name}:PLACEHOLDER>"
      ) config.sops.secrets;

      assertions =
        lib.mapAttrsToList (name: cfg: {
          assertion = !(cfg.owner != null && cfg.uid != 0);
          message = ''
            Assertion failed for `sops.templates.${name}`:
            Both `owner` and `uid` cannot be defined at the same time. Use either `owner` or leave `uid` as 0.
            owner: ${cfg.owner}
            uid: ${toString cfg.uid}
          '';
        }) config.sops.templates
        ++ lib.mapAttrsToList (name: cfg: {
          assertion = !(cfg.group != null && cfg.gid != 0);
          message = ''
            Assertion failed for `sops.templates.${name}`:
            Both `group` and `gid` cannot be defined at the same time. Use either `group` or leave `gid` as 0.
            owner: ${cfg.group}
            uid: ${toString cfg.gid}
          '';
        }) config.sops.templates;
    }
  );
}
</file>

<file path="modules/sops/default.nix">
{
  config,
  options,
  lib,
  pkgs,
  ...
}:

let
  cfg = config.sops;
  users = config.users.users;
  sops-install-secrets = cfg.package;
  manifestFor = pkgs.callPackage ./manifest-for.nix {
    inherit cfg;
    inherit (pkgs) writeTextFile;
  };
  manifest = manifestFor "" regularSecrets regularTemplates { };

  pathNotInStore = lib.mkOptionType {
    name = "pathNotInStore";
    description = "path not in the Nix store";
    descriptionClass = "noun";
    check = x: !lib.path.hasStorePathPrefix (/. + x);
    merge = lib.mergeEqualOption;
  };

  regularSecrets = lib.filterAttrs (_: v: !v.neededForUsers) cfg.secrets;

  # Currently, all templates are "regular" (there's no support for `neededForUsers` for templates.)
  regularTemplates = cfg.templates;

  useSystemdActivation =
    (options.systemd ? sysusers && config.systemd.sysusers.enable)
    || (options.services ? userborn && config.services.userborn.enable);

  withEnvironment = import ./with-environment.nix {
    # sops >=3.10.0 now unconditionally searches 
    # for an SSH key in $HOME/.ssh/, introduced in #1692 [0]. Since in the
    # activation script $HOME is never set, it just spits out a slew a
    # warnings [1].
    #
    # [0] https://github.com/Mic92/sops-nix/issues/764
    # [1] https://github.com/getsops/sops/pull/1692
    cfg = lib.recursiveUpdate cfg {
      environment.HOME = "/var/empty";
    };
    inherit lib;
  };
  secretType = lib.types.submodule (
    { config, ... }:
    {
      config = {
        sopsFile = lib.mkOptionDefault cfg.defaultSopsFile;
        sopsFileHash = lib.mkOptionDefault (
          lib.optionalString cfg.validateSopsFiles "${builtins.hashFile "sha256" config.sopsFile}"
        );
      };
      options = {
        name = lib.mkOption {
          type = lib.types.str;
          default = config._module.args.name;
          description = ''
            Name of the file used in /run/secrets
          '';
        };
        key = lib.mkOption {
          type = lib.types.str;
          default = if cfg.defaultSopsKey != null then cfg.defaultSopsKey else config._module.args.name;
          description = ''
            Key used to lookup in the sops file.
            No tested data structures are supported right now.
            This option is ignored if format is binary.
            "" means whole file.
          '';
        };
        path = lib.mkOption {
          type = lib.types.str;
          default =
            if config.neededForUsers then
              "/run/secrets-for-users/${config.name}"
            else
              "/run/secrets/${config.name}";
          defaultText = "/run/secrets-for-users/$name when neededForUsers is set, /run/secrets/$name when otherwise.";
          description = ''
            Path where secrets are symlinked to.
            If the default is kept no symlink is created.
          '';
        };
        format = lib.mkOption {
          type = lib.types.enum [
            "yaml"
            "json"
            "binary"
            "dotenv"
            "ini"
          ];
          default = cfg.defaultSopsFormat;
          description = ''
            File format used to decrypt the sops secret.
            Binary files are written to the target file as is.
          '';
        };
        mode = lib.mkOption {
          type = lib.types.str;
          default = "0400";
          description = ''
            Permissions mode of the in octal.
          '';
        };
        owner = lib.mkOption {
          type = with lib.types; nullOr str;
          default = null;
          description = ''
            User of the file. Can only be set if uid is 0.
          '';
        };
        uid = lib.mkOption {
          type = with lib.types; nullOr int;
          default = 0;
          description = ''
            UID of the file, only applied when owner is null. The UID will be applied even if the corresponding user doesn't exist.
          '';
        };
        group = lib.mkOption {
          type = with lib.types; nullOr str;
          default = if config.owner != null then users.${config.owner}.group else null;
          defaultText = lib.literalMD "{option}`config.users.users.\${owner}.group`";
          description = ''
            Group of the file. Can only be set if gid is 0.
          '';
        };
        gid = lib.mkOption {
          type = with lib.types; nullOr int;
          default = 0;
          description = ''
            GID of the file, only applied when group is null. The GID will be applied even if the corresponding group doesn't exist.
          '';
        };
        sopsFile = lib.mkOption {
          type = lib.types.path;
          defaultText = lib.literalExpression "\${config.sops.defaultSopsFile}";
          description = ''
            Sops file the secret is loaded from.
          '';
        };
        sopsFileHash = lib.mkOption {
          type = lib.types.str;
          readOnly = true;
          description = ''
            Hash of the sops file, useful in <xref linkend="opt-systemd.services._name_.restartTriggers" />.
          '';
        };
        restartUnits = lib.mkOption {
          type = lib.types.listOf lib.types.str;
          default = [ ];
          example = [ "sshd.service" ];
          description = ''
            Names of units that should be restarted when this secret changes.
            This works the same way as <xref linkend="opt-systemd.services._name_.restartTriggers" />.
          '';
        };
        reloadUnits = lib.mkOption {
          type = lib.types.listOf lib.types.str;
          default = [ ];
          example = [ "sshd.service" ];
          description = ''
            Names of units that should be reloaded when this secret changes.
            This works the same way as <xref linkend="opt-systemd.services._name_.reloadTriggers" />.
          '';
        };
        neededForUsers = lib.mkOption {
          type = lib.types.bool;
          default = false;
          description = ''
            Enabling this option causes the secret to be decrypted before users and groups are created.
            This can be used to retrieve user's passwords from sops-nix.
            Setting this option moves the secret to /run/secrets-for-users and disallows setting owner and group to anything else than root.
          '';
        };
      };
    }
  );

  # Skip ssh keys deployed with sops to avoid a catch 22
  defaultImportKeys =
    algo:
    if config.services.openssh.enable then
      map (e: e.path) (
        lib.filter (
          e: e.type == algo && !(lib.hasPrefix "/run/secrets" e.path)
        ) config.services.openssh.hostKeys
      )
    else
      [ ];
in
{
  options.sops = {
    secrets = lib.mkOption {
      type = lib.types.attrsOf secretType;
      default = { };
      description = ''
        Path where the latest secrets are mounted to.
      '';
    };

    defaultSopsFile = lib.mkOption {
      type = lib.types.path;
      description = ''
        Default sops file used for all secrets.
      '';
    };

    defaultSopsFormat = lib.mkOption {
      type = lib.types.str;
      default = "yaml";
      description = ''
        Default sops format used for all secrets.
      '';
    };

    defaultSopsKey = lib.mkOption {
      type = lib.types.nullOr lib.types.str;
      default = null;
      description = ''
        Default key used to lookup in all secrets.
        This option is ignored if format is binary.
        "" means whole file.
      '';
    };

    validateSopsFiles = lib.mkOption {
      type = lib.types.bool;
      default = true;
      description = ''
        Check all sops files at evaluation time.
        This requires sops files to be added to the nix store.
      '';
    };

    keepGenerations = lib.mkOption {
      type = lib.types.ints.unsigned;
      default = 1;
      description = ''
        Number of secrets generations to keep. Setting this to 0 disables pruning.
      '';
    };

    log = lib.mkOption {
      type = lib.types.listOf (
        lib.types.enum [
          "keyImport"
          "secretChanges"
        ]
      );
      default = [
        "keyImport"
        "secretChanges"
      ];
      description = "What to log";
    };

    environment = lib.mkOption {
      type = lib.types.attrsOf (lib.types.either lib.types.str lib.types.path);
      default = { };
      description = ''
        Environment variables to set before calling sops-install-secrets.

        The values are placed in single quotes and not escaped any further to
        allow usage of command substitutions for more flexibility. To properly quote
        strings with quotes use lib.escapeShellArg.

        This will be evaluated twice when using secrets that use neededForUsers but
        in a subshell each time so the environment variables don't collide.
      '';
    };

    package = lib.mkOption {
      type = lib.types.package;
      default = (pkgs.callPackage ../.. { }).sops-install-secrets;
      defaultText = lib.literalExpression "(pkgs.callPackage ../.. {}).sops-install-secrets";
      description = ''
        sops-install-secrets package to use.
      '';
    };

    validationPackage = lib.mkOption {
      type = lib.types.package;
      default =
        if pkgs.stdenv.buildPlatform == pkgs.stdenv.hostPlatform then
          sops-install-secrets
        else
          (pkgs.pkgsBuildHost.callPackage ../.. { }).sops-install-secrets;
      defaultText = lib.literalExpression "config.sops.package";

      description = ''
        sops-install-secrets package to use when validating configuration.

        Defaults to sops.package if building natively, and a native version of sops-install-secrets if cross compiling.
      '';
    };

    useTmpfs = lib.mkOption {
      type = lib.types.bool;
      default = false;
      description = ''
        Use tmpfs in place of ramfs for secrets storage.

        *WARNING*
        On Linux kernels earlier than 6.4, enabling this option has the potential to write secrets to disk unencrypted if the tmpfs volume is written to swap. Do not use unless absolutely necessary.

        When using a swap file or device, consider enabling swap encryption by setting the `randomEncryption.enable` option

        ```
        swapDevices = [{
          device = "/dev/sdXY";
          randomEncryption.enable = true;
        }];
        ```
      '';
    };

    age = {
      keyFile = lib.mkOption {
        type = lib.types.nullOr pathNotInStore;
        default = null;
        example = "/var/lib/sops-nix/key.txt";
        description = ''
          Path to age key file used for sops decryption.
        '';
      };

      generateKey = lib.mkOption {
        type = lib.types.bool;
        default = false;
        description = ''
          Whether or not to generate the age key. If this
          option is set to false, the key must already be
          present at the specified location.
        '';
      };

      sshKeyPaths = lib.mkOption {
        type = lib.types.listOf lib.types.path;
        default = defaultImportKeys "ed25519";
        defaultText = lib.literalMD "The ed25519 keys from {option}`config.services.openssh.hostKeys`";
        description = ''
          Paths to ssh keys added as age keys during sops description.
        '';
      };
    };

    gnupg = {
      home = lib.mkOption {
        type = lib.types.nullOr lib.types.str;
        default = null;
        example = "/root/.gnupg";
        description = ''
          Path to gnupg database directory containing the key for decrypting the sops file.
        '';
      };

      sshKeyPaths = lib.mkOption {
        type = lib.types.listOf lib.types.path;
        default = defaultImportKeys "rsa";
        defaultText = lib.literalMD "The rsa keys from {option}`config.services.openssh.hostKeys`";
        description = ''
          Path to ssh keys added as GPG keys during sops description.
          This option must be explicitly unset if <literal>config.sops.gnupg.home</literal> is set.
        '';
      };
    };
  };
  imports = [
    ./templates
    ./secrets-for-users
    (lib.mkRenamedOptionModule
      [
        "sops"
        "gnupgHome"
      ]
      [
        "sops"
        "gnupg"
        "home"
      ]
    )
    (lib.mkRenamedOptionModule
      [
        "sops"
        "sshKeyPaths"
      ]
      [
        "sops"
        "gnupg"
        "sshKeyPaths"
      ]
    )
  ];
  config = lib.mkMerge [
    (lib.mkIf (cfg.secrets != { }) {
      assertions =
        [
          {
            assertion =
              cfg.gnupg.home != null
              || cfg.gnupg.sshKeyPaths != [ ]
              || cfg.age.keyFile != null
              || cfg.age.sshKeyPaths != [ ];
            message = "No key source configured for sops. Either set services.openssh.enable or set sops.age.keyFile or sops.gnupg.home";
          }
          {
            assertion = !(cfg.gnupg.home != null && cfg.gnupg.sshKeyPaths != [ ]);
            message = "Exactly one of sops.gnupg.home and sops.gnupg.sshKeyPaths must be set";
          }
        ]
        ++ lib.optionals cfg.validateSopsFiles (
          lib.concatLists (
            lib.mapAttrsToList (name: secret: [
              {
                assertion = secret.uid != null && secret.uid != 0 -> secret.owner == null;
                message = "In ${secret.name} exactly one of sops.owner and sops.uid must be set";
              }
              {
                assertion = secret.gid != null && secret.gid != 0 -> secret.group == null;
                message = "In ${secret.name} exactly one of sops.group and sops.gid must be set";
              }
            ]) cfg.secrets
          )
        );

      sops.environment.SOPS_GPG_EXEC = lib.mkIf (cfg.gnupg.home != null || cfg.gnupg.sshKeyPaths != [ ]) (
        lib.mkDefault "${pkgs.gnupg}/bin/gpg"
      );

      # When using sysusers we no longer are started as an activation script because those are started in initrd while sysusers is started later.
      systemd.services.sops-install-secrets = lib.mkIf (regularSecrets != { } && useSystemdActivation) {
        wantedBy = [ "sysinit.target" ];
        after = [ "systemd-sysusers.service" ];
        environment = cfg.environment;
        unitConfig.DefaultDependencies = "no";

        serviceConfig = {
          Type = "oneshot";
          ExecStart = [ "${cfg.package}/bin/sops-install-secrets ${manifest}" ];
          RemainAfterExit = true;
        };
      };

      system.activationScripts = {
        setupSecrets = lib.mkIf (regularSecrets != { } && !useSystemdActivation) (
          lib.stringAfter
            (
              [
                "specialfs"
                "users"
                "groups"
              ]
              ++ lib.optional cfg.age.generateKey "generate-age-key"
            )
            ''
              [ -e /run/current-system ] || echo setting up secrets...
              ${withEnvironment "${sops-install-secrets}/bin/sops-install-secrets ${manifest}"}
            ''
          // lib.optionalAttrs (config.system ? dryActivationScript) {
            supportsDryActivation = true;
          }
        );

        generate-age-key =
          let
            escapedKeyFile = lib.escapeShellArg cfg.age.keyFile;
          in
          lib.mkIf cfg.age.generateKey (
            lib.stringAfter [ ] ''
              if [[ ! -f ${escapedKeyFile} ]]; then
                echo generating machine-specific age key...
                mkdir -p $(dirname ${escapedKeyFile})
                # age-keygen sets 0600 by default, no need to chmod.
                ${pkgs.age}/bin/age-keygen -o ${escapedKeyFile}
              fi
            ''
          );
      };
    })
    {
      system.build.sops-nix-manifest = manifest;
    }
  ];
}
</file>

<file path="modules/sops/manifest-for.nix">
{
  writeTextFile,
  cfg,
  lib,
}:

suffix: secrets: templates: extraJson:

let

  failedAssertions = builtins.foldl' (
    acc: secret:
    acc
    ++ (lib.optional (!builtins.pathExists secret.sopsFile)
      "Cannot find path '${secret.sopsFile}' set in sops.secrets.${lib.strings.escapeNixIdentifier secret.name}.sopsFile\n"
    )
    ++
      lib.optional
        (
          !builtins.isPath secret.sopsFile
          && !(builtins.isString secret.sopsFile && lib.hasPrefix builtins.storeDir secret.sopsFile)
        )
        "'${secret.sopsFile}' is not in the Nix store. Either add it to the Nix store or set sops.validateSopsFiles to false"
  ) [ ] (builtins.attrValues secrets);

in
if cfg.validateSopsFiles && failedAssertions != [ ] then
  throw "\nFailed assertions:\n${lib.concatStringsSep "\n" (map (x: "- ${x}") failedAssertions)}"
else
  writeTextFile {
    name = "manifest${suffix}.json";
    text = builtins.toJSON (
      {
        secrets = builtins.attrValues secrets;
        templates = builtins.attrValues templates;
        # Does this need to be configurable?
        secretsMountPoint = "/run/secrets.d";
        symlinkPath = "/run/secrets";
        keepGenerations = cfg.keepGenerations;
        gnupgHome = cfg.gnupg.home;
        sshKeyPaths = cfg.gnupg.sshKeyPaths;
        ageKeyFile = cfg.age.keyFile;
        ageSshKeyPaths = cfg.age.sshKeyPaths;
        useTmpfs = cfg.useTmpfs;
        placeholderBySecretName = cfg.placeholder;
        userMode = false;
        logging = {
          keyImport = builtins.elem "keyImport" cfg.log;
          secretChanges = builtins.elem "secretChanges" cfg.log;
        };
      }
      // extraJson
    );
    checkPhase = ''
      ${cfg.validationPackage}/bin/sops-install-secrets -check-mode=${
        if cfg.validateSopsFiles then "sopsfile" else "manifest"
      } "$out"
    '';
  }
</file>

<file path="modules/sops/with-environment.nix">
{ cfg, lib }:

sopsCall:

if cfg.environment == { } then
  sopsCall
else
  ''
    (
    ${lib.concatStringsSep "\n" (lib.mapAttrsToList (n: v: "  export ${n}='${v}'") cfg.environment)}
      ${sopsCall}
    )
  ''
</file>

<file path="pkgs/sops-import-keys-hook/test-assets/keys/key-with-subkeys.asc">
-----BEGIN PGP PUBLIC KEY BLOCK-----

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
W1YR5NNzw2GqjhH3nhj/SnUwXg==
=jshU
-----END PGP PUBLIC KEY BLOCK-----
</file>

<file path="pkgs/sops-import-keys-hook/test-assets/keys/key.asc">
../../../sops-install-secrets/test-assets/key.asc
</file>

<file path="pkgs/sops-import-keys-hook/test-assets/shell.nix">
# shell.nix
with import <nixpkgs> { };
mkShell {
  sopsPGPKeyDirs = [
    "./keys"
  ];
  sopsPGPKeys = [
    "./existing-key.gpg"
    "./non-existing-key.gpg"
  ];
  sopsCreateGPGHome = "1";
  nativeBuildInputs = [
    (pkgs.callPackage ../../.. { }).sops-import-keys-hook
  ];
}
</file>

<file path="pkgs/sops-import-keys-hook/default.nix">
{
  makeSetupHook,
  gnupg,
  sops,
  lib,
}:

let
  # FIXME: drop after 23.05
  propagatedBuildInputs =
    if (lib.versionOlder (lib.versions.majorMinor lib.version) "23.05") then
      "deps"
    else
      "propagatedBuildInputs";
in
(makeSetupHook {
  name = "sops-import-keys-hook";
  substitutions = {
    gpg = "${gnupg}/bin/gpg";
  };
  ${propagatedBuildInputs} = [
    sops
    gnupg
  ];
} ./sops-import-keys-hook.bash)
</file>

<file path="pkgs/sops-import-keys-hook/hook_test.go">
package main

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"runtime"
	"strings"
	"testing"
)

// ok fails the test if an err is not nil.
func ok(tb testing.TB, err error) {
	if err != nil {
		_, file, line, _ := runtime.Caller(1)
		fmt.Printf("\033[31m%s:%d: unexpected error: %s\033[39m\n\n", filepath.Base(file), line, err.Error())
		tb.FailNow()
	}
}

func TestShellHook(t *testing.T) {
	assets := os.Getenv("TEST_ASSETS")
	if assets == "" {
		_, filename, _, _ := runtime.Caller(0)
		assets = path.Join(path.Dir(filename), "test-assets")
	}
	tempdir, err := os.MkdirTemp("", "testdir")
	ok(t, err)
	cmd := exec.Command("cp", "-vra", assets+"/.", tempdir) // nolint:gosec
	fmt.Printf("$ %s\n", strings.Join(cmd.Args, " "))
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	ok(t, cmd.Run())

	defer os.RemoveAll(tempdir)

	cmd = exec.Command("nix-shell", path.Join(assets, "shell.nix"), "--run", "gpg --list-keys") // nolint:gosec
	var stdoutBuf, stderrBuf bytes.Buffer
	cmd.Stdout = &stdoutBuf
	cmd.Stderr = &stderrBuf
	cmd.Dir = tempdir
	fmt.Println(tempdir)
	err = cmd.Run()
	stdout := stdoutBuf.String()
	stderr := stderrBuf.String()
	fmt.Printf("$ %s\nstdout: \n%s\nstderr: \n%s\n", strings.Join(cmd.Args, " "), stdout, stderr)
	ok(t, err)

	expectedKeys := []string{
		"C6DA56E69A7C756564A8AFEB4A6B05B714D13EFD",
		"4EC40F8E04A945339F7F7C0032C5225271038E3F",
		"7FB89715AADA920D65D25E63F9BA9DEBD03F57C0",
		"E3B7464FBE89F5378ED4BC60FC925B42FC8B773D",
	}
	for _, key := range expectedKeys {
		if !strings.Contains(stdout, key) {
			t.Fatalf("'%v' not in '%v'", key, stdout)
		}
	}

	// it should ignore subkeys from ./keys/key-with-subkeys.asc
	subkey := "94F174F588090494E73D0835A79B1680BC4D9A54"
	if strings.Contains(stdout, subkey) {
		t.Fatalf("subkey found in %s", stdout)
	}

	expectedStderr := "./non-existing-key.gpg does not exists"
	if !strings.Contains(stderr, expectedStderr) {
		t.Fatalf("'%v' not in '%v'", expectedStderr, stdout)
	}
}
</file>

<file path="pkgs/sops-import-keys-hook/sops-import-keys-hook.bash">
sopsImportKeysHook() {
  local key dir
  if [ -v sopsCreateGPGHome ] && [ -n "${sopsCreateGPGHome}" ]; then
    export GNUPGHOME=${sopsGPGHome:-$(pwd)/.git/gnupg}
    mkdir -m 700 -p $GNUPGHOME
  fi
  for key in ${sopsPGPKeys-}; do
    if [[ -f "$key" ]]; then
        @gpg@ --quiet --import "$key"
    else
        echo "$key does not exists" >&2
    fi
  done
  for dir in ${sopsPGPKeyDirs-}; do
    while IFS= read -r -d '' key; do
      @gpg@ --quiet --import "$key"
    done < <(find -L "$dir" -type f \( -name '*.gpg' -o -name '*.asc' \) -print0)
  done
}

if [ -z "${shellHook-}" ]; then
  shellHook=sopsImportKeysHook
else
  shellHook="sopsImportKeysHook;${shellHook}"
fi
</file>

<file path="pkgs/sops-init-gpg-key/default.nix">
{
  stdenv,
  lib,
  makeWrapper,
  gnupg,
  coreutils,
  util-linux,
  unixtools,
}:

stdenv.mkDerivation {
  name = "sops-init-gpg-key";
  version = "0.1.0";
  src = ./sops-init-gpg-key;
  dontUnpack = true;

  nativeBuildInputs = [ makeWrapper ];

  installPhase = ''
    install -m755 -D $src $out/bin/sops-init-gpg-key
    wrapProgram $out/bin/sops-init-gpg-key \
      --prefix PATH : ${
        lib.makeBinPath [
          coreutils
          util-linux
          gnupg
          unixtools.hostname
        ]
      }
  '';

  doInstallCheck = true;
  installCheckPhase = ''
    $out/bin/sops-init-gpg-key --hostname server01 --gpghome $TMPDIR/key
  '';
}
</file>

<file path="pkgs/sops-init-gpg-key/sops-init-gpg-key">
#!/usr/bin/env bash

set -o errexit -o pipefail -o noclobber -o nounset

OPTIONS=h
LONGOPTS=help,gpghome:,hostname:,keytype:

! PARSED=$(getopt --options=$OPTIONS --longoptions=$LONGOPTS --name "$0" -- "$@")

if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
  # e.g. return value is 1
  #  then getopt has complained about wrong arguments to stdout
  exit 2
fi

eval set -- "$PARSED"

FINAL_GNUPGHOME=/root/.gnupg
HOSTNAME=$(hostname)
KEYTYPE="RSA"

usage() {
    echo "$0: [--hostname hostname] [--gpghome home] [--keytype keytype]"
    echo
    echo "  keytype: RSA (default) or Curve25519"
    echo
}

while true; do
  case "$1" in
    -h|--help)
      usage
      exit 0
      ;;
    --gpghome)
      FINAL_GNUPGHOME=$2
      shift 2
      ;;
    --hostname)
      HOSTNAME=$2
      shift 2
      ;;
    --keytype)
      KEYTYPE=$2
      shift 2
      ;;
    --)
      shift
      break
      ;;
    *)
      echo "unknown option: $1"
      usage
      exit 3
      ;;
  esac
done

if [[ -e "$FINAL_GNUPGHOME" ]]; then
  echo "secret path ${FINAL_GNUPGHOME} already exists"
  exit 1
fi

export GNUPGHOME=$(mktemp -d)
trap "rm -rf $GNUPGHOME" EXIT


cat > "$GNUPGHOME/key-template" <<EOF
%no-protection
EOF

if [[ "$KEYTYPE" == "Curve25519" ]]; then
  cat >> "$GNUPGHOME/key-template" <<EOF
Key-Type: eddsa
Key-Curve: Ed25519
Key-Usage: sign
Subkey-Type: ecdh
Subkey-Curve: Curve25519
Subkey-Usage: encrypt
EOF
elif [[ "$KEYTYPE" == "RSA" ]]; then
  cat >> "$GNUPGHOME/key-template" <<EOF
Key-Type: 1
Key-Length: 2048
EOF
else
  echo "unknown keytype '$KEYTYPE'"
  exit 1
fi

cat >> "$GNUPGHOME/key-template" <<EOF
Name-Real: $HOSTNAME
Name-Email: root@$HOSTNAME
Expire-Date: 0
EOF

gpg --quiet --batch --gen-key "${GNUPGHOME}/key-template"
echo >&2 "You can use the following command to save it to a file:"
echo >&2 "cat > $HOSTNAME.asc <<EOF"
gpg --export --armor >&2
echo >&2 'EOF'

fpr=$(gpg --quiet --list-keys --with-colons --fingerprint | awk -F: '$1 == "fpr" { print $10;}')
echo >&2 "fingerprint: $fpr"

rm "${GNUPGHOME}/key-template"
parent=$(dirname "$FINAL_GNUPGHOME")
mkdir -p "$parent"
mv "$GNUPGHOME" "$FINAL_GNUPGHOME"
</file>

<file path="pkgs/sops-install-secrets/sshkeys/convert.go">
package sshkeys

import (
	"crypto"
	"crypto/rsa"
	"fmt"
	"reflect"
	"time"

	"github.com/ProtonMail/go-crypto/openpgp"
	"github.com/ProtonMail/go-crypto/openpgp/packet"
	"golang.org/x/crypto/ssh"
)

func parsePrivateKey(sshPrivateKey []byte) (*rsa.PrivateKey, error) {
	privateKey, err := ssh.ParseRawPrivateKey(sshPrivateKey)
	if err != nil {
		return nil, err
	}

	rsaKey, ok := privateKey.(*rsa.PrivateKey)

	if !ok {
		return nil, fmt.Errorf("only RSA keys are supported right now, got: %s", reflect.TypeOf(privateKey))
	}

	return rsaKey, nil
}

func SSHPrivateKeyToPGP(sshPrivateKey []byte) (*openpgp.Entity, error) {
	key, err := parsePrivateKey(sshPrivateKey)
	if err != nil {
		return nil, fmt.Errorf("failed to parse private ssh key: %w", err)
	}

	// Let's make keys reproducible
	timeNull := time.Unix(0, 0)

	gpgKey := &openpgp.Entity{
		PrimaryKey: packet.NewRSAPublicKey(timeNull, &key.PublicKey),
		PrivateKey: packet.NewRSAPrivateKey(timeNull, key),
		Identities: make(map[string]*openpgp.Identity),
	}
	uid := packet.NewUserId("root", "Imported from SSH", "root@localhost")
	isPrimaryID := true
	gpgKey.Identities[uid.Id] = &openpgp.Identity{
		Name:   uid.Id,
		UserId: uid,
		SelfSignature: &packet.Signature{
			CreationTime:              timeNull,
			SigType:                   packet.SigTypePositiveCert,
			PubKeyAlgo:                packet.PubKeyAlgoRSA,
			Hash:                      crypto.SHA256,
			IsPrimaryId:               &isPrimaryID,
			FlagsValid:                true,
			FlagSign:                  true,
			FlagCertify:               true,
			FlagEncryptStorage:        true,
			FlagEncryptCommunications: true,
			IssuerKeyId:               &gpgKey.PrimaryKey.KeyId,
		},
	}
	err = gpgKey.Identities[uid.Id].SelfSignature.SignUserId(uid.Id, gpgKey.PrimaryKey, gpgKey.PrivateKey, nil)
	if err != nil {
		return nil, err
	}

	return gpgKey, nil
}
</file>

<file path="pkgs/sops-install-secrets/test-assets/age-keys.txt">
# created: 2020-07-18T03:16:47-07:00
# public key: age1yt3tfqlfrwdwx0z0ynwplcr6qxcxfaqycuprpmy89nr83ltx74tqdpszlw
AGE-SECRET-KEY-1NJT5YCS2LWU4V4QAJQ6R4JNU7LXPDX602DZ9NUFANVU5GDTGUWCQ5T59M6
</file>

<file path="pkgs/sops-install-secrets/test-assets/key.asc">
-----BEGIN PGP PRIVATE KEY BLOCK-----

lQOYBF7+3V4BCACqlg3cYAHiW4r4PtlD50lllgsildssbR2AY+0inaSoafWtmxWp
Rf+fTXpgiRdRCAEUn6XQ+tAjmhG2aA2IwEavCgr7Hpn13/TwseD2Hk8HrQmcGnJH
zP9HRbx71dZYY21PjOr+qHbQ0vYjfsU/g78bDbQu1mKf4IpBXsUGXah1hYFzfBVc
Agn/a86OjlAlHioMtoLMacKdaQn+zpzb9q0zhgEuhFUoGvwvFGuyZxiLe+ZdWHJi
cCFwGZv8aRJkRdXJlpCtY+XW7MowaRqyXTaGXhVzuCif6a7FObnTECHWHWIHLcnz
2aT2UWIINdDOAVVDKKzTRLxzBo7iCQxQu7IrABEBAAEAB/oD/V51n2+fC7Hd/IC4
X3OoAv2S4YGVMgTunwFJpF/Ytu6E3b7nJp8qUQ8u35+PLzckDfFvrqFCzYFJWUWq
9rqwfVukY++is71wcIVo1dMJxIV+nflUri0j5zQK8WvOxWryrikQ3uY1T1NsB4Fo
t69Qj3fkLVkN92jd/olwWXoHK/5q7xgDMXPE+CPq9sArBiS3WjWlxY+Q12hohnTy
47WlfUcvDuC4S7Ww+BfgRCKXJEQNFu3gfeAcv9ZOvTE9tR0RC704K3rxwK0JVRiI
g1EavhXNJwt6RuA5nPufS0juPokOa9yC/x5oz5/Rp9EW1kRptW1jIAC78/OxIgjH
No6BBADPHrPBJAmSH/hgFMqU8xR2u6ljFVppJvTg/D3/obYKMYf8ybJHit5ydGoP
AgpRqp22jim89vlzNrIYbhMFApQehzBxyfCwA7M9G+UVttmrqYWx5uSf5tTTdgnt
ONnX4nuaZV5Nm41z0r2NmkNunVUNEj9MszfRRQpfjBVNyw5lZQQA0tgjOi7oV0Sc
Kya/MyZLexVfZTI/oIszjPZ2UE9A0ICzwA/mZjQDJ2lD39XnylbninBa1utfEGQr
JTJceA3LLFfo0L2nmbHAbxU6fRkRKvyDUiyeQFoXYNbeOS60HRHq2T4d06aFrWjZ
eEp3iW35gE/ekgD0OVmPwGP11H5OSE8D/3G7vFQrvWewax7Dweqg8VZCBuyUdO7O
rzklc1m8QOYmcJv1L9aM8hXpUMB8IaxWlwJPCA3CHbztkaXm/Qa6rfIetkitKsQZ
cM8ftPt5rzfBUthslB8CdIR8GgTuA5ep/GCnOzsT/X+PKxksjNOrw6pW+D43pne3
8qp0owJjHllWPSm0HGtyb3BzLXRlc3QgPHJvb3RAa3JvcHMtdGVzdD6JAU4EEwEI
ADgWIQR/uJcVqtqSDWXSXmP5up3r0D9XwAUCXv7dXgIbLwULCQgHAgYVCgkICwIE
FgIDAQIeAQIXgAAKCRD5up3r0D9XwBGzB/9KEcq6wq6VMs5KGqlGyBoqlwuOqLma
Uc0Mvp3YjK5JuW+Sbuf8hPffeRvT/Ypp45YqdiW6AIMVYzAqzYZ9pxjWl6vJKA2m
T+PN0IqbdnZHiCn3KNdKk5849k/VxGrXP+EBJlgpSsvaCZfCK66+O3p2J8duFhbw
ZdgiMZcg7KoC/X/vV/KQSdgw+MIF6M6Qw7g+i8GtW23myDUQuyZExyv84HnIlDaL
slM8C5xZVTLHSE+Ko1sw3jZAgRc5b6mB53aGb5o047Nd5Ne4LF+/SROWBSwboWVm
dbqb6BY/TwZ7M3cnaTqr902ULLIKCmDtsyPPbtBkLwERprn0/GN4+KQ5
=lC9N
-----END PGP PRIVATE KEY BLOCK-----
</file>

<file path="pkgs/sops-install-secrets/test-assets/secrets.bin">
{
	"data": "ENC[AES256_GCM,data:AYNhe4LTj7Qg7KZZbg==,iv:/L0oue9ZaKTUPS4RHuFzcdDgumEd2PjBsAJROG66gVw=,tag:h8ZhK3NbiRuxnTSigauMaA==,type:str]",
	"sops": {
		"kms": null,
		"gcp_kms": null,
		"azure_kv": null,
		"lastmodified": "2020-07-05T20:44:28Z",
		"mac": "ENC[AES256_GCM,data:RDB36I9DqwhcTuvRzzrsm+4qr02+gnRBhvpyUlxb8RVm4SrrcF0rbbpnhbwQBVCdM16SK4LKYqeKgKbR8p4AOfAbiqw3Hzr0X2yzVOVfhur+MUcht2SwmBDjzfpfT/tKTmESa5qQvfOHW1wv0BWAWnkb0VX0nEQ7SPjFmZCDmMo=,iv:cBqhgYRTSmo81c08OK8nE+5G2XZKGupoz+89bPUM1tc=,tag:d4P+phbUMfScvJAiZvd3oA==,type:str]",
		"pgp": [
			{
				"created_at": "2020-07-05T20:44:26Z",
				"enc": "-----BEGIN PGP MESSAGE-----\n\nhQEMA/m6nevQP1fAAQf9GPihjHiNygjYKRsYQRTWRP7BoQmuumT0qakvVNj8a0tU\nz4Alqe8KUlEMurQ6PFxIzDzYoxANnD9sDXxkrdIlFHEVmftcjM6J5x5OZ2JPUO+j\nf7yOpTjb4pSxTWHqCGkUdfTqa2Tn1bOGissjHxu5bq39qR2tfirUHGgW3BbrcXx4\nJjUeSjEFOL//Djq7MuGW/usfKiyhRMmLtJ9sQRNSFYjdGpPbBJoh26zKnq7/fHSs\nJXBLkyk+Lt4TTZO7JpD91Rgtg6CAk3UJDxiwfo8lIWLOrUuMvYx/6ykq/gUlhZYJ\n0PEqNmalIjjRE+hnKGbWRV4Pi1MCSyo6CFwQbRrGaNJeAUG2I5hTRgpQ2KTHUHLU\niq8J53gdW+lkKt3K5KKoUJia4Wa1x6ut2UXZL1HyADLIWpVjDxG2qV/H8ZwHuizU\n3GLoLnQjC49OHUZW09F4ytU8zAyaei3h4jjbEyRv8A==\n=YHki\n-----END PGP MESSAGE-----\n",
				"fp": "7FB89715AADA920D65D25E63F9BA9DEBD03F57C0"
			}
		],
		"unencrypted_suffix": "_unencrypted",
		"version": "3.5.0"
	}
}
</file>

<file path="pkgs/sops-install-secrets/test-assets/secrets.env">
#ENC[AES256_GCM,data:TfdJsqJ9p/3tnClpyPQbfvbmYUmjryiSGA==,iv:YXiEYlAdzco3hZ7T+X6dOUb17ByZeyGXlimfD+yaTa0=,tag:67TgtX4Zn6Ft7ww+J5AjTQ==,type:comment]
hello=ENC[AES256_GCM,data:Y8BU+riqE9DInBi1iALx8iNG2Z5iAGFOgNhZg/wFtwqcLXFBTP1vouIewDdWfQ==,iv:dPftz1CxGYi81lSUbg0iRhXpFP4blmyRn5qKPnWUF0k=,tag:VzKiYYhNDSJsZ8q1A+EpMg==,type:str]
example_key=ENC[AES256_GCM,data:C8+6JSN7MbRpizcF9A==,iv:ODsEI46iuAT81Q/8r83tCfKpU9x2zJ3rzV4FhJmj+Xs=,tag:Mc4l4Kvzg0VvmzcvU3w1tA==,type:str]
example_multiline=ENC[AES256_GCM,data:M6QISEHpqpyUVC0=,iv:uow+EKFgOuSv84hCqtox4r8nvVRFC11xG7or7iMdNkg=,tag:AC5aoWP1LgALV1/YPZMplg==,type:str]
never_gonna=ENC[AES256_GCM,data:PrjZGWkgmmrT6Ms=,iv:ZaSHmgdKf0EUFehl+z4Xj2ouiw6T17xhqwsCGP8fdgQ=,tag:5YRX6obm4G9RUQIqECMf5A==,type:str]
sops_pgp__list_1__map_enc=-----BEGIN PGP MESSAGE-----\n\nhQGMA3ulPRkZxd/UAQwAtsL/Gdj32m81J5k3q4Vz+ev5B+zF/53hB+3FuJtUlWez\naNxQs6RxGC1JtlluMX0syzz8yoAspnfbKxPylMf/A81dhqnMVpZyktBtavb6K07E\nl2gOjgkq6SfOzqeVQdxjvi4VoZ86+KueQCPlALQWxVMGlCMjhGwd7HLWFbJt6O2G\nNCNa7HBABYUDQf8lND+7YtBKX4KyxJviQGpdlOvx7Xkw7hafYMxA79Jp7uLso5d4\n+IKhidKqR2ZWhNgcgKCesRS4hIAzqMmBiSNYHuM23Pe+jPzOvbADWPJEj/rV3qvo\ni8ehS/cGB4rRnLdfW6frQpC+cVKhxuZTJmoBXFazIB15fz32iuDZ8FBiJJXYrVJT\nIphOJt9NcnpoK4M5mQvKB6otZfZRfQYjbJ4Q7n5u4AD/TvMByRgG2B7XkaEXRbrx\ngNuSpaLtwTYpqzq/AynR3h4K5D0izhoviIrhyv6Y5EskDim5ulqbcW+lPAISkohE\nhqWx76/SyA0ehj9jqTrW0lgBXQDsnqgS5C0LZFLsPyDvEG0q03/eoUKSbYyVU5kh\nwy8yHcJmsDqgU+f5TjyNdXpOc+xfbGqfWmeWjSPDyx7lEZxXcBXqAVCpJo3QL9JX\n+VDTtrwqJ2Ho\n=nthm\n-----END PGP MESSAGE-----\n
sops_mac=ENC[AES256_GCM,data:onO42qeKMXa4Jl6Vt06zaoET+6WKzSGd8ak/LyXq1xABAtbVpt25tBdVKlfCD/lzDkOylexQfOBdRAqRPZ1ex3Q4ILZcjmPBkFsMbAs/7L1EzSXskWgeh7NuDXtNKsTmGp9BVcICh3O1+kECQSRZGcefUhV+HYMjRxh2Xxm8r5E=,iv:C8m3Ffbe12LSv0bsPmsxfhOjXNoJ0+75Q+sCYpqchJA=,tag:pahCk/P1Ig71xgvxVIZyPg==,type:str]
sops_version=3.7.3
sops_unencrypted_suffix=_unencrypted
sops_pgp__list_1__map_fp=2504791468B153B8A3963CC97BA53D1919C5DFD4
sops_pgp__list_0__map_fp=7FB89715AADA920D65D25E63F9BA9DEBD03F57C0
sops_pgp__list_0__map_created_at=2023-01-17T12:32:47Z
sops_lastmodified=2023-01-17T12:33:06Z
sops_pgp__list_0__map_enc=-----BEGIN PGP MESSAGE-----\n\nhQEMA/m6nevQP1fAAQf/cGIbOAVh6dy2xDztWHmOPfhBsEFJRzih25cVNbVqo6EC\nxAY31eEZpibKDhAxNKSQbUXjwpCY2Bw5iyRznvjy2kuwDxjyqbGVsNKJuLvlqZ/f\n8Pfs5xvI0A3nc4PRwm3U8n0UhrII9zMl9VB2THw7CP5ZnJy0mjEygxI7ml7k63Go\nSAukABD6QW1sIluP2Q7A6Cy7nXf8QcXI0O5cMJbQos8OOEIiRWoD33i5Uf9KNh9c\nwhNNvpfh1cMZ5StlaWlNXW3ZH/pOJWCLnmmQ/DgcR+LiMA01moykE9ewtwkXfwED\nRzNYZhFD2NKn9Y+smUQ2XaXwMeBw7wlCY7568wK3wtJeAVAEJHbFS7CXI1x3zRRL\nkEy3AI85MobyjGdWIi0+v1K3TqbABUNyg9O+6XpSkn3zPtneY1w4EgJqEvMMJoxN\nxGahyyxYhT2VDO7gPrlkITE6mo0jwyfCGjZERpQFiw==\n=X2R+\n-----END PGP MESSAGE-----\n
sops_pgp__list_1__map_created_at=2023-01-17T12:32:47Z
</file>

<file path="pkgs/sops-install-secrets/test-assets/secrets.ini">
; ENC[AES256_GCM,data:Q3CfbslIuolYPK9yZIgPdgnmYSuwBG9E,iv:d51C4MXhAa0pOMSTDtSzNyxgRd3IkHPW4+tCyTpHxbY=,tag:LzXKrOg72Td9PAhb4UdKMA==,type:comment]
[Welcome!]
hello       = ENC[AES256_GCM,data:NjaXxfkFK25JFGiPNJBDX0NfsZN70ltV4OCLR52PCFU880dw5NU8O2yvQQ2kUQ==,iv:eSYE2Pwu8J7Wdq0t80Dx1OKfq8B5nCkX8FqFnVqOSSM=,tag:gqf3oczxJM4V9/L48/PFAg==,type:str]
example_key = ENC[AES256_GCM,data:aYmYszjMLR+eEW0ZZw==,iv:K6qCGzVu56gjUWXtEad7QYRh/6OpytdkoyzOjp/1lMw=,tag:HqMQ0ckO7uVyOiZbOtbxkA==,type:str]
never_gonna = ENC[AES256_GCM,data:Q4xcNZE1R6tiXh4=,iv:7BgJXn3avu+7Mc9FRPqW0VtRiK7nUpA6cHfhzEWV+TA=,tag:/4YjMUA2la3/E71lgNcqIw==,type:str]

[sops]
pgp__list_0__map_created_at = 2023-01-17T13:06:50Z
mac                         = ENC[AES256_GCM,data:jCYesEFva/ptI23sBcOHxMhGsyF9E5w3tdsEONKtJj+7KbkG76f7e3AEQyjpURNuv6QVHwCwABJRJObl4VHXOoI/yb/AKSGSYPTM/nRYWXG8vrX1HHwFYWmQfZtm6G8bc8bhWjHh3nt6cV63VhfNB+5L3oaTdkrKfZhNrLI5ztI=,iv:VSbopP0E+ocMbsaM6jwkiG4K/H6N5JUv+3kKtU2jI6Q=,tag:TTjz2JifWiNSs8sComn5Ew==,type:str]
version                     = 3.7.3
pgp__list_0__map_enc        = -----BEGIN PGP MESSAGE-----\n\nhQEMA/m6nevQP1fAAQf/S9ggtaO8grsEYyicoQnrM0279m0+t5d6VP2bQoelneOw\nPEZOdKnwWw939rdUz5pNMWIdEL2mHE1Yu99lmal9TmMXf0kDoryDgHtChM6UyA/u\n0mqbEoASaebwAikWJcidhoWbTLr0eqpohVr+Y0wT3MjkX4sUZzPRapIT2rv/jecm\nq357aSy0kzmKnIal+h9Bqbl3tkiMvhdILRsN1Xlp7xa3H681D1EeRfw3BbR8h4Ui\ng9m9kBVRVmyLl46C4a1etcQgvU5jFUloDIaVV3XGErdEz8bL7B5jPuH5xJCAmVOM\nrouo1n6xJGxEq1lUoWTf/wfnsCCJzpPktsikeprj+9JeAT5DsZdnHr3nmgNYEgLp\neUTTB4aoKHsjehHV+aTpJSKPtzkAkA4mEregUes4T20WOYgurg2lf9a1TYQ+W5ve\ngrI2jdYYxVkWRJvuZRW3umKKQZhx96AP7RczbWL5BA==\n=WuNZ\n-----END PGP MESSAGE-----\n
lastmodified                = 2023-01-17T13:07:01Z
unencrypted_suffix          = _unencrypted
pgp__list_1__map_created_at = 2023-01-17T13:06:50Z
pgp__list_1__map_enc        = -----BEGIN PGP MESSAGE-----\n\nhQGMA3ulPRkZxd/UAQv9FFWTbfSQoC6OVhfIEk5+6t35rAAaJAEGyYPLDqRu0xQk\nd80jcsCmvFo8NqKQfBsC6GTsvbnAOuErIYcltKDya0mULDgskbCDQmrwF6AL0Bp9\noVnJ60tuMc72yGYgKTu7yll2DUJuas/qltvI/aA7SMFltltIqnPv7byZfH3BAJIY\nVpnNO1a9M1S7YrS8GtuLSdXfUWqpzoE2bVhsJCfQy4yxkyyMsEnObb6xTTSD2iio\nZXU50fR8JqXma1Z2XuVUmWLS7mp03iqIzwrBCIVuhfSYmy3gF36rToJ5EFgEhP6f\nB8S4xZyWN9Pp6r3keaKK4cYybKrk9rDUb1JcKiP0K/lGsX52M+IR0x0peTVp0ciq\nfYKOd9leEI8nsBpeMuvQnKhE+XHWiQBghmUCeK35O9oYJGKLrsKVXfMke7LUE5Zm\nQQ1CjvvVovAnuX/8/1+NscixBgXZXZgTqoRE84Qta+ohRZqmNGIv2VeEZx/jQxXG\nhiA5G+ylnlTZPGck8V5D0lgB++OQoiZVryFH1aVr1AHO0j2lCa3ckftLKkQ5vQIi\n1JHbPHZ1MHBut761L/RSnBmTVr3B3XW54NH78LeWS0y7z+8mXjWy7Cjl4cyst1b0\n/byCrk2EqPQP\n=LZBU\n-----END PGP MESSAGE-----\n
pgp__list_1__map_fp         = 2504791468B153B8A3963CC97BA53D1919C5DFD4
pgp__list_0__map_fp         = 7FB89715AADA920D65D25E63F9BA9DEBD03F57C0
</file>

<file path="pkgs/sops-install-secrets/test-assets/secrets.json">
{
	"test_key": "ENC[AES256_GCM,data:PSx6TW8XFEZu1Q==,iv:luoD3+RAkE87TmhD9tCFb+JkVINc1uoh88RhgOQUPVM=,tag:TuDOKHyvhk4UP3GO5lzrlw==,type:str]",
	"sops": {
		"kms": null,
		"gcp_kms": null,
		"azure_kv": null,
		"lastmodified": "2020-07-03T08:21:21Z",
		"mac": "ENC[AES256_GCM,data:WvHkCNOLkq8BdRA5A4OtA4tJOszNqx+cuEb7Mq5NIgDz2pNG2Sm6IbgqwzVqIZDndNfd/zpjtrxRuIyszijwmA67rgiqWorreqdKfqasi5U5SnMbbQX7wOCaAqqLut8KN7npWXN097D1AyhTTGBViPDuLJxYHG33+vZDwGG/YEw=,iv:Jfz8VWPhxPQf+vprq7NhcYWgpcGbUol6+ElWinTjaU0=,tag:8h3UQ3czxFY4SFZdSKZVuw==,type:str]",
		"pgp": [
			{
				"created_at": "2020-07-03T08:21:00Z",
				"enc": "-----BEGIN PGP MESSAGE-----\n\nhQEMA/m6nevQP1fAAQgAqCfoGygBptXq7TbKgJJc8R8BpOgIbK/L1VNH5dxGNIbC\nRL6bgMSqGmjHSKILxnBpLtStBjaxp8EzAdcPLmJ0VkjE9/M+rSVMTsFPMHrvpR6Y\n1BqSx/y2B9RF1UiGZ5Q6VdEEm3iXsNg+mJZYEFCbYAMpSE7iFT8DpgBAAJpJelCt\nSkubIWUz9Dp09oz1CKmK5HGUXTvxgl2upIPuRMHXoyTTuNNXbf+n9QOLo9LmBdCk\nI9ikdz21/uNhFuJhBavxcWfeOhRryYvF4DFbopn3H8+zR6bg4FqIHbwwhIG5x9By\nVOFzW/JyuZTeO7W+9+JI9r0/d4R2KYjZrPC7dxrhd9JeAbbIj+1OpbKwFAVC4+1U\nd1bXDgaZ5VlgfehpxRCRLFn2P6hBtEaW5GGGORlnb9LMvDviXE0vWnfk1o3sYipc\nPCJ9uDSE0WsvsuHBQSJwbDx0DcEtANxd6w7zRqn6Lw==\n=Khnx\n-----END PGP MESSAGE-----\n",
				"fp": "7FB89715AADA920D65D25E63F9BA9DEBD03F57C0"
			}
		],
		"unencrypted_suffix": "_unencrypted",
		"version": "3.5.0"
	}
}
</file>

<file path="pkgs/sops-install-secrets/test-assets/secrets.yaml">
test_key: ENC[AES256_GCM,data:2mP+IAdczoEr0g==,iv:voX4IQemcgt0O97oLExy5r2V85nn687cIyWmHNDhUag=,tag:R97qy4fKneU7D9UFhXNvgA==,type:str]
a_list:
    - ENC[AES256_GCM,data:oOQ=,iv:5P+1UQyIYOW8xXgsvTXC17msGcA6IGB3N8n+pstfqjo=,tag:ox4rgjbb8c0vYZ2XmwRgpg==,type:str]
    - ENC[AES256_GCM,data:mYU=,iv:LbGS8DjM6Vnr2nU7QokzQlg0gL+XMWhqbN+ypP7ZIZo=,tag:CFrhnZv6lYGJOVso+2YBFg==,type:str]
nested:
    test:
        file: ENC[AES256_GCM,data:9YhsaXoxxdbLUzeWqA==,iv:xBYQQpsC/Xq0wHXNcqmLxNs5yvG+yjBzcpdRpC+UJxs=,tag:OnonR98dn9CXh/LwlRwXIw==,type:str]
sops:
    kms: []
    gcp_kms: []
    azure_kv: []
    hc_vault: []
    age:
        - recipient: age1yt3tfqlfrwdwx0z0ynwplcr6qxcxfaqycuprpmy89nr83ltx74tqdpszlw
          enc: |
            -----BEGIN AGE ENCRYPTED FILE-----
            YWdlLWVuY3J5cHRpb24ub3JnL3YxCi0+IFgyNTUxOSBOcUlPTGtUY2R1Si9SUnpN
            dGVMVzMzTXd2Z09UeGdxQlNqeVg3WTFadWtNCkpzaVJqMkZ0b1JUamJsbysrdGll
            QVlLNU9xMnZqandMdGxKNlZ2amJFbncKLS0tIFlrbGtyMkZKNUthd0Z5VW5MVjBN
            bWFhWGlJaXMzWUJoZGpnMjNoSnlMYTgK2hM/Cc6xN1xkluL69jDaaoaEijAJk+l8
            TwhUG7Qlggod2xCWTC4cpjb+THip2u31tFoSPQZKEG8gDcGNIz2HOw==
            -----END AGE ENCRYPTED FILE-----
        - recipient: age1a8pk4akrdamj7nvqy3zywgtny8dxz7t5xzu7u8v9mhrayp9freqsqatyrs
          enc: |
            -----BEGIN AGE ENCRYPTED FILE-----
            YWdlLWVuY3J5cHRpb24ub3JnL3YxCi0+IFgyNTUxOSBCS2NvekFqa2dVeXUzRzZY
            emR6NDJqMnptOHpQUDBjTjdaMGp4SGZ1bTJVCk16Tnd3ZFl0dFUzQ1RNRzYyclV3
            d24xeDZMaXFvbEhZWXRObTM4RWRQMk0KLS0tIGs4bjFweEFjblFEalBOLzMyYyt6
            WHJmNkhFVStxRG5PZTZUWnRFTmtzemsKLXKJN3GSJKDI4MYPxDU5HbTzoSAt0jK9
            T9sJbd++By2OC9rl+GJoJcy4aM0uTYy83EDfqBV02Y1CfepRjHLRWQ==
            -----END AGE ENCRYPTED FILE-----
    lastmodified: "2021-09-30T19:49:41Z"
    mac: ENC[AES256_GCM,data:WQjpNaji5Jg/0m0brFXernN+n+zwroiyFRGmhXE2T13THjnxlPyTxkjTIf3oJlAwpeIsfaCCxRdBSJC1B9s3XaqCWHTY4wEOdZ5f+oNBlMxbwKyN5t+GG2CRdpoMsIQ/bBJ+v8LM5BEa3qNXQ6TwWrnhAXWWPRjRa1LsguvI+TM=,iv:fwWjzvLA2cYJNnanm/vw5yE1tXtGU2amZfhw3Ha5zbo=,tag:6FT1M6fqJfUX8E10pvEehw==,type:str]
    pgp:
        - created_at: "2020-07-12T08:03:51Z"
          enc: |
            -----BEGIN PGP MESSAGE-----

            hQEMA/m6nevQP1fAAQgApvcEy9FBr6kag0PkFBabiEhqtKG6CcN/ewbxfDGXbOPI
            hyndS7Poc6a7VeYo6cDQwxNqbUbjjn6BRZBFGHxuVInjvtDVm2phh/HOd25IH68s
            RGh93wyW637rqJGp8+X3of7b+XBxq0fg0hLqKxR8iMaVF3WnyAMfS/r1tAOuHRGF
            geMSQftnWkv1OIl2DPDcv02lqHSKqVZpidzxEdeAqAH/Ml9SoTOEyC8uNz0LIdvP
            SQUp5JFp5CEyXaAzeTiypodIjCKOmCNTLuR9VC8O5+P+E62xVmxoFVVfozg2ZBdk
            CJrEGR5jxTxAI1IB+ywWOde+cVzQtPXds1d3at2uFtJeAZuS3VYfvL1f4rXNrSBV
            3x7+rDknN8PsFAmmnLdxtbPJAij9eERpoAOsJOy6Ka4OSvOj4sCCU09wb2i/PugU
            a7y4M55KzV/8J5aQ4iMVym/9Gkb98XK2Ff5na1jQGQ==
            =MU7I
            -----END PGP MESSAGE-----
          fp: 7FB89715AADA920D65D25E63F9BA9DEBD03F57C0
        - created_at: "2020-07-12T08:03:51Z"
          enc: |
            -----BEGIN PGP MESSAGE-----

            hQGMA3ulPRkZxd/UAQwAidXXZa5HVHCuI9pULCMVfX25pjYk3CpGdo1jLt20teRu
            QVe5Ner7Z3QF8BMk4YRDDaJWlWLbHQE4KYM5/ER/iJyrSIp9wcIx7bQvoCO44KLh
            5wXbmxRnscUaW67+qdnjZBFSIHxtaeRYSBGCk3CGODnVamvGXdv733eG/O2IBHqt
            sIE3+cOk6N+gQxYcz5IxJlRJlF6NagD4RxdMzjx6QJ43pZp8tKupDFZ1Teh1c4mY
            8XtVekaWz9ToKiQD3uQoCIwSW/YszuviYf/ar4Bi7j2xTH9vzSxxoRsSjo0JXKyB
            EDj2Y1M5KzZAb3OWNINmNt2jqwKF8HS06TrbP6bdmRgHWRnwJLaSHSpxiclT/YpC
            En4/ZvjqJdxyJc0nmEyDpEgelpTzm19jzFvsEvj43GnnWjh6/aAb0TF2Ms1E7I5E
            VpJFI7l/I1JDacdDlvx1jFMhsya9n356GhZaiJky89hURsHhH5ek8E3f0PpC20dp
            J7o8e7N0zXV39iIw6kdT0lABPe8KVRzQOsIKqNGaVwZVQuX4i/C1vbz6yTb+cHc6
            yCYEoi674QYg7ofZV4VkY318XOQz7P5sVlASjADvKF9SzjENadp8Y0SHvuYkXU4W
            yQ==
            =DqFU
            -----END PGP MESSAGE-----
          fp: 2504791468B153B8A3963CC97BA53D1919C5DFD4
    unencrypted_suffix: _unencrypted
    version: 3.7.1
</file>

<file path="pkgs/sops-install-secrets/test-assets/sops-edit">
#!/usr/bin/env nix-shell
#! nix-shell -p gnupg -p bash -p sops -i bash

if [ "$#" -lt 1 ]; then
    echo "USAGE: $0 file"
    exit 1
fi

set -x
export GNUPGHOME=$(mktemp -d)
trap "gpgconf --kill gpg-agent && rm -rf $GNUPGHOME" EXIT

DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
gpg --import "$DIR/key.asc" "$DIR/ssh-key.asc"
gpg --fingerprint --list-keys

fpr=$(gpg --with-fingerprint --with-colons --show-key "$DIR/key.asc" "$DIR/ssh-key.asc" | awk -F: '$1 == "fpr" { print $10;}' | xargs | sed -e 's/ /,/g')

sops --pgp "$fpr" "$@"
</file>

<file path="pkgs/sops-install-secrets/test-assets/ssh-ed25519-key.pub">
ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIBI1+Q+ntzANebtnicCiAY29uqLGWOaOGLEa8bUqOVmS
</file>

<file path="pkgs/sops-install-secrets/test-assets/ssh-key.asc">
-----BEGIN PGP PRIVATE KEY BLOCK-----

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
=WFkZ
-----END PGP PRIVATE KEY BLOCK-----
</file>

<file path="pkgs/sops-install-secrets/test-assets/ssh-key.pub">
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDtwQhY3uyYF0EtACthbkam7TA672VqWH6epfX/m6KqVTbqozHstCp6CRuBhGxTtkHQNbf38iQkwePPaqXQWMD1ahyKmgUg1LNek1At6X+Q4kOHTKyS8ygbavKy7MhGT8TE3fG/M1PZoz58tw7Coe0tLlQh+wPnIFEhBeR15ZxZAaJWbxYXnvijbXwkxDV/KJ9itElmH3SpkOyhUhZCThWsORNF9ipbZVwiVRwOjoOdHISZUrUvcamhxxt8TM8sKWzao2GXnQTiMvf8xMfyAtHLGBdPpiVcSym2FvjPqRSmKoVFDFwsNQMfcDv1eSH1/c5art14KyKwuJpkiJUPWwfdppdjHbBV26moE+4YvMi04Z7tw2RMi0x8tXaiYxwhNvyDVqBdSD56AjckTmHo5dZCjbcsV00gzDiVZlWgP8RCzr55BJlMVjKLM6YkzVZl+c5kJorsfL3NyohxC/hrIwItQoqJW9XtA/rSd9/1AdkrE+iPahsCQQ1ZhH0KiUr00Pk= joerg@turingmachine
</file>

<file path="pkgs/sops-install-secrets/.envrc">
use nix
</file>

<file path="pkgs/sops-install-secrets/darwin.go">
//go:build darwin
// +build darwin

package main

import (
	"errors"
	"fmt"
	"os"
	"os/exec"
	"strings"
)

func RuntimeDir() (string, error) {
	// TODO this could be garbage collected on a 3d basis
	out, err := exec.Command("getconf", "DARWIN_USER_TEMP_DIR").Output()
	rundir := strings.TrimRight(string(out[:]), " \t\n")
	if err != nil {
		return "", fmt.Errorf("cannot get DARWIN_USER_TEMP_DIR: %v", err)
	}
	return strings.TrimSuffix(rundir, "/"), nil
}

// Does:
// mkdir /tmp/mymount
// NUMSECTORS=128000       # a sector is 512 bytes
// mydev=`hdiutil attach -nomount ram://$NUMSECTORS`
// newfs_hfs $mydev
// mount -t hfs $mydev /tmp/mymount
func MountSecretFs(mountpoint string, keysGID int, _useTmpfs bool, userMode bool) error {
	if err := os.MkdirAll(mountpoint, 0o751); err != nil {
		return fmt.Errorf("cannot create directory '%s': %w", mountpoint, err)
	}
	if _, err := os.Stat(mountpoint + "/sops-nix-secretfs"); !errors.Is(err, os.ErrNotExist) {
		return nil // secret fs already exists
	}

	// MacOS/darwin options for temporary files:
	// - /tmp or NSTemporaryDirectory is persistent, and regularly wiped from files not touched >3d
	//   https://wiki.lazarus.freepascal.org/Locating_the_macOS_tmp_directory
	// - there is no ramfs, also `man statfs` doesn't have flags for memfs things
	// - we can allocate and mount statically allocated memory (ram://), however most
	//   functions for that are not publicly exposed to userspace.
	mb := 64                       // size in MB
	size := mb * 1024 * 1024 / 512 // size in sectors a 512 bytes
	cmd := exec.Command("hdiutil", "attach", "-nomount", fmt.Sprintf("ram://%d", int(size)))
	out, err := cmd.Output() // /dev/diskN
	if err != nil {
		return fmt.Errorf("cannot execute hdiutil: %w", err)
	}
	diskpath := strings.TrimRight(string(out[:]), " \t\n")

	// format as hfs
	_, err = exec.Command("newfs_hfs", "-s", diskpath).Output()
	if err != nil {
		return fmt.Errorf("cannot create hfs filesystem at '%s': %w", diskpath, err)
	}

	// "posix" mount takes `struct hfs_mount_args` which we dont have bindings for at hand.
	// See https://stackoverflow.com/a/49048846/4108673
	// err = unix.Mount("hfs", mountpoint, unix.MNT_NOEXEC|unix.MNT_NODEV, mount_args)
	// Instead we call:
	_, err = exec.Command("mount", "-t", "hfs", "-o", "nobrowse,nodev,nosuid,-m=0751", diskpath, mountpoint).Output()
	if err != nil {
		return fmt.Errorf("cannot mount '%s' to '%s': %w", diskpath, mountpoint, err)
	}

	// There is no documented way to check for memfs mountpoint. Thus we place a file.
	path := mountpoint + "/sops-nix-secretfs"
	_, err = os.Create(path)
	if err != nil {
		return fmt.Errorf("cannot create file '%s': %w", path, err)
	}

	// This would be the way to check on unix.
	//buf := unix.Statfs_t{}
	//if err := unix.Statfs(mountpoint, &buf); err != nil {
	//	return fmt.Errorf("Cannot get statfs for directory '%s': %w", mountpoint, err)
	//}
	//
	//if int32(buf.Type) != RAMFS_MAGIC {
	//	if err := unix.Mount("none", mountpoint, "ramfs", unix.MS_NODEV|unix.MS_NOSUID, "mode=0751"); err != nil {
	//		return fmt.Errorf("Cannot mount: %s", err)
	//	}
	//}

	if !userMode {
		if err := os.Chown(mountpoint, 0, int(keysGID)); err != nil {
			return fmt.Errorf("cannot change owner/group of '%s' to 0/%d: %w", mountpoint, keysGID, err)
		}
	}

	return nil
}
</file>

<file path="pkgs/sops-install-secrets/default.nix">
{
  lib,
  buildGo124Module,
  stdenv,
  vendorHash,
  go,
}:
buildGo124Module {
  pname = "sops-install-secrets";
  version = "0.0.1";

  src = lib.sourceByRegex ../.. [
    "go\.(mod|sum)"
    "pkgs"
    "pkgs/sops-install-secrets.*"
  ];

  subPackages = [ "pkgs/sops-install-secrets" ];

  # requires root privileges for tests
  doCheck = false;

  outputs = [ "out" ] ++ lib.optional stdenv.isLinux "unittest";

  postInstall =
    ''
      go test -c ./pkgs/sops-install-secrets
    ''
    + lib.optionalString stdenv.isLinux ''
      # *.test is only tested on linux. $unittest does not exist on darwin.
      install -D ./sops-install-secrets.test $unittest/bin/sops-install-secrets.test
      # newer versions of nixpkgs no longer require this step
      if command -v remove-references-to >/dev/null; then
        remove-references-to -t ${go} $unittest/bin/sops-install-secrets.test
      fi
    '';

  inherit vendorHash;

  meta = with lib; {
    description = "Atomic secret provisioning based on sops";
    homepage = "https://github.com/Mic92/sops-nix";
    license = licenses.mit;
    maintainers = with maintainers; [ mic92 ];
    platforms = platforms.linux ++ platforms.darwin;
  };
}
</file>

<file path="pkgs/sops-install-secrets/linux.go">
//go:build linux
// +build linux

package main

import (
	"errors"
	"fmt"
	"os"

	"golang.org/x/sys/unix"
	"github.com/moby/sys/mountinfo"
)

func RuntimeDir() (string, error) {
	rundir, ok := os.LookupEnv("XDG_RUNTIME_DIR")
	if !ok {
		return "", fmt.Errorf("$XDG_RUNTIME_DIR is not set")
	}
	return rundir, nil
}

func MountSecretFs(mountpoint string, keysGID int, useTmpfs bool, userMode bool) error {
	if err := os.MkdirAll(mountpoint, 0o751); err != nil {
		return fmt.Errorf("cannot create directory '%s': %w", mountpoint, err)
	}

	// We can't create a ramfs as user
	if userMode {
		return nil
	}

	var fstype = "ramfs"
	var fsmagic = RamfsMagic
	var fsoptions = "mode=0751"
	if useTmpfs {
		fstype = "tmpfs"
		fsmagic = TmpfsMagic
		fsoptions += ",noswap"
	}

	buf := unix.Statfs_t{}
	if err := unix.Statfs(mountpoint, &buf); err != nil {
		return fmt.Errorf("cannot get statfs for directory '%s': %w", mountpoint, err)
	}
	mounted, err := mountinfo.Mounted(mountpoint)
	if err != nil {
		return fmt.Errorf("cannot check if directory '%s' is a mountpoint: %w", mountpoint, err)
	}
	if !mounted || int32(buf.Type) != fsmagic {
		flags := uintptr(unix.MS_NODEV | unix.MS_NOSUID | unix.MS_NOEXEC)
		if err := unix.Mount("none", mountpoint, fstype, flags, fsoptions); err != nil {
			if useTmpfs && errors.Is(err, unix.EINVAL) {
				if err := unix.Mount("none", mountpoint, fstype, flags, "mode=0751"); err != nil {
					return fmt.Errorf("cannot mount (fallback without noswap failed): %w", err)
				}
			} else {
				return fmt.Errorf("cannot mount: %w", err)
			}
		}
	}

	if err := os.Chown(mountpoint, 0, int(keysGID)); err != nil {
		return fmt.Errorf("cannot change owner/group of '%s' to 0/%d: %w", mountpoint, keysGID, err)
	}

	return nil
}
</file>

<file path="pkgs/sops-install-secrets/main_test.go">
//go:build linux || darwin
// +build linux darwin

package main

import (
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"os/user"
	"path"
	"path/filepath"
	"reflect"
	"runtime"
	"strconv"
	"strings"
	"syscall"
	"testing"
)

// ok fails the test if an err is not nil.
func ok(tb testing.TB, err error) {
	if err != nil {
		_, file, line, _ := runtime.Caller(1)
		fmt.Printf("\033[31m%s:%d: unexpected error: %s\033[39m\n\n", filepath.Base(file), line, err.Error())
		tb.FailNow()
	}
}

func equals(tb testing.TB, exp, act interface{}) {
	if !reflect.DeepEqual(exp, act) {
		_, file, line, _ := runtime.Caller(1)
		fmt.Printf("\033[31m%s:%d:\n\n\texp: %#v\n\n\tgot: %#v\033[39m\n\n", filepath.Base(file), line, exp, act)
		tb.FailNow()
	}
}

func writeManifest(t *testing.T, dir string, m *manifest) string {
	filename := path.Join(dir, "manifest.json")
	f, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE, 0o755)
	ok(t, err)
	encoder := json.NewEncoder(f)
	ok(t, encoder.Encode(m))
	_ = f.Close()
	return filename
}

func testAssetPath() string {
	assets := os.Getenv("TEST_ASSETS")
	if assets != "" {
		return assets
	}
	_, filename, _, _ := runtime.Caller(0)
	return path.Join(path.Dir(filename), "test-assets")
}

type testDir struct {
	path, secretsPath, symlinkPath string
}

func (dir testDir) Remove() {
	_ = os.RemoveAll(dir.path)
}

func newTestDir(t *testing.T) testDir {
	tempdir, err := os.MkdirTemp("", "symlinkDir")
	ok(t, err)
	return testDir{tempdir, path.Join(tempdir, "secrets.d"), path.Join(tempdir, "secrets")}
}

func testInstallSecret(t *testing.T, testdir testDir, m *manifest) {
	path := writeManifest(t, testdir.path, m)
	ok(t, installSecrets([]string{"sops-install-secrets", path}))
}

func testGPG(t *testing.T) {
	assets := testAssetPath()

	testdir := newTestDir(t)
	defer testdir.Remove()
	gpgHome := path.Join(testdir.path, "gpg-home")
	gpgEnv := append(os.Environ(), fmt.Sprintf("GNUPGHOME=%s", gpgHome))

	ok(t, os.Mkdir(gpgHome, os.FileMode(0o700)))
	cmd := exec.Command("gpg", "--import", path.Join(assets, "key.asc")) // nolint:gosec
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	cmd.Env = gpgEnv
	ok(t, cmd.Run())
	stopGpgCmd := exec.Command("gpgconf", "--kill", "gpg-agent")
	stopGpgCmd.Stdout = os.Stdout
	stopGpgCmd.Stderr = os.Stderr
	stopGpgCmd.Env = gpgEnv
	defer func() {
		if err := stopGpgCmd.Run(); err != nil {
			fmt.Printf("failed to stop gpg-agent: %s\n", err)
		}
	}()

	nobody := "nobody"
	nogroup := "nogroup"
	// should create a symlink
	yamlSecret := secret{
		Name:         "test",
		Key:          "test_key",
		Owner:        &nobody,
		Group:        &nogroup,
		SopsFile:     path.Join(assets, "secrets.yaml"),
		Path:         path.Join(testdir.path, "test-target"),
		Mode:         "0400",
		RestartUnits: []string{"affected-service"},
		ReloadUnits:  []string{"affected-reload-service"},
	}

	var jsonSecret, binarySecret, dotenvSecret, iniSecret secret
	root := "root"
	// should not create a symlink
	jsonSecret = yamlSecret
	jsonSecret.Name = "test2"
	jsonSecret.Owner = &root
	jsonSecret.Format = "json"
	jsonSecret.Group = &root
	jsonSecret.SopsFile = path.Join(assets, "secrets.json")
	jsonSecret.Path = path.Join(testdir.secretsPath, "test2")
	jsonSecret.Mode = "0700"

	binarySecret = yamlSecret
	binarySecret.Name = "test3"
	binarySecret.Format = "binary"
	binarySecret.SopsFile = path.Join(assets, "secrets.bin")
	binarySecret.Path = path.Join(testdir.secretsPath, "test3")

	dotenvSecret = yamlSecret
	dotenvSecret.Name = "test4"
	dotenvSecret.Owner = &root
	dotenvSecret.Group = &root
	dotenvSecret.Format = "dotenv"
	dotenvSecret.SopsFile = path.Join(assets, "secrets.env")
	dotenvSecret.Path = path.Join(testdir.secretsPath, "test4")

	iniSecret = yamlSecret
	iniSecret.Name = "test5"
	iniSecret.Owner = &root
	iniSecret.Group = &root
	iniSecret.Format = "ini"
	iniSecret.SopsFile = path.Join(assets, "secrets.ini")
	iniSecret.Path = path.Join(testdir.secretsPath, "test5")

	manifest := manifest{
		Secrets:           []secret{yamlSecret, jsonSecret, binarySecret, dotenvSecret, iniSecret},
		SecretsMountPoint: testdir.secretsPath,
		SymlinkPath:       testdir.symlinkPath,
		GnupgHome:         gpgHome,
	}

	testInstallSecret(t, testdir, &manifest)

	_, err := os.Stat(manifest.SecretsMountPoint)
	ok(t, err)

	_, err = os.Stat(manifest.SymlinkPath)
	ok(t, err)

	yamlLinkStat, err := os.Lstat(yamlSecret.Path)
	ok(t, err)

	equals(t, os.ModeSymlink, yamlLinkStat.Mode()&os.ModeSymlink)

	yamlStat, err := os.Stat(yamlSecret.Path)
	ok(t, err)

	equals(t, true, yamlStat.Mode().IsRegular())
	equals(t, 0o400, int(yamlStat.Mode().Perm()))
	stat, success := yamlStat.Sys().(*syscall.Stat_t)
	equals(t, true, success)
	content, err := os.ReadFile(yamlSecret.Path)
	ok(t, err)
	equals(t, "test_value", string(content))

	u, err := user.LookupId(strconv.Itoa(int(stat.Uid)))
	ok(t, err)
	equals(t, "nobody", u.Username)

	g, err := user.LookupGroupId(strconv.Itoa(int(stat.Gid)))
	ok(t, err)
	equals(t, "nogroup", g.Name)

	jsonStat, err := os.Stat(jsonSecret.Path)
	ok(t, err)
	equals(t, true, jsonStat.Mode().IsRegular())
	equals(t, 0o700, int(jsonStat.Mode().Perm()))
	if stat, ok := jsonStat.Sys().(*syscall.Stat_t); ok {
		equals(t, 0, int(stat.Uid))
		equals(t, 0, int(stat.Gid))
	}

	content, err = os.ReadFile(binarySecret.Path)
	ok(t, err)
	equals(t, 13, len(content))

	testInstallSecret(t, testdir, &manifest)

	target, err := os.Readlink(testdir.symlinkPath)
	ok(t, err)
	equals(t, path.Join(testdir.secretsPath, "2"), target)
}

func testSSHKey(t *testing.T) {
	assets := testAssetPath()

	testdir := newTestDir(t)
	defer testdir.Remove()

	target := path.Join(testdir.path, "existing-target")
	file, err := os.Create(target)
	ok(t, err)
	_ = file.Close()

	nobody := "nobody"
	nogroup := "nogroup"
	s := secret{
		Name:         "test",
		Key:          "test_key",
		Owner:        &nobody,
		Group:        &nogroup,
		SopsFile:     path.Join(assets, "secrets.yaml"),
		Path:         target,
		Mode:         "0400",
		RestartUnits: []string{"affected-service"},
		ReloadUnits:  []string{"affected-reload-service"},
	}

	m := manifest{
		Secrets:           []secret{s},
		SecretsMountPoint: testdir.secretsPath,
		SymlinkPath:       testdir.symlinkPath,
		SSHKeyPaths:       []string{path.Join(assets, "ssh-key")},
	}

	testInstallSecret(t, testdir, &m)
}

func TestAge(t *testing.T) {
	assets := testAssetPath()

	testdir := newTestDir(t)
	defer testdir.Remove()

	target := path.Join(testdir.path, "existing-target")
	file, err := os.Create(target)
	ok(t, err)
	_ = file.Close()

	nobody := "nobody"
	nogroup := "nogroup"
	s := secret{
		Name:         "test",
		Key:          "test_key",
		Owner:        &nobody,
		Group:        &nogroup,
		SopsFile:     path.Join(assets, "secrets.yaml"),
		Path:         target,
		Mode:         "0400",
		RestartUnits: []string{"affected-service"},
		ReloadUnits:  []string{"affected-reload-service"},
	}

	m := manifest{
		Secrets:           []secret{s},
		SecretsMountPoint: testdir.secretsPath,
		SymlinkPath:       testdir.symlinkPath,
		AgeKeyFile:        path.Join(assets, "age-keys.txt"),
	}

	testInstallSecret(t, testdir, &m)
}

func TestAgeWithSSH(t *testing.T) {
	assets := testAssetPath()

	testdir := newTestDir(t)
	defer testdir.Remove()

	target := path.Join(testdir.path, "existing-target")
	file, err := os.Create(target)
	ok(t, err)
	_ = file.Close()

	nobody := "nobody"
	nogroup := "nogroup"
	s := secret{
		Name:         "test",
		Key:          "test_key",
		Owner:        &nobody,
		Group:        &nogroup,
		SopsFile:     path.Join(assets, "secrets.yaml"),
		Path:         target,
		Mode:         "0400",
		RestartUnits: []string{"affected-service"},
		ReloadUnits:  []string{"affected-reload-service"},
	}

	m := manifest{
		Secrets:           []secret{s},
		SecretsMountPoint: testdir.secretsPath,
		SymlinkPath:       testdir.symlinkPath,
		AgeSSHKeyPaths:    []string{path.Join(assets, "ssh-ed25519-key")},
	}

	testInstallSecret(t, testdir, &m)
}

func TestAll(t *testing.T) {
	// we can't test in parallel because we rely on GNUPGHOME environment variable
	testGPG(t)
	testSSHKey(t)
}

func TestValidateManifest(t *testing.T) {
	assets := testAssetPath()

	testdir := newTestDir(t)
	defer testdir.Remove()

	nobody := "nobody"
	nogroup := "nogroup"
	s := secret{
		Name:         "test",
		Key:          "test_key",
		Owner:        &nobody,
		Group:        &nogroup,
		SopsFile:     path.Join(assets, "secrets.yaml"),
		Path:         path.Join(testdir.path, "test-target"),
		Mode:         "0400",
		RestartUnits: []string{},
		ReloadUnits:  []string{},
	}

	m := manifest{
		Secrets:           []secret{s},
		SecretsMountPoint: testdir.secretsPath,
		SymlinkPath:       testdir.symlinkPath,
		SSHKeyPaths:       []string{"non-existing-key"},
	}

	path := writeManifest(t, testdir.path, &m)

	ok(t, installSecrets([]string{"sops-install-secrets", "-check-mode=manifest", path}))
	ok(t, installSecrets([]string{"sops-install-secrets", "-check-mode=sopsfile", path}))
}

func TestIsValidFormat(t *testing.T) {
	generateCase := func(input string, mustBe bool) {
		result := IsValidFormat(input)
		if result != mustBe {
			t.Errorf("input %s must return %v but returned %v", input, mustBe, result)
		}
	}
	for _, format := range []string{string(Yaml), string(JSON), string(Binary), string(Dotenv)} {
		generateCase(format, true)
		generateCase(strings.ToUpper(format), false)
	}
}
</file>

<file path="pkgs/sops-install-secrets/main.go">
package main

import (
	"bytes"
	"encoding/hex"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"os"
	"os/user"
	"path"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
	"syscall"
	"time"

	"github.com/Mic92/sops-nix/pkgs/sops-install-secrets/sshkeys"
	agessh "github.com/Mic92/ssh-to-age"

	"github.com/getsops/sops/v3/decrypt"
	"github.com/joho/godotenv"
	"github.com/mozilla-services/yaml"
	"gopkg.in/ini.v1"
)

type secret struct {
	Name         string     `json:"name"`
	Key          string     `json:"key"`
	Path         string     `json:"path"`
	Owner        *string    `json:"owner,omitempty"`
	UID          int        `json:"uid"`
	Group        *string    `json:"group,omitempty"`
	GID          int        `json:"gid"`
	SopsFile     string     `json:"sopsFile"`
	Format       FormatType `json:"format"`
	Mode         string     `json:"mode"`
	RestartUnits []string   `json:"restartUnits"`
	ReloadUnits  []string   `json:"reloadUnits"`
	value        []byte
	mode         os.FileMode
	owner        int
	group        int
}

type loggingConfig struct {
	KeyImport     bool `json:"keyImport"`
	SecretChanges bool `json:"secretChanges"`
}

type template struct {
	Name         string   `json:"name"`
	Content      string   `json:"content"`
	Path         string   `json:"path"`
	Mode         string   `json:"mode"`
	Owner        *string  `json:"owner,omitempty"`
	UID          int      `json:"uid"`
	Group        *string  `json:"group,omitempty"`
	GID          int      `json:"gid"`
	File         string   `json:"file"`
	RestartUnits []string `json:"restartUnits"`
	ReloadUnits  []string `json:"reloadUnits"`
	value        []byte
	mode         os.FileMode
	content      string
	owner        int
	group        int
}

type manifest struct {
	Secrets                 []secret          `json:"secrets"`
	Templates               []template        `json:"templates"`
	PlaceholderBySecretName map[string]string `json:"placeholderBySecretName"`
	SecretsMountPoint       string            `json:"secretsMountPoint"`
	SymlinkPath             string            `json:"symlinkPath"`
	KeepGenerations         int               `json:"keepGenerations"`
	SSHKeyPaths             []string          `json:"sshKeyPaths"`
	GnupgHome               string            `json:"gnupgHome"`
	AgeKeyFile              string            `json:"ageKeyFile"`
	AgeSSHKeyPaths          []string          `json:"ageSshKeyPaths"`
	UseTmpfs                bool              `json:"useTmpfs"`
	UserMode                bool              `json:"userMode"`
	Logging                 loggingConfig     `json:"logging"`
}

type secretFile struct {
	cipherText []byte
	keys       map[string]interface{}
	/// First secret that defined this secretFile, used for error messages
	firstSecret *secret
}

type FormatType string

const (
	Yaml   FormatType = "yaml"
	JSON   FormatType = "json"
	Binary FormatType = "binary"
	Dotenv FormatType = "dotenv"
	Ini    FormatType = "ini"
)

func IsValidFormat(format string) bool {
	switch format {
	case string(Yaml),
		string(JSON),
		string(Binary),
		string(Dotenv),
		string(Ini):
		return true
	default:
		return false
	}
}

func (f *FormatType) UnmarshalJSON(b []byte) error {
	var s string
	if err := json.Unmarshal(b, &s); err != nil {
		return err
	}
	t := FormatType(s)
	switch t {
	case "":
		*f = Yaml
	case Yaml, JSON, Binary, Dotenv, Ini:
		*f = t
	}

	return nil
}

func (f FormatType) MarshalJSON() ([]byte, error) {
	return json.Marshal(string(f))
}

type CheckMode string

const (
	Manifest CheckMode = "manifest"
	SopsFile CheckMode = "sopsfile"
	Off      CheckMode = "off"
)

type options struct {
	checkMode    CheckMode
	manifest     string
	ignorePasswd bool
}

type appContext struct {
	manifest            manifest
	secretFiles         map[string]secretFile
	secretByPlaceholder map[string]*secret
	checkMode           CheckMode
	ignorePasswd        bool
}

// Keep this in sync with `modules/sops/templates/default.nix`
const RenderedSubdir string = "rendered"

func readManifest(path string) (*manifest, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, fmt.Errorf("failed to open manifest: %w", err)
	}
	defer func() { _ = file.Close() }()
	dec := json.NewDecoder(file)
	var m manifest
	if err := dec.Decode(&m); err != nil {
		return nil, fmt.Errorf("failed to parse manifest: %w", err)
	}
	return &m, nil
}

func linksAreEqual(linkTarget, targetFile string, info os.FileInfo, owner int, group int) bool {
	validUG := true
	if stat, ok := info.Sys().(*syscall.Stat_t); ok {
		validUG = validUG && int(stat.Uid) == owner
		validUG = validUG && int(stat.Gid) == group
	} else {
		panic("Failed to cast fileInfo Sys() to *syscall.Stat_t. This is possibly an unsupported OS.")
	}
	return linkTarget == targetFile && validUG
}

func SecureSymlinkChown(targetFile string, path string, owner int, group int) error {
	// Create a temp directory to house the symlink while we change it's
	// ownership. `os.MkdirTemp` creates a directory with the permissions 0700.
	// The temp dir is created in the same parent directory of the final
	// symlink, because the later `os.Rename` operation won't work across disk
	// devices.
	dir, err := os.MkdirTemp(filepath.Dir(path), "")
	if err != nil {
		return fmt.Errorf("cannot create temporary symlink directory: %w", err)
	}
	defer func() { _ = os.RemoveAll(dir) }()

	// Create symlink to `targetFile` in the temp dir, before chowning it.
	tmpSymlink := filepath.Join(dir, filepath.Base(path))
	if err = os.Symlink(targetFile, tmpSymlink); err != nil {
		return fmt.Errorf(
			"cannot create symlink '%s' (pointing to '%s'): %w", path, targetFile, err)
	}

	err = os.Lchown(tmpSymlink, owner, group)
	if err != nil {
		return fmt.Errorf(
			"cannot change owner of symlink '%s' (pointing to '%s') to owner/group: %d/%d: %w",
			tmpSymlink, targetFile, owner, group, err)
	}

	// Move the chowned symlink to it's final location.
	err = os.Rename(tmpSymlink, path)
	if err != nil {
		return fmt.Errorf("cannot move symlink '%s' to '%s': %w", tmpSymlink, path, err)
	}
	return nil
}

func createSymlink(targetFile string, path string, owner int, group int, userMode bool) error {
	for {
		stat, err := os.Lstat(path)
		if os.IsNotExist(err) {
			if !userMode {
				if err = SecureSymlinkChown(targetFile, path, owner, group); err != nil {
					return fmt.Errorf("cannot chown symlink '%s': %w", path, err)
				}
			} else if err = os.Symlink(targetFile, path); err != nil {
				return fmt.Errorf("cannot create symlink '%s': %w", path, err)
			}
			return nil
		} else if err != nil {
			return fmt.Errorf("cannot stat '%s': %w", path, err)
		}
		if stat.Mode()&os.ModeSymlink == os.ModeSymlink {
			linkTarget, err := os.Readlink(path)
			if os.IsNotExist(err) {
				continue
			} else if err != nil {
				return fmt.Errorf("cannot read symlink '%s': %w", path, err)
			} else if linksAreEqual(linkTarget, targetFile, stat, owner, group) {
				return nil
			}
		}
		if err := os.Remove(path); err != nil {
			return fmt.Errorf("cannot override %s: %w", path, err)
		}
	}
}

func symlinkSecretsAndTemplates(targetDir string, secrets []secret, templates []template, userMode bool) error {
	for _, secret := range secrets {
		targetFile := filepath.Join(targetDir, secret.Name)
		if targetFile == secret.Path {
			continue
		}
		parent := filepath.Dir(secret.Path)
		if err := os.MkdirAll(parent, os.ModePerm); err != nil {
			return fmt.Errorf("cannot create parent directory of '%s': %w", secret.Path, err)
		}
		if err := createSymlink(targetFile, secret.Path, secret.owner, secret.group, userMode); err != nil {
			return fmt.Errorf("failed to symlink secret '%s': %w", secret.Path, err)
		}
	}

	for _, template := range templates {
		targetFile := filepath.Join(targetDir, RenderedSubdir, template.Name)
		if targetFile == template.Path {
			continue
		}
		parent := filepath.Dir(template.Path)
		if err := os.MkdirAll(parent, os.ModePerm); err != nil {
			return fmt.Errorf("cannot create parent directory of '%s': %w", template.Path, err)
		}
		if err := createSymlink(targetFile, template.Path, template.owner, template.group, userMode); err != nil {
			return fmt.Errorf("failed to symlink template '%s': %w", template.Path, err)
		}
	}

	return nil
}

type plainData struct {
	data   map[string]interface{}
	binary []byte
}

func recurseSecretKey(keys map[string]interface{}, wantedKey string) (string, error) {
	var val interface{}
	var ok bool
	currentKey := wantedKey
	currentData := keys
	keyUntilNow := ""

	for {
		slashIndex := strings.IndexByte(currentKey, '/')
		if slashIndex == -1 {
			// We got to the end
			val, ok = currentData[currentKey]
			if !ok {
				if keyUntilNow != "" {
					keyUntilNow += "/"
				}
				return "", fmt.Errorf("the key '%s%s' cannot be found", keyUntilNow, currentKey)
			}
			break
		}
		thisKey := currentKey[:slashIndex]
		if keyUntilNow == "" {
			keyUntilNow = thisKey
		} else {
			keyUntilNow += "/" + thisKey
		}
		currentKey = currentKey[(slashIndex + 1):]
		val, ok = currentData[thisKey]
		if !ok {
			return "", fmt.Errorf("the key '%s' cannot be found", keyUntilNow)
		}
		var valWithWrongType map[interface{}]interface{}
		valWithWrongType, ok = val.(map[interface{}]interface{})
		if !ok {
			return "", fmt.Errorf("key '%s' does not refer to a dictionary", keyUntilNow)
		}
		currentData = make(map[string]interface{})
		for key, value := range valWithWrongType {
			currentData[key.(string)] = value
		}
	}

	strVal, ok := val.(string)
	if !ok {
		return "", fmt.Errorf("the value of key '%s' is not a string", keyUntilNow)
	}
	return strVal, nil
}

func decryptSecret(s *secret, sourceFiles map[string]plainData) error {
	sourceFile := sourceFiles[s.SopsFile]
	if sourceFile.data == nil || sourceFile.binary == nil {
		plain, err := decrypt.File(s.SopsFile, string(s.Format))
		if err != nil {
			return fmt.Errorf("failed to decrypt '%s': %w", s.SopsFile, err)
		}

		switch s.Format {
		case Binary, Dotenv, Ini:
			sourceFile.binary = plain
		case Yaml:
			if s.Key == "" {
				sourceFile.binary = plain
			} else {
				if err := yaml.Unmarshal(plain, &sourceFile.data); err != nil {
					return fmt.Errorf("cannot parse yaml of '%s': %w", s.SopsFile, err)
				}
			}
		case JSON:
			if s.Key == "" {
				sourceFile.binary = plain
			} else {
				if err := json.Unmarshal(plain, &sourceFile.data); err != nil {
					return fmt.Errorf("cannot parse json of '%s': %w", s.SopsFile, err)
				}
			}
		default:
			return fmt.Errorf("secret of type %s in %s is not supported", s.Format, s.SopsFile)
		}
	}
	switch s.Format {
	case Binary, Dotenv, Ini:
		s.value = sourceFile.binary
	case Yaml, JSON:
		if s.Key == "" {
			s.value = sourceFile.binary
		} else {
			strVal, err := recurseSecretKey(sourceFile.data, s.Key)
			if err != nil {
				return fmt.Errorf("secret %s in %s is not valid: %w", s.Name, s.SopsFile, err)
			}
			s.value = []byte(strVal)
		}
	}
	sourceFiles[s.SopsFile] = sourceFile
	return nil
}

func decryptSecrets(secrets []secret) error {
	sourceFiles := make(map[string]plainData)
	for i := range secrets {
		if err := decryptSecret(&secrets[i], sourceFiles); err != nil {
			return err
		}
	}
	return nil
}

const (
	RamfsMagic int32 = -2054924042
	TmpfsMagic int32 = 16914836
)

func prepareSecretsDir(secretMountpoint string, linkName string, keysGID int, userMode bool) (*string, error) {
	var generation uint64
	linkTarget, err := os.Readlink(linkName)
	if err == nil {
		if strings.HasPrefix(linkTarget, secretMountpoint) {
			targetBasename := filepath.Base(linkTarget)
			generation, err = strconv.ParseUint(targetBasename, 10, 64)
			if err != nil {
				return nil, fmt.Errorf("cannot parse %s of %s as a number: %w", targetBasename, linkTarget, err)
			}
		}
	} else if !os.IsNotExist(err) {
		if _, err2 := os.Lstat(linkName); err2 != nil {
			return nil, fmt.Errorf("cannot access %s: %w", linkName, err)
		}
		// if `/run/secrets` exists, but is not a symlink, we need to remove it
		if err = os.RemoveAll(linkName); err != nil {
			return nil, fmt.Errorf("cannot remove %s: %w", linkName, err)
		}
	}
	generation++
	dir := filepath.Join(secretMountpoint, strconv.Itoa(int(generation)))
	if _, err := os.Stat(dir); !os.IsNotExist(err) {
		if err := os.RemoveAll(dir); err != nil {
			return nil, fmt.Errorf("cannot remove existing %s: %w", dir, err)
		}
	}
	if err := os.Mkdir(dir, os.FileMode(0o751)); err != nil {
		return nil, fmt.Errorf("mkdir(): %w", err)
	}
	if !userMode {
		if err := os.Chown(dir, 0, int(keysGID)); err != nil {
			return nil, fmt.Errorf("cannot change owner/group of '%s' to 0/%d: %w", dir, keysGID, err)
		}
	}
	return &dir, nil
}

func createParentDirs(parent string, target string, keysGID int, userMode bool) error {
	dirs := strings.Split(filepath.Dir(target), "/")
	pathSoFar := parent
	for _, dir := range dirs {
		pathSoFar = filepath.Join(pathSoFar, dir)
		if err := os.MkdirAll(pathSoFar, 0o751); err != nil {
			return fmt.Errorf("cannot create directory '%s' for %s: %w", pathSoFar, filepath.Join(parent, target), err)
		}
		if !userMode {
			if err := os.Chown(pathSoFar, 0, int(keysGID)); err != nil {
				return fmt.Errorf("cannot own directory '%s' for %s: %w", pathSoFar, filepath.Join(parent, target), err)
			}
		}
	}
	return nil
}

func writeSecrets(secretDir string, secrets []secret, keysGID int, userMode bool) error {
	for _, secret := range secrets {
		fp := filepath.Join(secretDir, secret.Name)

		if err := createParentDirs(secretDir, secret.Name, keysGID, userMode); err != nil {
			return err
		}
		if err := os.WriteFile(fp, []byte(secret.value), secret.mode); err != nil {
			return fmt.Errorf("cannot write %s: %w", fp, err)
		}
		if !userMode {
			if err := os.Chown(fp, secret.owner, secret.group); err != nil {
				return fmt.Errorf("cannot change owner/group of '%s' to %d/%d: %w", fp, secret.owner, secret.group, err)
			}
		}
	}
	return nil
}

func lookupGroup(groupname string) (int, error) {
	group, err := user.LookupGroup(groupname)
	if err != nil {
		return 0, fmt.Errorf("failed to lookup 'keys' group: %w", err)
	}
	gid, err := strconv.ParseInt(group.Gid, 10, 64)
	if err != nil {
		return 0, fmt.Errorf("cannot parse keys gid %s: %w", group.Gid, err)
	}
	return int(gid), nil
}

func lookupKeysGroup() (int, error) {
	gid, err1 := lookupGroup("keys")
	if err1 == nil {
		return gid, nil
	}
	gid, err2 := lookupGroup("nogroup")
	if err2 == nil {
		return gid, nil
	}
	return 0, fmt.Errorf("can't find group 'keys' nor 'nogroup' (%w)", err2)
}

func (app *appContext) loadSopsFile(s *secret) (*secretFile, error) {
	if app.checkMode == Manifest {
		return &secretFile{firstSecret: s}, nil
	}

	cipherText, err := os.ReadFile(s.SopsFile)
	if err != nil {
		return nil, fmt.Errorf("failed reading %s: %w", s.SopsFile, err)
	}

	var keys map[string]interface{}

	switch s.Format {
	case Binary:
		if err := json.Unmarshal(cipherText, &keys); err != nil {
			return nil, fmt.Errorf("cannot parse json of '%s': %w", s.SopsFile, err)
		}
		return &secretFile{cipherText: cipherText, firstSecret: s}, nil
	case Yaml:
		if err := yaml.Unmarshal(cipherText, &keys); err != nil {
			return nil, fmt.Errorf("cannot parse yaml of '%s': %w", s.SopsFile, err)
		}
	case Dotenv:
		env, err := godotenv.Unmarshal(string(cipherText))
		if err != nil {
			return nil, fmt.Errorf("cannot parse dotenv of '%s': %w", s.SopsFile, err)
		}
		keys = map[string]interface{}{}
		for k, v := range env {
			keys[k] = v
		}
	case JSON:
		if err := json.Unmarshal(cipherText, &keys); err != nil {
			return nil, fmt.Errorf("cannot parse json of '%s': %w", s.SopsFile, err)
		}
	case Ini:
		_, err := ini.Load(bytes.NewReader(cipherText))
		if err != nil {
			return nil, fmt.Errorf("cannot parse ini of '%s': %w", s.SopsFile, err)
		}
		// TODO: we do not actually check the contents of the ini here...
	}

	return &secretFile{
		cipherText:  cipherText,
		keys:        keys,
		firstSecret: s,
	}, nil
}

func (app *appContext) validateSopsFile(s *secret, file *secretFile) error {
	if file.firstSecret.Format != s.Format {
		return fmt.Errorf("secret %s defined the format of %s as %s, but it was specified as %s in %s before",
			s.Name, s.SopsFile, s.Format,
			file.firstSecret.Format, file.firstSecret.Name)
	}
	if app.checkMode != Manifest && (s.Format != Binary && s.Format != Dotenv && s.Format != Ini) && s.Key != "" {
		_, err := recurseSecretKey(file.keys, s.Key)
		if err != nil {
			return fmt.Errorf("secret %s in %s is not valid: %w", s.Name, s.SopsFile, err)
		}
	}
	return nil
}

func validateMode(mode string) (os.FileMode, error) {
	parsed, err := strconv.ParseUint(mode, 8, 16)
	if err != nil {
		return 0, fmt.Errorf("invalid number in mode: %s: %w", mode, err)
	}
	return os.FileMode(parsed), nil
}

func validateOwner(owner string) (int, error) {
	lookedUp, err := user.Lookup(owner)
	if err != nil {
		return 0, fmt.Errorf("failed to lookup user '%s': %w", owner, err)
	}
	ownerNr, err := strconv.ParseUint(lookedUp.Uid, 10, 64)
	if err != nil {
		return 0, fmt.Errorf("cannot parse uid %s: %w", lookedUp.Uid, err)
	}
	return int(ownerNr), nil
}

func validateGroup(group string) (int, error) {
	lookedUp, err := user.LookupGroup(group)
	if err != nil {
		return 0, fmt.Errorf("failed to lookup group '%s': %w", group, err)
	}
	groupNr, err := strconv.ParseUint(lookedUp.Gid, 10, 64)
	if err != nil {
		return 0, fmt.Errorf("cannot parse gid %s: %w", lookedUp.Gid, err)
	}
	return int(groupNr), nil
}

func (app *appContext) validateSecret(secret *secret) error {
	mode, err := validateMode(secret.Mode)
	if err != nil {
		return err
	}
	secret.mode = mode

	if app.ignorePasswd || os.Getenv("NIXOS_ACTION") == "dry-activate" {
		secret.owner = 0
		secret.group = 0
	} else if app.checkMode == Off || app.ignorePasswd {
		if secret.Owner == nil {
			secret.owner = secret.UID
		} else {
			owner, err := validateOwner(*secret.Owner)
			if err != nil {
				return err
			}
			secret.owner = owner
		}

		if secret.Group == nil {
			secret.group = secret.GID
		} else {
			group, err := validateGroup(*secret.Group)
			if err != nil {
				return err
			}
			secret.group = group
		}
	}

	if secret.Format == "" {
		secret.Format = "yaml"
	}

	if !IsValidFormat(string(secret.Format)) {
		return fmt.Errorf("unsupported format %s for secret %s", secret.Format, secret.Name)
	}

	file, ok := app.secretFiles[secret.SopsFile]
	if !ok {
		maybeFile, err := app.loadSopsFile(secret)
		if err != nil {
			return err
		}
		app.secretFiles[secret.SopsFile] = *maybeFile

		file = *maybeFile
	}

	return app.validateSopsFile(secret, &file)
}

func renderTemplates(templates []template, secretByPlaceholder map[string]*secret) {
	for i := range templates {
		template := &templates[i]
		rendered := renderTemplate(&template.content, secretByPlaceholder)
		template.value = []byte(rendered)
	}
}

func renderTemplate(content *string, secretByPlaceholder map[string]*secret) string {
	rendered := *content
	for placeholder, secret := range secretByPlaceholder {
		rendered = strings.ReplaceAll(rendered, placeholder, string(secret.value))
	}
	return rendered
}

func (app *appContext) validateTemplate(template *template) error {
	mode, err := validateMode(template.Mode)
	if err != nil {
		return err
	}
	template.mode = mode

	if app.ignorePasswd || os.Getenv("NIXOS_ACTION") == "dry-activate" {
		template.owner = 0
		template.group = 0
	} else if app.checkMode == Off || app.ignorePasswd {
		if template.Owner == nil {
			template.owner = template.UID
		} else {
			owner, err := validateOwner(*template.Owner)
			if err != nil {
				return err
			}
			template.owner = owner
		}

		if template.Group == nil {
			template.group = template.GID
		} else {
			group, err := validateGroup(*template.Group)
			if err != nil {
				return err
			}
			template.group = group
		}
	}

	var templateText string
	if template.Content != "" {
		templateText = template.Content
	} else if template.File != "" {
		templateBytes, err := os.ReadFile(template.File)
		if err != nil {
			return fmt.Errorf("cannot read %s: %w", template.File, err)
		}
		templateText = string(templateBytes)
	} else {
		return fmt.Errorf("neither content nor file was specified for template %s", template.Name)
	}

	template.content = templateText

	return nil
}

func (app *appContext) validateManifest() error {
	m := &app.manifest
	if m.GnupgHome != "" {
		errorFmt := "gnupgHome and %s were specified in the manifest. " +
			"Both options are mutually exclusive."
		if len(m.SSHKeyPaths) > 0 {
			return fmt.Errorf(errorFmt, "sshKeyPaths")
		}
		if m.AgeKeyFile != "" {
			return fmt.Errorf(errorFmt, "ageKeyFile")
		}
	}

	for i := range m.Secrets {
		secret := &m.Secrets[i]
		if err := app.validateSecret(secret); err != nil {
			return err
		}

		// The Nix module only defines placeholders for secrets if there are
		// templates.
		if len(m.Templates) > 0 {
			placeholder, present := m.PlaceholderBySecretName[secret.Name]
			if !present {
				return fmt.Errorf("placeholder for %s not found in manifest", secret.Name)
			}

			app.secretByPlaceholder[placeholder] = secret
		}
	}

	for i := range m.Templates {
		template := &m.Templates[i]
		if err := app.validateTemplate(template); err != nil {
			return err
		}
	}
	return nil
}

func atomicSymlink(oldname, newname string) error {
	if err := os.MkdirAll(filepath.Dir(newname), 0o755); err != nil {
		return fmt.Errorf("cannot create directory %s: %w", filepath.Dir(newname), err)
	}

	// Fast path: if newname does not exist yet, we can skip the whole dance
	// below.
	if err := os.Symlink(oldname, newname); err == nil || !os.IsExist(err) {
		return err
	}

	// We need to use ioutil.TempDir, as we cannot overwrite a ioutil.TempFile,
	// and removing+symlinking creates a TOCTOU race.
	d, err := os.MkdirTemp(filepath.Dir(newname), "."+filepath.Base(newname))
	if err != nil {
		return fmt.Errorf("cannot create temporary directory: %w", err)
	}
	defer func() {
		_ = os.RemoveAll(d)
	}()

	symlink := filepath.Join(d, "tmp.symlink")
	if err := os.Symlink(oldname, symlink); err != nil {
		return fmt.Errorf("cannot create symlink %s: %w", symlink, err)
	}

	if err := os.Rename(symlink, newname); err != nil {
		return fmt.Errorf("cannot rename %s to %s: %w", symlink, newname, err)
	}

	return nil
}

func pruneGenerations(secretsMountPoint, secretsDir string, keepGenerations int) error {
	if keepGenerations == 0 {
		return nil // Nothing to prune
	}

	// Prepare our failsafe
	currentGeneration, err := strconv.Atoi(path.Base(secretsDir))
	if err != nil {
		return fmt.Errorf("logic error, current generation is not numeric: %w", err)
	}

	// Read files in the mount directory
	file, err := os.Open(secretsMountPoint)
	if err != nil {
		return fmt.Errorf("cannot open %s: %w", secretsMountPoint, err)
	}
	defer func() { _ = file.Close() }()

	generations, err := file.Readdirnames(0)
	if err != nil {
		return fmt.Errorf("cannot read %s: %w", secretsMountPoint, err)
	}
	for _, generationName := range generations {
		generationNum, err := strconv.Atoi(generationName)
		// Not a number? Not relevant
		if err != nil {
			continue
		}
		// Not strictly necessary but a good failsafe to
		// make sure we don't prune the current generation
		if generationNum == currentGeneration {
			continue
		}
		if currentGeneration-keepGenerations >= generationNum {
			err = os.RemoveAll(path.Join(secretsMountPoint, generationName))
			if err != nil {
				return err
			}
		}
	}

	return nil
}

func importSSHKeys(logcfg loggingConfig, keyPaths []string, gpgHome string) error {
	secringPath := filepath.Join(gpgHome, "secring.gpg")
	pubringPath := filepath.Join(gpgHome, "pubring.gpg")

	secring, err := os.OpenFile(secringPath, os.O_WRONLY|os.O_CREATE, 0o600)
	if err != nil {
		return fmt.Errorf("cannot create %s: %w", secringPath, err)
	}
	defer func() {
		_ = secring.Close()
	}()

	pubring, err := os.OpenFile(pubringPath, os.O_WRONLY|os.O_CREATE, 0o600)
	if err != nil {
		return fmt.Errorf("cannot create %s: %w", pubringPath, err)
	}
	defer func() {
		_ = pubring.Close()
	}()

	for _, p := range keyPaths {
		sshKey, err := os.ReadFile(p)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Cannot read ssh key '%s': %s\n", p, err)
			continue
		}
		gpgKey, err := sshkeys.SSHPrivateKeyToPGP(sshKey)
		if err != nil {
			fmt.Fprintf(os.Stderr, "%s\n", err)
			continue
		}

		if err := gpgKey.SerializePrivate(secring, nil); err != nil {
			fmt.Fprintf(os.Stderr, "Cannot write secring: %s\n", err)
			continue
		}

		if err := gpgKey.Serialize(pubring); err != nil {
			fmt.Fprintf(os.Stderr, "Cannot write pubring: %s\n", err)
			continue
		}

		if logcfg.KeyImport {
			fmt.Printf("%s: Imported %s as GPG key with fingerprint %s\n", path.Base(os.Args[0]), p, hex.EncodeToString(gpgKey.PrimaryKey.Fingerprint[:]))
		}
	}

	return nil
}

func importAgeSSHKeys(logcfg loggingConfig, keyPaths []string, ageFile os.File) {
	for _, p := range keyPaths {
		// Read the key
		sshKey, err := os.ReadFile(p)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Cannot read ssh key '%s': %s\n", p, err)
			continue
		}
		// Convert the key to age
		privKey, pubKey, err := agessh.SSHPrivateKeyToAge(sshKey, []byte{})
		if err != nil {
			fmt.Fprintf(os.Stderr, "Cannot convert ssh key '%s': %s\n", p, err)
			continue
		}
		// Append it to the file
		_, err = ageFile.WriteString(*privKey + "\n")
		if err != nil {
			fmt.Fprintf(os.Stderr, "Cannot write key to age file: %s\n", err)
			continue
		}

		if logcfg.KeyImport {
			fmt.Fprintf(os.Stderr, "%s: Imported %s as age key with fingerprint %s\n", path.Base(os.Args[0]), p, *pubKey)
			continue
		}
	}
}

// Like filepath.Walk but symlink-aware.
// Inspired by https://github.com/facebookarchive/symwalk
func symlinkWalk(filename string, linkDirname string, walkFn filepath.WalkFunc) error {
	symWalkFunc := func(path string, info os.FileInfo, err error) error {
		if fname, err := filepath.Rel(filename, path); err == nil {
			path = filepath.Join(linkDirname, fname)
		} else {
			return err
		}

		if err == nil && info.Mode()&os.ModeSymlink == os.ModeSymlink {
			finalPath, err := filepath.EvalSymlinks(path)
			if err != nil {
				return err
			}
			info, err := os.Lstat(finalPath)
			if err != nil {
				return walkFn(path, info, err)
			}
			if info.IsDir() {
				return symlinkWalk(finalPath, path, walkFn)
			}
		}

		return walkFn(path, info, err)
	}
	return filepath.Walk(filename, symWalkFunc)
}

func handleModifications(isDry bool, logcfg loggingConfig, symlinkPath string, secretDir string, secrets []secret, templates []template) error {
	var restart []string
	var reload []string

	newSecrets := make(map[string]bool)
	modifiedSecrets := make(map[string]bool)
	removedSecrets := make(map[string]bool)

	newTemplates := make(map[string]bool)
	modifiedTemplates := make(map[string]bool)
	removedTemplates := make(map[string]bool)

	// When the symlink path does not exist yet, we are being run in stage-2-init.sh
	// where switch-to-configuration is not run so the services would only be restarted
	// the next time switch-to-configuration is run.
	if _, err := os.Stat(symlinkPath); os.IsNotExist(err) {
		return nil
	}

	// Find modified/new secrets
	for _, secret := range secrets {
		oldPath := filepath.Join(symlinkPath, secret.Name)
		newPath := filepath.Join(secretDir, secret.Name)

		// Read the old file
		oldData, err := os.ReadFile(oldPath)
		if err != nil {
			// File did not exist before or the path changed from a file to a directory or vice versa
			if os.IsNotExist(err) || errors.Is(err, syscall.ENOTDIR) || errors.Is(err, syscall.EISDIR) {
				restart = append(restart, secret.RestartUnits...)
				reload = append(reload, secret.ReloadUnits...)
				newSecrets[secret.Name] = true
				continue
			}
			return err
		}

		// Read the new file
		newData, err := os.ReadFile(newPath)
		if err != nil {
			return err
		}

		if !bytes.Equal(oldData, newData) {
			restart = append(restart, secret.RestartUnits...)
			reload = append(reload, secret.ReloadUnits...)
			modifiedSecrets[secret.Name] = true
		}
	}

	// Find modified/new templates
	for _, template := range templates {
		oldPath := filepath.Join(symlinkPath, RenderedSubdir, template.Name)
		newPath := filepath.Join(secretDir, RenderedSubdir, template.Name)

		// Read the old file
		oldData, err := os.ReadFile(oldPath)
		if err != nil {
			// File did not exist before or the path changed from a file to a directory or vice versa
			if os.IsNotExist(err) || errors.Is(err, syscall.ENOTDIR) || errors.Is(err, syscall.EISDIR) {
				restart = append(restart, template.RestartUnits...)
				reload = append(reload, template.ReloadUnits...)
				newTemplates[template.Name] = true
				continue
			}
			return err
		}

		// Read the new file
		newData, err := os.ReadFile(newPath)
		if err != nil {
			return err
		}

		if !bytes.Equal(oldData, newData) {
			restart = append(restart, template.RestartUnits...)
			reload = append(reload, template.ReloadUnits...)
			modifiedTemplates[template.Name] = true
		}
	}

	writeLines := func(list []string, file string) error {
		if len(list) != 0 {
			if _, err := os.Stat(filepath.Dir(file)); err != nil {
				if os.IsNotExist(err) {
					return nil
				}
				return err
			}
			f, err := os.OpenFile(file, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0o600)
			if err != nil {
				return err
			}
			defer func() { _ = f.Close() }()
			for _, unit := range list {
				if _, err = f.WriteString(unit + "\n"); err != nil {
					return err
				}
			}
		}
		return nil
	}
	var dryPrefix string
	if isDry {
		dryPrefix = "/run/nixos/dry-activation"
	} else {
		dryPrefix = "/run/nixos/activation"
	}
	if err := writeLines(restart, dryPrefix+"-restart-list"); err != nil {
		return err
	}
	if err := writeLines(reload, dryPrefix+"-reload-list"); err != nil {
		return err
	}

	// Do not output changes if not requested
	if !logcfg.SecretChanges {
		return nil
	}

	// Find removed secrets/templates.
	symlinkRenderedPath := filepath.Join(symlinkPath, RenderedSubdir)
	err := symlinkWalk(symlinkPath, symlinkPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() {
			return nil
		}

		// If the path we're looking at isn't in `symlinkRenderedPath`, then
		// it's a secret.
		rel, err := filepath.Rel(symlinkRenderedPath, path)
		if err != nil {
			return err
		}
		isSecret := strings.HasPrefix(rel, "..")

		if isSecret {
			path = strings.TrimPrefix(path, symlinkPath+string(os.PathSeparator))
			for _, secret := range secrets {
				if secret.Name == path {
					return nil
				}
			}
			removedSecrets[path] = true
		} else {
			path = strings.TrimPrefix(path, symlinkRenderedPath+string(os.PathSeparator))
			for _, template := range templates {
				if template.Name == path {
					return nil
				}
			}
			removedTemplates[path] = true
		}
		return nil
	})
	if err != nil {
		return err
	}

	// Output new/modified/removed secrets/templates
	outputChanged := func(noun string, changed map[string]bool, regularPrefix, dryPrefix string) {
		if len(changed) > 0 {
			s := ""
			if len(changed) != 1 {
				s = "s"
			}
			if isDry {
				fmt.Printf("%s %s%s: ", dryPrefix, noun, s)
			} else {
				fmt.Printf("%s %s%s: ", regularPrefix, noun, s)
			}

			// Sort the output for deterministic behavior.
			keys := make([]string, 0, len(changed))
			for key := range changed {
				keys = append(keys, key)
			}
			sort.Strings(keys)

			fmt.Println(strings.Join(keys, ", "))
		}
	}
	outputChanged("secret", newSecrets, "adding", "would add")
	outputChanged("secret", modifiedSecrets, "modifying", "would modify")
	outputChanged("secret", removedSecrets, "removing", "would remove")
	outputChanged("rendered secret", newTemplates, "adding", "would add")
	outputChanged("rendered secret", modifiedTemplates, "modifying", "would modify")
	outputChanged("rendered secret", removedTemplates, "removing", "would remove")

	return nil
}

type keyring struct {
	path string
}

func (k *keyring) Remove() {
	_ = os.RemoveAll(k.path)
	_ = os.Unsetenv("GNUPGHOME")
}

func setupGPGKeyring(logcfg loggingConfig, sshKeys []string, parentDir string) (*keyring, error) {
	dir, err := os.MkdirTemp(parentDir, "gpg")
	if err != nil {
		return nil, fmt.Errorf("cannot create gpg home in '%s': %w", parentDir, err)
	}
	k := keyring{dir}

	if err := importSSHKeys(logcfg, sshKeys, dir); err != nil {
		err = os.RemoveAll(dir)
		return nil, err
	}
	_ = os.Setenv("GNUPGHOME", dir)

	return &k, nil
}

func parseFlags(args []string) (*options, error) {
	var opts options
	fs := flag.NewFlagSet(args[0], flag.ContinueOnError)
	fs.Usage = func() {
		_, err := fmt.Fprintf(flag.CommandLine.Output(), "Usage: %s [OPTION] manifest.json\n", args[0])
		if err != nil {
			return
		}
		fs.PrintDefaults()
	}
	var checkMode string
	fs.StringVar(&checkMode, "check-mode", "off", `Validate configuration without installing it (possible values: "manifest","sopsfile","off")`)
	fs.BoolVar(&opts.ignorePasswd, "ignore-passwd", false, `Don't look up anything in /etc/passwd. Causes everything to be owned by root:root or the user executing the tool in user mode`)
	if err := fs.Parse(args[1:]); err != nil {
		return nil, err
	}

	switch CheckMode(checkMode) {
	case Manifest, SopsFile, Off:
		opts.checkMode = CheckMode(checkMode)
	default:
		return nil, fmt.Errorf("invalid value provided for -check-mode flag: %s", opts.checkMode)
	}

	if fs.NArg() != 1 {
		flag.Usage()
		return nil, flag.ErrHelp
	}
	opts.manifest = fs.Arg(0)
	return &opts, nil
}

func replaceRuntimeDir(path, rundir string) (ret string) {
	parts := strings.Split(path, "%%")
	first := true
	for _, part := range parts {
		if !first {
			ret += "%"
		}
		first = false
		ret += strings.ReplaceAll(part, "%r", rundir)
	}
	return
}

func writeTemplate(targetDir string, template template, keysGID int, userMode bool) error {
	templatePath := filepath.Join(targetDir, template.Name)

	if err := createParentDirs(targetDir, template.Name, keysGID, userMode); err != nil {
		return err
	}

	dir := filepath.Dir(templatePath)
	tempFile, err := os.CreateTemp(dir, "sops-*")
	tempfileRemoved := false
	if err != nil {
		return fmt.Errorf("cannot create temporary file in directory %s: %w", dir, err)
	}
	defer func() {
		_ = tempFile.Close() // noop if already closed

		if !tempfileRemoved {
			if err := os.Remove(tempFile.Name()); err != nil {
				fmt.Fprintf(os.Stderr, "failed to remove temporary file %s: %s\n", tempFile.Name(),
					err)
			}
		}
	}()

	if _, err := tempFile.Write(template.value); err != nil {
		return fmt.Errorf("cannot write to temporary file %s: %w", tempFile.Name(), err)
	}

	if err := tempFile.Chmod(template.mode); err != nil {
		return fmt.Errorf("cannot change mode of temporary file %s to %o: %w", tempFile.Name(), template.mode, err)
	}

	if !userMode {
		if err := tempFile.Chown(template.owner, template.group); err != nil {
			return fmt.Errorf("cannot change owner/group of '%s' to %d/%d: %w", templatePath, template.owner, template.group, err)
		}
	}

	if err := tempFile.Close(); err != nil {
		return fmt.Errorf("cannot close temporary file %s: %w", tempFile.Name(), err)
	}

	if err := os.Rename(tempFile.Name(), templatePath); err != nil {
		return fmt.Errorf("cannot rename temporary file %s to %s: %w", tempFile.Name(), templatePath, err)
	}
	tempfileRemoved = true
	return nil
}

func writeTemplates(targetDir string, templates []template, keysGID int, userMode bool) error {
	for _, template := range templates {
		if err := writeTemplate(targetDir, template, keysGID, userMode); err != nil {
			return err
		}
	}
	return nil
}

func installSecrets(args []string) error {
	opts, err := parseFlags(args)
	if err != nil {
		return err
	}

	manifest, err := readManifest(opts.manifest)
	if err != nil {
		return err
	}

	if manifest.UserMode {
		var rundir string
		rundir, err = RuntimeDir()
		if opts.checkMode == Off && err != nil {
			return fmt.Errorf("cannot figure out runtime directory: %w", err)
		}
		manifest.SecretsMountPoint = replaceRuntimeDir(manifest.SecretsMountPoint, rundir)
		manifest.SymlinkPath = replaceRuntimeDir(manifest.SymlinkPath, rundir)
		var newSecrets []secret
		for _, secret := range manifest.Secrets {
			secret.Path = replaceRuntimeDir(secret.Path, rundir)
			newSecrets = append(newSecrets, secret)
		}
		manifest.Secrets = newSecrets
		var newTemplates []template
		for _, template := range manifest.Templates {
			template.Path = replaceRuntimeDir(template.Path, rundir)
			newTemplates = append(newTemplates, template)
		}
		manifest.Templates = newTemplates
	}

	app := appContext{
		manifest:            *manifest,
		checkMode:           opts.checkMode,
		ignorePasswd:        opts.ignorePasswd,
		secretFiles:         make(map[string]secretFile),
		secretByPlaceholder: make(map[string]*secret),
	}

	if err = app.validateManifest(); err != nil {
		return fmt.Errorf("manifest is not valid: %w", err)
	}

	if app.checkMode != Off {
		return nil
	}

	var keysGID int
	if opts.ignorePasswd {
		keysGID = 0
	} else {
		keysGID, err = lookupKeysGroup()
		if err != nil {
			return err
		}
	}

	isDry := os.Getenv("NIXOS_ACTION") == "dry-activate"

	if err = MountSecretFs(manifest.SecretsMountPoint, keysGID, manifest.UseTmpfs, manifest.UserMode); err != nil {
		return fmt.Errorf("failed to mount filesystem for secrets: %w", err)
	}

	if len(manifest.SSHKeyPaths) != 0 {
		var keyring *keyring
		keyring, err = setupGPGKeyring(manifest.Logging, manifest.SSHKeyPaths, manifest.SecretsMountPoint)
		if err != nil {
			return fmt.Errorf("error setting up gpg keyring: %w", err)
		}
		defer keyring.Remove()
	} else if manifest.GnupgHome != "" {
		err = os.Setenv("GNUPGHOME", manifest.GnupgHome)
		if err != nil {
			return err
		}
	}

	// Import age keys
	if len(manifest.AgeSSHKeyPaths) != 0 || manifest.AgeKeyFile != "" {
		keyfile := filepath.Join(manifest.SecretsMountPoint, "age-keys.txt")
		err = os.Setenv("SOPS_AGE_KEY_FILE", keyfile)
		if err != nil {
			return err
		}

		// Create the keyfile
		var ageFile *os.File
		ageFile, err = os.OpenFile(keyfile, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0o600)
		if err != nil {
			return fmt.Errorf("cannot create '%s': %w", keyfile, err)
		}
		defer func() {
			_ = ageFile.Close()
		}()
		_, err = fmt.Fprintf(ageFile, "# generated by sops-nix at %s\n", time.Now().Format(time.RFC3339))
		if err != nil {
			return err
		}

		// Import SSH keys
		if len(manifest.AgeSSHKeyPaths) != 0 {
			importAgeSSHKeys(manifest.Logging, manifest.AgeSSHKeyPaths, *ageFile)
		}
		// Import the keyfile
		if manifest.AgeKeyFile != "" {
			// Read the keyfile
			var contents []byte
			contents, err = os.ReadFile(manifest.AgeKeyFile)
			if err != nil {
				return fmt.Errorf("cannot read keyfile '%s': %w", manifest.AgeKeyFile, err)
			}
			// Append it to the file
			_, err = ageFile.WriteString(string(contents) + "\n")
			if err != nil {
				return fmt.Errorf("cannot write key to age file: %w", err)
			}
		}
	}

	if err := decryptSecrets(manifest.Secrets); err != nil {
		return err
	}

	// Now that the secrets are decrypted, we can render the templates.
	renderTemplates(manifest.Templates, app.secretByPlaceholder)

	secretDir, err := prepareSecretsDir(manifest.SecretsMountPoint, manifest.SymlinkPath, keysGID, manifest.UserMode)
	if err != nil {
		return fmt.Errorf("failed to prepare new secrets directory: %w", err)
	}
	if err := writeSecrets(*secretDir, manifest.Secrets, keysGID, manifest.UserMode); err != nil {
		return fmt.Errorf("cannot write secrets: %w", err)
	}

	if err := writeTemplates(path.Join(*secretDir, RenderedSubdir), manifest.Templates, keysGID, manifest.UserMode); err != nil {
		return fmt.Errorf("cannot render templates: %w", err)
	}

	if !manifest.UserMode {
		if err := handleModifications(isDry, manifest.Logging, manifest.SymlinkPath, *secretDir, manifest.Secrets, manifest.Templates); err != nil {
			return fmt.Errorf("cannot request units to restart: %w", err)
		}
	}
	// No need to perform the actual symlinking
	if isDry {
		return nil
	}
	if err := symlinkSecretsAndTemplates(manifest.SymlinkPath, manifest.Secrets, manifest.Templates, manifest.UserMode); err != nil {
		return fmt.Errorf("failed to prepare symlinks to secret store: %w", err)
	}
	if err := atomicSymlink(*secretDir, manifest.SymlinkPath); err != nil {
		return fmt.Errorf("cannot update secrets symlink: %w", err)
	}
	if err := pruneGenerations(manifest.SecretsMountPoint, *secretDir, manifest.KeepGenerations); err != nil {
		return fmt.Errorf("cannot prune old secrets generations: %w", err)
	}

	return nil
}

func main() {
	if err := installSecrets(os.Args); err != nil {
		if errors.Is(err, flag.ErrHelp) {
			return
		}
		fmt.Fprintf(os.Stderr, "%s: %s\n", os.Args[0], err)
		os.Exit(1)
	}
}
</file>

<file path="pkgs/sops-install-secrets/shell.nix">
{
  pkgs ? import <nixpkgs> { },
}:
pkgs.mkShell {
  nativeBuildInputs = with pkgs; [
    go
    delve
    util-linux
    gnupg
  ];
}
</file>

<file path="pkgs/sops-pgp-hook/test-assets/keys/key-with-subkeys.asc">
-----BEGIN PGP PUBLIC KEY BLOCK-----

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
W1YR5NNzw2GqjhH3nhj/SnUwXg==
=jshU
-----END PGP PUBLIC KEY BLOCK-----
</file>

<file path="pkgs/sops-pgp-hook/test-assets/keys/key.asc">
../../../sops-install-secrets/test-assets/key.asc
</file>

<file path="pkgs/sops-pgp-hook/test-assets/shell.nix">
# shell.nix
with import <nixpkgs> { };
mkShell {
  sopsPGPKeyDirs = [
    "./keys"
  ];
  sopsPGPKeys = [
    "./existing-key.gpg"
    "./non-existing-key.gpg"
  ];
  nativeBuildInputs = [
    (pkgs.callPackage ../../.. { }).sops-pgp-hook
  ];
}
</file>

<file path="pkgs/sops-pgp-hook/default.nix">
{
  makeSetupHook,
  gnupg,
  sops,
}:

(makeSetupHook {
  name = "sops-pgp-hook";
  substitutions = {
    gpg = "${gnupg}/bin/gpg";
  };
  propagatedBuildInputs = [
    sops
    gnupg
  ];
} ./sops-pgp-hook.bash)
</file>

<file path="pkgs/sops-pgp-hook/hook_test.go">
package main

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"runtime"
	"strings"
	"testing"
)

// ok fails the test if an err is not nil.
func ok(tb testing.TB, err error) {
	if err != nil {
		_, file, line, _ := runtime.Caller(1)
		fmt.Printf("\033[31m%s:%d: unexpected error: %s\033[39m\n\n", filepath.Base(file), line, err.Error())
		tb.FailNow()
	}
}

func TestShellHook(t *testing.T) {
	assets := os.Getenv("TEST_ASSETS")
	if assets == "" {
		_, filename, _, _ := runtime.Caller(0)
		assets = path.Join(path.Dir(filename), "test-assets")
	}
	tempdir, err := os.MkdirTemp("", "testdir")
	ok(t, err)
	defer os.RemoveAll(tempdir)

	cmd := exec.Command("nix-shell", "shell.nix", "--run", "echo SOPS_PGP_FP=$SOPS_PGP_FP")
	cmd.Env = append(os.Environ(), fmt.Sprintf("GNUPGHOME=%s", tempdir))
	var stdoutBuf, stderrBuf bytes.Buffer
	cmd.Stdout = &stdoutBuf
	cmd.Stderr = &stderrBuf
	cmd.Dir = assets
	err = cmd.Run()
	stdout := stdoutBuf.String()
	stderr := stderrBuf.String()
	fmt.Printf("$ %s\nstdout: \n%s\nstderr: \n%s\n", strings.Join(cmd.Args, " "), stdout, stderr)
	ok(t, err)

	expectedKeys := []string{
		"C6DA56E69A7C756564A8AFEB4A6B05B714D13EFD",
		"4EC40F8E04A945339F7F7C0032C5225271038E3F",
		"7FB89715AADA920D65D25E63F9BA9DEBD03F57C0",
		"E3B7464FBE89F5378ED4BC60FC925B42FC8B773D",
	}
	for _, key := range expectedKeys {
		if !strings.Contains(stdout, key) {
			t.Fatalf("'%v' not in '%v'", key, stdout)
		}
	}

	// it should ignore subkeys from ./keys/key-with-subkeys.asc
	subkey := "94F174F588090494E73D0835A79B1680BC4D9A54"
	if strings.Contains(stdout, subkey) {
		t.Fatalf("subkey found in %s", stdout)
	}

	expectedStderr := "./non-existing-key.gpg does not exists"
	if !strings.Contains(stderr, expectedStderr) {
		t.Fatalf("'%v' not in '%v'", expectedStderr, stdout)
	}
}
</file>

<file path="pkgs/sops-pgp-hook/sops-pgp-hook.bash">
_sopsAddKey() {
  @gpg@ --quiet --import "$key"
  local fpr
  # only add the first fingerprint, this way we ignore subkeys
  fpr=$(@gpg@ --with-fingerprint --with-colons --show-key "$key" \
         | awk -F: '$1 == "fpr" { print $10; exit }')
  if [[ $fpr != "" ]]; then
      export SOPS_PGP_FP=''${SOPS_PGP_FP-}''${SOPS_PGP_FP:+','}$fpr
  fi
}

sopsPGPHook() {
  local key dir
  for key in ${sopsPGPKeys-}; do
    if [[ -f "$key" ]]; then
        _sopsAddKey "$key"
    else
        echo "$key does not exists" >&2
    fi
  done
  for dir in ${sopsPGPKeyDirs-}; do
    while IFS= read -r -d '' key; do
      _sopsAddKey "$key"
    done < <(find -L "$dir" -type f \( -name '*.gpg' -o -name '*.asc' \) -print0)
  done
}

if [ -z "${shellHook-}" ]; then
  shellHook=sopsPGPHook
else
  shellHook="sopsPGPHook;${shellHook}"
fi
</file>

<file path="pkgs/cross-build.nix">
{ sops-install-secrets, gox }:

sops-install-secrets.overrideAttrs (old: {
  name = "cross-build";
  nativeBuildInputs = old.nativeBuildInputs ++ [ gox ];
  buildPhase = ''
    (cd pkgs/sops-install-secrets && gox -os linux)
  '';
  doCheck = false;
  installPhase = ''
    touch $out $unittest
  '';
  fixupPhase = ":";
})
</file>

<file path="pkgs/lint.nix">
{
  sops-install-secrets,
  golangci-lint,
}:
sops-install-secrets.overrideAttrs (old: {
  name = "golangci-lint";
  nativeBuildInputs = old.nativeBuildInputs ++ [
    golangci-lint
  ];
  buildPhase = ''
    HOME=$TMPDIR golangci-lint run --timeout 360s
  '';
  doCheck = false;
  installPhase = ''
    touch $out $unittest
  '';
  fixupPhase = ":";
})
</file>

<file path="pkgs/sops-pgp-hook-test.nix">
{ buildGoModule, vendorHash }:

buildGoModule {
  name = "sops-pgp-hook-test";
  src = ../.;
  inherit vendorHash;
  buildPhase = ''
    go test -c ./pkgs/sops-pgp-hook
    install -D sops-pgp-hook.test $out/bin/sops-pgp-hook.test
  '';
}
</file>

<file path="pkgs/unit-tests.nix">
{
  pkgs ? import <nixpkgs> { },
}:
let
  sopsPkgs = import ../. { inherit pkgs; };
in
pkgs.stdenv.mkDerivation {
  name = "env";
  nativeBuildInputs =
    with pkgs;
    [
      bashInteractive
      gnupg
      util-linux
      nix
      sopsPkgs.sops-pgp-hook-test
    ]
    ++ pkgs.lib.optional (pkgs.stdenv.isLinux) sopsPkgs.sops-install-secrets.unittest;
  # allow to prefetch shell dependencies in build phase
  dontUnpack = true;
  installPhase = ''
    echo $nativeBuildInputs > $out
  '';
  shellHook = ''
    set -x
    NIX_PATH=nixpkgs=${toString pkgs.path} TEST_ASSETS=$(realpath ./pkgs/sops-pgp-hook/test-assets) \
      sops-pgp-hook.test
    ${pkgs.lib.optionalString (pkgs.stdenv.isLinux) ''
      sudo TEST_ASSETS=$(realpath ./pkgs/sops-install-secrets/test-assets) \
        unshare --mount --fork sops-install-secrets.test
    ''}
  '';
}
</file>

<file path="scripts/update-vendor-hash.sh">
#!/usr/bin/env nix-shell
#!nix-shell -i bash -p nix -p coreutils -p gnused -p gawk

set -exuo pipefail

go mod tidy
failedbuild=$(nix build --impure --expr '(with import <nixpkgs> {}; pkgs.callPackage ./. { vendorHash = ""; }).sops-install-secrets' 2>&1 || true)
echo "$failedbuild"
checksum=$(echo "$failedbuild" | awk '/got:.*sha256/ { print $2 }')
sed -i -e "s|vendorHash ? \".*\"|vendorHash ? \"$checksum\"|" default.nix
</file>

<file path=".envrc">
use flake
</file>

<file path=".gitignore">
# Binaries for programs and plugins
*.exe
*.exe~
*.dll
*.so
*.dylib

# Test binary, built with `go test -c`
*.test

# Output of the go coverage tool, specifically when used with LiteIDE
*.out
.vscode
.direnv

# Dependency directories (remove the comment below to include it)
# vendor/

/pkgs/sops-install-secrets/sops-install-secrets
/pkgs/ssh-to-pgp/ssh-to-pgp

# nix build result
result
</file>

<file path=".golangci.yml">
version: "2"
linters:
  enable:
    - asasalint
    - asciicheck
    - bidichk
    - bodyclose
    - contextcheck
    - durationcheck
    - errchkjson
    - errorlint
    - exhaustive
    - gocheckcompilerdirectives
    - gochecksumtype
    - gosmopolitan
    - loggercheck
    - makezero
    - misspell
    - musttag
    - nilerr
    - nilnesserr
    - protogetter
    - reassign
    - recvcheck
    - revive
    - rowserrcheck
    - spancheck
    - sqlclosecheck
    - staticcheck
    - testifylint
    - unparam
    - zerologlint
  disable:
    - noctx
  exclusions:
    generated: lax
    presets:
      - comments
      - common-false-positives
      - legacy
      - std-error-handling
    paths:
      - third_party$
      - builtin$
      - examples$
formatters:
  enable:
    - gofmt
  exclusions:
    generated: lax
    paths:
      - third_party$
      - builtin$
      - examples$
</file>

<file path="default.nix">
{
  pkgs ? import <nixpkgs> { },
  vendorHash ? "sha256-RI16z0I7eU1PVtOQMy5LNaTuIKhZVKHbI1g/wFMtWO4=",
}:
let
  sops-install-secrets = pkgs.callPackage ./pkgs/sops-install-secrets {
    inherit vendorHash;
  };
in
rec {
  inherit sops-install-secrets;
  sops-init-gpg-key = pkgs.callPackage ./pkgs/sops-init-gpg-key { };
  sops-pgp-hook = pkgs.callPackage ./pkgs/sops-pgp-hook { };
  default = sops-init-gpg-key;

  sops-import-keys-hook = pkgs.callPackage ./pkgs/sops-import-keys-hook { };

  # backwards compatibility
  inherit (pkgs) ssh-to-pgp;

  # used in the CI only
  sops-pgp-hook-test = pkgs.callPackage ./pkgs/sops-pgp-hook-test.nix {
    inherit vendorHash;
  };
  unit-tests = pkgs.callPackage ./pkgs/unit-tests.nix { };
}
// pkgs.lib.optionalAttrs (pkgs ? buildGo124Module) {
  lint = pkgs.callPackage ./pkgs/lint.nix {
    inherit sops-install-secrets;
  };
}
// pkgs.lib.optionalAttrs pkgs.stdenv.isLinux {
  cross-build = pkgs.callPackage ./pkgs/cross-build.nix {
    inherit sops-install-secrets;
  };
}
</file>

<file path="flake.lock">
{
  "nodes": {
    "nixpkgs": {
      "locked": {
        "lastModified": 1760596604,
        "narHash": "sha256-J/i5K6AAz/y5dBePHQOuzC7MbhyTOKsd/GLezSbEFiM=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "3cbe716e2346710d6e1f7c559363d14e11c32a43",
        "type": "github"
      },
      "original": {
        "owner": "NixOS",
        "ref": "nixpkgs-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "nixpkgs": "nixpkgs"
      }
    }
  },
  "root": "root",
  "version": 7
}
</file>

<file path="flake.nix">
{
  description = "Integrates sops into nixos";
  inputs.nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";

  nixConfig.extra-substituters = [ "https://cache.thalheim.io" ];
  nixConfig.extra-trusted-public-keys = [
    "cache.thalheim.io-1:R7msbosLEZKrxk/lKxf9BTjOOH7Ax3H0Qj0/6wiHOgc="
  ];
  outputs =
    {
      self,
      nixpkgs,
    }@inputs:
    let
      loadPrivateFlake =
        path:
        let
          flakeHash = builtins.readFile "${toString path}.narHash";
          flakePath = "path:${toString path}?narHash=${flakeHash}";
        in
        builtins.getFlake (builtins.unsafeDiscardStringContext flakePath);

      privateFlake = loadPrivateFlake ./dev/private;

      privateInputs = privateFlake.inputs;

      systems = [
        "x86_64-linux"
        "x86_64-darwin"
        "aarch64-darwin"
        "aarch64-linux"
      ];

      eachSystem =
        f:
        builtins.listToAttrs (
          builtins.map (system: {
            name = system;
            value = f {
              pkgs = inputs.nixpkgs.legacyPackages.${system};
              inherit system;
            };
          }) systems
        );

    in
    # public outputs
    {
      overlays.default =
        final: prev:
        let
          localPkgs = import ./default.nix { pkgs = final; };
        in
        {
          inherit (localPkgs)
            sops-install-secrets
            sops-init-gpg-key
            sops-pgp-hook
            sops-import-keys-hook
            sops-ssh-to-age
            ;
          # backward compatibility
          inherit (prev) ssh-to-pgp;
        };
      nixosModules = {
        sops = ./modules/sops;
        default = self.nixosModules.sops;
      };
      homeManagerModules = {
        sops = ./modules/home-manager/sops.nix;
        default = self.homeManagerModules.sops;
      };
      homeManagerModule = self.homeManagerModules.sops;
      homeModules = self.homeManagerModules;
      darwinModules = {
        sops = ./modules/nix-darwin;
        default = self.darwinModules.sops;
      };
      packages = eachSystem ({ pkgs, ... }: import ./default.nix { inherit pkgs; });
    }
    //
      # dev outputs
      {
        checks = eachSystem (
          { pkgs, system, ... }:
          let
            packages-stable = import ./default.nix {
              pkgs = privateInputs.nixpkgs-stable.legacyPackages.${system};
            };
            dropOverride = attrs: nixpkgs.lib.removeAttrs attrs [
              "override"
              "overrideDerivation"
            ];
            tests = dropOverride (pkgs.callPackage ./checks/nixos-test.nix { });
            tests-stable = dropOverride (
              privateInputs.nixpkgs-stable.legacyPackages.${system}.callPackage ./checks/nixos-test.nix { }
            );
            suffix-version =
              version: attrs:
              nixpkgs.lib.mapAttrs' (name: value: nixpkgs.lib.nameValuePair (name + version) value) attrs;
            suffix-stable = suffix-version "-25_05";
          in
          {
            home-manager = self.legacyPackages.${system}.homeConfigurations.sops.activation-script;
          }
          // (suffix-stable packages-stable)
          // nixpkgs.lib.optionalAttrs pkgs.stdenv.isLinux tests
          // nixpkgs.lib.optionalAttrs pkgs.stdenv.isLinux (suffix-stable tests-stable)
          // nixpkgs.lib.optionalAttrs pkgs.stdenv.isDarwin {
            darwin-sops =
              self.darwinConfigurations."sops-${pkgs.hostPlatform.darwinArch}".config.system.build.toplevel;
          }
        );

        darwinConfigurations.sops-arm64 = privateInputs.nix-darwin.lib.darwinSystem {
          modules = [
            ./checks/darwin.nix
            { nixpkgs.hostPlatform = "aarch64-darwin"; }
          ];
        };

        darwinConfigurations.sops-x86_64 = privateInputs.nix-darwin.lib.darwinSystem {
          modules = [
            ./checks/darwin.nix
            { nixpkgs.hostPlatform = "x86_64-darwin"; }
          ];
        };

        legacyPackages = eachSystem (
          { pkgs, ... }:
          {
            homeConfigurations.sops = privateInputs.home-manager.lib.homeManagerConfiguration {
              modules = [
                ./checks/home-manager.nix
              ];
              inherit pkgs;
            };
          }
        );

        apps = eachSystem (
          { pkgs, ... }:
          {
            update-dev-private-narHash = {
              type = "app";
              program = "${pkgs.writeShellScript "update-dev-private-narHash" ''
                nix --extra-experimental-features "nix-command flakes" flake lock ./dev/private
                nix --extra-experimental-features "nix-command flakes" hash path ./dev/private | tr -d '\n' > ./dev/private.narHash
              ''}";
            };
          }
        );

        devShells = eachSystem (
          { pkgs, ... }:
          {
            unit-tests = pkgs.callPackage ./pkgs/unit-tests.nix { };
            default = pkgs.callPackage ./shell.nix { };
          }
        );
      };
}
</file>

<file path="go.mod">
module github.com/Mic92/sops-nix

go 1.24.0

toolchain go1.24.1

require (
	github.com/Mic92/ssh-to-age v0.0.0-20240115094500-460a2109aaf0
	github.com/ProtonMail/go-crypto v1.3.0
	github.com/getsops/sops/v3 v3.11.0
	github.com/joho/godotenv v1.5.1
	github.com/moby/sys/mountinfo v0.7.2
	github.com/mozilla-services/yaml v0.0.0-20201007153854-c369669a6625
	golang.org/x/crypto v0.43.0
	golang.org/x/sys v0.37.0
	gopkg.in/ini.v1 v1.67.0
)

require (
	cel.dev/expr v0.24.0 // indirect
	cloud.google.com/go v0.121.6 // indirect
	cloud.google.com/go/auth v0.16.5 // indirect
	cloud.google.com/go/auth/oauth2adapt v0.2.8 // indirect
	cloud.google.com/go/compute/metadata v0.8.4 // indirect
	cloud.google.com/go/iam v1.5.2 // indirect
	cloud.google.com/go/kms v1.23.0 // indirect
	cloud.google.com/go/longrunning v0.6.7 // indirect
	cloud.google.com/go/monitoring v1.24.2 // indirect
	cloud.google.com/go/storage v1.57.0 // indirect
	filippo.io/age v1.2.1 // indirect
	filippo.io/edwards25519 v1.1.0 // indirect
	github.com/Azure/azure-sdk-for-go/sdk/azcore v1.19.1 // indirect
	github.com/Azure/azure-sdk-for-go/sdk/azidentity v1.12.0 // indirect
	github.com/Azure/azure-sdk-for-go/sdk/internal v1.11.2 // indirect
	github.com/Azure/azure-sdk-for-go/sdk/security/keyvault/azkeys v1.4.0 // indirect
	github.com/Azure/azure-sdk-for-go/sdk/security/keyvault/internal v1.2.0 // indirect
	github.com/AzureAD/microsoft-authentication-library-for-go v1.5.0 // indirect
	github.com/GoogleCloudPlatform/opentelemetry-operations-go/detectors/gcp v1.29.0 // indirect
	github.com/GoogleCloudPlatform/opentelemetry-operations-go/exporter/metric v0.53.0 // indirect
	github.com/GoogleCloudPlatform/opentelemetry-operations-go/internal/resourcemapping v0.53.0 // indirect
	github.com/aws/aws-sdk-go-v2 v1.39.2 // indirect
	github.com/aws/aws-sdk-go-v2/aws/protocol/eventstream v1.7.1 // indirect
	github.com/aws/aws-sdk-go-v2/config v1.31.11 // indirect
	github.com/aws/aws-sdk-go-v2/credentials v1.18.15 // indirect
	github.com/aws/aws-sdk-go-v2/feature/ec2/imds v1.18.9 // indirect
	github.com/aws/aws-sdk-go-v2/feature/s3/manager v1.19.9 // indirect
	github.com/aws/aws-sdk-go-v2/internal/configsources v1.4.9 // indirect
	github.com/aws/aws-sdk-go-v2/internal/endpoints/v2 v2.7.9 // indirect
	github.com/aws/aws-sdk-go-v2/internal/ini v1.8.3 // indirect
	github.com/aws/aws-sdk-go-v2/internal/v4a v1.4.9 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/accept-encoding v1.13.1 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/checksum v1.8.9 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/presigned-url v1.13.9 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/s3shared v1.19.9 // indirect
	github.com/aws/aws-sdk-go-v2/service/kms v1.45.6 // indirect
	github.com/aws/aws-sdk-go-v2/service/s3 v1.88.3 // indirect
	github.com/aws/aws-sdk-go-v2/service/sso v1.29.5 // indirect
	github.com/aws/aws-sdk-go-v2/service/ssooidc v1.35.1 // indirect
	github.com/aws/aws-sdk-go-v2/service/sts v1.38.6 // indirect
	github.com/aws/smithy-go v1.23.0 // indirect
	github.com/blang/semver v3.5.1+incompatible // indirect
	github.com/cenkalti/backoff/v4 v4.3.0 // indirect
	github.com/cespare/xxhash/v2 v2.3.0 // indirect
	github.com/cloudflare/circl v1.6.1 // indirect
	github.com/cncf/xds/go v0.0.0-20250501225837-2ac532fd4443 // indirect
	github.com/cpuguy83/go-md2man/v2 v2.0.7 // indirect
	github.com/envoyproxy/go-control-plane/envoy v1.32.4 // indirect
	github.com/envoyproxy/protoc-gen-validate v1.2.1 // indirect
	github.com/fatih/color v1.18.0 // indirect
	github.com/felixge/httpsnoop v1.0.4 // indirect
	github.com/getsops/gopgagent v0.0.0-20241224165529-7044f28e491e // indirect
	github.com/go-jose/go-jose/v4 v4.1.1 // indirect
	github.com/go-logr/logr v1.4.3 // indirect
	github.com/go-logr/stdr v1.2.2 // indirect
	github.com/golang-jwt/jwt/v5 v5.3.0 // indirect
	github.com/google/go-cmp v0.7.0 // indirect
	github.com/google/s2a-go v0.1.9 // indirect
	github.com/google/shlex v0.0.0-20191202100458-e7afc7fbc510 // indirect
	github.com/google/uuid v1.6.0 // indirect
	github.com/googleapis/enterprise-certificate-proxy v0.3.6 // indirect
	github.com/googleapis/gax-go/v2 v2.15.0 // indirect
	github.com/goware/prefixer v0.0.0-20160118172347-395022866408 // indirect
	github.com/hashicorp/errwrap v1.1.0 // indirect
	github.com/hashicorp/go-cleanhttp v0.5.2 // indirect
	github.com/hashicorp/go-multierror v1.1.1 // indirect
	github.com/hashicorp/go-retryablehttp v0.7.8 // indirect
	github.com/hashicorp/go-rootcerts v1.0.2 // indirect
	github.com/hashicorp/go-secure-stdlib/parseutil v0.2.0 // indirect
	github.com/hashicorp/go-secure-stdlib/strutil v0.1.2 // indirect
	github.com/hashicorp/go-sockaddr v1.0.7 // indirect
	github.com/hashicorp/hcl v1.0.1-vault-7 // indirect
	github.com/hashicorp/vault/api v1.21.0 // indirect
	github.com/kylelemons/godebug v1.1.0 // indirect
	github.com/lib/pq v1.10.9 // indirect
	github.com/mattn/go-colorable v0.1.14 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/mitchellh/go-homedir v1.1.0 // indirect
	github.com/mitchellh/go-wordwrap v1.0.1 // indirect
	github.com/mitchellh/mapstructure v1.5.0 // indirect
	github.com/pkg/browser v0.0.0-20240102092130-5ac0b6a4141c // indirect
	github.com/pkg/errors v0.9.1 // indirect
	github.com/planetscale/vtprotobuf v0.6.1-0.20240319094008-0393e58bdf10 // indirect
	github.com/russross/blackfriday/v2 v2.1.0 // indirect
	github.com/ryanuber/go-glob v1.0.0 // indirect
	github.com/sirupsen/logrus v1.9.3 // indirect
	github.com/spiffe/go-spiffe/v2 v2.5.0 // indirect
	github.com/urfave/cli v1.22.17 // indirect
	github.com/zeebo/errs v1.4.0 // indirect
	go.opentelemetry.io/auto/sdk v1.1.0 // indirect
	go.opentelemetry.io/contrib/detectors/gcp v1.36.0 // indirect
	go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.61.0 // indirect
	go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.61.0 // indirect
	go.opentelemetry.io/otel v1.37.0 // indirect
	go.opentelemetry.io/otel/metric v1.37.0 // indirect
	go.opentelemetry.io/otel/sdk v1.37.0 // indirect
	go.opentelemetry.io/otel/sdk/metric v1.37.0 // indirect
	go.opentelemetry.io/otel/trace v1.37.0 // indirect
	go.yaml.in/yaml/v3 v3.0.4 // indirect
	golang.org/x/net v0.45.0 // indirect
	golang.org/x/oauth2 v0.31.0 // indirect
	golang.org/x/sync v0.17.0 // indirect
	golang.org/x/term v0.36.0 // indirect
	golang.org/x/text v0.30.0 // indirect
	golang.org/x/time v0.13.0 // indirect
	google.golang.org/api v0.250.0 // indirect
	google.golang.org/genproto v0.0.0-20250603155806-513f23925822 // indirect
	google.golang.org/genproto/googleapis/api v0.0.0-20250818200422-3122310a409c // indirect
	google.golang.org/genproto/googleapis/rpc v0.0.0-20250908214217-97024824d090 // indirect
	google.golang.org/grpc v1.75.1 // indirect
	google.golang.org/protobuf v1.36.9 // indirect
)
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2020 Jrg Thalheim

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="shell.nix">
{
  mkShell,
  bashInteractive,
  go,
  delve,
  gnupg,
  util-linux,
  nix,
  golangci-lint,
}:
mkShell {
  nativeBuildInputs = [
    bashInteractive
    go
    delve
    gnupg
    util-linux
    nix
    golangci-lint
  ];
  # delve does not compile with hardening enabled
  hardeningDisable = [ "all" ];
}
</file>

</files>
