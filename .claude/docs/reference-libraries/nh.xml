This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.cargo/
  config.toml
.github/
  ISSUE_TEMPLATE/
    bug.yml
  workflows/
    build.yaml
    check.yaml
    cleanup.yaml
    nixos-search.yaml
    tag.yaml
    test.yaml
    update.yaml
  dependabot.yaml
  FUNDING.yaml
  nh_clean_screenshot.png
  nh_search_screenshot.png
  nh_switch_screenshot.png
  PULL_REQUEST_TEMPLATE.md
src/
  util/
    platform.rs
  checks.rs
  clean.rs
  commands.rs
  completion.rs
  darwin.rs
  generations.rs
  home.rs
  installable.rs
  interface.rs
  json.rs
  lib.rs
  logging.rs
  main.rs
  nixos.rs
  search.rs
  update.rs
  util.rs
test/
  configuration.nix
  home.nix
  nixos.nix
xtask/
  src/
    main.rs
    man.rs
  Cargo.toml
.editorconfig
.envrc
.gitignore
.rustfmt.toml
.taplo.toml
Cargo.toml
CHANGELOG.md
fix.sh
flake.lock
flake.nix
LICENSE
package.nix
README.md
shell.nix
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".cargo/config.toml">
[alias]
xtask = "run --package xtask --"
</file>

<file path=".github/FUNDING.yaml">
github: [viperML, notashelf]
</file>

<file path="src/lib.rs">
//! Internal library output for NH. This is not meant for public consumption.
pub mod checks;
pub mod clean;
pub mod commands;
pub mod completion;
pub mod darwin;
pub mod generations;
pub mod home;
pub mod installable;
pub mod interface;
pub mod json;
pub mod logging;
pub mod nixos;
pub mod search;
pub mod update;
pub mod util;

pub use color_eyre::Result;

pub const NH_VERSION: &str = env!("CARGO_PKG_VERSION");
pub const NH_REV: Option<&str> = option_env!("NH_REV");
</file>

<file path="test/home.nix">
let
  hm = builtins.getFlake "github:nix-community/home-manager";
  pkgs = import <nixpkgs> { };
in
import "${hm}/modules" {
  inherit pkgs;
  configuration = {
    home.stateVersion = "24.05";
    home.packages = [ pkgs.hello ];
    home.username = "anon";
    home.homeDirectory = "/anonfiles";
  };
}
</file>

<file path="test/nixos.nix">
import <nixpkgs/nixos> { configuration = ./configuration.nix; }
</file>

<file path="xtask/Cargo.toml">
[package]
name              = "xtask"
version.workspace = true
edition.workspace = true
publish           = false

[dependencies]
clap.workspace = true
clap_mangen    = "0.2.28"
nh             = { path = "../." }
roff           = "0.2.2"
</file>

<file path=".editorconfig">
root = true

[*]
charset = utf-8
end_of_line = lf
indent_style = space
indent_size = 2
insert_final_newline = true
tab_width = 2
trim_trailing_whitespace = true

[*.md]
indent_style = space
indent_size = 2
trim_trailing_whitespace = false

[*.{lock,diff,patch}]
indent_style = unset
indent_size = unset
insert_final_newline = unset
trim_trailing_whitespace = unset
end_of_line = unset
</file>

<file path=".envrc">
watch_file shell.nix

use flake
</file>

<file path=".taplo.toml">
[formatting]
align_entries         = true
column_width          = 100
compact_arrays        = false
reorder_inline_tables = true
reorder_keys          = true

[[rule]]
include = [ "**/Cargo.toml" ]
keys    = [ "package" ]

[rule.formatting]
reorder_keys = false
</file>

<file path="fix.sh">
#! /usr/bin/env bash
set -eux

echo "Running 'cargo fix' on the codebase"
cargo fix --allow-dirty

echo "Running clippy linter and applying available fixes"
cargo clippy --fix --allow-dirty -- -W clippy::pedantic \
  -W clippy::correctness \
  -W clippy::suspicious \
  -W clippy::cargo

echo "Running Rust formatter"
cargo fmt

echo "Running TOML formatter"
</file>

<file path="flake.nix">
{
  inputs.nixpkgs.url = "github:NixOS/nixpkgs/nixos-25.05";

  outputs =
    {
      self,
      nixpkgs,
    }:
    let
      forAllSystems =
        function:
        nixpkgs.lib.genAttrs [
          "x86_64-linux"
          "aarch64-linux"
          # experimental
          "x86_64-darwin"
          "aarch64-darwin"
        ] (system: function nixpkgs.legacyPackages.${system});

      rev = self.shortRev or self.dirtyShortRev or "dirty";
    in
    {
      overlays.default = final: _: { nh = final.callPackage ./package.nix { inherit rev; }; };

      packages = forAllSystems (pkgs: {
        nh = pkgs.callPackage ./package.nix { inherit rev; };
        default = self.packages.${pkgs.hostPlatform.system}.nh;
      });

      checks = self.packages // self.devShells;

      devShells = forAllSystems (pkgs: {
        default = import ./shell.nix { inherit pkgs; };
      });

      formatter = forAllSystems (
        pkgs:
        # Provides the default formatter for 'nix fmt', which will format the
        # entire tree with Nixfmt. Treefmt is *wildly* overkill for this project
        # so a simple bash script will suffice.
        pkgs.writeShellApplication {
          name = "nix3-fmt-wrapper";

          runtimeInputs = [
            pkgs.nixfmt-rfc-style
            pkgs.fd
          ];

          text = ''
            # Find Nix files in the tree and format them with Alejandra
            fd "$@" -t f -e nix -x nixfmt -q '{}'
          '';
        }
      );
    };
}
</file>

<file path="LICENSE">
EUROPEAN UNION PUBLIC LICENCE v. 1.2
                      EUPL © the European Union 2007, 2016

This European Union Public Licence (the ‘EUPL’) applies to the Work (as defined
below) which is provided under the terms of this Licence. Any use of the Work,
other than as authorised under this Licence is prohibited (to the extent such
use is covered by a right of the copyright holder of the Work).

The Work is provided under the terms of this Licence when the Licensor (as
defined below) has placed the following notice immediately following the
copyright notice for the Work:

        Licensed under the EUPL

or has expressed by any other means his willingness to license under the EUPL.

1. Definitions

In this Licence, the following terms have the following meaning:

- ‘The Licence’: this Licence.

- ‘The Original Work’: the work or software distributed or communicated by the
  Licensor under this Licence, available as Source Code and also as Executable
  Code as the case may be.

- ‘Derivative Works’: the works or software that could be created by the
  Licensee, based upon the Original Work or modifications thereof. This Licence
  does not define the extent of modification or dependence on the Original Work
  required in order to classify a work as a Derivative Work; this extent is
  determined by copyright law applicable in the country mentioned in Article 15.

- ‘The Work’: the Original Work or its Derivative Works.

- ‘The Source Code’: the human-readable form of the Work which is the most
  convenient for people to study and modify.

- ‘The Executable Code’: any code which has generally been compiled and which is
  meant to be interpreted by a computer as a program.

- ‘The Licensor’: the natural or legal person that distributes or communicates
  the Work under the Licence.

- ‘Contributor(s)’: any natural or legal person who modifies the Work under the
  Licence, or otherwise contributes to the creation of a Derivative Work.

- ‘The Licensee’ or ‘You’: any natural or legal person who makes any usage of
  the Work under the terms of the Licence.

- ‘Distribution’ or ‘Communication’: any act of selling, giving, lending,
  renting, distributing, communicating, transmitting, or otherwise making
  available, online or offline, copies of the Work or providing access to its
  essential functionalities at the disposal of any other natural or legal
  person.

2. Scope of the rights granted by the Licence

The Licensor hereby grants You a worldwide, royalty-free, non-exclusive,
sublicensable licence to do the following, for the duration of copyright vested
in the Original Work:

- use the Work in any circumstance and for all usage,
- reproduce the Work,
- modify the Work, and make Derivative Works based upon the Work,
- communicate to the public, including the right to make available or display
  the Work or copies thereof to the public and perform publicly, as the case may
  be, the Work,
- distribute the Work or copies thereof,
- lend and rent the Work or copies thereof,
- sublicense rights in the Work or copies thereof.

Those rights can be exercised on any media, supports and formats, whether now
known or later invented, as far as the applicable law permits so.

In the countries where moral rights apply, the Licensor waives his right to
exercise his moral right to the extent allowed by law in order to make effective
the licence of the economic rights here above listed.

The Licensor grants to the Licensee royalty-free, non-exclusive usage rights to
any patents held by the Licensor, to the extent necessary to make use of the
rights granted on the Work under this Licence.

3. Communication of the Source Code

The Licensor may provide the Work either in its Source Code form, or as
Executable Code. If the Work is provided as Executable Code, the Licensor
provides in addition a machine-readable copy of the Source Code of the Work
along with each copy of the Work that the Licensor distributes or indicates, in
a notice following the copyright notice attached to the Work, a repository where
the Source Code is easily and freely accessible for as long as the Licensor
continues to distribute or communicate the Work.

4. Limitations on copyright

Nothing in this Licence is intended to deprive the Licensee of the benefits from
any exception or limitation to the exclusive rights of the rights owners in the
Work, of the exhaustion of those rights or of other applicable limitations
thereto.

5. Obligations of the Licensee

The grant of the rights mentioned above is subject to some restrictions and
obligations imposed on the Licensee. Those obligations are the following:

Attribution right: The Licensee shall keep intact all copyright, patent or
trademarks notices and all notices that refer to the Licence and to the
disclaimer of warranties. The Licensee must include a copy of such notices and a
copy of the Licence with every copy of the Work he/she distributes or
communicates. The Licensee must cause any Derivative Work to carry prominent
notices stating that the Work has been modified and the date of modification.

Copyleft clause: If the Licensee distributes or communicates copies of the
Original Works or Derivative Works, this Distribution or Communication will be
done under the terms of this Licence or of a later version of this Licence
unless the Original Work is expressly distributed only under this version of the
Licence — for example by communicating ‘EUPL v. 1.2 only’. The Licensee
(becoming Licensor) cannot offer or impose any additional terms or conditions on
the Work or Derivative Work that alter or restrict the terms of the Licence.

Compatibility clause: If the Licensee Distributes or Communicates Derivative
Works or copies thereof based upon both the Work and another work licensed under
a Compatible Licence, this Distribution or Communication can be done under the
terms of this Compatible Licence. For the sake of this clause, ‘Compatible
Licence’ refers to the licences listed in the appendix attached to this Licence.
Should the Licensee's obligations under the Compatible Licence conflict with
his/her obligations under this Licence, the obligations of the Compatible
Licence shall prevail.

Provision of Source Code: When distributing or communicating copies of the Work,
the Licensee will provide a machine-readable copy of the Source Code or indicate
a repository where this Source will be easily and freely available for as long
as the Licensee continues to distribute or communicate the Work.

Legal Protection: This Licence does not grant permission to use the trade names,
trademarks, service marks, or names of the Licensor, except as required for
reasonable and customary use in describing the origin of the Work and
reproducing the content of the copyright notice.

6. Chain of Authorship

The original Licensor warrants that the copyright in the Original Work granted
hereunder is owned by him/her or licensed to him/her and that he/she has the
power and authority to grant the Licence.

Each Contributor warrants that the copyright in the modifications he/she brings
to the Work are owned by him/her or licensed to him/her and that he/she has the
power and authority to grant the Licence.

Each time You accept the Licence, the original Licensor and subsequent
Contributors grant You a licence to their contributions to the Work, under the
terms of this Licence.

7. Disclaimer of Warranty

The Work is a work in progress, which is continuously improved by numerous
Contributors. It is not a finished work and may therefore contain defects or
‘bugs’ inherent to this type of development.

For the above reason, the Work is provided under the Licence on an ‘as is’ basis
and without warranties of any kind concerning the Work, including without
limitation merchantability, fitness for a particular purpose, absence of defects
or errors, accuracy, non-infringement of intellectual property rights other than
copyright as stated in Article 6 of this Licence.

This disclaimer of warranty is an essential part of the Licence and a condition
for the grant of any rights to the Work.

8. Disclaimer of Liability

Except in the cases of wilful misconduct or damages directly caused to natural
persons, the Licensor will in no event be liable for any direct or indirect,
material or moral, damages of any kind, arising out of the Licence or of the use
of the Work, including without limitation, damages for loss of goodwill, work
stoppage, computer failure or malfunction, loss of data or any commercial
damage, even if the Licensor has been advised of the possibility of such damage.
However, the Licensor will be liable under statutory product liability laws as
far such laws apply to the Work.

9. Additional agreements

While distributing the Work, You may choose to conclude an additional agreement,
defining obligations or services consistent with this Licence. However, if
accepting obligations, You may act only on your own behalf and on your sole
responsibility, not on behalf of the original Licensor or any other Contributor,
and only if You agree to indemnify, defend, and hold each Contributor harmless
for any liability incurred by, or claims asserted against such Contributor by
the fact You have accepted any warranty or additional liability.

10. Acceptance of the Licence

The provisions of this Licence can be accepted by clicking on an icon ‘I agree’
placed under the bottom of a window displaying the text of this Licence or by
affirming consent in any other similar way, in accordance with the rules of
applicable law. Clicking on that icon indicates your clear and irrevocable
acceptance of this Licence and all of its terms and conditions.

Similarly, you irrevocably accept this Licence and all of its terms and
conditions by exercising any rights granted to You by Article 2 of this Licence,
such as the use of the Work, the creation by You of a Derivative Work or the
Distribution or Communication by You of the Work or copies thereof.

11. Information to the public

In case of any Distribution or Communication of the Work by means of electronic
communication by You (for example, by offering to download the Work from a
remote location) the distribution channel or media (for example, a website) must
at least provide to the public the information requested by the applicable law
regarding the Licensor, the Licence and the way it may be accessible, concluded,
stored and reproduced by the Licensee.

12. Termination of the Licence

The Licence and the rights granted hereunder will terminate automatically upon
any breach by the Licensee of the terms of the Licence.

Such a termination will not terminate the licences of any person who has
received the Work from the Licensee under the Licence, provided such persons
remain in full compliance with the Licence.

13. Miscellaneous

Without prejudice of Article 9 above, the Licence represents the complete
agreement between the Parties as to the Work.

If any provision of the Licence is invalid or unenforceable under applicable
law, this will not affect the validity or enforceability of the Licence as a
whole. Such provision will be construed or reformed so as necessary to make it
valid and enforceable.

The European Commission may publish other linguistic versions or new versions of
this Licence or updated versions of the Appendix, so far this is required and
reasonable, without reducing the scope of the rights granted by the Licence. New
versions of the Licence will be published with a unique version number.

All linguistic versions of this Licence, approved by the European Commission,
have identical value. Parties can take advantage of the linguistic version of
their choice.

14. Jurisdiction

Without prejudice to specific agreement between parties,

- any litigation resulting from the interpretation of this License, arising
  between the European Union institutions, bodies, offices or agencies, as a
  Licensor, and any Licensee, will be subject to the jurisdiction of the Court
  of Justice of the European Union, as laid down in article 272 of the Treaty on
  the Functioning of the European Union,

- any litigation arising between other parties and resulting from the
  interpretation of this License, will be subject to the exclusive jurisdiction
  of the competent court where the Licensor resides or conducts its primary
  business.

15. Applicable Law

Without prejudice to specific agreement between parties,

- this Licence shall be governed by the law of the European Union Member State
  where the Licensor has his seat, resides or has his registered office,

- this licence shall be governed by Belgian law if the Licensor has no seat,
  residence or registered office inside a European Union Member State.

Appendix

‘Compatible Licences’ according to Article 5 EUPL are:

- GNU General Public License (GPL) v. 2, v. 3
- GNU Affero General Public License (AGPL) v. 3
- Open Software License (OSL) v. 2.1, v. 3.0
- Eclipse Public License (EPL) v. 1.0
- CeCILL v. 2.0, v. 2.1
- Mozilla Public Licence (MPL) v. 2
- GNU Lesser General Public Licence (LGPL) v. 2.1, v. 3
- Creative Commons Attribution-ShareAlike v. 3.0 Unported (CC BY-SA 3.0) for
  works other than software
- European Union Public Licence (EUPL) v. 1.1, v. 1.2
- Québec Free and Open-Source Licence — Reciprocity (LiLiQ-R) or Strong
  Reciprocity (LiLiQ-R+).

The European Commission may update this Appendix to later versions of the above
licences without producing a new version of the EUPL, as long as they provide
the rights granted in Article 2 of this Licence and protect the covered Source
Code from exclusive appropriation.

All other changes or additions to this Appendix require the production of a new
EUPL version.
</file>

<file path="package.nix">
{
  lib,
  rustPlatform,
  installShellFiles,
  makeBinaryWrapper,
  use-nom ? true,
  nix-output-monitor ? null,
  rev ? "dirty",
}:
assert use-nom -> nix-output-monitor != null;
let
  runtimeDeps = lib.optionals use-nom [ nix-output-monitor ];
  cargoToml = builtins.fromTOML (builtins.readFile ./Cargo.toml);
in
rustPlatform.buildRustPackage {
  pname = "nh";
  version = "${cargoToml.workspace.package.version}-${rev}";

  src = lib.fileset.toSource {
    root = ./.;
    fileset = lib.fileset.intersection (lib.fileset.fromSource (lib.sources.cleanSource ./.)) (
      lib.fileset.unions [
        ./.cargo
        ./src
        ./xtask
        ./Cargo.toml
        ./Cargo.lock
      ]
    );
  };

  strictDeps = true;

  nativeBuildInputs = [
    installShellFiles
    makeBinaryWrapper
  ];

  postInstall = ''
    mkdir completions man

    for shell in bash zsh fish; do
      NH_NO_CHECKS=1 $out/bin/nh completions $shell > completions/nh.$shell
    done

    installShellCompletion completions/*

    cargo xtask man --out-dir gen
    installManPage gen/nh.1
  '';

  postFixup = ''
    wrapProgram $out/bin/nh \
      --prefix PATH : ${lib.makeBinPath runtimeDeps}
  '';

  cargoLock.lockFile = ./Cargo.lock;

  env.NH_REV = rev;

  meta = {
    description = "Yet another nix cli helper";
    homepage = "https://github.com/nix-community/nh";
    license = lib.licenses.eupl12;
    mainProgram = "nh";
    maintainers = with lib.maintainers; [
      drupol
      NotAShelf
      viperML
    ];
  };
}
</file>

<file path="shell.nix">
{
  pkgs ? import <nixpkgs> { },
}:
with pkgs;
mkShell {
  strictDeps = true;

  nativeBuildInputs = [
    cargo
    rustc

    rust-analyzer-unwrapped
    (rustfmt.override { asNightly = true; })
    clippy
    nix-output-monitor
    taplo
    yaml-language-server
    lldb
  ];

  buildInputs = lib.optionals stdenv.isDarwin [
    libiconv
  ];

  env = {
    NH_NOM = "1";
    NH_LOG = "nh=trace";
    RUST_SRC_PATH = "${rustPlatform.rustLibSrc}";
  };
}
</file>

<file path=".github/workflows/build.yaml">
name: "Build NH"

on:
  workflow_dispatch:
  pull_request:
    paths:
      - "Cargo.toml"
      - "Cargo.lock"
      - "xtask/Cargo.toml"
      - "src/**"
      - "xtask/src/**"
      - ".cargo/**"
      - ".github/workflows/build.yaml"
  push:
    branches-ignore:
      - "update-*"
    paths:
      - "Cargo.toml"
      - "Cargo.lock"
      - "xtask/Cargo.toml"
      - "src/**"
      - "xtask/src/**"
      - ".cargo/**"
      - ".github/workflows/build.yaml"

jobs:
  build-linux:
    name: "Build NH on Linux"
    runs-on: ubuntu-latest
    steps:
      - uses: cachix/install-nix-action@master
        with:
          github_access_token: ${{ secrets.GITHUB_TOKEN }}

      - uses: actions/checkout@v5

      - run: nix build -L --no-link
        name: Build

  build-darwin:
    name: "Build NH on Darwin"
    runs-on: macos-latest

    steps:
      - uses: cachix/install-nix-action@master
        with:
          github_access_token: ${{ secrets.GITHUB_TOKEN }}

      - uses: actions/checkout@v5

      - name: Build NH with Nix
        run: nix build -L --no-link
</file>

<file path=".github/workflows/check.yaml">
name: "Check formating & lints"

on:
  workflow_dispatch:
  pull_request:
    branches: ["master"]
    paths:
      - "Cargo.toml"
      - "Cargo.lock"
      - "xtask/Cargo.toml"
      - "src/**"
      - "xtask/src/**"
      - ".cargo/**"
      - ".github/workflows/check.yaml"
  push:
    branches-ignore:
      - "update-*"
    paths:
      - "Cargo.toml"
      - "Cargo.lock"
      - "xtask/Cargo.toml"
      - "src/**"
      - "xtask/src/**"
      - ".cargo/**"
      - ".github/workflows/check.yaml"

jobs:
  treewide-checks:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - uses: cachix/install-nix-action@v31
        with:
          github_access_token: ${{ secrets.GITHUB_TOKEN }}

      # Check if the source code is formatted as per the tooling configurations
      # in the repository root. Unlike the Clippy lints below, formatting lints
      # **must** pass.
      - name: Prepare Dev Environment
        run: |
          eval "$(nix print-dev-env)"
          set -x

          # Verify that Rust source code is formatted
          cargo fmt --check || exit 1

          # Verify that TOML files are formatted
          taplo fmt --check || exit 1

      # We run clippy with lints that help avoid overall low-quality code or what is called "code smell."
      # Stylistic lints (e.g., clippy::style and clippy::complexity) are avoided but it is a good idea to
      # follow those while working on the codebase.
      - name: Clippy Lints
        run: |
          eval "$(nix print-dev-env)"
          set -x

          # Lint Changes
          cargo clippy -- \
            -W clippy::pedantic \
            -W clippy::correctness \
            -W clippy::suspicious
</file>

<file path=".github/workflows/nixos-search.yaml">
name: "Check version of nixos-search"

on:
  schedule:
    - cron: '0 */12 * * *'
  workflow_dispatch:

jobs:
  main:
    runs-on: ubuntu-latest

    steps:
      - name: Check nixos-search version
        run: |
          VERSION_CONTENT=$(curl --silent "https://raw.githubusercontent.com/nixos/nixos-search/main/VERSION" | tr -d '[:space:]')
          # NOTE: this number and the version number in src/search.rs have
          # to be updated when nixos-search updates it's version number.
          VERSION_NUMBER=44

          echo "Found VERSION: $VERSION_CONTENT"

          if [ "$VERSION_CONTENT" != "$VERSION_NUMBER" ]; then
            echo "::error:: Expected version $VERSION_NUMBER, but found $VERSION_CONTENT"
            exit 1
          fi

          echo "Version check passed. nixos-search version is $VERSION_NUMBER."
</file>

<file path=".github/workflows/tag.yaml">
name: Tag version

concurrency: tag

on:
  workflow_dispatch:
  push:
    branches:
      - master

jobs:
  main:
    runs-on: ubuntu-latest
    steps:
      - uses: cachix/install-nix-action@master
        with:
          github_access_token: ${{ secrets.GITHUB_TOKEN }}

      - uses: actions/checkout@v5
        name: Checkout

      - name: Read version
        run: |
          echo -n "nh_version=v" >> "$GITHUB_ENV"
          nix run nixpkgs#fq -- -r '.workspace.package.version' Cargo.toml >> "$GITHUB_ENV"
          cat "$GITHUB_ENV"

      - name: Tag
        run: |
          set -x
          git tag $nh_version
          git push --tags || :
</file>

<file path=".github/workflows/update.yaml">
name: "Update NH"

on:
  workflow_dispatch:
  schedule:
    - cron: "0 4 1 * *"

jobs:
  main:
    runs-on: ubuntu-latest

    steps:
    - uses: cachix/install-nix-action@master
      with:
        github_access_token: ${{ secrets.GITHUB_TOKEN }}

    - uses: actions/checkout@v5
      name: Checkout

    - name: Update
      run: |
        nix flake update
        eval "$(nix print-dev-env)"
        cargo update
        ./fix.sh

    - name: Create Pull Request
      uses: peter-evans/create-pull-request@v7
      with:
        token: '${{ secrets.PAT }}'
        title: "build: bump dependencies"
        committer: GitHub <noreply@github.com>
        author: GitHub <noreply@github.com>
        commit-message: |
          build: bump dependencies

          Co-authored-by: ${{ github.actor }} <${{ github.actor }}@users.noreply.github.com>
        branch: update
        # branch-suffix: timestamp
        delete-branch: true
</file>

<file path=".github/dependabot.yaml">
version: 2
updates:
  # Update used workflows
  - package-ecosystem: github-actions
    directory: "/"
    schedule:
      interval: daily
</file>

<file path="src/util/platform.rs">
use std::env;
use std::ffi::OsString;
use std::path::{Path, PathBuf};

use color_eyre::Result;
use color_eyre::eyre::WrapErr;
use color_eyre::eyre::bail;
use tracing::{debug, info, warn};

use crate::commands;
use crate::installable::Installable;
use crate::interface::NixBuildPassthroughArgs;

/// Resolves an Installable from an environment variable.
///
/// Returns `Some(Installable)` if the environment variable is set and can be parsed,
/// or `None` if the environment variable is not set.
pub fn resolve_env_installable(var: &str) -> Option<Installable> {
    env::var(var).ok().map(|val| {
        let mut elems = val.splitn(2, '#');
        let reference = elems.next().unwrap().to_owned();
        let attribute = elems
            .next()
            .map(crate::installable::parse_attribute)
            .unwrap_or_default();
        Installable::Flake {
            reference,
            attribute,
        }
    })
}

/// Extends an Installable with the appropriate attribute path for a platform.
///
/// - `config_type`: e.g. "homeConfigurations", "nixosConfigurations", "darwinConfigurations"
/// - `extra_path`: e.g. ["config", "home", "activationPackage"]
/// - `config_name`: Optional configuration name (e.g. username@hostname)
/// - `push_drv`: Whether to push the drv path (platform-specific)
/// - `extra_args`: Extra args for nix eval (for config detection)
pub fn extend_installable_for_platform(
    mut installable: Installable,
    config_type: &str,
    extra_path: &[&str],
    config_name: Option<String>,
    push_drv: bool,
    extra_args: &[OsString],
) -> Result<Installable> {
    use tracing::debug;

    use crate::util::get_hostname;

    match &mut installable {
        Installable::Flake {
            reference,
            attribute,
        } => {
            // If attribute path is already specified, use it as-is
            if !attribute.is_empty() {
                debug!(
                    "Using explicit attribute path from installable: {:?}",
                    attribute
                );
                return Ok(installable);
            }

            // Otherwise, build the attribute path
            attribute.push(config_type.to_string());
            let flake_reference = reference.clone();

            // Try to find the configuration by name if one was provided
            if let Some(config_name) = config_name {
                if find_config_in_flake(
                    &config_name,
                    attribute,
                    &flake_reference,
                    extra_args,
                    push_drv,
                    extra_path,
                )? {
                    return Ok(installable);
                }

                return Err(color_eyre::eyre::eyre!(
                    "Explicitly specified configuration not found in flake."
                ));
            }

            // Try to auto-detect the configuration
            let username = std::env::var("USER").unwrap_or_else(|_| "user".to_string());
            let hostname = get_hostname().unwrap_or_else(|_| "host".to_string());

            for attr_name in [format!("{username}@{hostname}"), username] {
                if find_config_in_flake(
                    &attr_name,
                    attribute,
                    &flake_reference,
                    extra_args,
                    push_drv,
                    extra_path,
                )? {
                    return Ok(installable);
                }
            }

            return Err(color_eyre::eyre::eyre!(
                "Couldn't find configuration automatically in flake."
            ));
        }
        Installable::File { attribute, .. } | Installable::Expression { attribute, .. } => {
            if push_drv {
                attribute.extend(extra_path.iter().map(|s| (*s).to_string()));
            }
        }
        Installable::Store { .. } => {
            // Nothing to do for store paths
        }
    }
    Ok(installable)
}

/// Find a configuration in a flake
///
/// Returns true if the configuration was found, false otherwise
fn find_config_in_flake(
    config_name: &str,
    attribute: &mut Vec<String>,
    flake_reference: &str,
    extra_args: &[OsString],
    push_drv: bool,
    extra_path: &[&str],
) -> Result<bool> {
    let func = format!(r#"x: x ? "{config_name}""#);
    let check_res = commands::Command::new("nix")
        .arg("eval")
        .args(extra_args)
        .arg("--apply")
        .arg(&func)
        .args(
            (Installable::Flake {
                reference: flake_reference.to_string(),
                attribute: attribute.clone(),
            })
            .to_args(),
        )
        .run_capture();

    if let Ok(res) = check_res {
        if res.map(|s| s.trim().to_owned()).as_deref() == Some("true") {
            debug!("Found configuration: {}", config_name);
            attribute.push(config_name.to_string());

            if push_drv {
                attribute.extend(extra_path.iter().map(|s| (*s).to_string()));
            }

            return Ok(true);
        }
    }

    Ok(false)
}

/// Handles common specialisation logic for all platforms
pub fn handle_specialisation(
    specialisation_path: &str,
    no_specialisation: bool,
    explicit_specialisation: Option<String>,
) -> Option<String> {
    if no_specialisation {
        None
    } else {
        let current_specialisation = std::fs::read_to_string(specialisation_path).ok();
        explicit_specialisation.or(current_specialisation)
    }
}

/// Checks if the user wants to proceed with applying the configuration
pub fn confirm_action(ask: bool, dry: bool) -> Result<bool> {
    use tracing::{info, warn};

    if dry {
        if ask {
            warn!("--ask has no effect as dry run was requested");
        }
        return Ok(false);
    }

    if ask {
        info!("Apply the config?");
        let confirmation = Confirm::new("Apply the config?")
            .with_default(false)
            .prompt()?;

        if !confirmation {
            bail!("User rejected the new config");
        }
    }

    Ok(true)
}

/// Common function to ensure we're not running as root
pub fn check_not_root(bypass_root_check: bool) -> Result<bool> {
    use tracing::warn;

    if bypass_root_check {
        warn!("Bypassing root check, now running nix as root");
        return Ok(false);
    }

    if nix::unistd::Uid::effective().is_root() {
        // Protect users from themselves
        bail!("Don't run nh os as root. I will call sudo internally as needed");
    }

    Ok(true)
}

/// Creates a temporary output path for build results
pub fn create_output_path(
    out_link: Option<impl AsRef<std::path::Path>>,
    prefix: &str,
) -> Result<Box<dyn crate::util::MaybeTempPath>> {
    let out_path: Box<dyn crate::util::MaybeTempPath> = match out_link {
        Some(ref p) => Box::new(std::path::PathBuf::from(p.as_ref())),
        None => Box::new({
            let dir = tempfile::Builder::new().prefix(prefix).tempdir()?;
            (dir.as_ref().join("result"), dir)
        }),
    };

    Ok(out_path)
}

/// Compare configurations using nvd diff
pub fn compare_configurations(
    current_profile: &str,
    target_profile: &std::path::Path,
    skip_compare: bool,
    message: &str,
) -> Result<()> {
    if skip_compare {
        debug!("Skipping configuration comparison");
        return Ok(());
    }

    commands::Command::new("nvd")
        .arg("diff")
        .arg(current_profile)
        .arg(target_profile)
        .message(message)
        .run()
        .with_context(|| {
            format!(
                "Failed to compare configurations with nvd: {} vs {}",
                current_profile,
                target_profile.display()
            )
        })?;

    Ok(())
}

/// Build a configuration using the nix build command
pub fn build_configuration(
    installable: Installable,
    out_path: &dyn crate::util::MaybeTempPath,
    extra_args: &[impl AsRef<std::ffi::OsStr>],
    builder: Option<String>,
    message: &str,
    no_nom: bool,
    passthrough_args: NixBuildPassthroughArgs,
) -> Result<()> {
    let passthrough = passthrough_args.parse_passthrough_args()?;

    commands::Build::new(installable)
        .extra_arg("--out-link")
        .extra_arg(out_path.get_path())
        .extra_args(extra_args)
        .passthrough(&self.passthrough)
        .builder(builder)
        .message(message)
        .nom(!no_nom)
        .run()
        .with_context(|| format!("Failed to build configuration: {}", message))?;

    Ok(())
}

/// Determine the target profile path considering specialisation
pub fn get_target_profile(
    out_path: &dyn crate::util::MaybeTempPath,
    target_specialisation: &Option<String>,
) -> PathBuf {
    match target_specialisation {
        None => out_path.get_path().to_owned(),
        Some(spec) => out_path.get_path().join("specialisation").join(spec),
    }
}

/// Common logic for handling REPL for different platforms
pub fn run_repl(
    installable: Installable,
    config_type: &str,
    extra_path: &[&str],
    config_name: Option<String>,
    extra_args: &[String],
) -> Result<()> {
    // Store paths don't work with REPL
    if let Installable::Store { .. } = installable {
        bail!("Nix doesn't support nix store installables with repl.");
    }

    let installable = extend_installable_for_platform(
        installable,
        config_type,
        extra_path,
        config_name,
        false,
        &[],
    )?;

    debug!("Running nix repl with installable: {:?}", installable);

    // NOTE: Using stdlib Command directly is necessary for interactive REPL
    // Interactivity implodes otherwise.
    use std::process::{Command as StdCommand, Stdio};

    let mut command = StdCommand::new("nix");
    command.arg("repl");

    // Add installable arguments
    for arg in installable.to_args() {
        command.arg(arg);
    }

    // Add any extra arguments
    for arg in extra_args {
        command.arg(arg);
    }

    // Configure for interactive use
    command
        .stdin(Stdio::inherit())
        .stdout(Stdio::inherit())
        .stderr(Stdio::inherit());

    // Execute and wait for completion
    let status = command.status()?;

    if !status.success() {
        bail!("nix repl exited with non-zero status: {}", status);
    }

    Ok(())
}

/// Process the target specialisation based on common patterns
pub fn process_specialisation(
    no_specialisation: bool,
    specialisation: Option<String>,
    specialisation_path: &str,
) -> Result<Option<String>> {
    let target_specialisation =
        handle_specialisation(specialisation_path, no_specialisation, specialisation);

    debug!("target_specialisation: {target_specialisation:?}");

    Ok(target_specialisation)
}

/// Execute common actions for a rebuild operation across platforms
///
/// This function handles the core workflow for building and managing system
/// configurations across different platforms (`NixOS`, Darwin, Home Manager).
/// It unifies what would otherwise be duplicated across platform-specific modules.
///
/// The function takes care of:
/// 1. Properly configuring the attribute path based on platform type
/// 2. Building the configuration
/// 3. Handling specialisations where applicable
/// 4. Comparing the new configuration with the current one
///
/// # Arguments
///
/// * `installable` - The Nix installable representing the configuration
/// * `config_type` - The configuration type (e.g., "nixosConfigurations", "darwinConfigurations")
/// * `extra_path` - Additional path elements for the attribute path
/// * `config_name` - Optional hostname or configuration name
/// * `out_path` - Output path for the build result
/// * `extra_args` - Additional arguments to pass to the build command
/// * `builder` - Optional remote builder to use
/// * `message` - Message to display during the build process
/// * `no_nom` - Whether to disable nix-output-monitor
/// * `specialisation_path` - Path to read specialisations from
/// * `no_specialisation` - Whether to ignore specialisations
/// * `specialisation` - Optional explicit specialisation to use
/// * `current_profile` - Path to the current system profile for comparison
/// * `skip_compare` - Whether to skip comparing the new and current configuration
///
/// # Returns
///
/// The path to the built configuration, which can be used for activation
#[allow(clippy::too_many_arguments)]
pub fn handle_rebuild_workflow(
    installable: Installable,
    config_type: &str,
    extra_path: &[&str],
    config_name: Option<String>,
    out_path: &dyn crate::util::MaybeTempPath,
    extra_args: &[impl AsRef<std::ffi::OsStr>],
    builder: Option<String>,
    message: &str,
    no_nom: bool,
    specialisation_path: &str,
    no_specialisation: bool,
    specialisation: Option<String>,
    current_profile: &str,
    skip_compare: bool,
    passthrough_args: NixBuildPassthroughArgs,
) -> Result<PathBuf> {
    // Convert the extra_args to OsString for the config struct
    let extra_args_vec: Vec<OsString> = extra_args
        .iter()
        .map(|arg| arg.as_ref().to_os_string())
        .collect();

    // Create a config struct from the parameters
    let config = RebuildWorkflowConfig {
        installable,
        config_type,
        extra_path,
        config_name,
        out_path,
        extra_args: extra_args_vec,
        builder,
        message,
        no_nom,
        specialisation_path,
        no_specialisation,
        specialisation,
        current_profile,
        skip_compare,
        passthrough_args,
    };

    // Delegate to the new implementation
    handle_rebuild_workflow_with_config(config)
}

/// Determine proper hostname based on provided or automatically detected
pub fn get_target_hostname(
    explicit_hostname: Option<String>,
    skip_if_mismatch: bool,
) -> Result<(String, bool)> {
    let system_hostname = match crate::util::get_hostname() {
        Ok(hostname) => {
            debug!("Auto-detected hostname: {}", hostname);
            Some(hostname)
        }
        Err(err) => {
            warn!("Failed to detect hostname: {}", err);
            None
        }
    };

    let target_hostname = match explicit_hostname {
        Some(hostname) => hostname,
        None => match system_hostname.clone() {
            Some(hostname) => hostname,
            None => bail!(
                "Unable to fetch hostname automatically. Please specify explicitly with --hostname."
            ),
        },
    };

    // Skip comparison when system hostname != target hostname if requested
    let hostname_mismatch = skip_if_mismatch
        && system_hostname.is_some()
        && system_hostname.unwrap() != target_hostname;

    debug!(
        ?target_hostname,
        ?hostname_mismatch,
        "Determined target hostname"
    );
    Ok((target_hostname, hostname_mismatch))
}

/// Common function to activate configurations in `NixOS`
pub fn activate_nixos_configuration(
    target_profile: &Path,
    variant: &str,
    target_host: Option<String>,
    elevate: bool,
    message: &str,
) -> Result<()> {
    let switch_to_configuration = target_profile.join("bin").join("switch-to-configuration");
    let switch_to_configuration = switch_to_configuration.canonicalize().map_err(|e| {
        color_eyre::eyre::eyre!("Failed to canonicalize switch-to-configuration path: {}", e)
    })?;

    commands::Command::new(switch_to_configuration)
        .arg(variant)
        .ssh(target_host)
        .message(message)
        .elevate(elevate)
        .run()
}

/// Configuration options for rebuilding workflows
pub struct RebuildWorkflowConfig<'a> {
    /// The Nix installable representing the configuration
    pub installable: Installable,

    /// The configuration type (e.g., "nixosConfigurations", "darwinConfigurations")
    pub config_type: &'a str,

    /// Additional path elements for the attribute path
    pub extra_path: &'a [&'a str],

    /// Optional hostname or configuration name
    pub config_name: Option<String>,

    /// Output path for the build result
    pub out_path: &'a dyn crate::util::MaybeTempPath,

    /// Additional arguments to pass to the build command as OsStrings
    pub extra_args: Vec<OsString>,

    /// Optional remote builder to use
    pub builder: Option<String>,

    /// Message to display during the build process
    pub message: &'a str,

    /// Whether to disable nix-output-monitor
    pub no_nom: bool,

    /// Path to read specialisations from
    pub specialisation_path: &'a str,

    /// Whether to ignore specialisations
    pub no_specialisation: bool,

    /// Optional explicit specialisation to use
    pub specialisation: Option<String>,

    /// Path to the current system profile for comparison
    pub current_profile: &'a str,

    /// Whether to skip comparing the new and current configuration
    pub skip_compare: bool,

    /// Arguments to pass to Nix
    pub passthrough_args: NixBuildPassthroughArgs,
}

/// Execute common actions for a rebuild operation across platforms using configuration struct
///
/// This function takes a configuration struct instead of many individual parameters
fn handle_rebuild_workflow_with_config(config: RebuildWorkflowConfig) -> Result<PathBuf> {
    // Special handling for darwin configurations
    if config.config_type == "darwinConfigurations" {
        // First construct the proper attribute path for darwin configs
        let mut processed_installable = config.installable;
        if let Installable::Flake {
            ref mut attribute, ..
        } = processed_installable
        {
            // Only set the attribute path if user hasn't already specified one
            if attribute.is_empty() {
                attribute.push(String::from(config.config_type));
                if let Some(name) = &config.config_name {
                    attribute.push(name.clone());
                }
            }
        }

        // Next, add config.system.build.<attr> to the path to access the derivation
        let mut toplevel_attr = processed_installable;
        if let Installable::Flake {
            ref mut attribute, ..
        } = toplevel_attr
        {
            // All darwin configurations expose their outputs under system.build
            let toplevel_path = ["config", "system", "build"];
            attribute.extend(toplevel_path.iter().map(|s| (*s).to_string()));

            // Add the final component (usually "toplevel")
            if !config.extra_path.is_empty() {
                attribute.push(config.extra_path[0].to_string());
            }
        }

        // Build the configuration
        build_configuration(
            toplevel_attr,
            config.out_path,
            &config.extra_args,
            config.builder.clone(),
            config.message,
            config.no_nom,
            config.passthrough_args,
        )?;

        // Darwin doesn't use the specialisation mechanism like NixOS
        let target_profile = config.out_path.get_path().to_owned();

        // Run the diff to show changes
        if !config.skip_compare {
            compare_configurations(
                config.current_profile,
                &target_profile,
                false,
                "Comparing changes",
            )?;
        }

        return Ok(target_profile);
    }

    // Configure the installable with platform-specific attributes
    let configured_installable = extend_installable_for_platform(
        config.installable,
        config.config_type,
        config.extra_path,
        config.config_name.clone(),
        true,
        &config.extra_args,
    )?;

    // Build the configuration
    build_configuration(
        configured_installable,
        config.out_path,
        &config.extra_args,
        config.builder.clone(),
        config.message,
        config.no_nom,
        config.passthrough_args,
    )?;

    // Process any specialisations (NixOS/Home-Manager specific feature)
    let target_specialisation = process_specialisation(
        config.no_specialisation,
        config.specialisation.clone(),
        config.specialisation_path,
    )?;

    // Get target profile path
    let target_profile = get_target_profile(config.out_path, &target_specialisation);

    // Compare configurations if applicable
    if !config.skip_compare {
        compare_configurations(
            config.current_profile,
            &target_profile,
            false,
            "Comparing changes",
        )?;
    }

    Ok(target_profile)
}
</file>

<file path="src/completion.rs">
use clap_complete::generate;
use color_eyre::Result;
use tracing::instrument;

use crate::{interface, interface::Main};

impl interface::CompletionArgs {
  #[instrument(ret, level = "trace")]
  /// Run the completion subcommand.
  ///
  /// # Errors
  ///
  /// Returns an error if completion script generation or output fails.
  pub fn run(&self) -> Result<()> {
    let mut cmd = <Main as clap::CommandFactory>::command();
    generate(self.shell, &mut cmd, "nh", &mut std::io::stdout());
    Ok(())
  }
}
</file>

<file path="src/json.rs">
use std::fmt::Display;

#[derive(Debug, Clone)]
pub struct Value<'v> {
  pub inner: &'v serde_json::Value,
  get_stack: Vec<String>,
}

#[derive(Debug)]
pub struct Error {
  get_stack: Vec<String>,
}

impl Display for Error {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    write!(f, "Failed to index json value with ")?;

    for (i, elem) in self.get_stack.iter().enumerate() {
      if i != 0 {
        write!(f, ".")?;
      }
      write!(f, "{elem}")?;
    }

    Ok(())
  }
}

impl std::error::Error for Error {}

#[allow(unused)]
impl<'v> Value<'v> {
  #[must_use]
  pub const fn new(value: &'v serde_json::Value) -> Self {
    Self {
      inner:     value,
      get_stack: vec![],
    }
  }

  pub fn get(&self, index: &str) -> Result<Self, Error> {
    let mut get_stack = self.get_stack.clone();
    get_stack.push(index.to_owned());

    match self.inner.get(index) {
      Some(value) => {
        Ok(Self {
          inner: value,
          get_stack,
        })
      },
      None => Err(Error { get_stack }),
    }
  }
}

#[test]
fn test_value() {
  let input = serde_json::json!({
      "foo": {
          "bar": "baz",
          "some": {
              "other": "value"
          }
      }
  });

  let i = Value::new(&input);

  assert!(i.get("foo").is_ok());
  assert!(i.get("foo_bad").is_err());
  assert!(i.get("foo").unwrap().get("bar").is_ok());
  assert!(
    i.get("foo")
      .unwrap()
      .get("some")
      .unwrap()
      .get("other_bad")
      .is_err()
  );
  assert!(
    i.get("foo")
      .unwrap()
      .get("some")
      .unwrap()
      .get("other")
      .is_ok()
  );
}
</file>

<file path="test/configuration.nix">
{ pkgs, ... }:
{
  fileSystems."/" = {
    device = "none";
    fsType = "tmpfs";
    options = [ "size=1G" ];
  };

  boot.loader.grub.devices = [ "nodev" ];

  environment.systemPackages = [ pkgs.hello ];
}
</file>

<file path="xtask/src/main.rs">
use std::{
  env,
  path::{Path, PathBuf},
};

use clap::{Parser, Subcommand};

mod man;

#[derive(Parser)]
struct Cli {
  #[command(subcommand)]
  command: Command,
}

#[derive(Subcommand)]
enum Command {
  /// Generate manpage
  Man {
    /// Output directory for manpage
    #[arg(long, default_value = "gen")]
    out_dir: String,
  },
}

fn main() {
  let Cli { command } = Cli::parse();
  env::set_current_dir(project_root()).unwrap();
  match command {
    Command::Man { out_dir } => man::r#gen(&out_dir),
  }
}

fn project_root() -> PathBuf {
  Path::new(
    &env::var("CARGO_MANIFEST_DIR")
      .unwrap_or_else(|_| env!("CARGO_MANIFEST_DIR").to_owned()),
  )
  .ancestors()
  .nth(1)
  .unwrap()
  .to_path_buf()
}
</file>

<file path="xtask/src/man.rs">
use std::path::Path;

use clap::CommandFactory;
use roff::{Roff, bold, roman};

pub fn r#gen(out_dir: &str) {
  let gen_dir = Path::new(out_dir);
  if !gen_dir.exists() {
    std::fs::create_dir_all(gen_dir)
      .expect("failed to create output directory");
  }
  gen_man(gen_dir);
}

fn gen_man(base_dir: &Path) {
  let man_path = base_dir.join("nh.1");
  let mut buffer: Vec<u8> = Vec::new();

  let mut cmd = nh::interface::Main::command();
  let mut man = clap_mangen::Man::new(cmd.clone());
  man = man.manual("nh manual".to_string());
  man.render_title(&mut buffer).unwrap();
  man.render_name_section(&mut buffer).unwrap();
  man.render_synopsis_section(&mut buffer).unwrap();
  man.render_description_section(&mut buffer).unwrap();
  render_command_recursive(&mut cmd, 1, &mut buffer);

  let statuses = [
    ("0", "Successful program execution."),
    ("1", "Unsuccessful program execution."),
    ("101", "The program panicked."),
  ];
  let mut sect = Roff::new();
  sect.control("SH", ["EXIT STATUS"]);
  for (code, reason) in statuses {
    sect.control("IP", [code]).text([roman(reason)]);
  }
  sect.to_writer(&mut buffer).unwrap();

  // EXAMPLES section
  let examples = [
    (
      "Switch to a new NixOS configuration",
      "nh os switch --hostname myhost --specialisation dev",
      "",
    ),
    (
      "Rollback to a previous NixOS generation",
      "nh os rollback --to 42",
      "",
    ),
    (
      "Switch to a home-manager configuration",
      "nh home switch --configuration alice@work",
      "",
    ),
    (
      "Build a home-manager configuration with backup",
      "nh home build --backup-extension .bak",
      "",
    ),
    (
      "Switch to a darwin configuration",
      "nh darwin switch --hostname mymac",
      "",
    ),
    ("Search for ripgrep", "nh search ripgrep", ""),
    (
      "Show supported platforms for a package",
      "nh search --platforms ripgrep",
      "",
    ),
    (
      "Clean all but keep 5 generations",
      "nh clean all --keep 5",
      "",
    ),
    (
      "Clean a specific profile",
      "nh clean profile /nix/var/nix/profiles/system",
      "",
    ),
  ];
  let mut sect = Roff::new();
  sect.control("SH", ["EXAMPLES"]);
  for (desc, command, result) in examples {
    sect
      .control("TP", [])
      .text([roman(desc)])
      .text([bold(format!("$ {}", command))])
      .control("br", []);
    if !result.is_empty() {
      sect.text([roman(result)]);
    }
  }
  sect.to_writer(&mut buffer).unwrap();

  std::fs::write(man_path, buffer).expect("failed to write manpage");
}

fn render_command_recursive(
  cmd: &mut clap::Command,
  depth: usize,
  buffer: &mut Vec<u8>,
) {
  let mut sect = Roff::new();

  // Section header
  let title = if depth == 1 { "OPTIONS" } else { "SUBCOMMAND" };
  sect.control("SH", [title]);

  // About/long_about/help
  if let Some(about) = cmd.get_long_about().or(cmd.get_about()) {
    sect.text([roman(about.to_string())]);
  }

  // Usage
  let usage = cmd.render_usage().to_string();
  sect.control("TP", []);
  sect.text([bold(usage)]);

  // Arguments/options
  for arg in cmd.get_arguments() {
    if arg.is_hide_set() {
      continue;
    }
    sect.control("TP", []);
    let mut opt = String::new();
    if let Some(short) = arg.get_short() {
      opt.push('-');
      opt.push(short);
      if arg.get_long().is_some() {
        opt.push_str(", ");
      }
    }
    if let Some(long) = arg.get_long() {
      opt.push_str("--");
      opt.push_str(long);
    }
    if !opt.is_empty() {
      sect.text([bold(opt)]);
    }
    if let Some(help) = arg.get_help().or(arg.get_long_help()) {
      sect.text([roman(help.to_string())]);
    }
    if let Some(env) = arg.get_env() {
      sect.text([roman(format!(" [env: {}]", env.to_string_lossy()))]);
    }
    let mut defaults_iter = arg.get_default_values().iter();
    if let Some(default) = defaults_iter.next() {
      sect.text([roman(format!(" [default: {}]", default.to_string_lossy()))]);
    }
    if arg.is_required_set() {
      sect.text([roman(" [required]")]);
    }
  }

  sect.to_writer(buffer).unwrap();

  // Subcommands
  for sub in cmd.get_subcommands_mut() {
    render_command_recursive(sub, depth + 1, buffer);
  }
}
</file>

<file path=".gitignore">
# Rust
target
gen*
!generations.rs

# Nix
.direnv
result*

# From cargo-mutants
mutants*

# Misc
report*
</file>

<file path=".github/ISSUE_TEMPLATE/bug.yml">
---
name: Bug Report
description: Report a bug
title: "<short description of the bug>"
labels: ["bug (requires confirmation)"]

body:
  - type: checkboxes
    attributes:
      label: I have confirmed that this is a bug related to nh
      description: >-
        If you are unsure whether this is a bug, a packaging issue, or user error that is *not*
        stemming from NH, please consider creating a [discussion](https://github.com/nix-community/nh/discussions)
        post instead. Invalid bug reports will be closed without an explanation.
      options:
        - required: true
          label: >-
            This is a bug, and not an user error or a support request. I understand that my issue
            will be closed if it is not a bug in NH.
        - required: true
          label: >-
            I have checked the [issues tab](https://github.com/nix-community/nh/issues?q=is%3Aissue)
            and confirmed that my issue has not yet been reported. I understand that my issue will
            be closed if it is a duplicate.


  - type: textarea
    attributes:
      label: Description
      placeholder: Describe the issue here...
      description: >-
        Describe the issue in detail, with steps you have taken included. If applicable, please include
        a minimal reproducible example, relevant Nix logs, comparisons with alternative commands and
        screenshots. Do note that **logs** are preferred over screenshots.
    validations:
      required: true

  - type: dropdown
    attributes:
      label: Installation Method
      description: How was NH installed?
      options:
        - Stable Release (nixpkgs, `pkgs.nh` from nixos-unstable or nixos-yy-mm)
        - Flakes (`nix profile add`) / Channels (`nix-env` from master branch or from a release)
        - Other (Please specify)

    validations:
      required: true

  - type: textarea
    attributes:
      label: Installation Method (Other)
      description: "If you have selected 'Other' in the previous section, please describe your installation method"
      placeholder: >-
        I installed nh from...

    validations:
      required: false

  - type: textarea
    attributes:
      label: NH Version
      description: "Which version of NH is currently in use? (`nh --version`)"
      placeholder: >-
        For example, v4.1.0.

    validations:
      required: true

  - type: textarea
    attributes:
      label: System Information
      description: "Output of `nix-info --markdown`"
      placeholder: |-
         - system:
         - host os:
         - multi-user?:
         - sandbox:
         - version:
         - nixpkgs:

    validations:
      required: true
</file>

<file path=".github/workflows/cleanup.yaml">
name: Cleanup

on:
  workflow_dispatch:
  schedule:
    - cron: "0 4 1 * *"

jobs:
  branches:
    name: Cleanup old branches
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Run delete-old-branches-action
        uses: beatlabs/delete-old-branches-action@v0.0.11
        with:
          repo_token: ${{ github.token }}
          date: '1 months ago'
          dry_run: false
          delete_tags: false
          exclude_open_pr_branches: true
</file>

<file path="src/installable.rs">
use std::{env, fs, path::PathBuf};

use clap::{Arg, ArgAction, Args, FromArgMatches, error::ErrorKind};
use tracing::debug;
use yansi::{Color, Paint};

// Reference: https://nix.dev/manual/nix/2.18/command-ref/new-cli/nix

#[derive(Debug, Clone)]
pub enum Installable {
  Flake {
    reference: String,
    attribute: Vec<String>,
  },
  File {
    path:      PathBuf,
    attribute: Vec<String>,
  },
  Store {
    path: PathBuf,
  },
  Expression {
    expression: String,
    attribute:  Vec<String>,
  },
}

impl FromArgMatches for Installable {
  fn from_arg_matches(matches: &clap::ArgMatches) -> Result<Self, clap::Error> {
    let mut matches = matches.clone();
    Self::from_arg_matches_mut(&mut matches)
  }

  fn from_arg_matches_mut(
    matches: &mut clap::ArgMatches,
  ) -> Result<Self, clap::Error> {
    let installable = matches.get_one::<String>("installable");
    let file = matches.get_one::<String>("file");
    let expr = matches.get_one::<String>("expr");

    if let Some(i) = installable {
      let canonincal = fs::canonicalize(i);

      if let Ok(p) = canonincal {
        if p.starts_with("/nix/store") {
          return Ok(Self::Store { path: p });
        }
      }
    }

    if let Some(f) = file {
      return Ok(Self::File {
        path:      PathBuf::from(f),
        attribute: parse_attribute(installable.cloned().unwrap_or_default()),
      });
    }

    if let Some(e) = expr {
      return Ok(Self::Expression {
        expression: e.to_string(),
        attribute:  parse_attribute(installable.cloned().unwrap_or_default()),
      });
    }

    if let Some(i) = installable {
      let mut elems = i.splitn(2, '#');
      let reference = elems.next().unwrap().to_owned();
      return Ok(Self::Flake {
        reference,
        attribute: parse_attribute(
          elems
            .next()
            .map(std::string::ToString::to_string)
            .unwrap_or_default(),
        ),
      });
    }

    // Env var parsing & fallbacks
    fn parse_flake_env(var: &str) -> Option<Installable> {
      env::var(var).ok().map(|f| {
        let mut elems = f.splitn(2, '#');
        Installable::Flake {
          reference: elems.next().unwrap().to_owned(),
          attribute: parse_attribute(
            elems
              .next()
              .map(std::string::ToString::to_string)
              .unwrap_or_default(),
          ),
        }
      })
    }

    // Command-specific flake env vars
    if let Ok(subcommand) = env::var("NH_CURRENT_COMMAND") {
      debug!("Current subcommand: {subcommand:?}");
      let env_var = match subcommand.as_str() {
        "os" => "NH_OS_FLAKE",
        "home" => "NH_HOME_FLAKE",
        "darwin" => "NH_DARWIN_FLAKE",
        _ => "",
      };

      if !env_var.is_empty() {
        if let Some(installable) = parse_flake_env(env_var) {
          return Ok(installable);
        }
      }
    }

    // General flake env fallbacks
    for var in &[
      "NH_FLAKE",
      "NH_OS_FLAKE",
      "NH_HOME_FLAKE",
      "NH_DARWIN_FLAKE",
    ] {
      if let Some(installable) = parse_flake_env(var) {
        return Ok(installable);
      }
    }

    if let Ok(f) = env::var("NH_FILE") {
      return Ok(Self::File {
        path:      PathBuf::from(f),
        attribute: parse_attribute(env::var("NH_ATTRP").unwrap_or_default()),
      });
    }

    Err(clap::Error::new(ErrorKind::TooFewValues))
  }

  fn update_from_arg_matches(
    &mut self,
    _matches: &clap::ArgMatches,
  ) -> Result<(), clap::Error> {
    todo!()
  }
}

impl Args for Installable {
  fn augment_args(cmd: clap::Command) -> clap::Command {
    cmd
      .arg(
        Arg::new("file")
          .short('f')
          .long("file")
          .action(ArgAction::Set)
          .hide(true),
      )
      .arg(
        Arg::new("expr")
          .short('E')
          .long("expr")
          .conflicts_with("file")
          .hide(true)
          .action(ArgAction::Set),
      )
      .arg(
        Arg::new("installable")
          .action(ArgAction::Set)
          .value_name("INSTALLABLE")
          .help("Which installable to use")
          .long_help(format!(
            r"Which installable to use.
Nix accepts various kinds of installables:

[FLAKEREF[#ATTRPATH]]
    Flake reference with an optional attribute path.
    [env: NH_FLAKE={}]
    [env: NH_OS_FLAKE={}]
    [env: NH_HOME_FLAKE={}]
    [env: NH_DARWIN_FLAKE={}]

{}, {} <FILE> [ATTRPATH]
    Path to file with an optional attribute path.
    [env: NH_FILE={}]
    [env: NH_ATTRP={}]

{}, {} <EXPR> [ATTRPATH]
    Nix expression with an optional attribute path.

[PATH]
    Path or symlink to a /nix/store path
",
            env::var("NH_FLAKE").unwrap_or_default(),
            env::var("NH_OS_FLAKE").unwrap_or_default(),
            env::var("NH_HOME_FLAKE").unwrap_or_default(),
            env::var("NH_DARWIN_FLAKE").unwrap_or_default(),
            Paint::new("-f").fg(Color::Yellow),
            Paint::new("--file").fg(Color::Yellow),
            env::var("NH_FILE").unwrap_or_default(),
            env::var("NH_ATTR").unwrap_or_default(),
            Paint::new("-e").fg(Color::Yellow),
            Paint::new("--expr").fg(Color::Yellow),
          )),
      )
  }

  fn augment_args_for_update(cmd: clap::Command) -> clap::Command {
    Self::augment_args(cmd)
  }
}

// TODO: should handle quoted attributes, like foo."bar.baz" -> ["foo",
// "bar.baz"] maybe use chumsky?
pub fn parse_attribute<S>(s: S) -> Vec<String>
where
  S: AsRef<str>,
{
  let s = s.as_ref();
  let mut res = Vec::new();

  if s.is_empty() {
    return res;
  }

  let mut in_quote = false;

  let mut elem = String::new();
  for char in s.chars() {
    match char {
      '.' => {
        if in_quote {
          elem.push(char);
        } else {
          res.push(elem.clone());
          elem = String::new();
        }
      },
      '"' => {
        in_quote = !in_quote;
      },
      _ => elem.push(char),
    }
  }

  res.push(elem);

  assert!(!in_quote, "Failed to parse attribute: {s}");

  res
}

#[test]
fn test_parse_attribute() {
  assert_eq!(parse_attribute(r"foo.bar"), vec!["foo", "bar"]);
  assert_eq!(parse_attribute(r#"foo."bar.baz""#), vec!["foo", "bar.baz"]);
  let v: Vec<String> = vec![];
  assert_eq!(parse_attribute(""), v);
}

impl Installable {
  #[must_use]
  pub fn to_args(&self) -> Vec<String> {
    let mut res = Vec::new();
    match self {
      Self::Flake {
        reference,
        attribute,
      } => {
        res.push(format!("{reference}#{}", join_attribute(attribute)));
      },
      Self::File { path, attribute } => {
        res.push(String::from("--file"));
        res.push(path.to_str().unwrap().to_string());
        res.push(join_attribute(attribute));
      },
      Self::Expression {
        expression,
        attribute,
      } => {
        res.push(String::from("--expr"));
        res.push(expression.to_string());
        res.push(join_attribute(attribute));
      },
      Self::Store { path } => res.push(path.to_str().unwrap().to_string()),
    }

    res
  }
}

#[test]
fn test_installable_to_args() {
  assert_eq!(
    (Installable::Flake {
      reference: String::from("w"),
      attribute: ["x", "y.z"].into_iter().map(str::to_string).collect(),
    })
    .to_args(),
    vec![r#"w#x."y.z""#]
  );

  assert_eq!(
    (Installable::File {
      path:      PathBuf::from("w"),
      attribute: ["x", "y.z"].into_iter().map(str::to_string).collect(),
    })
    .to_args(),
    vec!["--file", "w", r#"x."y.z""#]
  );
}

fn join_attribute<I>(attribute: I) -> String
where
  I: IntoIterator,
  I::Item: AsRef<str>,
{
  let mut res = String::new();
  let mut first = true;
  for elem in attribute {
    if first {
      first = false;
    } else {
      res.push('.');
    }

    let s = elem.as_ref();

    if s.contains('.') {
      res.push_str(&format!(r#""{s}""#));
    } else {
      res.push_str(s);
    }
  }

  res
}

#[test]
fn test_join_attribute() {
  assert_eq!(join_attribute(vec!["foo", "bar"]), "foo.bar");
  assert_eq!(join_attribute(vec!["foo", "bar.baz"]), r#"foo."bar.baz""#);
}

impl Installable {
  #[must_use]
  pub const fn str_kind(&self) -> &str {
    match self {
      Self::Flake { .. } => "flake",
      Self::File { .. } => "file",
      Self::Store { .. } => "store path",
      Self::Expression { .. } => "expression",
    }
  }
}
</file>

<file path="src/logging.rs">
use clap_verbosity_flag::InfoLevel;
use tracing::{Event, Level, Subscriber};
use tracing_subscriber::{
  EnvFilter,
  filter::LevelFilter,
  fmt::{self, FormatEvent, FormatFields},
  prelude::*,
  registry::LookupSpan,
};
use yansi::{Color, Paint};

use crate::Result;

struct InfoFormatter;

impl<S, N> FormatEvent<S, N> for InfoFormatter
where
  S: Subscriber + for<'a> LookupSpan<'a>,
  N: for<'a> FormatFields<'a> + 'static,
{
  fn format_event(
    &self,
    ctx: &fmt::FmtContext<'_, S, N>,
    mut writer: fmt::format::Writer,
    event: &Event,
  ) -> std::fmt::Result {
    // Based on https://docs.rs/tracing-subscriber/latest/tracing_subscriber/fmt/trait.FormatEvent.html#examples
    // Without the unused parts
    let metadata = event.metadata();
    let level = metadata.level();

    match *level {
      Level::ERROR => {
        write!(writer, "{} ", Paint::new("ERROR").fg(Color::Red))?
      },
      Level::WARN => write!(writer, "{} ", Paint::new("!").fg(Color::Yellow))?,
      Level::INFO => write!(writer, "{} ", Paint::new(">").fg(Color::Green))?,
      Level::DEBUG => {
        write!(writer, "{} ", Paint::new("DEBUG").fg(Color::Blue))?
      },
      Level::TRACE => {
        write!(writer, "{} ", Paint::new("TRACE").fg(Color::Cyan))?
      },
    }

    ctx.field_format().format_fields(writer.by_ref(), event)?;

    if *level != Level::INFO {
      if let (Some(file), Some(line)) = (metadata.file(), metadata.line()) {
        write!(writer, " (nh/{file}:{line})")?;
      }
    }

    writeln!(writer)?;
    Ok(())
  }
}

pub fn setup_logging(
  verbosity: clap_verbosity_flag::Verbosity<InfoLevel>,
) -> Result<()> {
  color_eyre::config::HookBuilder::default()
    .display_location_section(true)
    .panic_section(
      "Please report the bug at https://github.com/nix-community/nh/issues",
    )
    .display_env_section(false)
    .install()?;

  let fallback_level =
    verbosity.log_level().map_or(LevelFilter::WARN, |level| {
      match level {
        clap_verbosity_flag::log::Level::Error => LevelFilter::ERROR,
        clap_verbosity_flag::log::Level::Warn => LevelFilter::WARN,
        clap_verbosity_flag::log::Level::Info => LevelFilter::INFO,
        clap_verbosity_flag::log::Level::Debug => LevelFilter::DEBUG,
        clap_verbosity_flag::log::Level::Trace => LevelFilter::TRACE,
      }
    });

  let layer = fmt::layer()
    .with_writer(std::io::stderr)
    .without_time()
    .compact()
    .with_line_number(true)
    .event_format(InfoFormatter)
    .with_filter(
      EnvFilter::from_env("NH_LOG").add_directive(fallback_level.into()),
    );

  tracing_subscriber::registry().with(layer).init();

  tracing::trace!("Logging OK");

  Ok(())
}
</file>

<file path="src/update.rs">
use tracing::warn;

use crate::{Result, commands::Command, installable::Installable};

pub fn update(
  installable: &Installable,
  inputs: Option<Vec<String>>,
) -> Result<()> {
  let Installable::Flake { reference, .. } = installable else {
    warn!(
      "Only flake installables can be updated, {} is not supported",
      installable.str_kind()
    );
    return Ok(());
  };

  let mut cmd = Command::new("nix").args(["flake", "update"]);

  if let Some(inputs) = inputs {
    for input in &inputs {
      cmd = cmd.arg(input);
    }
    cmd = cmd.message(format!(
      "Updating flake input{maybe_plural} {inputs}",
      maybe_plural = if inputs.len() > 1 { "s" } else { "" },
      inputs = inputs.join(", ")
    ));
  } else {
    cmd = cmd.message("Updating all flake inputs");
  }

  cmd.arg("--flake").arg(reference).run()?;

  Ok(())
}
</file>

<file path=".rustfmt.toml">
condense_wildcard_suffixes   = true
doc_comment_code_block_width = 80
edition                      = "2024"               # Keep in sync with Cargo.toml.
enum_discrim_align_threshold = 60
force_explicit_abi           = false
force_multiline_blocks       = true
format_code_in_doc_comments  = true
format_macro_matchers        = true
format_strings               = true
group_imports                = "StdExternalCrate"
hex_literal_case             = "Upper"
imports_granularity          = "Crate"
imports_layout               = "HorizontalVertical"
inline_attribute_width       = 60
match_block_trailing_comma   = true
max_width                    = 80
newline_style                = "Unix"
normalize_comments           = true
normalize_doc_attributes     = true
overflow_delimited_expr      = true
struct_field_align_threshold = 60
tab_spaces                   = 2
unstable_features            = true
use_field_init_shorthand     = true
use_try_shorthand            = true
wrap_comments                = true
</file>

<file path="flake.lock">
{
  "nodes": {
    "nixpkgs": {
      "locked": {
        "lastModified": 1759580034,
        "narHash": "sha256-YWo57PL7mGZU7D4WeKFMiW4ex/O6ZolUS6UNBHTZfkI=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "3bcc93c5f7a4b30335d31f21e2f1281cba68c318",
        "type": "github"
      },
      "original": {
        "owner": "NixOS",
        "ref": "nixos-25.05",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "nixpkgs": "nixpkgs"
      }
    }
  },
  "root": "root",
  "version": 7
}
</file>

<file path=".github/PULL_REQUEST_TEMPLATE.md">
<!--
^ Please include a clear and concise description of the aim of your Pull Request above this line ^

For plugin dependency/module additions, please make sure to link the source link
of the added plugin or dependency in this section. If your pull request aims to
fix an open issue or bug, please also link the relevant issue below this
line. You may attach an issue to your pull request with `Fixes #<issue number>`
above this comment, and it will be closed when your pull request is merged.
-->

## Sanity Checking

<!--
Please check all that apply. As before, this section is not a hard requirement
but checklists with more checked items are likely to be merged faster. You may
save some time in maintainer reviews by performing self-reviews here before
submitting your pull request.

If your pull request includes any change or unexpected behaviour not covered below,
please do make sure to include it above in your description.
-->

[changelog]: https://github.com/nix-community/nh/tree/master/CHANGELOG.md

- [ ] I have updated the [changelog] as per my changes
- [ ] I have tested, and self-reviewed my code
- Style and consistency
  - [ ] I ran **`nix fmt`** to format my Nix code
  - [ ] I ran **`cargo fmt`** to format my Rust code
  - [ ] I have added appropriate documentation to new code
  - [ ] My changes are consistent with the rest of the codebase
- Correctness
  - [ ] I ran **`cargo clippy`** and fixed any new linter warnings.
- If new changes are particularly complex:
  - [ ] My code includes comments in particularly complex areas to explain the
        logic
  - [ ] I have documented the motive for those changes in the PR body or commit
        description.
- Tested on platform(s)
  - [ ] `x86_64-linux`
  - [ ] `aarch64-linux`
  - [ ] `x86_64-darwin`
  - [ ] `aarch64-darwin`

---

Add a :+1: [reaction] to [pull requests you find important].

[reaction]: https://github.blog/2016-03-10-add-reactions-to-pull-requests-issues-and-comments/
[pull requests you find important]: https://github.com/nix-community/nh/pulls?q=is%3Aopen+sort%3Areactions-%2B1-desc
</file>

<file path="src/checks.rs">
use std::{cmp::Ordering, env};

use color_eyre::Result;
use semver::Version;
use tracing::{debug, warn};

use crate::util::{self, NixVariant, normalize_version_string};

/// Verifies if the installed Nix version meets requirements
///
/// # Returns
///
/// * `Result<()>` - Ok if version requirements are met, error otherwise
///
/// # Errors
///
/// Returns an error if the Nix version cannot be determined or parsed.
pub fn check_nix_version() -> Result<()> {
  // XXX: Both Nix and Lix follow semantic versioning (semver). Update the
  // versions below once latest stable for either of those packages change.
  // We *also* cannot (or rather, will not) make this check for non-nixpkgs
  // Nix variants, since there is no good baseline for what to support
  // without the understanding of stable/unstable branches. What do we check
  // for, whether upstream made an announcement? No thanks.
  // TODO: Set up a CI to automatically update those in the future.
  const MIN_LIX_VERSION: &str = "2.91.3";
  const MIN_NIX_VERSION: &str = "2.28.4";

  if env::var("NH_NO_CHECKS").is_ok() {
    return Ok(());
  }

  let nix_variant = util::get_nix_variant();
  let version = util::get_nix_version()?;
  let version_normal = normalize_version_string(&version);

  // Minimum supported versions. Those should generally correspond to
  // latest package versions in the stable branch.
  //
  // Q: Why are you doing this?
  // A: First of all to make sure we do not make baseless assumptions
  // about the user's system; we should only work around APIs that we
  // are fully aware of, and not try to work around every edge case.
  // Also, nh should be responsible for nudging the user to use the
  // relevant versions of the software it wraps, so that we do not have
  // to try and support too many versions. NixOS stable and unstable
  // will ALWAYS be supported, but outdated versions will not. If your
  // Nix fork uses a different versioning scheme, please open an issue.
  let min_version = match nix_variant {
    util::NixVariant::Lix => MIN_LIX_VERSION,
    _ => MIN_NIX_VERSION,
  };

  let current = match Version::parse(&version_normal) {
    Ok(ver) => ver,
    Err(e) => {
      warn!(
        "Failed to parse Nix version '{version_normal}': {e}. Skipping \
         version check.",
      );
      return Ok(());
    },
  };

  let required = Version::parse(min_version)?;

  match current.cmp(&required) {
    Ordering::Less => {
      let binary_name = match nix_variant {
        util::NixVariant::Lix => "Lix",
        util::NixVariant::Determinate => "Determinate Nix",
        util::NixVariant::Nix => "Nix",
      };
      warn!(
        "Warning: {} version {} is older than the recommended minimum version \
         {}. You may encounter issues.",
        binary_name, version, min_version
      );
      Ok(())
    },
    _ => Ok(()),
  }
}

/// Checks if core NH environment variables are set correctly. This was
/// previously `setup_environment()`, but the setup logic has been moved away.
///
/// # Returns
///
/// - `Result<()>` - Ok under all conditions. The user will only receive a
///   warning when their variable is determined to be outdated.
pub fn verify_variables() -> Result<()> {
  if let Ok(f) = std::env::var("FLAKE") {
    // Set NH_FLAKE if it's not already set
    if std::env::var("NH_FLAKE").is_err() {
      unsafe {
        std::env::set_var("NH_FLAKE", f);
      }

      // Only warn if FLAKE is set and we're using it to set NH_FLAKE
      // AND none of the command-specific env vars are set
      if std::env::var("NH_OS_FLAKE").is_err()
        && std::env::var("NH_HOME_FLAKE").is_err()
        && std::env::var("NH_DARWIN_FLAKE").is_err()
      {
        tracing::warn!(
          "nh {} now uses NH_FLAKE instead of FLAKE, please update your \
           configuration",
          super::NH_VERSION
        );
      }
    }
  }

  Ok(())
}

/// Consolidate all necessary checks for Nix functionality into a single
/// function. This will be executed in the main function, but can be executed
/// before critical commands to double-check if necessary.
///
/// NOTE: Experimental feature checks are now done per-command to avoid
/// redundant error messages for features not needed by the specific command.
///
/// # Returns
///
/// * `Result<()>` - Ok if all checks pass, error otherwise
///
/// # Errors
///
/// Returns an error if any required Nix environment checks fail.
pub fn verify_nix_environment() -> Result<()> {
  if env::var("NH_NO_CHECKS").is_ok() {
    return Ok(());
  }

  // Only check version globally. Features are checked per-command now.
  // This function is kept as is for backwards compatibility.
  check_nix_version()?;
  Ok(())
}

/// Trait for types that have feature requirements
pub trait FeatureRequirements {
  /// Returns the list of required experimental features
  fn required_features(&self) -> Vec<&'static str>;

  /// Checks if all required features are enabled
  ///
  /// # Errors
  ///
  /// Returns an error if any required Nix features are not enabled.
  fn check_features(&self) -> Result<()> {
    if env::var("NH_NO_CHECKS").is_ok() {
      return Ok(());
    }

    let required = self.required_features();
    if required.is_empty() {
      return Ok(());
    }

    debug!("Required Nix features: {}", required.join(", "));

    let missing = util::get_missing_experimental_features(&required)?;
    if !missing.is_empty() {
      return Err(color_eyre::eyre::eyre!(
        "Missing required experimental features for this command: {}",
        missing.join(", ")
      ));
    }

    debug!("All required Nix features are enabled");
    Ok(())
  }
}

/// Feature requirements for commands that use flakes
#[derive(Debug)]
pub struct FlakeFeatures;

impl FeatureRequirements for FlakeFeatures {
  fn required_features(&self) -> Vec<&'static str> {
    let mut features = vec![];

    // Determinate Nix doesn't require nix-command or flakes to be experimental
    // as they simply decided to mark those as no-longer-experimental-lol.
    // Remove redundant experimental features if the Nix variant is
    // determinate.
    let variant = util::get_nix_variant();
    if !matches!(variant, NixVariant::Determinate) {
      features.push("nix-command");
      features.push("flakes");
    }

    features
  }
}

/// Feature requirements for legacy (non-flake) commands
/// XXX: There are actually no experimental feature requirements for legacy
/// (nix2) CLI but since move-fast-break-everything is a common mantra among Nix
/// & Nix-adjacent software, I've implemented this. Do not remove, this is
/// simply for futureproofing.
#[derive(Debug)]
pub struct LegacyFeatures;

impl FeatureRequirements for LegacyFeatures {
  fn required_features(&self) -> Vec<&'static str> {
    vec![]
  }
}

/// Feature requirements for OS repl commands
#[derive(Debug)]
pub struct OsReplFeatures {
  pub is_flake: bool,
}

impl FeatureRequirements for OsReplFeatures {
  fn required_features(&self) -> Vec<&'static str> {
    let mut features = vec![];

    // For non-flake repls, no experimental features needed
    if !self.is_flake {
      return features;
    }

    // For flake repls, check if we need experimental features
    match util::get_nix_variant() {
      NixVariant::Determinate => {
        // Determinate Nix doesn't need experimental features
      },
      NixVariant::Lix => {
        features.push("nix-command");
        features.push("flakes");

        // Lix-specific repl-flake feature for older versions
        if let Ok(version) = util::get_nix_version() {
          let normalized_version = normalize_version_string(&version);
          if let Ok(current) = Version::parse(&normalized_version) {
            if let Ok(threshold) = Version::parse("2.93.0") {
              if current < threshold {
                features.push("repl-flake");
              }
            }
          }
        }
      },
      NixVariant::Nix => {
        features.push("nix-command");
        features.push("flakes");
      },
    }

    features
  }
}

/// Feature requirements for Home Manager repl commands
#[derive(Debug)]
pub struct HomeReplFeatures {
  pub is_flake: bool,
}

impl FeatureRequirements for HomeReplFeatures {
  fn required_features(&self) -> Vec<&'static str> {
    let mut features = vec![];

    // For non-flake repls, no experimental features needed
    if !self.is_flake {
      return features;
    }

    // For flake repls, only need nix-command and flakes
    let variant = util::get_nix_variant();
    if !matches!(variant, NixVariant::Determinate) {
      features.push("nix-command");
      features.push("flakes");
    }

    features
  }
}

/// Feature requirements for Darwin repl commands
#[derive(Debug)]
pub struct DarwinReplFeatures {
  pub is_flake: bool,
}

impl FeatureRequirements for DarwinReplFeatures {
  fn required_features(&self) -> Vec<&'static str> {
    let mut features = vec![];

    // For non-flake repls, no experimental features needed
    if !self.is_flake {
      return features;
    }

    // For flake repls, only need nix-command and flakes
    let variant = util::get_nix_variant();
    if !matches!(variant, NixVariant::Determinate) {
      features.push("nix-command");
      features.push("flakes");
    }

    features
  }
}

/// Feature requirements for commands that don't need experimental features
#[derive(Debug)]
pub struct NoFeatures;

impl FeatureRequirements for NoFeatures {
  fn required_features(&self) -> Vec<&'static str> {
    vec![]
  }
}

#[cfg(test)]
mod tests {
  use std::env;

  use proptest::prelude::*;
  use serial_test::serial;

  use super::*;

  // This helps set environment variables safely in tests
  struct EnvGuard {
    key:      String,
    original: Option<String>,
  }

  impl EnvGuard {
    fn new(key: &str, value: &str) -> Self {
      let original = env::var(key).ok();
      unsafe {
        env::set_var(key, value);
      }
      EnvGuard {
        key: key.to_string(),
        original,
      }
    }
  }

  impl Drop for EnvGuard {
    fn drop(&mut self) {
      unsafe {
        match &self.original {
          Some(val) => env::set_var(&self.key, val),
          None => env::remove_var(&self.key),
        }
      }
    }
  }

  proptest! {
      #[test]
      fn test_normalize_version_string_handles_various_formats(
          major in 1u32..10,
          minor in 0u32..99,
          patch in 0u32..99
      ) {
          // Test basic semver format
          let basic = format!("{major}.{minor}.{patch}");
          prop_assert_eq!(normalize_version_string(&basic), basic.clone());

          // Test with pre-release suffix
          let pre_release = format!("{major}.{minor}.{patch}-pre");
          prop_assert_eq!(normalize_version_string(&pre_release), basic.clone());

          // Test with distro suffix
          let distro = format!("{major}.{minor}.{patch}-1");
          prop_assert_eq!(normalize_version_string(&distro), basic.clone());

          // Test Nix-style version without patch (should add .0)
          let no_patch = format!("{major}.{minor}");
          let expected_no_patch = format!("{major}.{minor}.0");
          prop_assert_eq!(normalize_version_string(&no_patch), expected_no_patch);

          // Test complex Nix format like "2.30pre20250521_76a4d4c2"
          let complex = format!("{major}.{minor}pre20250521_76a4d4c2");
          let expected_complex = format!("{major}.{minor}.0");
          prop_assert_eq!(normalize_version_string(&complex), expected_complex);
      }

      #[test]
      fn test_flake_features_always_returns_consistent_results(
          _dummy in 0..100u32
      ) {
          let features = FlakeFeatures;
          let result1 = features.required_features();
          let result2 = features.required_features();

          // Property: Multiple calls should return identical results
          prop_assert_eq!(result1.clone(), result2.clone());

          // Property: Should only contain known experimental features
          for feature in &result1 {
              prop_assert!(
                  *feature == "nix-command" ||
                  *feature == "flakes",
                  "Unknown feature: {}", feature
              );
          }

          // Property: Results should be deterministic based on variant
          // We can't control the actual variant in this test, but we can verify
          // that the logic is consistent
          if result1.is_empty() {
              // If empty, variant should be Determinate (when available)
              // This property holds when the system has Determinate Nix
          } else {
              // If not empty, should contain both nix-command and flakes
              prop_assert!(result1.contains(&"nix-command"));
              prop_assert!(result1.contains(&"flakes"));
              prop_assert_eq!(result1.len(), 2);
          }
      }

      #[test]
      fn test_legacy_features_always_empty(
          _dummy in 0..100u32
      ) {
          let features = LegacyFeatures;
          let result = features.required_features();

          // Property: Legacy features should always be empty
          prop_assert!(result.is_empty());
      }

      #[test]
      fn test_no_features_always_empty(
          _dummy in 0..100u32
      ) {
          let features = NoFeatures;
          let result = features.required_features();

          // Property: NoFeatures should always be empty
          prop_assert!(result.is_empty());
      }

      #[test]
      fn test_repl_features_consistency_with_flake_flag(
          is_flake in any::<bool>()
      ) {
          // Test OS repl features
          let os_features = OsReplFeatures { is_flake };
          let os_result = os_features.required_features();

          // Test Home repl features
          let home_features = HomeReplFeatures { is_flake };
          let home_result = home_features.required_features();

          // Test Darwin repl features
          let darwin_features = DarwinReplFeatures { is_flake };
          let darwin_result = darwin_features.required_features();

          if is_flake {
              // Property: All flake repls should have consistent base features
              // (when features are required, they should include nix-command and flakes)
              for result in [&os_result, &home_result, &darwin_result] {
                  if !result.is_empty() {
                      prop_assert!(result.contains(&"nix-command"));
                      prop_assert!(result.contains(&"flakes"));
                  }
              }

              // Property: Only OS repl may have additional features (repl-flake for older Lix)
              // Home and Darwin should never have more than the base features
              if !home_result.is_empty() {
                  prop_assert_eq!(home_result.len(), 2);
              }
              if !darwin_result.is_empty() {
                  prop_assert_eq!(darwin_result.len(), 2);
              }

              // Property: OS repl may have 2 or 3 features (base + optional repl-flake)
              if !os_result.is_empty() {
                  prop_assert!(os_result.len() >= 2 && os_result.len() <= 3);
                  if os_result.len() == 3 {
                      prop_assert!(os_result.contains(&"repl-flake"));
                  }
              }
          } else {
              // Property: Non-flake repls should never require features
              prop_assert!(os_result.is_empty());
              prop_assert!(home_result.is_empty());
              prop_assert!(darwin_result.is_empty());
          }
      }

      #[test]
      fn test_feature_requirements_trait_idempotency(
          is_flake in any::<bool>()
      ) {
          let test_cases = vec![
              Box::new(FlakeFeatures) as Box<dyn FeatureRequirements>,
              Box::new(LegacyFeatures) as Box<dyn FeatureRequirements>,
              Box::new(OsReplFeatures { is_flake }) as Box<dyn FeatureRequirements>,
              Box::new(HomeReplFeatures { is_flake }) as Box<dyn FeatureRequirements>,
              Box::new(DarwinReplFeatures { is_flake }) as Box<dyn FeatureRequirements>,
              Box::new(NoFeatures) as Box<dyn FeatureRequirements>,
          ];

          for feature_req in test_cases {
              let result1 = feature_req.required_features();
              let result2 = feature_req.required_features();

              // Property: Multiple calls should be idempotent
              prop_assert_eq!(result1.clone(), result2.clone());

              // Property: All features should be valid strings
              for feature in &result1 {
                  prop_assert!(!feature.is_empty());
                  prop_assert!(feature.chars().all(|c| c.is_ascii_alphanumeric() || c == '-'));
              }

              // Property: No duplicate features
              let mut sorted = result1.clone();
              sorted.sort_unstable();
              sorted.dedup();
              prop_assert_eq!(result1.len(), sorted.len());
          }
      }
  }

  // Regular unit tests for specific scenarios
  #[test]
  fn test_normalize_version_string_with_real_nix_versions() {
    // Test the exact format you mentioned
    assert_eq!(
      normalize_version_string("2.30pre20250521_76a4d4c2"),
      "2.30.0"
    );

    // Test other real Nix version formats
    assert_eq!(normalize_version_string("2.25.0-pre"), "2.25.0");
    assert_eq!(normalize_version_string("2.24.14-1"), "2.24.14");
    assert_eq!(normalize_version_string("2.91.1"), "2.91.1");
    assert_eq!(normalize_version_string("2.18"), "2.18.0");

    // Test edge cases
    assert_eq!(normalize_version_string("3.0dev"), "3.0.0");
    assert_eq!(normalize_version_string("2.22rc1"), "2.22.0");
    assert_eq!(normalize_version_string("2.19_git_abc123"), "2.19.0");

    // Test fallback cases where patch component is missing
    assert_eq!(normalize_version_string("1.2-beta"), "1.2.0");
    assert_eq!(normalize_version_string("3.4+build.1"), "3.4.0");
    assert_eq!(normalize_version_string("5.6_alpha"), "5.6.0");

    // Test fallback cases where both minor and patch are missing
    assert_eq!(normalize_version_string("2-rc1"), "2.0.0");
    assert_eq!(normalize_version_string("4+build"), "4.0.0");
    assert_eq!(normalize_version_string("7_dev"), "7.0.0");
  }

  #[test]
  #[serial]
  fn test_setup_environment_flake_to_nh_flake_migration() {
    unsafe {
      env::remove_var("FLAKE");
      env::remove_var("NH_FLAKE");
      env::remove_var("NH_OS_FLAKE");
      env::remove_var("NH_HOME_FLAKE");
      env::remove_var("NH_DARWIN_FLAKE");
    }

    let _guard = EnvGuard::new("FLAKE", "/test/flake");

    let result = verify_variables();

    assert!(
      result.is_ok(),
      "Should warn when migrating FLAKE to NH_FLAKE"
    );
    assert_eq!(env::var("NH_FLAKE").unwrap(), "/test/flake");
  }

  #[test]
  #[serial]
  fn test_setup_environment_no_migration_when_nh_flake_exists() {
    unsafe {
      env::remove_var("FLAKE");
      env::remove_var("NH_FLAKE");
      env::remove_var("NH_OS_FLAKE");
      env::remove_var("NH_HOME_FLAKE");
      env::remove_var("NH_DARWIN_FLAKE");
    }

    let _guard1 = EnvGuard::new("FLAKE", "/test/flake");
    let _guard2 = EnvGuard::new("NH_FLAKE", "/existing/flake");

    let result = verify_variables();

    assert!(
      result.is_ok(),
      "Should not warn when NH_FLAKE already exists"
    );
    assert_eq!(env::var("NH_FLAKE").unwrap(), "/existing/flake");
  }

  #[test]
  #[serial]
  fn test_setup_environment_no_migration_when_specific_flake_vars_exist() {
    unsafe {
      env::remove_var("FLAKE");
      env::remove_var("NH_FLAKE");
      env::remove_var("NH_OS_FLAKE");
      env::remove_var("NH_HOME_FLAKE");
      env::remove_var("NH_DARWIN_FLAKE");
    }

    let _guard1 = EnvGuard::new("FLAKE", "/test/flake");
    let _guard2 = EnvGuard::new("NH_OS_FLAKE", "/os/flake");

    let result = verify_variables();

    assert!(
      result.is_ok(),
      "Should not warn when specific flake vars exist"
    );
    assert_eq!(env::var("NH_FLAKE").unwrap(), "/test/flake");
  }

  #[test]
  #[serial]
  fn test_check_features_bypassed_with_nh_no_checks() {
    let _guard = EnvGuard::new("NH_NO_CHECKS", "1");

    let features = FlakeFeatures;
    let result = features.check_features();

    assert!(
      result.is_ok(),
      "check_features should succeed when NH_NO_CHECKS is set"
    );
  }

  #[test]
  #[serial]
  fn test_verify_nix_environment_bypassed_with_nh_no_checks() {
    let _guard = EnvGuard::new("NH_NO_CHECKS", "1");

    let result = verify_nix_environment();

    assert!(
      result.is_ok(),
      "verify_nix_environment should succeed when NH_NO_CHECKS is set"
    );
  }

  #[test]
  #[serial]
  fn test_check_nix_version_bypassed_with_nh_no_checks() {
    let _guard = EnvGuard::new("NH_NO_CHECKS", "1");

    let result = check_nix_version();

    assert!(
      result.is_ok(),
      "check_nix_version should succeed when NH_NO_CHECKS is set"
    );
  }

  proptest! {
      #[test]
      #[serial]
      fn test_env_guard_cleanup_property(
          key in "[A-Z_]{1,20}",
          value in "[a-zA-Z0-9/._-]{1,50}"
      ) {
          let original = env::var(&key).ok();

          {
              let _guard = EnvGuard::new(&key, &value);
              prop_assert_eq!(env::var(&key).unwrap(), value);
          }

          // Property: Environment should be restored after guard is dropped
          match original {
              Some(orig_val) => prop_assert_eq!(env::var(&key).unwrap(), orig_val),
              None => prop_assert!(env::var(&key).is_err()),
          }
      }
  }
}
</file>

<file path="src/main.rs">
mod checks;
mod clean;
mod commands;
mod completion;
mod darwin;
mod generations;
mod home;
mod installable;
mod interface;
mod json;
mod logging;
mod nixos;
mod search;
mod update;
mod util;

use color_eyre::Result;

use crate::commands::ElevationStrategy;

pub const NH_VERSION: &str = env!("CARGO_PKG_VERSION");
pub const NH_REV: Option<&str> = option_env!("NH_REV");

fn main() -> Result<()> {
  let args = <crate::interface::Main as clap::Parser>::parse();

  // Set up logging
  crate::logging::setup_logging(args.verbosity)?;
  tracing::debug!("{args:#?}");
  tracing::debug!(%NH_VERSION, ?NH_REV);

  // Check Nix version upfront
  checks::verify_nix_environment()?;

  // Once we assert required Nix features, validate NH environment checks
  // For now, this is just NH_* variables being set. More checks may be
  // added to setup_environment in the future.
  checks::verify_variables()?;

  let elevation = args
    .elevation_program
    .map_or(ElevationStrategy::Auto, ElevationStrategy::Prefer);

  args.command.run(elevation)
}
</file>

<file path=".github/workflows/test.yaml">
name: "Test NH"

on:
  workflow_dispatch:
  pull_request:
    paths:
      - "Cargo.toml"
      - "Cargo.lock"
      - "xtask/Cargo.toml"
      - "src/**"
      - "xtask/src/**"
      - ".cargo/**"
      - ".github/workflows/build.yaml"
  push:
    branches-ignore:
      - "update-*"
    paths:
      - "Cargo.toml"
      - "Cargo.lock"
      - "xtask/Cargo.toml"
      - "src/**"
      - "xtask/src/**"
      - ".cargo/**"
      - ".github/workflows/build.yaml"

jobs:
  test-linux:
    name: "Test NH on Linux"
    runs-on: ubuntu-latest
    steps:
      - uses: cachix/install-nix-action@master
        with:
          github_access_token: ${{ secrets.GITHUB_TOKEN }}
          nix_path: nixpkgs=channel:nixos-unstable

      - uses: actions/checkout@v5

      - name: Run Tests
        run: |
          set -x

          # Verify that tests pass
          nix develop --command cargo test

      - name: Test Switching to NixOS Configuration
        run: |
          nix run .#nh -- os switch --diff never --dry --no-nom --verbose --file ./test/nixos.nix

  build-darwin:
    name: "Test NH on Darwin"
    runs-on: macos-latest

    steps:
      - uses: cachix/install-nix-action@master
        with:
          github_access_token: ${{ secrets.GITHUB_TOKEN }}

      - uses: actions/checkout@v5

      - name: Run Tests
        run: |
          set -x

          # Verify that tests pass
          nix develop --command cargo test

      - name: Test Switching to Nix Darwin Configuration
        run: |
          mkdir flake
          cd flake
          nix flake init -t nix-darwin
          git add flake.nix
          cd ..
          nix run .#nh -- darwin switch --diff never --hostname simple --dry --no-nom --verbose ./flake
</file>

<file path="src/generations.rs">
use std::{collections::HashMap, fs, path::Path, process};

use chrono::{DateTime, Local, TimeZone, Utc};
use clap::ValueEnum;
use color_eyre::eyre::{Result, bail};
use tracing::debug;

#[derive(Debug, Clone)]
pub struct GenerationInfo {
  /// Number of a generation
  pub number: String,

  /// Date on switch a generation was built
  pub date: String,

  /// `NixOS` version derived from `nixos-version`
  pub nixos_version: String,

  /// Version of the bootable kernel for a given generation
  pub kernel_version: String,

  /// Revision for a configuration. This will be the value
  /// set in `config.system.configurationRevision`
  pub configuration_revision: String,

  /// Specialisations, if any.
  pub specialisations: Vec<String>,

  /// Whether a given generation is the current one.
  pub current: bool,

  /// Closure size of the generation.
  pub closure_size: String,
}

#[derive(ValueEnum, Clone, Debug)]
pub enum Field {
  /// Generation Id
  Id,

  /// Build Date
  Date,

  /// Nixos Version
  Nver,

  /// Kernel Version
  Kernel,

  /// Configuration Revision
  #[clap(name = "confRev")]
  Confrev,

  /// Specialisations
  Spec,

  /// Closure Size
  Size,
}

#[derive(Clone, Copy)]
struct ColumnWidths {
  id:      usize,
  date:    usize,
  nver:    usize,
  kernel:  usize,
  confrev: usize,
  spec:    usize,
  size:    usize,
}

impl Field {
  fn column_info(&self, width: ColumnWidths) -> (&'static str, usize) {
    match self {
      Field::Id => ("Generation No", width.id),
      Field::Date => ("Build Date", width.date),
      Field::Nver => ("NixOS Version", width.nver),
      Field::Kernel => ("Kernel", width.kernel),
      Field::Confrev => ("Configuration Revision", width.confrev),
      Field::Spec => ("Specialisations", width.spec),
      Field::Size => ("Closure Size", width.size),
    }
  }
}
#[must_use]
pub fn from_dir(generation_dir: &Path) -> Option<u64> {
  generation_dir
    .file_name()
    .and_then(|os_str| os_str.to_str())
    .and_then(|generation_base| {
      let no_link_gen = generation_base.trim_end_matches("-link");
      no_link_gen
        .rsplit_once('-')
        .and_then(|(_, generation_num)| generation_num.parse::<u64>().ok())
    })
}

#[must_use]
pub fn get_closure_size(generation_dir: &Path) -> Option<String> {
  let store_path = generation_dir
    .read_link()
    .unwrap_or_else(|_| generation_dir.to_path_buf());
  match process::Command::new("nix")
    .arg("path-info")
    .arg(generation_dir)
    .arg("-Sh")
    .arg("--json")
    .output()
  {
    Ok(output) => {
      let output_str = String::from_utf8_lossy(&output.stdout);
      match serde_json::from_str::<serde_json::Value>(&output_str) {
        #[allow(clippy::cast_precision_loss)]
        Ok(json) => {
          // `nix path-info --json` returns an array, we need to handle it
          let store_path_str = store_path.to_string_lossy();
          let closure_size = json.as_array().and_then(|arr| {
            arr.iter().find_map(|entry| {
              let path = entry.get("path").and_then(|v| v.as_str());
              let size =
                entry.get("closureSize").and_then(serde_json::Value::as_u64);
              if let (Some(path), Some(size)) = (path, size) {
                if path == store_path_str {
                  return Some(size);
                }
              }
              None
            })
          });
          if closure_size.is_none() {
            let paths: Vec<String> = json
              .as_array()
              .map(|arr| {
                arr
                  .iter()
                  .filter_map(|entry| {
                    entry.get("path").and_then(|v| {
                      v.as_str().map(std::string::ToString::to_string)
                    })
                  })
                  .collect()
              })
              .unwrap_or_default();
            debug!(
              "get_closure_size: store_path not found or closureSize missing. \
               store_path: {store_path_str}, json paths: {:?}, output: {}",
              paths, output_str
            );
          }
          Some(closure_size.map_or_else(
            || "Unknown".to_string(),
            |bytes| format!("{:.1} GB", bytes as f64 / 1_073_741_824.0),
          ))
        },
        Err(e) => {
          debug!(
            "get_closure_size: failed to parse JSON: {e} output: {output_str}"
          );
          Some("Unknown".to_string())
        },
      }
    },
    Err(e) => {
      debug!("get_closure_size: failed to run nix path-info: {e:?}");
      Some("Unknown".to_string())
    },
  }
}

pub fn describe(generation_dir: &Path) -> Option<GenerationInfo> {
  let generation_number = from_dir(generation_dir)?;
  let closure_size = get_closure_size(generation_dir)?;
  // Get metadata once and reuse for both date and existence checks
  let metadata = fs::metadata(generation_dir).ok()?;
  let build_date = metadata
    .created()
    .or_else(|_| metadata.modified())
    .map_or_else(
      |_| "Unknown".to_string(),
      |system_time| {
        let duration = system_time
          .duration_since(std::time::UNIX_EPOCH)
          .unwrap_or_default();
        DateTime::<Utc>::from(std::time::UNIX_EPOCH + duration).to_rfc3339()
      },
    );

  let nixos_version = fs::read_to_string(generation_dir.join("nixos-version"))
    .unwrap_or_else(|_| "Unknown".to_string());

  // XXX: Nixpkgs appears to have changed where kernel modules are stored in a
  // recent change. I do not care to track which, but we should try the new path
  // and fall back to the old one IF and ONLY IF the new one fails. This is to
  // avoid breakage for outdated channels.
  let kernel_modules_dir_new =
    generation_dir.join("kernel-modules/lib/modules");
  let kernel_modules_dir_old = generation_dir
    .join("kernel")
    .canonicalize()
    .ok()
    .and_then(|path| path.parent().map(std::path::Path::to_path_buf))
    .unwrap_or_else(|| generation_dir.to_path_buf())
    .join("lib/modules");

  let kernel_version = if kernel_modules_dir_new.exists() {
    match fs::read_dir(&kernel_modules_dir_new) {
      Ok(entries) => {
        let mut versions = Vec::with_capacity(4);
        for entry in entries.filter_map(Result::ok) {
          if let Some(name) = entry.file_name().to_str() {
            versions.push(name.to_string());
          }
        }
        versions.join(", ")
      },
      Err(_) => "Unknown".to_string(),
    }
  } else if kernel_modules_dir_old.exists() {
    match fs::read_dir(&kernel_modules_dir_old) {
      Ok(entries) => {
        let mut versions = Vec::with_capacity(4);
        for entry in entries.filter_map(Result::ok) {
          if let Some(name) = entry.file_name().to_str() {
            versions.push(name.to_string());
          }
        }
        versions.join(", ")
      },
      Err(_) => "Unknown".to_string(),
    }
  } else {
    "Unknown".to_string()
  };

  let configuration_revision = {
    let nixos_version_path = generation_dir.join("sw/bin/nixos-version");
    if nixos_version_path.exists() {
      process::Command::new(&nixos_version_path)
        .arg("--configuration-revision")
        .output()
        .ok()
        .and_then(|output| String::from_utf8(output.stdout).ok())
        .unwrap_or_default()
        .trim()
        .to_string()
    } else {
      String::new()
    }
  };

  let specialisations = {
    let specialisation_path = generation_dir.join("specialisation");
    if specialisation_path.exists() {
      fs::read_dir(specialisation_path)
        .map(|entries| {
          let mut specs = Vec::with_capacity(5);
          for entry in entries.filter_map(Result::ok) {
            if let Some(name) = entry.file_name().to_str() {
              specs.push(name.to_string());
            }
          }
          specs
        })
        .unwrap_or_default()
    } else {
      Vec::new()
    }
  };

  // Check if this generation is the current one
  let Some(run_current_target) = fs::read_link("/run/current-system")
    .ok()
    .and_then(|p| fs::canonicalize(p).ok())
  else {
    return Some(GenerationInfo {
      number: generation_number.to_string(),
      date: build_date,
      nixos_version,
      kernel_version,
      configuration_revision,
      specialisations,
      current: false,
      closure_size,
    });
  };

  let Some(gen_store_path) = fs::read_link(generation_dir)
    .ok()
    .and_then(|p| fs::canonicalize(p).ok())
  else {
    return Some(GenerationInfo {
      number: generation_number.to_string(),
      date: build_date,
      nixos_version,
      kernel_version,
      configuration_revision,
      specialisations,
      current: false,
      closure_size,
    });
  };

  let current = run_current_target == gen_store_path;

  Some(GenerationInfo {
    number: generation_number.to_string(),
    date: build_date,
    nixos_version,
    kernel_version,
    configuration_revision,
    specialisations,
    current,
    closure_size,
  })
}

/// Print information about the given generations.
///
/// # Errors
///
/// Returns an error if output or formatting fails.
pub fn print_info(
  mut generations: Vec<GenerationInfo>,
  fields: &[Field],
) -> Result<()> {
  // Parse all dates at once and cache them
  let mut parsed_dates = HashMap::with_capacity(generations.len());
  for generation in &generations {
    let date = DateTime::parse_from_rfc3339(&generation.date).map_or_else(
      |_| Local.timestamp_opt(0, 0).unwrap(),
      |dt| dt.with_timezone(&Local),
    );
    parsed_dates.insert(
      generation.date.clone(),
      date.format("%Y-%m-%d %H:%M:%S").to_string(),
    );
  }

  // Sort generations by numeric value of the generation number
  generations
    .sort_by_key(|generation| generation.number.parse::<u64>().unwrap_or(0));

  let current_generation =
    generations.iter().find(|generation| generation.current);
  debug!(?current_generation);

  if let Some(current) = current_generation {
    println!("NixOS {}", current.nixos_version);
  } else {
    bail!("Error getting current generation!");
  }

  // Determine column widths for pretty printing
  let max_nixos_version_len = generations
    .iter()
    .map(|g| g.nixos_version.len())
    .max()
    .unwrap_or(22); // length of version + date + rev, assumes no tags

  let max_kernel_len = generations
    .iter()
    .map(|g| g.kernel_version.len())
    .max()
    .unwrap_or(12); // arbitrary value

  let widths = ColumnWidths {
    id:      13, // "Generation No"
    date:    20, // "Build Date"
    nver:    max_nixos_version_len,
    kernel:  max_kernel_len,
    confrev: 22, // "Configuration Revision"
    spec:    15, // "Specialisations"
    size:    12, // "Closure Size"
  };

  let header = fields
    .iter()
    .map(|f| {
      let (name, width) = f.column_info(widths);
      format!("{name:<width$}")
    })
    .collect::<Vec<String>>()
    .join(" ");
  println!("{header}");

  // Print generations in descending order
  for generation in generations.iter().rev() {
    let formatted_date = parsed_dates
      .get(&generation.date)
      .cloned()
      .unwrap_or_else(|| "Unknown".to_string());

    let specialisations = if generation.specialisations.is_empty() {
      String::new()
    } else {
      generation
        .specialisations
        .iter()
        .map(|s| format!("*{s}"))
        .collect::<Vec<String>>()
        .join(" ")
    };

    let row: String = fields
      .iter()
      .map(|f| {
        let (_, width) = f.column_info(widths);
        let cell_content = match f {
          Field::Id => {
            format!(
              "{}{}",
              generation.number,
              if generation.current { " (current)" } else { "" }
            )
          },
          Field::Date => formatted_date.clone(),
          Field::Nver => generation.nixos_version.clone(),
          Field::Kernel => generation.kernel_version.clone(),
          Field::Confrev => generation.configuration_revision.clone(),
          Field::Spec => specialisations.clone(),
          Field::Size => generation.closure_size.clone(),
        };
        format!("{cell_content:width$}")
      })
      .collect::<Vec<String>>()
      .join(" ");
    println!("{row}");
  }

  Ok(())
}
</file>

<file path="src/home.rs">
use std::{env, ffi::OsString, path::PathBuf};

use color_eyre::{
  Result,
  eyre::{Context, bail, eyre},
};
use tracing::{debug, info, warn};

use crate::{
  commands,
  commands::Command,
  installable::Installable,
  interface::{self, DiffType, HomeRebuildArgs, HomeReplArgs, HomeSubcommand},
  update::update,
  util::{get_hostname, print_dix_diff},
};

impl interface::HomeArgs {
  /// Run the `home` subcommand.
  ///
  /// # Errors
  ///
  /// Returns an error if the operation fails.
  pub fn run(self) -> Result<()> {
    use HomeRebuildVariant::{Build, Switch};
    match self.subcommand {
      HomeSubcommand::Switch(args) => args.rebuild(&Switch),
      HomeSubcommand::Build(args) => {
        if args.common.ask || args.common.dry {
          warn!("`--ask` and `--dry` have no effect for `nh home build`");
        }
        args.rebuild(&Build)
      },
      HomeSubcommand::Repl(args) => args.run(),
    }
  }
}

#[derive(Debug)]
enum HomeRebuildVariant {
  Build,
  Switch,
}

impl HomeRebuildArgs {
  fn rebuild(self, variant: &HomeRebuildVariant) -> Result<()> {
    use HomeRebuildVariant::Build;

    if self.update_args.update_all || self.update_args.update_input.is_some() {
      update(&self.common.installable, self.update_args.update_input)?;
    }

    let (out_path, _tempdir_guard): (PathBuf, Option<tempfile::TempDir>) =
      if let Some(ref p) = self.common.out_link {
        (p.clone(), None)
      } else {
        let dir = tempfile::Builder::new().prefix("nh-home").tempdir()?;
        (dir.as_ref().join("result"), Some(dir))
      };

    debug!("Output path: {out_path:?}");

    // Use NH_HOME_FLAKE if available, otherwise use the provided installable
    let installable = if let Ok(home_flake) = env::var("NH_HOME_FLAKE") {
      debug!("Using NH_HOME_FLAKE: {}", home_flake);

      let mut elems = home_flake.splitn(2, '#');
      let reference = match elems.next() {
        Some(r) => r.to_owned(),
        None => return Err(eyre!("NH_HOME_FLAKE missing reference part")),
      };
      let attribute = elems
        .next()
        .map(crate::installable::parse_attribute)
        .unwrap_or_default();

      Installable::Flake {
        reference,
        attribute,
      }
    } else {
      self.common.installable.clone()
    };

    let toplevel = toplevel_for(
      installable,
      true,
      &self.extra_args,
      self.configuration.clone(),
    )?;

    commands::Build::new(toplevel)
      .extra_arg("--out-link")
      .extra_arg(&out_path)
      .extra_args(&self.extra_args)
      .passthrough(&self.common.passthrough)
      .message("Building Home-Manager configuration")
      .nom(!self.common.no_nom)
      .run()
      .wrap_err("Failed to build Home-Manager configuration")?;

    let prev_generation: Option<PathBuf> = [
      PathBuf::from("/nix/var/nix/profiles/per-user")
        .join(env::var("USER").map_err(|_| eyre!("Couldn't get username"))?)
        .join("home-manager"),
      PathBuf::from(
        env::var("HOME").map_err(|_| eyre!("Couldn't get home directory"))?,
      )
      .join(".local/state/nix/profiles/home-manager"),
    ]
    .into_iter()
    .find(|next| next.exists());

    debug!("Previous generation: {prev_generation:?}");

    let spec_location = PathBuf::from(std::env::var("HOME")?)
      .join(".local/share/home-manager/specialisation");

    let current_specialisation = if let Some(s) = spec_location.to_str() {
      std::fs::read_to_string(s).ok()
    } else {
      tracing::warn!("spec_location path is not valid UTF-8");
      None
    };

    let target_specialisation = if self.no_specialisation {
      None
    } else {
      current_specialisation.or(self.specialisation)
    };

    debug!("target_specialisation: {target_specialisation:?}");

    let target_profile: PathBuf = if let Some(spec) = &target_specialisation {
      out_path.join("specialisation").join(spec)
    } else {
      out_path.clone()
    };

    // just do nothing for None case (fresh installs)
    if let Some(generation) = prev_generation {
      match self.common.diff {
        DiffType::Never => {
          debug!("Not running dix as the --diff flag is set to never.");
        },
        _ => {
          let _ = print_dix_diff(&generation, &target_profile);
        },
      }
    }

    if self.common.dry || matches!(variant, Build) {
      if self.common.ask {
        warn!("--ask has no effect as dry run was requested");
      }
      return Ok(());
    }

    if self.common.ask {
      let confirmation = inquire::Confirm::new("Apply the config?")
        .with_default(false)
        .prompt()?;

      if !confirmation {
        bail!("User rejected the new config");
      }
    }

    if let Some(ext) = &self.backup_extension {
      info!("Using {} as the backup extension", ext);
      unsafe {
        env::set_var("HOME_MANAGER_BACKUP_EXT", ext);
      }
    }

    Command::new(target_profile.join("activate"))
      .with_required_env()
      .message("Activating configuration")
      .run()
      .wrap_err("Activation failed")?;

    debug!("Completed operation with output path: {target_profile:?}");

    Ok(())
  }
}

fn toplevel_for<I, S>(
  installable: Installable,
  push_drv: bool,
  extra_args: I,
  configuration_name: Option<String>,
) -> Result<Installable>
where
  I: IntoIterator<Item = S>,
  S: AsRef<std::ffi::OsStr>,
{
  let mut res = installable;
  let extra_args: Vec<OsString> = {
    let mut vec = Vec::new();
    for elem in extra_args {
      vec.push(elem.as_ref().to_owned());
    }
    vec
  };

  let toplevel = ["config", "home", "activationPackage"]
    .into_iter()
    .map(String::from);

  match res {
    Installable::Flake {
      ref reference,
      ref mut attribute,
    } => {
      // If user explicitly selects some other attribute in the installable
      // itself then don't push homeConfigurations
      if !attribute.is_empty() {
        debug!(
          "Using explicit attribute path from installable: {:?}",
          attribute
        );
        return Ok(res);
      }

      attribute.push(String::from("homeConfigurations"));

      let flake_reference = reference.clone();
      let mut found_config = false;

      // Check if an explicit configuration name was provided via the flag
      if let Some(config_name) = configuration_name {
        // Verify the provided configuration exists
        let func = format!(r#" x: x ? "{config_name}" "#);
        let check_res = commands::Command::new("nix")
          .with_required_env()
          .arg("eval")
          .args(&extra_args)
          .arg("--apply")
          .arg(func)
          .args(
            (Installable::Flake {
              reference: flake_reference.clone(),
              attribute: attribute.clone(),
            })
            .to_args(),
          )
          .run_capture()
          .wrap_err(format!(
            "Failed running nix eval to check for explicit configuration \
             '{config_name}'"
          ))?;

        if check_res.map(|s| s.trim().to_owned()).as_deref() == Some("true") {
          debug!("Using explicit configuration from flag: {config_name:?}");

          attribute.push(config_name);
          if push_drv {
            attribute.extend(toplevel.clone());
          }

          found_config = true;
        } else {
          // Explicit config provided but not found
          let tried_attr_path = {
            let mut attr_path = attribute.clone();
            attr_path.push(config_name);
            Installable::Flake {
              reference: flake_reference,
              attribute: attr_path,
            }
            .to_args()
            .join(" ")
          };
          bail!(
            "Explicitly specified home-manager configuration not found: \
             {tried_attr_path}"
          );
        }
      }

      // If no explicit config was found via flag, try automatic detection
      if !found_config {
        let username =
          std::env::var("USER").map_err(|_| eyre!("Couldn't get username"))?;
        let hostname = get_hostname(None)?;
        let mut tried = vec![];

        for attr_name in [format!("{username}@{hostname}"), username] {
          let func = format!(r#" x: x ? "{attr_name}" "#);
          let check_res = commands::Command::new("nix")
            .with_required_env()
            .arg("eval")
            .args(&extra_args)
            .arg("--apply")
            .arg(func)
            .args(
              (Installable::Flake {
                reference: flake_reference.clone(),
                attribute: attribute.clone(),
              })
              .to_args(),
            )
            .run_capture()
            .wrap_err(format!(
              "Failed running nix eval to check for automatic configuration \
               '{attr_name}'"
            ))?;

          let current_try_attr = {
            let mut attr_path = attribute.clone();
            attr_path.push(attr_name.clone());
            attr_path
          };
          tried.push(current_try_attr.clone());

          if let Some("true") =
            check_res.map(|s| s.trim().to_owned()).as_deref()
          {
            debug!("Using automatically detected configuration: {}", attr_name);
            attribute.push(attr_name);
            if push_drv {
              attribute.extend(toplevel.clone());
            }
            found_config = true;
            break;
          }
        }

        // If still not found after automatic detection, error out
        if !found_config {
          let tried_str = tried
            .into_iter()
            .map(|a| {
              Installable::Flake {
                reference: flake_reference.clone(),
                attribute: a,
              }
              .to_args()
              .join(" ")
            })
            .collect::<Vec<_>>()
            .join(", ");
          bail!(
            "Couldn't find home-manager configuration automatically, tried: \
             {tried_str}"
          );
        }
      }
    },
    Installable::File {
      ref mut attribute, ..
    } => {
      if push_drv {
        attribute.extend(toplevel);
      }
    },
    Installable::Expression {
      ref mut attribute, ..
    } => {
      if push_drv {
        attribute.extend(toplevel);
      }
    },
    Installable::Store { .. } => {},
  }

  Ok(res)
}

impl HomeReplArgs {
  fn run(self) -> Result<()> {
    // Use NH_HOME_FLAKE if available, otherwise use the provided installable
    let installable = if let Ok(home_flake) = env::var("NH_HOME_FLAKE") {
      debug!("Using NH_HOME_FLAKE: {home_flake}");

      let mut elems = home_flake.splitn(2, '#');
      let reference = match elems.next() {
        Some(r) => r.to_owned(),
        None => return Err(eyre!("NH_HOME_FLAKE missing reference part")),
      };
      let attribute = elems
        .next()
        .map(crate::installable::parse_attribute)
        .unwrap_or_default();

      Installable::Flake {
        reference,
        attribute,
      }
    } else {
      self.installable
    };

    let toplevel = toplevel_for(
      installable,
      false,
      &self.extra_args,
      self.configuration.clone(),
    )?;

    Command::new("nix")
      .with_required_env()
      .arg("repl")
      .args(toplevel.to_args())
      .show_output(true)
      .run()?;

    Ok(())
  }
}
</file>

<file path="src/util.rs">
use std::{
  collections::HashSet,
  fmt,
  io,
  path::Path,
  process::{Command as StdCommand, Stdio},
  str,
  sync::{LazyLock, OnceLock},
};

use color_eyre::{Result, eyre};
use regex::Regex;
use tracing::{debug, info};

use crate::commands::{Command, ElevationStrategy};

#[derive(Debug, Clone, PartialEq)]
pub enum NixVariant {
  Nix,
  Lix,
  Determinate,
}

static NIX_VARIANT: OnceLock<NixVariant> = OnceLock::new();

struct WriteFmt<W: io::Write>(W);

impl<W: io::Write> fmt::Write for WriteFmt<W> {
  fn write_str(&mut self, string: &str) -> fmt::Result {
    self.0.write_all(string.as_bytes()).map_err(|_| fmt::Error)
  }
}
/// Get the Nix variant (cached)
pub fn get_nix_variant() -> &'static NixVariant {
  NIX_VARIANT.get_or_init(|| {
    let output = Command::new("nix")
      .arg("--version")
      .run_capture()
      .ok()
      .flatten();

    // XXX: If running with dry=true or Nix is not installed, output might be
    // None The latter is less likely to occur, but we still want graceful
    // handling.
    let output_str = match output {
      Some(output) => output,
      None => return NixVariant::Nix, // default to standard Nix variant
    };

    let output_lower = output_str.to_lowercase();

    // FIXME: This fails to account for Nix variants we don't check for and
    // assumes the environment is mainstream Nix.
    if output_lower.contains("determinate") {
      NixVariant::Determinate
    } else if output_lower.contains("lix") {
      NixVariant::Lix
    } else {
      NixVariant::Nix
    }
  });

  NIX_VARIANT
    .get()
    .expect("NIX_VARIANT should be initialized by get_nix_variant")
}

// Matches and captures major, minor, and optional patch numbers from semantic
// version strings, optionally followed by a "pre" pre-release suffix.
static VERSION_REGEX: LazyLock<Regex> =
  LazyLock::new(|| Regex::new(r"(\d+)\.(\d+)(?:\.(\d+))?(?:pre\d*)?").unwrap());

/// Normalizes a version string to be compatible with semver parsing.
///
/// This function handles, or at least tries to handle, various Nix
/// vendors' complex version formats by extracting just the semantic
/// version part.
///
/// Examples of supported formats:
/// - "2.25.0-pre" -> "2.25.0"
/// - "2.24.14-1" -> "2.24.14"
/// - "`2.30pre20250521_76a4d4c2`" -> "2.30.0"
/// - "2.91.1" -> "2.91.1"
///
/// # Arguments
///
/// * `version` - The raw version string to normalize
///
/// # Returns
///
/// * `String` - The normalized version string suitable for semver parsing
pub fn normalize_version_string(version: &str) -> String {
  if let Some(captures) = VERSION_REGEX.captures(version) {
    let major = captures.get(1).map(|m| m.as_str()).unwrap_or_else(|| {
      debug!("Failed to extract major version from '{}'", version);
      version
    });
    let minor = captures.get(2).map(|m| m.as_str()).unwrap_or_else(|| {
      debug!("Failed to extract minor version from '{}'", version);
      version
    });
    let patch = captures.get(3).map_or("0", |m| m.as_str());

    let normalized = format!("{major}.{minor}.{patch}");
    if version != normalized {
      debug!("Version normalized: '{}' -> '{}'", version, normalized);
    }

    return normalized;
  }

  // Fallback: split on common separators and take the first part
  let base_version = version
    .split(&['-', '+', 'p', '_'][..])
    .next()
    .unwrap_or(version);

  // Version should have all three components (major.minor.patch)
  let normalized = match base_version.split('.').collect::<Vec<_>>().as_slice()
  {
    [major] => format!("{major}.0.0"),
    [major, minor] => format!("{major}.{minor}.0"),
    _ => base_version.to_string(),
  };

  if version != normalized {
    debug!("Version normalized: '{}' -> '{}'", version, normalized);
  }

  normalized
}

/// Retrieves the installed Nix version as a string.
///
/// This function executes the `nix --version` command, parses the output to
/// extract the version string, and returns it. This function does not perform
/// any kind of validation; it's sole purpose is to get the version. To validate
/// a version string, use `normalize_version_string()`.
///
/// # Returns
///
/// * `Result<String>` - The Nix version string or an error if the version
///   cannot be retrieved.
pub fn get_nix_version() -> Result<String> {
  let output = Command::new("nix")
    .arg("--version")
    .run_capture()?
    .ok_or_else(|| eyre::eyre!("No output from command"))?;

  let version_str = output
    .lines()
    .next()
    .ok_or_else(|| eyre::eyre!("No version string found"))?;

  Ok(version_str.to_string())
}

/// Prompts the user for ssh key login if needed
pub fn ensure_ssh_key_login() -> Result<()> {
  // ssh-add -L checks if there are any currently usable ssh keys

  if StdCommand::new("ssh-add")
    .arg("-L")
    .stdout(Stdio::null())
    .status()?
    .success()
  {
    return Ok(());
  }
  StdCommand::new("ssh-add")
    .stdin(Stdio::inherit())
    .stdout(Stdio::inherit())
    .stderr(Stdio::inherit())
    .spawn()?
    .wait()?;
  Ok(())
}

/// Gets the hostname of the current system
///
/// # Arguments
/// * `supplied_hostname` - An optional hostname provided by the user.
///
/// # Returns
///
/// * `Ok(String)` with the resolved hostname.
/// * `Err` if no hostname is supplied and fetching the system hostname fails.
pub fn get_hostname(supplied_hostname: Option<String>) -> Result<String> {
  if let Some(h) = supplied_hostname {
    return Ok(h);
  }
  #[cfg(not(target_os = "macos"))]
  {
    use color_eyre::eyre::Context;
    Ok(
      hostname::get()
        .context("Failed to get hostname, and no hostname supplied")?
        .to_str()
        .map_or_else(
          || String::from("unknown-hostname"),
          std::string::ToString::to_string,
        ),
    )
  }
  #[cfg(target_os = "macos")]
  {
    use color_eyre::eyre::bail;
    use system_configuration::{
      core_foundation::{base::TCFType, string::CFString},
      sys::dynamic_store_copy_specific::SCDynamicStoreCopyLocalHostName,
    };

    let ptr = unsafe { SCDynamicStoreCopyLocalHostName(std::ptr::null()) };
    if ptr.is_null() {
      bail!("Failed to get hostname, and no hostname supplied");
    }
    let name = unsafe { CFString::wrap_under_get_rule(ptr) };

    Ok(name.to_string())
  }
}

/// Retrieves all enabled experimental features in Nix.
///
/// This function executes the `nix config show experimental-features` command
/// and returns a `HashSet` of the enabled features.
///
/// # Returns
///
/// * `Result<HashSet<String>>` - A `HashSet` of enabled experimental features
///   or an error.
pub fn get_nix_experimental_features() -> Result<HashSet<String>> {
  let output = Command::new("nix")
    .args(["config", "show", "experimental-features"])
    .run_capture()?;

  // If running with dry=true, output might be None
  let output_str = match output {
    Some(output) => output,
    None => return Ok(HashSet::new()),
  };

  let enabled_features: HashSet<String> =
    output_str.split_whitespace().map(String::from).collect();

  Ok(enabled_features)
}

/// Gets the missing experimental features from a required list.
///
/// # Arguments
///
/// * `required_features` - A slice of string slices representing the features
///   required.
///
/// # Returns
///
/// * `Result<Vec<String>>` - A vector of missing experimental features or an
///   error.
pub fn get_missing_experimental_features(
  required_features: &[&str],
) -> Result<Vec<String>> {
  let enabled_features = get_nix_experimental_features()?;

  let missing_features: Vec<String> = required_features
    .iter()
    .filter(|&feature| !enabled_features.contains(*feature))
    .map(|&s| s.to_string())
    .collect();

  Ok(missing_features)
}

/// Self-elevates the current process by re-executing it with sudo
///
/// # Panics
///
/// Panics if the process re-execution with elevated privileges fails.
///
/// # Examples
///
/// ```rust
/// use nh::commands::ElevationStrategy;
///
/// // Elevate the current process to run as root
/// let elevate: fn(ElevationStrategy) -> ! = nh::util::self_elevate;
/// ```
pub fn self_elevate(strategy: ElevationStrategy) -> ! {
  use std::os::unix::process::CommandExt;

  let mut cmd = crate::commands::Command::self_elevate_cmd(strategy)
    .expect("Failed to create self-elevation command");
  debug!("{:?}", cmd);
  let err = cmd.exec();
  panic!("{}", err);
}

/// Prints the difference between two generations in terms of paths and closure
/// sizes.
///
/// # Arguments
///
/// * `old_generation` - A reference to the path of the old generation.
/// * `new_generation` - A reference to the path of the new generation.
///
/// # Returns
///
/// Returns `Ok(())` if the operation completed successfully, or an error
/// wrapped in `eyre::Result` if something went wrong.
///
/// # Errors
///
/// Returns an error if the closure size thread panics or if writing size
/// differences fails.
pub fn print_dix_diff(
  old_generation: &Path,
  new_generation: &Path,
) -> Result<()> {
  let mut out = WriteFmt(io::stdout());

  // Handle to the thread collecting closure size information.
  let closure_size_handle = dix::spawn_size_diff(
    old_generation.to_path_buf(),
    new_generation.to_path_buf(),
  );

  let wrote = dix::write_paths_diffln(&mut out, old_generation, new_generation)
    .unwrap_or_default();

  if let Ok((size_old, size_new)) =
    closure_size_handle.join().map_err(|_| {
      eyre::eyre!("Failed to join closure size computation thread")
    })?
  {
    if size_old == size_new {
      info!("No version or size changes.");
    } else {
      if wrote > 0 {
        println!();
      }
      dix::write_size_diffln(&mut out, size_old, size_new)?;
    }
  }
  Ok(())
}
</file>

<file path="README.md">
<!-- markdownlint-disable no-inline-html first-line-heading line-length -->
<div align="center">
  <h1 id="header">nh</h1>
  <a alt="CI" href="https://github.com/nix-community/nh/actions">
    <img
      src="https://github.com/nix-community/nh/actions/workflows/build.yaml/badge.svg"
      alt="Build Status"
    />
  </a>
  <a alt="Deps" href="https://deps.rs/repo/github/nix-community/nh">
    <img
      src="https://deps.rs/repo/github/nix-community/nh/status.svg"
      alt="Dependency Status"
    />
  </a>
  <a alt="License" href="https://github.com/nix-community/nh/blob/master/LICENSE">
    <img
      src="https://img.shields.io/github/license/nix-community/nh?label=License"
      alt="License"
    />
  </a>
  <br/>
  <h6>Because the name "yet-another-<u>n</u>ix-<u>h</u>elper" was too long to type...</h1>
  <br/>
  <a href="#what-does-it-do">Synopsis</a><br/>
  <a href="#features">Features</a> | <a href="#usage">Usage</a><br/>
  <a href="#hacking">Contributing</a>
  <br/>
</div>

## What Does it Do?

NH is a modern helper utility that aims to consolidate and reimplement some of
the commands from various tools within the NixOS ecosystem. Our goal is to
provide a cohesive, easily-understandable interface with more features, better
ergonomics and at many times better _speed_. In addition to bringing together
relevant 3rd party projects, NH also acts a super-convenient all-in-one utility
that reimplements well known Nix commands.

## Features

- **Unified CLI**: Consistent, intuitive interface for NixOS, Home Manager, and
  Darwin workflows.
- **Rich Interface**: Each major function (`os`, `home`, `darwin`, `search`,
  `clean`) exposes granular subcommands and flags for fine-tuned control.
- **Eye Candy**: It looks great, without any compromise. I mean who does not
  love some cool looking UIs?
- **Enhanced Garbage Collection**: `nh clean` extends `nix-collect-garbage` with
  gcroot cleanup, profile targeting, and time-based retention.
- **Build-tree Visualization**: `nh os` and similar commands display build trees
  for clear dependency tracking.
- **Diff & Change Review**: Integrated, super-fast diffing of derivation changes
  before activation or switch.
- **Specialisation Support**: Easily select or ignore NixOS & Home-Manager
  specialisations via flags.
- **Generation Management**: Inspect, rollback, and manage system generations
  with explicit targeting.
- **Extensible & Futureproof**: Designed for seamless, rapid addition of new
  subcommands and flags.

## Status

[update request]: https://github.com/NixOS/nixpkgs/issues

<a href="https://repology.org/project/nh/versions">
    <img
      src="https://repology.org/badge/vertical-allrepos/nh.svg"
      alt="Packaging status"
      align="right"
      style="padding-left: 20px"
    >
</a>

NH is packaged in nixpkgs, and is available under both nixpkgs stable and
nixpkgs unstable. Outside of extreme circumstances, all updates will be
backported to the stable branch. Refer to the [installation](#installation)
section for more details. Make sure you submit an [update request] in Nixpkgs if
the package is outdated.

## Usage

One of the features and the core principles of NH is to provide a clean, uniform
and intuitive CLI for its users. The `nh` command offers several subcommands,
all with their extensive CLI flags for extensive configuration.

### Global Subcommands

- `nh search` - a super-fast package searching tool (powered by an Elasticsearch
  client) for Nix packages in supported Nixpkgs branches.
  <p align="center">
    <img
      alt="nh search showcase"
      src="./.github/nh_search_screenshot.png"
      width="750px"
    >
  </p>

- `nh clean` - a re-implementation of `nix-collect-garbage` that also collects
  gcroots.
  <p align="center">
    <img
      alt="nh clean showcase"
      src="./.github/nh_clean_screenshot.png"
      width="750px"
    >
  </p>

### Platform Specific Subcommands

- `nh os` - reimplements `nixos-rebuild`[^1] with the addition of
  - build-tree displays.
  - diff of changes.
  - confirmation.
  <p align="center">
    <img
      alt="nh os switch showcase"
      src="./.github/nh_switch_screenshot.png"
      width="750px"
    >
  </p>

- `nh home` - reimplements `home-manager`.
- `nh darwin` - reimplements `darwin-rebuild`.

[^1]: `nh os` does not yet provide full feature parity with `nixos-rebuild`.
    While a large collection of subcommands have been implemented, you might be
    missing some features. Please visit
    [#358](https://github.com/nix-community/nh/issues/358) for a roadmap.

> [!TIP]
> See the help page for individual subcommands, or `man 1 nh` for more
> information on each subcommand.

## Installation

The latest, tagged version is available in Nixpkgs as **NH stable**. This is
recommended for most users, as tagged releases will usually undergo more
testing.This repository also provides the latest development version of NH,
which you can get from the flake outputs.

```sh
nix shell nixpkgs#nh # stable
nix shell github:nix-community/nh # dev
```

You can try NH in a Nix shell today, no setup required!

### NixOS

We provide a NixOS module that integrates `nh clean` as a service. To enable it,
set the following configuration:

```nix
{
  programs.nh = {
    enable = true;
    clean.enable = true;
    clean.extraArgs = "--keep-since 4d --keep 3";
    flake = "/home/user/my-nixos-config"; # sets NH_OS_FLAKE variable for you
  };
}
```

> [!TIP]
> As of 4.0, NH fully supports both **Nix flakes** and classical NixOS
> configurations via channels or manual dependency pinning and the such. Please
> consider the new API mature, but somewhat experimental as it is a new
> addition. Remember to report any bugs!

- For flakes, the command is `nh os switch /path/to/flake`
- For a classical configuration:
  - `nh os switch -f '<nixpkgs/nixos>'`, or
  - `nh os switch -f '<nixpkgs/nixos>' -- -I
  nixos-config=/path/to/configuration.nix`
    if using a different location than the default.

You might want to check `nh os --help` for other values and the defaults from
environment variables.

#### Specialisations support

NH is capable of detecting which specialisation you are running, so it runs the
proper activation script. To do so, you need to give NH some information of the
spec that is currently running by writing its name to `/etc/specialisation`. The
config would look like this:

```nix
{config, pkgs, ...}: {
  specialisation."foo".configuration = {
    environment.etc."specialisation".text = "foo";
    # ..rest of config
  };

  specialisation."bar".configuration = {
    environment.etc."specialisation".text = "bar";
    # ..rest of config
  };
}
```

#### Home-Manager

Home specialisations are read from `~/.local/share/home-manager/specialisation`.
The config would look like this:

```nix
{config, pkgs, ...}: {
  specialisation."foo".configuration = {
    xdg.dataFile."home-manager/specialisation".text = "foo";
    # ..rest of config
  };

  specialisation."bar".configuration = {
    xdg.dataFile."home-manager/specialisation".text = "bar";
    # ..rest of config
  };
}
```

## Environment variables

NH supports several environment variables to control command behaviour. Some of
the common variables that you may encounter or choose to employ are as follows:

### Global

- `NIXOS_INSTALL_BOOTLOADER`
  - This is a variable accepted by `switch-to-configuration`, which handles the
    system switching behind the scenes. If `true`, `swith-to-configuration` will
    call the necessary script to force and installation of your bootloader. This
    behaviour can also be replicated by passing `--install-bootloader` to
    `nh os switch` and `nh os boot` commands.

### NH Specific

- `NH_NO_CHECKS`
  - When set (any non-empty value), skips startup checks such as Nix version and
    experimental feature validation. Useful for generating completions or
    running in constrained build environments. You can also consider this an
    "expert flag" that you can set for a non-zero performance benefit. It
    assumes you know what you are doing.

- `NH_FLAKE`
  - Preferred flake path/reference used by NH when running flake-based commands.
    Historically `FLAKE` was used; NH will migrate `FLAKE` into `NH_FLAKE` if
    present and the specific `NH_*_FLAKE` vars are not set.

- `NH_OS_FLAKE`, `NH_HOME_FLAKE`, `NH_DARWIN_FLAKE`
  - Command-specific flake references for `os`, `home`, and `darwin` commands
    respectively. If present they take precedence over `NH_FLAKE`.

- `NH_SUDO_ASKPASS`
  - Path to a program used as `SUDO_ASKPASS` when NH self-elevates with `sudo`.
    If set and `sudo` is used for elevation, NH will pass `-A` to `sudo` and set
    `SUDO_ASKPASS` accordingly.

- `NH_PRESERVE_ENV`
  - Controls whether environment variables marked for preservation are passed to
    elevated commands. Set to `"0"` to disable preservation, `"1"` to force
    preservation. If unset, preservation defaults to enabled.

- `NH_LOG`
  - Sets the tracing/log filter for NH. This uses the same format as
    `tracing_subscriber` env filters (for example: `nh=trace`).

- `NH_NOM`
  - Control whether `nom` (nix-output-monitor) should be enabled for the build
    processes. Equivalent of `--no-nom`.

### Notes

- Any environment variables prefixed with `NH_` are explicitly propagated by NH
  to commands when appropriate.
- For backwards compatibility, if `FLAKE` is present and none of the
  command-specific `NH_*_FLAKE` variables exist, NH will set `NH_FLAKE` from
  `FLAKE` and emit a warning recommending migration to `NH_FLAKE`. `FLAKE` will
  be removed in the future versions of NH.

## Hacking

Contributions are always welcome. To get started, just clone the repository and
run `nix develop`. We also provide a `.envrc` for Direnv users, who may use
`direnv allow` to enter a shell with the necessary dependencies.

### Structure

NH consists of two modules. The core of NH is found in the `src` directory, and
is separated into different modules. Some of the critical modules that you may
want to be aware of are `nh::commands` for command interfaces, `nh::checks` for
pre-startup checks and `nh::util` to store shared logic. Platform-specific logic
is placed in the appropriate platform module, such as `nh::nixos` or
`nh::darwin` with generic helpers placed in `nh::util`.

The `xtask` directory contains the cargo-xtask tasks used by NH, used to
generate manpages and possibly more in the future. Some of the

### Submitting Changes

Once your changes are complete, remember to run [fix.sh](./fix.sh) to apply
general formatter and linter rules that will be expected by the CI.

Lastly, update the [changelog](/CHANGELOG.md) and open your pull request.

## Attributions

[nix-output-monitor]: https://github.com/maralorn/nix-output-monitor
[dix]: https://github.com/bloxx12/dix

NH would not be possible without all the tools we run under the hood

- Tree of builds with [nix-output-monitor].
- Visualization of the upgrade diff with [dix].
- And of course, all the [crates](./Cargo.toml) we depend on.

Last but not least, thank you to those who contributed to NH or simply talked
about it on various channels. NH would not be where it is without you.
</file>

<file path="src/clean.rs">
use std::{
  collections::{BTreeMap, HashMap},
  fmt,
  path::{Path, PathBuf},
  sync::LazyLock,
  time::SystemTime,
};

use color_eyre::eyre::{Context, ContextCompat, bail, eyre};
use inquire::Confirm;
use nix::{
  errno::Errno,
  fcntl::AtFlags,
  unistd::{AccessFlags, faccessat},
};
use regex::Regex;
use tracing::{Level, debug, info, instrument, span, warn};
use yansi::{Color, Paint};

use crate::{
  Result,
  commands::{Command, ElevationStrategy},
  interface,
};

// Nix impl:
// https://github.com/NixOS/nix/blob/master/src/nix-collect-garbage/nix-collect-garbage.cc

static DIRENV_REGEX: LazyLock<Regex> = LazyLock::new(|| {
  Regex::new(r".*/.direnv/.*").expect("Failed to compile direnv regex")
});

static RESULT_REGEX: LazyLock<Regex> = LazyLock::new(|| {
  Regex::new(r".*result.*").expect("Failed to compile result regex")
});

static GENERATION_REGEX: LazyLock<Regex> = LazyLock::new(|| {
  Regex::new(r"^(.*)-(\d+)-link$").expect("Failed to compile generation regex")
});

#[derive(Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
struct Generation {
  number:        u32,
  last_modified: SystemTime,
  path:          PathBuf,
}

type ToBeRemoved = bool;
// BTreeMap to automatically sort generations by id
type GenerationsTagged = BTreeMap<Generation, ToBeRemoved>;
type ProfilesTagged = HashMap<PathBuf, GenerationsTagged>;

/// Filter paths to only include existing directories, logging warnings for
/// missing ones
fn filter_existing_dirs<I>(paths: I) -> impl Iterator<Item = PathBuf>
where
  I: IntoIterator<Item = PathBuf>,
{
  paths.into_iter().filter_map(|path| {
    if path.is_dir() {
      Some(path)
    } else {
      warn!("Profiles directory not found, skipping: {}", path.display());
      None
    }
  })
}

impl interface::CleanMode {
  /// Run the clean operation for the selected mode.
  ///
  /// # Errors
  ///
  /// Returns an error if any IO, Nix, or environment operation fails.
  ///
  /// # Panics
  ///
  /// Panics if the current user's UID cannot be resolved to a user. For
  /// example, if  `User::from_uid(uid)` returns `None`.
  pub fn run(&self, elevate: ElevationStrategy) -> Result<()> {
    let mut profiles = Vec::new();
    let mut gcroots_tagged: HashMap<PathBuf, ToBeRemoved> = HashMap::new();
    let now = SystemTime::now();
    let mut is_profile_clean = false;

    // What profiles to clean depending on the call mode
    let uid = nix::unistd::Uid::effective();
    let args = match self {
      Self::Profile(args) => {
        profiles.push(args.profile.clone());
        is_profile_clean = true;
        &args.common
      },
      Self::All(args) => {
        if !uid.is_root() {
          crate::util::self_elevate(elevate);
        }

        let paths_to_check = [
          PathBuf::from("/nix/var/nix/profiles"),
          PathBuf::from("/nix/var/nix/profiles/per-user"),
        ];

        profiles.extend(filter_existing_dirs(paths_to_check).flat_map(
          |path| {
            if path.ends_with("per-user") {
              path
                .read_dir()
                .map(|read_dir| {
                  read_dir
                    .filter_map(std::result::Result::ok)
                    .map(|entry| entry.path())
                    .filter(|path| path.is_dir())
                    .flat_map(profiles_in_dir)
                    .collect::<Vec<_>>()
                })
                .unwrap_or_default()
            } else {
              profiles_in_dir(path)
            }
          },
        ));

        // Most unix systems start regular users at uid 1000+, but macos is
        // special at 501+ https://en.wikipedia.org/wiki/User_identifier
        let uid_min = if cfg!(target_os = "macos") { 501 } else { 1000 };
        let uid_max = uid_min + 100;
        debug!("Scanning XDG profiles for users 0, {uid_min}-{uid_max}");

        // Check root user (uid 0)
        if let Some(user) =
          nix::unistd::User::from_uid(nix::unistd::Uid::from_raw(0))?
        {
          debug!(?user, "Adding XDG profiles for root user");
          let user_profiles_path = user.dir.join(".local/state/nix/profiles");
          if user_profiles_path.is_dir() {
            profiles.extend(profiles_in_dir(user_profiles_path));
          }
        }

        // Check regular users in the expected range
        for uid in uid_min..uid_max {
          if let Some(user) =
            nix::unistd::User::from_uid(nix::unistd::Uid::from_raw(uid))?
          {
            debug!(?user, "Adding XDG profiles for user");
            let user_profiles_path = user.dir.join(".local/state/nix/profiles");
            if user_profiles_path.is_dir() {
              profiles.extend(profiles_in_dir(user_profiles_path));
            }
          }
        }
        args
      },
      Self::User(args) => {
        if uid.is_root() {
          bail!("nh clean user: don't run me as root!");
        }
        let user = nix::unistd::User::from_uid(uid)?
          .ok_or_else(|| eyre!("User not found for uid {}", uid))?;
        let home_dir = PathBuf::from(std::env::var("HOME")?);

        let paths_to_check = [
          home_dir.join(".local/state/nix/profiles"),
          PathBuf::from("/nix/var/nix/profiles/per-user").join(&user.name),
        ];

        profiles.extend(
          filter_existing_dirs(paths_to_check).flat_map(profiles_in_dir),
        );

        if profiles.is_empty() {
          warn!(
            "No active profile directories found for the current user. \
             Nothing to clean."
          );
        }

        args
      },
    };

    // Use mutation to raise errors as they come
    let mut profiles_tagged = ProfilesTagged::new();
    for p in profiles {
      profiles_tagged.insert(
        p.clone(),
        cleanable_generations(&p, args.keep, args.keep_since)?,
      );
    }

    // Query gcroots
    let regexes = [&*DIRENV_REGEX, &*RESULT_REGEX];

    if !is_profile_clean && !args.no_gcroots {
      for elem in PathBuf::from("/nix/var/nix/gcroots/auto")
        .read_dir()
        .wrap_err("Reading auto gcroots dir")?
      {
        let src = elem.wrap_err("Reading auto gcroots element")?.path();
        let dst = src.read_link().wrap_err("Reading symlink destination")?;
        let span = span!(Level::TRACE, "gcroot detection", ?dst);
        let _entered = span.enter();
        debug!(?src);

        if !regexes
          .iter()
          .any(|next| next.is_match(&dst.to_string_lossy()))
        {
          debug!("dst doesn't match any gcroot regex, skipping");
          continue;
        }

        // Create a file descriptor for the current working directory
        let dirfd = nix::fcntl::open(
          ".",
          nix::fcntl::OFlag::O_DIRECTORY,
          nix::sys::stat::Mode::empty(),
        )?;

        // Use .exists to not travel symlinks
        if match faccessat(
          &dirfd,
          &dst,
          AccessFlags::F_OK | AccessFlags::W_OK,
          AtFlags::AT_SYMLINK_NOFOLLOW,
        ) {
          Ok(()) => true,
          Err(errno) => {
            match errno {
              Errno::EACCES | Errno::ENOENT => false,
              _ => {
                bail!(
                  eyre!("Checking access for gcroot {:?}, unknown error", dst)
                    .wrap_err(errno)
                )
              },
            }
          },
        } {
          let dur = now.duration_since(
            dst
              .symlink_metadata()
              .wrap_err("Reading gcroot metadata")?
              .modified()?,
          );
          debug!(?dur);
          match dur {
            Err(err) => {
              warn!(?err, ?now, "Failed to compare time!");
            },
            Ok(val) if val <= args.keep_since.into() => {
              gcroots_tagged.insert(dst, false);
            },
            Ok(_) => {
              gcroots_tagged.insert(dst, true);
            },
          }
        } else {
          debug!("dst doesn't exist or is not writable, skipping");
        }
      }
    }

    // Present the user the information about the paths to clean
    println!();
    println!("{}", Paint::new("Welcome to nh clean").bold());
    println!(
      "Keeping {} generation(s)",
      Paint::new(args.keep).fg(Color::Green)
    );
    println!(
      "Keeping paths newer than {}",
      Paint::new(args.keep_since).fg(Color::Green)
    );
    println!();
    println!("legend:");
    println!(
      "{}: path regular expression to be matched",
      Paint::new("RE").fg(Color::Magenta)
    );
    println!("{}: path to be kept", Paint::new("OK").fg(Color::Green));
    println!("{}: path to be removed", Paint::new("DEL").fg(Color::Red));
    println!();
    if !gcroots_tagged.is_empty() {
      println!(
        "{}",
        Paint::new("gcroots (matching the following regex patterns)")
          .fg(Color::Blue)
          .bold()
      );
      for re in regexes {
        println!("- {}  {}", Paint::new("RE").fg(Color::Magenta), re.as_str());
      }
      for (path, tbr) in &gcroots_tagged {
        if *tbr {
          println!(
            "- {} {}",
            Paint::new("DEL").fg(Color::Red),
            path.to_string_lossy()
          );
        } else {
          println!(
            "- {} {}",
            Paint::new("OK ").fg(Color::Green),
            path.to_string_lossy()
          );
        }
      }
      println!();
    }
    for (profile, generations_tagged) in &profiles_tagged {
      println!(
        "{}",
        Paint::new(profile.to_string_lossy()).fg(Color::Blue).bold()
      );
      for (generation, tbr) in generations_tagged.iter().rev() {
        if *tbr {
          println!(
            "- {} {}",
            Paint::new("DEL").fg(Color::Red),
            generation.path.to_string_lossy()
          );
        } else {
          println!(
            "- {} {}",
            Paint::new("OK ").fg(Color::Green),
            generation.path.to_string_lossy()
          );
        }
      }
      println!();
    }

    // Clean the paths
    if args.ask
      && !Confirm::new("Confirm the cleanup plan?")
        .with_default(false)
        .prompt()?
    {
      bail!("User rejected the cleanup plan");
    }

    if !args.dry {
      for (path, tbr) in &gcroots_tagged {
        if *tbr {
          remove_path_nofail(path);
        }
      }

      for generations_tagged in profiles_tagged.values() {
        for (generation, tbr) in generations_tagged.iter().rev() {
          if *tbr {
            remove_path_nofail(&generation.path);
          }
        }
      }
    }

    if !args.no_gc {
      let mut gc_args = vec!["store", "gc"];
      if let Some(ref max) = args.max {
        gc_args.push("--max");
        gc_args.push(max.as_str());
      }
      Command::new("nix")
        .args(gc_args)
        .dry(args.dry)
        .message("Performing garbage collection on the nix store")
        .show_output(true)
        .with_required_env()
        .run()?;
    }

    if args.optimise {
      Command::new("nix-store")
        .args(["--optimise"])
        .dry(args.dry)
        .message("Optimising the nix store")
        .show_output(true)
        .with_required_env()
        .run()?;
    }

    Ok(())
  }
}

#[instrument(ret, level = "debug")]
fn profiles_in_dir<P: AsRef<Path> + fmt::Debug>(dir: P) -> Vec<PathBuf> {
  let mut res = Vec::new();
  let dir = dir.as_ref();

  match dir.read_dir() {
    Ok(read_dir) => {
      for entry in read_dir {
        match entry {
          Ok(e) => {
            let path = e.path();

            if let Ok(dst) = path.read_link() {
              let name = if let Some(f) = dst.file_name() {
                f.to_string_lossy()
              } else {
                warn!("Failed to get filename for {dst:?}");
                continue;
              };

              if GENERATION_REGEX.captures(&name).is_some() {
                res.push(path);
              }
            }
          },
          Err(error) => {
            warn!(?dir, ?error, "Failed to read folder element");
          },
        }
      }
    },
    Err(error) => {
      warn!(?dir, ?error, "Failed to read profiles directory");
    },
  }

  res
}

#[instrument(err, level = "debug")]
fn cleanable_generations(
  profile: &Path,
  keep: u32,
  keep_since: humantime::Duration,
) -> Result<GenerationsTagged> {
  let name = profile
    .file_name()
    .context("Checking profile's name")?
    .to_str()
    .context("Profile name is not valid UTF-8")?;

  let mut result = GenerationsTagged::new();

  for entry in profile
    .parent()
    .context("Reading profile's parent dir")?
    .read_dir()
    .context("Reading profile's generations")?
  {
    let path = entry?.path();
    let captures = {
      let file_name = path.file_name().context("Failed to get filename")?;
      let file_name_str =
        file_name.to_str().context("Filename is not valid UTF-8")?;
      GENERATION_REGEX.captures(file_name_str)
    };

    if let Some(caps) = captures {
      // Check if this generation belongs to the current profile
      if let Some(profile_name) = caps.get(1) {
        if profile_name.as_str() != name {
          continue;
        }
      }
      if let Some(number) = caps.get(2) {
        let last_modified = path
          .symlink_metadata()
          .context("Checking symlink metadata")?
          .modified()
          .context("Reading modified time")?;

        result.insert(
          Generation {
            number: number
              .as_str()
              .parse()
              .context("Failed to parse generation number")?,
            last_modified,
            path,
          },
          true,
        );
      }
    }
  }

  let now = SystemTime::now();
  for (generation, tbr) in &mut result {
    match now.duration_since(generation.last_modified) {
      Err(err) => {
        warn!(?err, ?now, ?generation, "Failed to compare time!");
      },
      Ok(val) if val <= keep_since.into() => {
        *tbr = false;
      },
      Ok(_) => {},
    }
  }

  for (_, tbr) in result.iter_mut().rev().take(keep as _) {
    *tbr = false;
  }

  debug!("{:#?}", result);
  Ok(result)
}

fn remove_path_nofail(path: &Path) {
  info!("Removing {}", path.to_string_lossy());
  if let Err(err) = std::fs::remove_file(path) {
    warn!(?path, ?err, "Failed to remove path");
  }
}
</file>

<file path="src/darwin.rs">
use std::{env, path::PathBuf};

use color_eyre::eyre::{Context, bail, eyre};
use tracing::{debug, warn};

use crate::{
  Result,
  commands,
  commands::{Command, ElevationStrategy},
  installable::Installable,
  interface::{
    DarwinArgs,
    DarwinRebuildArgs,
    DarwinReplArgs,
    DarwinSubcommand,
    DiffType,
  },
  nixos::toplevel_for,
  update::update,
  util::{get_hostname, print_dix_diff},
};

const SYSTEM_PROFILE: &str = "/nix/var/nix/profiles/system";
const CURRENT_PROFILE: &str = "/run/current-system";

impl DarwinArgs {
  /// Run the `darwin` subcommand.
  ///
  /// # Errors
  ///
  /// Returns an error if the operation fails.
  pub fn run(self, elevation: ElevationStrategy) -> Result<()> {
    use DarwinRebuildVariant::{Build, Switch};
    match self.subcommand {
      DarwinSubcommand::Switch(args) => args.rebuild(&Switch, elevation),
      DarwinSubcommand::Build(args) => {
        if args.common.ask || args.common.dry {
          warn!("`--ask` and `--dry` have no effect for `nh darwin build`");
        }
        args.rebuild(&Build, elevation)
      },
      DarwinSubcommand::Repl(args) => args.run(),
    }
  }
}

enum DarwinRebuildVariant {
  Switch,
  Build,
}

impl DarwinRebuildArgs {
  fn rebuild(
    self,
    variant: &DarwinRebuildVariant,
    elevation: ElevationStrategy,
  ) -> Result<()> {
    use DarwinRebuildVariant::{Build, Switch};

    if nix::unistd::Uid::effective().is_root() && !self.bypass_root_check {
      bail!("Don't run nh os as root. I will call sudo internally as needed");
    }

    if self.update_args.update_all || self.update_args.update_input.is_some() {
      update(&self.common.installable, self.update_args.update_input)?;
    }

    let hostname = get_hostname(self.hostname)?;

    let (out_path, _tempdir_guard): (PathBuf, Option<tempfile::TempDir>) =
      if let Some(ref p) = self.common.out_link {
        (p.clone(), None)
      } else {
        let dir = tempfile::Builder::new().prefix("nh-os").tempdir()?;
        (dir.as_ref().join("result"), Some(dir))
      };

    debug!("Output path: {out_path:?}");

    // Use NH_DARWIN_FLAKE if available, otherwise use the provided installable
    let installable = if let Ok(darwin_flake) = env::var("NH_DARWIN_FLAKE") {
      debug!("Using NH_DARWIN_FLAKE: {}", darwin_flake);

      let mut elems = darwin_flake.splitn(2, '#');
      let reference = match elems.next() {
        Some(r) => r.to_owned(),
        None => return Err(eyre!("NH_DARWIN_FLAKE missing reference part")),
      };
      let attribute = elems
        .next()
        .map(crate::installable::parse_attribute)
        .unwrap_or_default();

      Installable::Flake {
        reference,
        attribute,
      }
    } else {
      self.common.installable.clone()
    };

    let mut processed_installable = installable;
    if let Installable::Flake {
      ref mut attribute, ..
    } = processed_installable
    {
      // If user explicitly selects some other attribute, don't push
      // darwinConfigurations
      if attribute.is_empty() {
        attribute.push(String::from("darwinConfigurations"));
        attribute.push(hostname.clone());
      }
    }

    let toplevel = toplevel_for(hostname, processed_installable, "toplevel");

    commands::Build::new(toplevel)
      .extra_arg("--out-link")
      .extra_arg(&out_path)
      .extra_args(&self.extra_args)
      .passthrough(&self.common.passthrough)
      .message("Building Darwin configuration")
      .nom(!self.common.no_nom)
      .run()
      .wrap_err("Failed to build Darwin configuration")?;

    let target_profile = out_path.clone();

    target_profile.try_exists().context("Doesn't exist")?;

    debug!(
      "Comparing with target profile: {}",
      target_profile.display()
    );

    // Compare changes between current and target generation
    if matches!(self.common.diff, DiffType::Never) {
      debug!("Not running dix as the --diff flag is set to never.");
    } else {
      debug!(
        "Comparing with target profile: {}",
        target_profile.display()
      );
      let _ = print_dix_diff(&PathBuf::from(CURRENT_PROFILE), &target_profile);
    }

    if self.common.ask && !self.common.dry && !matches!(variant, Build) {
      let confirmation = inquire::Confirm::new("Apply the config?")
        .with_default(false)
        .prompt()?;

      if !confirmation {
        bail!("User rejected the new config");
      }
    }

    if matches!(variant, Switch) {
      Command::new("nix")
        .args(["build", "--no-link", "--profile", SYSTEM_PROFILE])
        .arg(&out_path)
        .elevate(Some(elevation.clone()))
        .dry(self.common.dry)
        .with_required_env()
        .run()
        .wrap_err("Failed to set Darwin system profile")?;

      let darwin_rebuild = out_path.join("sw/bin/darwin-rebuild");
      let activate_user = out_path.join("activate-user");

      // Determine if we need to elevate privileges
      let needs_elevation = !activate_user
        .try_exists()
        .context("Failed to check if activate-user file exists")?
        || std::fs::read_to_string(&activate_user)
          .context("Failed to read activate-user file")?
          .contains("# nix-darwin: deprecated");

      // Create and run the activation command with or without elevation
      Command::new(darwin_rebuild)
        .arg("activate")
        .message("Activating configuration")
        .elevate(needs_elevation.then_some(elevation))
        .dry(self.common.dry)
        .show_output(true)
        .with_required_env()
        .run()
        .wrap_err("Darwin activation failed")?;
    }

    debug!("Completed operation with output path: {out_path:?}");

    Ok(())
  }
}

impl DarwinReplArgs {
  fn run(self) -> Result<()> {
    // Use NH_DARWIN_FLAKE if available, otherwise use the provided installable
    let mut target_installable =
      if let Ok(darwin_flake) = env::var("NH_DARWIN_FLAKE") {
        debug!("Using NH_DARWIN_FLAKE: {}", darwin_flake);

        let mut elems = darwin_flake.splitn(2, '#');
        let reference = match elems.next() {
          Some(r) => r.to_owned(),
          None => return Err(eyre!("NH_DARWIN_FLAKE missing reference part")),
        };
        let attribute = elems
          .next()
          .map(crate::installable::parse_attribute)
          .unwrap_or_default();

        Installable::Flake {
          reference,
          attribute,
        }
      } else {
        self.installable
      };

    if matches!(target_installable, Installable::Store { .. }) {
      bail!("Nix doesn't support nix store installables.");
    }

    let hostname = get_hostname(self.hostname)?;

    if let Installable::Flake {
      ref mut attribute, ..
    } = target_installable
    {
      if attribute.is_empty() {
        attribute.push(String::from("darwinConfigurations"));
        attribute.push(hostname);
      }
    }

    Command::new("nix")
      .arg("repl")
      .args(target_installable.to_args())
      .with_required_env()
      .show_output(true)
      .run()?;

    Ok(())
  }
}
</file>

<file path="src/interface.rs">
use std::{env, path::PathBuf};

use anstyle::Style;
use clap::{Args, Parser, Subcommand, ValueEnum, builder::Styles};
use clap_verbosity_flag::InfoLevel;

use crate::{
  Result,
  checks::{
    DarwinReplFeatures,
    FeatureRequirements,
    FlakeFeatures,
    HomeReplFeatures,
    LegacyFeatures,
    NoFeatures,
    OsReplFeatures,
  },
  commands::ElevationStrategy,
  generations::Field,
  installable::Installable,
};

const fn make_style() -> Styles {
  Styles::plain().header(Style::new().bold()).literal(
    Style::new()
      .bold()
      .fg_color(Some(anstyle::Color::Ansi(anstyle::AnsiColor::Yellow))),
  )
}

#[derive(Parser, Debug)]
#[command(
    version,
    about,
    long_about = None,
    styles=make_style(),
    propagate_version = false,
    help_template = "
{name} {version}
{about-with-newline}
{usage-heading} {usage}

{all-args}{after-help}
"
)]
/// Yet another nix helper
pub struct Main {
  #[command(flatten)]
  /// Increase logging verbosity, can be passed multiple times for
  /// more detailed logs.
  pub verbosity: clap_verbosity_flag::Verbosity<InfoLevel>,

  #[arg(short, long, global = true, env = "NH_ELEVATION_PROGRAM", value_hint = clap::ValueHint::CommandName)]
  /// Choose what privilege elevation program should be used
  pub elevation_program: Option<PathBuf>,

  #[command(subcommand)]
  pub command: NHCommand,
}

#[derive(Subcommand, Debug)]
#[command(disable_help_subcommand = true)]
pub enum NHCommand {
  Os(OsArgs),
  Home(HomeArgs),
  Darwin(DarwinArgs),
  Search(SearchArgs),
  Clean(CleanProxy),
  #[command(hide = true)]
  Completions(CompletionArgs),
}

impl NHCommand {
  #[must_use]
  pub fn get_feature_requirements(&self) -> Box<dyn FeatureRequirements> {
    match self {
      Self::Os(args) => args.get_feature_requirements(),
      Self::Home(args) => args.get_feature_requirements(),
      Self::Darwin(args) => args.get_feature_requirements(),
      Self::Search(_) => Box::new(NoFeatures),
      Self::Clean(_) => Box::new(NoFeatures),
      Self::Completions(_) => Box::new(NoFeatures),
    }
  }

  pub fn run(self, elevation: ElevationStrategy) -> Result<()> {
    // Check features specific to this command
    let requirements = self.get_feature_requirements();
    requirements.check_features()?;

    match self {
      Self::Os(args) => {
        unsafe {
          std::env::set_var("NH_CURRENT_COMMAND", "os");
        }
        args.run(elevation)
      },
      Self::Search(args) => args.run(),
      Self::Clean(proxy) => proxy.command.run(elevation),
      Self::Completions(args) => args.run(),
      Self::Home(args) => {
        unsafe {
          std::env::set_var("NH_CURRENT_COMMAND", "home");
        }
        args.run()
      },
      Self::Darwin(args) => {
        unsafe {
          std::env::set_var("NH_CURRENT_COMMAND", "darwin");
        }
        args.run(elevation)
      },
    }
  }
}

#[derive(Args, Debug)]
#[clap(verbatim_doc_comment)]
/// `NixOS` functionality
///
/// Implements functionality mostly around but not exclusive to nixos-rebuild
pub struct OsArgs {
  #[command(subcommand)]
  pub subcommand: OsSubcommand,
}

impl OsArgs {
  #[must_use]
  pub fn get_feature_requirements(&self) -> Box<dyn FeatureRequirements> {
    match &self.subcommand {
      OsSubcommand::Repl(args) => {
        let is_flake = args.uses_flakes();
        Box::new(OsReplFeatures { is_flake })
      },
      OsSubcommand::Switch(args)
      | OsSubcommand::Boot(args)
      | OsSubcommand::Test(args)
      | OsSubcommand::Build(args) => {
        if args.uses_flakes() {
          Box::new(FlakeFeatures)
        } else {
          Box::new(LegacyFeatures)
        }
      },
      OsSubcommand::BuildVm(args) => {
        if args.common.uses_flakes() {
          Box::new(FlakeFeatures)
        } else {
          Box::new(LegacyFeatures)
        }
      },
      OsSubcommand::Info(_) | OsSubcommand::Rollback(_) => {
        Box::new(LegacyFeatures)
      },
    }
  }
}

#[derive(Debug, Subcommand)]
pub enum OsSubcommand {
  /// Build and activate the new configuration, and make it the boot default
  Switch(OsRebuildArgs),

  /// Build the new configuration and make it the boot default
  Boot(OsRebuildArgs),

  /// Build and activate the new configuration
  Test(OsRebuildArgs),

  /// Build the new configuration
  Build(OsRebuildArgs),

  /// Load system in a repl
  Repl(OsReplArgs),

  /// List available generations from profile path
  Info(OsGenerationsArgs),

  /// Rollback to a previous generation
  Rollback(OsRollbackArgs),

  /// Build a `NixOS` VM image
  BuildVm(OsBuildVmArgs),
}

#[derive(Debug, Args)]
pub struct OsBuildVmArgs {
  #[command(flatten)]
  pub common: OsRebuildArgs,

  /// Build with bootloader. Bootloader is bypassed by default.
  #[arg(long, short = 'B')]
  pub with_bootloader: bool,

  /// Run the VM immediately after building
  #[arg(long, short = 'r')]
  pub run: bool,
}

#[derive(Debug, Args)]
pub struct OsRebuildArgs {
  #[command(flatten)]
  pub common: CommonRebuildArgs,

  #[command(flatten)]
  pub update_args: UpdateArgs,

  /// When using a flake installable, select this hostname from
  /// nixosConfigurations
  #[arg(long, short = 'H', global = true)]
  pub hostname: Option<String>,

  /// Explicitly select some specialisation
  #[arg(long, short)]
  pub specialisation: Option<String>,

  /// Ignore specialisations
  #[arg(long, short = 'S')]
  pub no_specialisation: bool,

  /// Install bootloader for switch and boot commands
  #[arg(long)]
  pub install_bootloader: bool,

  /// Extra arguments passed to nix build
  #[arg(last = true)]
  pub extra_args: Vec<String>,

  /// Don't panic if calling nh as root
  #[arg(short = 'R', long, env = "NH_BYPASS_ROOT_CHECK")]
  pub bypass_root_check: bool,

  /// Deploy the configuration to a different host over ssh
  #[arg(long)]
  pub target_host: Option<String>,

  /// Build the configuration to a different host over ssh
  #[arg(long)]
  pub build_host: Option<String>,
}

impl OsRebuildArgs {
  #[must_use]
  pub fn uses_flakes(&self) -> bool {
    // Check environment variables first
    if env::var("NH_OS_FLAKE").is_ok_and(|v| !v.is_empty()) {
      return true;
    }

    // Check installable type
    matches!(self.common.installable, Installable::Flake { .. })
  }
}

#[derive(ValueEnum, Clone, Default, Debug)]
pub enum DiffType {
  /// Display package diff only if the of the
  /// current and the deployed configuration matches
  #[default]
  Auto,
  /// Always display package diff
  Always,
  /// Never display package diff
  Never,
}

#[derive(Debug, Args)]
pub struct OsRollbackArgs {
  /// Only print actions, without performing them
  #[arg(long, short = 'n')]
  pub dry: bool,

  /// Ask for confirmation
  #[arg(long, short)]
  pub ask: bool,

  /// Explicitly select some specialisation
  #[arg(long, short)]
  pub specialisation: Option<String>,

  /// Ignore specialisations
  #[arg(long, short = 'S')]
  pub no_specialisation: bool,

  /// Rollback to a specific generation number (defaults to previous
  /// generation)
  #[arg(long, short)]
  pub to: Option<u64>,

  /// Don't panic if calling nh as root
  #[arg(short = 'R', long, env = "NH_BYPASS_ROOT_CHECK")]
  pub bypass_root_check: bool,

  /// Whether to display a package diff
  #[arg(long, short, value_enum, default_value_t = DiffType::Auto)]
  pub diff: DiffType,
}

#[derive(Debug, Args)]
pub struct CommonRebuildArgs {
  /// Only print actions, without performing them
  #[arg(long, short = 'n')]
  pub dry: bool,

  /// Ask for confirmation
  #[arg(long, short)]
  pub ask: bool,

  #[command(flatten)]
  pub installable: Installable,

  /// Don't use nix-output-monitor for the build process
  #[arg(long)]
  pub no_nom: bool,

  /// Path to save the result link, defaults to using a temporary directory
  #[arg(long, short)]
  pub out_link: Option<PathBuf>,

  /// Whether to display a package diff
  #[arg(long, short, value_enum, default_value_t = DiffType::Auto)]
  pub diff: DiffType,

  #[command(flatten)]
  pub passthrough: NixBuildPassthroughArgs,
}

#[derive(Debug, Args)]
pub struct OsReplArgs {
  #[command(flatten)]
  pub installable: Installable,

  /// When using a flake installable, select this hostname from
  /// nixosConfigurations
  #[arg(long, short = 'H', global = true)]
  pub hostname: Option<String>,
}

impl OsReplArgs {
  #[must_use]
  pub fn uses_flakes(&self) -> bool {
    // Check environment variables first
    if env::var("NH_OS_FLAKE").is_ok() {
      return true;
    }

    // Check installable type
    matches!(self.installable, Installable::Flake { .. })
  }
}

#[derive(Debug, Args)]
pub struct OsGenerationsArgs {
  /// Path to Nix' profiles directory
  #[arg(long, short = 'P', default_value = "/nix/var/nix/profiles/system")]
  pub profile: Option<String>,

  /// Comma-delimited list of field(s) to display
  #[arg(
    long,
    value_delimiter = ',',
    default_value = "id,date,nver,kernel,confRev,spec,size"
  )]
  pub fields: Vec<Field>,
}

#[derive(Args, Debug)]
/// Searches packages by querying search.nixos.org
pub struct SearchArgs {
  #[arg(long, short, default_value = "30")]
  /// Number of search results to display
  pub limit: u64,

  #[arg(
    long,
    short,
    env = "NH_SEARCH_CHANNEL",
    default_value = "nixos-unstable"
  )]
  /// Name of the channel to query (e.g nixos-23.11, nixos-unstable, etc)
  pub channel: String,

  #[arg(long, short = 'P', env = "NH_SEARCH_PLATFORM", value_parser = clap::builder::BoolishValueParser::new())]
  /// Show supported platforms for each package
  pub platforms: bool,

  #[arg(long, short = 'j', env = "NH_SEARCH_JSON", value_parser = clap::builder::BoolishValueParser::new())]
  /// Output results as JSON
  pub json: bool,

  /// Name of the package to search
  pub query: Vec<String>,
}

#[derive(Debug, Clone, ValueEnum)]
pub enum SearchNixpkgsFrom {
  Flake,
  Path,
}

// Needed a struct to have multiple sub-subcommands
#[derive(Debug, Clone, Args)]
pub struct CleanProxy {
  #[clap(subcommand)]
  command: CleanMode,
}

#[derive(Debug, Clone, Subcommand)]
/// Enhanced nix cleanup
pub enum CleanMode {
  /// Clean all profiles
  All(CleanArgs),
  /// Clean the current user's profiles
  User(CleanArgs),
  /// Clean a specific profile
  Profile(CleanProfileArgs),
}

#[derive(Args, Clone, Debug)]
#[clap(verbatim_doc_comment)]
/// Enhanced nix cleanup
///
/// For --keep-since, see the documentation of humantime for possible formats: <https://docs.rs/humantime/latest/humantime/fn.parse_duration.html>
pub struct CleanArgs {
  #[arg(long, short, default_value = "1")]
  /// At least keep this number of generations
  pub keep: u32,

  #[arg(long, short = 'K', default_value = "0h")]
  /// At least keep gcroots and generations in this time range since now.
  pub keep_since: humantime::Duration,

  /// Only print actions, without performing them
  #[arg(long, short = 'n')]
  pub dry: bool,

  /// Ask for confirmation
  #[arg(long, short)]
  pub ask: bool,

  /// Don't run nix store --gc
  #[arg(long = "no-gc", alias = "nogc")]
  pub no_gc: bool,

  /// Don't clean gcroots
  #[arg(long = "no-gcroots", alias = "nogcroots")]
  pub no_gcroots: bool,

  /// Run nix-store --optimise after gc
  #[arg(long)]
  pub optimise: bool,

  /// Pass --max to nix store gc
  #[arg(long)]
  pub max: Option<String>,
}

#[derive(Debug, Clone, Args)]
pub struct CleanProfileArgs {
  #[command(flatten)]
  pub common: CleanArgs,

  /// Which profile to clean
  pub profile: PathBuf,
}

#[derive(Debug, Args)]
/// Home-manager functionality
pub struct HomeArgs {
  #[command(subcommand)]
  pub subcommand: HomeSubcommand,
}

impl HomeArgs {
  #[must_use]
  pub fn get_feature_requirements(&self) -> Box<dyn FeatureRequirements> {
    match &self.subcommand {
      HomeSubcommand::Repl(args) => {
        let is_flake = args.uses_flakes();
        Box::new(HomeReplFeatures { is_flake })
      },
      HomeSubcommand::Switch(args) | HomeSubcommand::Build(args) => {
        if args.uses_flakes() {
          Box::new(FlakeFeatures)
        } else {
          Box::new(LegacyFeatures)
        }
      },
    }
  }
}

#[derive(Debug, Subcommand)]
pub enum HomeSubcommand {
  /// Build and activate a home-manager configuration
  Switch(HomeRebuildArgs),

  /// Build a home-manager configuration
  Build(HomeRebuildArgs),

  /// Load a home-manager configuration in a Nix REPL
  Repl(HomeReplArgs),
}

#[derive(Debug, Args)]
pub struct HomeRebuildArgs {
  #[command(flatten)]
  pub common: CommonRebuildArgs,

  #[command(flatten)]
  pub update_args: UpdateArgs,

  /// Name of the flake homeConfigurations attribute, like username@hostname
  ///
  /// If unspecified, will try <username>@<hostname> and <username>
  #[arg(long, short)]
  pub configuration: Option<String>,

  /// Explicitly select some specialisation
  #[arg(long, short)]
  pub specialisation: Option<String>,

  /// Ignore specialisations
  #[arg(long, short = 'S')]
  pub no_specialisation: bool,

  /// Extra arguments passed to nix build
  #[arg(last = true)]
  pub extra_args: Vec<String>,

  /// Move existing files by backing up with this file extension
  #[arg(long, short = 'b')]
  pub backup_extension: Option<String>,
}

impl HomeRebuildArgs {
  #[must_use]
  pub fn uses_flakes(&self) -> bool {
    // Check environment variables first
    if env::var("NH_HOME_FLAKE").is_ok_and(|v| !v.is_empty()) {
      return true;
    }

    // Check installable type
    matches!(self.common.installable, Installable::Flake { .. })
  }
}

#[derive(Debug, Args)]
pub struct HomeReplArgs {
  #[command(flatten)]
  pub installable: Installable,

  /// Name of the flake homeConfigurations attribute, like username@hostname
  ///
  /// If unspecified, will try <username>@<hostname> and <username>
  #[arg(long, short)]
  pub configuration: Option<String>,

  /// Extra arguments passed to nix repl
  #[arg(last = true)]
  pub extra_args: Vec<String>,
}

impl HomeReplArgs {
  #[must_use]
  pub fn uses_flakes(&self) -> bool {
    // Check environment variables first
    if env::var("NH_HOME_FLAKE").is_ok_and(|v| !v.is_empty()) {
      return true;
    }

    // Check installable type
    matches!(self.installable, Installable::Flake { .. })
  }
}

#[derive(Debug, Parser)]
/// Generate shell completion files into stdout
pub struct CompletionArgs {
  /// Name of the shell
  pub shell: clap_complete::Shell,
}

/// Nix-darwin functionality
///
/// Implements functionality mostly around but not exclusive to darwin-rebuild
#[derive(Debug, Args)]
pub struct DarwinArgs {
  #[command(subcommand)]
  pub subcommand: DarwinSubcommand,
}

impl DarwinArgs {
  #[must_use]
  pub fn get_feature_requirements(&self) -> Box<dyn FeatureRequirements> {
    match &self.subcommand {
      DarwinSubcommand::Repl(args) => {
        let is_flake = args.uses_flakes();
        Box::new(DarwinReplFeatures { is_flake })
      },
      DarwinSubcommand::Switch(args) | DarwinSubcommand::Build(args) => {
        if args.uses_flakes() {
          Box::new(FlakeFeatures)
        } else {
          Box::new(LegacyFeatures)
        }
      },
    }
  }
}

#[derive(Debug, Subcommand)]
pub enum DarwinSubcommand {
  /// Build and activate a nix-darwin configuration
  Switch(DarwinRebuildArgs),
  /// Build a nix-darwin configuration
  Build(DarwinRebuildArgs),
  /// Load a nix-darwin configuration in a Nix REPL
  Repl(DarwinReplArgs),
}

#[derive(Debug, Args)]
pub struct DarwinRebuildArgs {
  #[command(flatten)]
  pub common: CommonRebuildArgs,

  #[command(flatten)]
  pub update_args: UpdateArgs,

  /// When using a flake installable, select this hostname from
  /// darwinConfigurations
  #[arg(long, short = 'H', global = true)]
  pub hostname: Option<String>,

  /// Extra arguments passed to nix build
  #[arg(last = true)]
  pub extra_args: Vec<String>,

  /// Don't panic if calling nh as root
  #[arg(short = 'R', long, env = "NH_BYPASS_ROOT_CHECK")]
  pub bypass_root_check: bool,
}

impl DarwinRebuildArgs {
  #[must_use]
  pub fn uses_flakes(&self) -> bool {
    // Check environment variables first
    if env::var("NH_DARWIN_FLAKE").is_ok_and(|v| !v.is_empty()) {
      return true;
    }

    // Check installable type
    matches!(self.common.installable, Installable::Flake { .. })
  }
}

#[derive(Debug, Args)]
pub struct DarwinReplArgs {
  #[command(flatten)]
  pub installable: Installable,

  /// When using a flake installable, select this hostname from
  /// darwinConfigurations
  #[arg(long, short = 'H', global = true)]
  pub hostname: Option<String>,
}

impl DarwinReplArgs {
  #[must_use]
  pub fn uses_flakes(&self) -> bool {
    // Check environment variables first
    if env::var("NH_DARWIN_FLAKE").is_ok_and(|v| !v.is_empty()) {
      return true;
    }

    // Check installable type
    matches!(self.installable, Installable::Flake { .. })
  }
}

#[derive(Debug, Args)]
pub struct UpdateArgs {
  #[arg(short = 'u', long = "update", conflicts_with = "update_input")]
  /// Update all flake inputs
  pub update_all: bool,

  #[arg(short = 'U', long = "update-input", conflicts_with = "update_all")]
  /// Update the specified flake input(s)
  pub update_input: Option<Vec<String>>,
}

#[derive(Debug, Args)]
pub struct NixBuildPassthroughArgs {
  /// Number of concurrent jobs Nix should run
  #[arg(long, short = 'j')]
  pub max_jobs: Option<usize>,

  /// Number of cores Nix should utilize
  #[arg(long)]
  pub cores: Option<usize>,

  /// Logging format used by Nix
  #[arg(long)]
  pub log_format: Option<String>,

  /// Continue building despite encountering errors
  #[arg(long, short = 'k')]
  pub keep_going: bool,

  /// Keep build outputs from failed builds
  #[arg(long, short = 'K')]
  pub keep_failed: bool,

  /// Attempt to build locally if substituters fail
  #[arg(long)]
  pub fallback: bool,

  /// Repair corrupted store paths
  #[arg(long)]
  pub repair: bool,

  /// Explicitly define remote builders
  #[arg(long)]
  pub builders: Option<String>,

  /// Paths to include
  #[arg(long, short = 'I')]
  pub include: Vec<String>,

  /// Print build logs directly to stdout
  #[arg(long, short = 'L')]
  pub print_build_logs: bool,

  /// Display tracebacks on errors
  #[arg(long, short = 't')]
  pub show_trace: bool,

  /// Accept configuration from flakes
  #[arg(long)]
  pub accept_flake_config: bool,

  /// Refresh flakes to the latest revision
  #[arg(long)]
  pub refresh: bool,

  /// Allow impure builds
  #[arg(long)]
  pub impure: bool,

  /// Build without internet access
  #[arg(long)]
  pub offline: bool,

  /// Prohibit network usage
  #[arg(long)]
  pub no_net: bool,

  /// Recreate the flake.lock file entirely
  #[arg(long)]
  pub recreate_lock_file: bool,

  /// Do not update the flake.lock file
  #[arg(long)]
  pub no_update_lock_file: bool,

  /// Do not write a lock file
  #[arg(long)]
  pub no_write_lock_file: bool,

  /// Ignore registries
  #[arg(long)]
  pub no_registries: bool,

  /// Commit the lock file after updates
  #[arg(long)]
  pub commit_lock_file: bool,

  /// Suppress build output
  #[arg(long, short = 'Q')]
  pub no_build_output: bool,

  /// Use substitutes when copying
  #[arg(long)]
  pub use_substitutes: bool,

  /// Output results in JSON format
  #[arg(long)]
  pub json: bool,
}

impl NixBuildPassthroughArgs {
  #[must_use]
  pub fn generate_passthrough_args(&self) -> Vec<String> {
    let mut args = Vec::new();

    if let Some(jobs) = self.max_jobs {
      args.push("--max-jobs".into());
      args.push(jobs.to_string());
    }
    if let Some(cores) = self.cores {
      args.push("--cores".into());
      args.push(cores.to_string());
    }
    if let Some(ref format) = self.log_format {
      args.push("--log-format".into());
      args.push(format.clone());
    }
    if self.keep_going {
      args.push("--keep-going".into());
    }
    if self.keep_failed {
      args.push("--keep-failed".into());
    }
    if self.fallback {
      args.push("--fallback".into());
    }
    if self.repair {
      args.push("--repair".into());
    }
    if let Some(ref builders) = self.builders {
      args.push("--builders".into());
      args.push(builders.clone());
    }
    for inc in &self.include {
      args.push("--include".into());
      args.push(inc.clone());
    }
    if self.print_build_logs {
      args.push("--print-build-logs".into());
    }
    if self.show_trace {
      args.push("--show-trace".into());
    }
    if self.accept_flake_config {
      args.push("--accept-flake-config".into());
    }
    if self.refresh {
      args.push("--refresh".into());
    }
    if self.impure {
      args.push("--impure".into());
    }
    if self.offline {
      args.push("--offline".into());
    }
    if self.no_net {
      args.push("--no-net".into());
    }
    if self.recreate_lock_file {
      args.push("--recreate-lock-file".into());
    }
    if self.no_update_lock_file {
      args.push("--no-update-lock-file".into());
    }
    if self.no_write_lock_file {
      args.push("--no-write-lock-file".into());
    }
    if self.no_registries {
      args.push("--no-registries".into());
    }
    if self.commit_lock_file {
      args.push("--commit-lock-file".into());
    }
    if self.no_build_output {
      args.push("--no-build-output".into());
    }
    if self.use_substitutes {
      args.push("--use-substitutes".into());
    }
    if self.json {
      args.push("--json".into());
    }

    args
  }
}
</file>

<file path="src/search.rs">
use std::{process::Stdio, sync::OnceLock, time::Instant};

use color_eyre::eyre::{Context, bail};
use elasticsearch_dsl::{
  Operator,
  Query,
  Search,
  SearchResponse,
  TextQueryType,
};
use interface::SearchArgs;
use regex::Regex;
use serde::{Deserialize, Serialize};
use tracing::{debug, trace, warn};
use yansi::{Color, Paint};

use crate::{Result, interface};

// List of deprecated NixOS versions
// Add new versions as they become deprecated.
const DEPRECATED_VERSIONS: &[&str] =
  &["nixos-23.11", "nixos-24.05", "nixos-24.11"];

#[derive(Debug, Deserialize, Serialize)]
#[allow(non_snake_case, dead_code)]
struct SearchResult {
  // r#type: String,
  package_attr_name:       String,
  package_attr_set:        String,
  package_pname:           String,
  package_pversion:        String,
  package_platforms:       Vec<String>,
  package_outputs:         Vec<String>,
  package_default_output:  Option<String>,
  package_programs:        Vec<String>,
  // package_license: Vec<License>,
  package_license_set:     Vec<String>,
  // package_maintainers: Vec<HashMap<String, String>>,
  package_description:     Option<String>,
  package_longDescription: Option<String>,
  package_hydra:           (),
  package_system:          String,
  package_homepage:        Vec<String>,
  package_position:        Option<String>,
}

macro_rules! print_hyperlink {
  ($text:expr, $link:expr) => {
    print!("\x1b]8;;{}\x07", $link);
    print!("{}", Paint::new($text).underline());
    println!("\x1b]8;;\x07");
  };
}

#[derive(Debug, Serialize)]
struct JSONOutput {
  query:      String,
  channel:    String,
  elapsed_ms: u128,
  results:    Vec<SearchResult>,
}

impl SearchArgs {
  pub fn run(&self) -> Result<()> {
    trace!("args: {self:?}");

    let mut channel = self.channel.clone();
    if DEPRECATED_VERSIONS.contains(&channel.as_str()) {
      warn!(
        "Channel '{channel}' is deprecated or unavailable, falling back to \
         'nixos-unstable'"
      );
      channel = "nixos-unstable".to_string();
    }
    if !supported_branch(&channel) {
      bail!("Channel {channel} is not supported!");
    }

    let nixpkgs_path = std::thread::spawn(|| {
      std::process::Command::new("nix")
        .stderr(Stdio::inherit())
        .args(["eval", "-f", "<nixpkgs>", "path"])
        .output()
    });

    let query_s = self.query.join(" ");
    debug!(?query_s);

    let query = Search::new().from(0).size(self.limit).query(
      Query::bool().filter(Query::term("type", "package")).must(
        Query::dis_max()
          .tie_breaker(0.7)
          .query(
            Query::multi_match(
              [
                "package_attr_name^9",
                "package_attr_name.*^5.3999999999999995",
                "package_programs^9",
                "package_programs.*^5.3999999999999995",
                "package_pname^6",
                "package_pname.*^3.5999999999999996",
                "package_description^1.3",
                "package_description.*^0.78",
                "package_longDescription^1",
                "package_longDescription.*^0.6",
                "flake_name^0.5",
                "flake_name.*^0.3",
              ],
              query_s.clone(),
            )
            .r#type(TextQueryType::CrossFields)
            .analyzer("whitespace")
            .auto_generate_synonyms_phrase_query(false)
            .operator(Operator::And),
          )
          .query(
            Query::wildcard("package_attr_name", format!("*{}*", &query_s))
              .case_insensitive(true),
          ),
      ),
    );

    if !self.json {
      println!(
        "Querying search.nixos.org, with channel {}...",
        self.channel
      );
    }
    let then = Instant::now();

    let client = reqwest::blocking::Client::new();
    let req = client
            // NOTE: when the version of the backend API changes,
            // this file and the corresponding workflow called
            // nixos-search.yaml have to be updated accordingly.
            .post(format!(
                "https://search.nixos.org/backend/latest-44-{channel}/_search"
            ))
            .json(&query)
            .header("User-Agent", format!("nh/{}", crate::NH_VERSION))
            // Hardcoded upstream
            // https://github.com/NixOS/nixos-search/blob/744ec58e082a3fcdd741b2c9b0654a0f7fda4603/frontend/src/index.js
            .basic_auth("aWVSALXpZv", Some("X8gPHnzL52wFEekuxsfQ9cSh"))
            .build()
            .context("building search query")?;

    debug!(?req);

    let response = client
      .execute(req)
      .context("querying the elasticsearch API")?;
    let elapsed = then.elapsed();
    debug!(?elapsed);
    trace!(?response);

    if !response.status().is_success() {
      eprintln!(
        "Error: search.nixos.org returned HTTP {} for channel '{}'. This \
         usually means the channel does not exist, is not indexed, or the \
         request was malformed.",
        response.status(),
        self.channel
      );
      return Err(color_eyre::eyre::eyre!(
        "search.nixos.org returned HTTP {} for channel '{}'",
        response.status(),
        self.channel
      ));
    }

    if !self.json {
      println!("Took {}ms", elapsed.as_millis());
      println!("Most relevant results at the end");
      println!();
    }

    let parsed_response: SearchResponse = response
      .json()
      .context("parsing response into the elasticsearch format")?;
    trace!(?parsed_response);

    let documents = parsed_response
      .documents::<SearchResult>()
      .context("parsing search document")?;

    if self.json {
      // Output as JSON
      let json_output = JSONOutput {
        query: query_s,
        channel,
        elapsed_ms: elapsed.as_millis(),
        results: documents,
      };

      println!("{}", serde_json::to_string_pretty(&json_output)?);
      return Ok(());
    }

    let hyperlinks = supports_hyperlinks::supports_hyperlinks();
    debug!(?hyperlinks);

    let nixpkgs_path_output = nixpkgs_path.join().map_err(|e| {
      color_eyre::eyre::eyre!("nixpkgs_path thread panicked: {e:?}")
    })?;

    let nixpkgs_path_output =
      nixpkgs_path_output.context("Evaluating the nixpkgs path location")?;

    let nixpkgs_path = String::from_utf8(nixpkgs_path_output.stdout)
      .context("Converting nixpkgs_path to UTF-8")?;

    for elem in documents.iter().rev() {
      println!();
      trace!("{elem:#?}");

      print!("{}", Paint::new(&elem.package_attr_name).fg(Color::Blue));
      let v = &elem.package_pversion;
      if !v.is_empty() {
        print!(" ({})", Paint::new(v).fg(Color::Green));
      }

      println!();

      if let Some(ref desc) = elem.package_description {
        let desc = desc.replace('\n', " ");
        for line in textwrap::wrap(&desc, textwrap::Options::with_termwidth()) {
          println!("  {line}");
        }
      }

      for url in &elem.package_homepage {
        print!("  Homepage: ");
        if hyperlinks {
          print_hyperlink!(url, url);
        } else {
          println!("{url}");
        }
      }

      if self.platforms && !elem.package_platforms.is_empty() {
        println!("  Platforms: {}", elem.package_platforms.join(", "));
      }

      if let Some(position) = &elem.package_position {
        let position = position.split(':').next().unwrap();
        print!("  Defined at: ");
        if hyperlinks {
          let position_trimmed = position
            .split(':')
            .next()
            .expect("Removing line number from position");

          print_hyperlink!(
            position,
            format!("file://{nixpkgs_path}/{position_trimmed}")
          );
        } else {
          println!("{position}");
        }
      }
    }

    Ok(())
  }
}

fn supported_branch<S: AsRef<str>>(branch: S) -> bool {
  let branch = branch.as_ref();

  if branch == "nixos-unstable" {
    return true;
  }

  if DEPRECATED_VERSIONS.contains(&branch) {
    warn!("Channel {} is deprecated and not supported", branch);
    return false;
  }

  // Support for current version pattern
  static SUPPORTED_BRANCH_REGEX: OnceLock<Regex> = OnceLock::new();
  let re = SUPPORTED_BRANCH_REGEX.get_or_init(|| {
    Regex::new(r"^nixos-\d+\.\d+$").unwrap_or_else(|e| {
      warn!("invalid regex in supported_branch: {e}");
      Regex::new("$^").unwrap()
    })
  });
  re.is_match(branch)
}

#[test]
fn test_supported_branch() {
  assert!(supported_branch("nixos-unstable"));
  assert!(supported_branch("nixos-25.05"));
  assert!(!supported_branch("nixos-unstable-small"));
  assert!(!supported_branch("nixos-24.05"));
  assert!(!supported_branch("nixos-24.11"));
  assert!(!supported_branch("24.05"));
  assert!(!supported_branch("nixpkgs-darwin"));
  assert!(!supported_branch("nixpks-21.11-darwin"));
}
</file>

<file path="CHANGELOG.md">
<!-- markdownlint-disable no-duplicate-heading -->

# NH Changelog

<!--
This is the Nh changelog. It aims to describe changes that occurred within the
codebase, to the extent that concerns *both users and contributors*. If you are
a contributor, please add your changes under the "Unreleased" section as tags
will be created at the discretion of maintainers. If your changes fix an
existing bug, you must describe the new behaviour (ideally in comparison to the
old one) and put it under the "Fixed" subsection. Linking the relevant open
issue is not necessary, but good to have. Otherwise, general-purpose changes can
be put in the "Changed" section or, if it's just to remove code or
functionality, under the "Removed" section.
-->

## Unreleased

### Changed

- `nh os info` now support `--fields` to select which field(s) to display; also
  add a per-generation "Closure Size" coloumn.
  ([#375](https://github.com/nix-community/nh/issues/375))
- `nh os switch` and `nh os boot` now support the `--install-bootloader` flag,
  which will explicitly set `NIXOS_INSTALL_BOOTLOADER` for
  `switch-to-configuration`. Bootloader behaviour was previously supported by
  explicitly passing the variable to `nh` commands, which has now been made
  explicit through the `--install-bootloader` flag.
  ([#424](https://github.com/nix-community/nh/issues/424))
- A `--run` flag was added to `nh os build-vm`, which allows immediately
  starting a built VM after the build is complete. This can be chained with
  other `build-vm` flags such as `--with-bootloader`.
- Switched from owo-colors to Yansi as the internal coloring library. This
  should not affect end-users, but please create an issue if you notice anything
  different.

## 4.2.0

### Changed

- Nh checks are now more robust in the sense that unnecessary features will not
  be required when the underlying command does not depend on them.
- The `--update-input` flag now supports being specified multiple times.
- The `--update-input` flag no longer requires `--update` in order to take
  effect, and both flags are now considered mutually exclusive. If you specify
  the `--update` flag, all flake inputs will be updated. If you specify the
  `--update-input NAME` flag, only the specified flake(s) will be updated.
- `nh darwin switch` now shows the output from the `darwin-rebuild` activation.
  This allows you to see more details about the activation from `nix-darwin`, as
  well as `Home Manager`.
- `nvd` is replaced by `dix`, resulting in saner and faster diffing.
- Nh now supports a new `--diff` flag, which takes one of `auto` `always`
  `never` and toggles displaying the package diff after a build.
- Manpages have been added to nh, and will be available as `man 1 nh` if the
  package vendor provides them.
- `nh clean` will now skip directories that are checked and don't exist. Instead
  of throwing an error, it will print a warning about which directories were
  skipped.
- nh's verbosity flag can now be passed multiple times for more verbose debug
  output.
- `nh search` will now use the system trust store for it's HTTPS requests.
- Error handling has been improved across the board, with more contextful errors
  replacing direct error propagation or unwraps.
- The directory traversal during `nh clean` has been improved slightly and
  relevant bits of the clean module has been sped up.
  - It's roughly %4 faster according to testing, but IO is still a limiting
    factor and results may differ.
- Added more context to some minor debug messages across platform commands.
- Nh now supports alternative privilege escalation methods. Namely `doas`,
  `run0` and a fallback `pkexec` strategies will be attempted if the system does
  not use `sudo`.
- Nh will correctly prompt you for your `sudo` password while deploying
  remotely. This helps mitigate the need to allow password-less `sudo` on the
  target host to deploy remotely.

### Fixed

- Nh will now correctly detect non-semver version strings, such as `x.ygit`.
  Instead of failing the check, we now try to normalize the string and simply
  skip the check with a warning.
- In the case system switch is disabled (`system.switch enable = false;`) Nh
  will provide a more descriptive error message hinting at what might be the
  issue. ([#331](https://github.com/nix-community/nh/issues/331))
  - We cannot accurately guess what the issue is, but this should be more
    graceful than simply throwing an error about a missing path (what path?)
- Nh will now carefully pick environment variables passed to individual
  commands. This resolves the "`$HOME` is not owned by you!" error, but it's
  also a part of a larger refactor that involves only providing relevant
  variables to individual commands. This is an experimental change, please let
  us know if you face any new bugs.
  ([#314](https://github.com/nix-community/nh/issues/314))
- Fixed a tempdir race condition causing activation failures.
  [#386](https://github.com/nix-community/nh/pull/386)

## 4.1.2

### Changed

- The environment and Nix feature checks have been made more robust, which
  should allow false positives caused by the initial implementation
  - Version normalization for the Nix version is now much more robust. This gets
    rid of unexpected breakage when using, e.g., `pkgs.nixVersions.git`
- Support for additional Nix variants have been added. This allows for us to
  handle non-supported Nix variants gracefully, treating them as mainline Nix.
- Version check regex in checks module is now compiled only once, instead of in
  a loop.

## 4.1.1

### Changed

- Nh is now built on Cargo 2024 edition. This does not imply any changes for the
  users, but contributors might need to adapt.

- `nh os build` and `nh os build-vm` now default to placing the output at
  `./result` instead of a temp directory.

### Fixed

- The Elasticsearch backend version has been updated to v43, which fixes failing
  search commands ([#316](https://github.com/nix-community/nh/pull/316))

## 4.1.0

### Added

- A new `nh os rollback` subcommand has been added to allow rolling back a
  generation, or to a specific generation with the `--to` flag. See
  `nh os rollback --help` for more details on this subcommand.

- Nh now supports the `--build-host` and `--target-host` cli arguments

- Nh now checks if the current Nix implementation has necessary experimental
  features enabled. In mainline Nix (CppNix, etc.) we check for `nix-command`
  and `flakes` being set. In Lix, we also use `repl-flake` as it is still
  provided as an experimental feature in versions below 2.93.0.

- Nh will now check if you are using the latest stable, or "recommended,"
  version of Nix (or Lix.) This check has been placed to make it clear we do not
  support legacy/vulnerable versions of Nix, and encourage users to update if
  they have not yet done so.

- NixOS: Nh now accepts the subcommand `nh os build-vm`, which builds a virtual
  machine image activation script instead of a full system. This includes a new
  option `--with-bootloader/-B` that applies to just build-vm, to build a VM
  with a bootloader.

### Changed

- Darwin: Use `darwin-rebuild` directly for activation instead of old scripts
- Darwin: Future-proof handling of `activate-user` script removal
- Darwin: Improve compatibility with root-only activation in newer nix-darwin
  versions
- NixOS: Check if the target hostname matches the running system hostname before
  running `nvd` to compare them.

## 4.0.3

### Added

- Nh now supports specifying `NH_SUDO_ASKPASS` to pass a custom value to
  `SUDO_ASKPASS` in self-elevation. If specified, `sudo` will be called with
  `-A` and the `NH_SUDO_ASKPASS` will be `SUDO_ASKPASS` locally.

### Fixed

- Fix `--configuration` being ignored in `nh home switch`
  ([#262](https://github.com/nix-community/nh/issues/262))

## 4.0.2

### Added

- Add `--json` to `nh search`, which will return results in JSON format. Useful
  for parsing the output of `nh search` with, e.g., jq.

## 4.0.1

### Removed

- NixOS 24.05 is now marked as deprecated, and will emit an error if the search
  command attempts to use it for the channel. While the Elasticsearch backend
  still seems to support 24.05, it is deprecated in Nixpkgs and is actively
  discouraged. Please update your system at your earliest convenience.
</file>

<file path="src/commands.rs">
use std::{
  collections::HashMap,
  ffi::{OsStr, OsString},
  path::PathBuf,
  sync::{Mutex, OnceLock},
};

use color_eyre::{
  Result,
  eyre::{self, Context, bail},
};
use secrecy::{ExposeSecret, SecretString};
use subprocess::{Exec, ExitStatus, Redirection};
use thiserror::Error;
use tracing::{debug, info, warn};
use which::which;

use crate::{installable::Installable, interface::NixBuildPassthroughArgs};

static PASSWORD_CACHE: OnceLock<Mutex<HashMap<String, SecretString>>> =
  OnceLock::new();

fn get_cached_password(host: &str) -> Option<SecretString> {
  let cache = PASSWORD_CACHE.get_or_init(|| Mutex::new(HashMap::new()));
  let guard = cache
    .lock()
    .unwrap_or_else(std::sync::PoisonError::into_inner);
  guard.get(host).cloned()
}

fn cache_password(host: &str, password: SecretString) {
  let cache = PASSWORD_CACHE.get_or_init(|| Mutex::new(HashMap::new()));
  let mut guard = cache
    .lock()
    .unwrap_or_else(std::sync::PoisonError::into_inner);
  guard.insert(host.to_string(), password);
}

fn ssh_wrap(
  cmd: Exec,
  ssh: Option<&str>,
  password: Option<&SecretString>,
) -> Exec {
  if let Some(ssh) = ssh {
    let mut ssh_cmd = Exec::cmd("ssh")
      .arg("-T")
      .arg(ssh)
      .arg(cmd.to_cmdline_lossy());

    if let Some(pwd) = password {
      ssh_cmd = ssh_cmd.stdin(format!("{}\n", pwd.expose_secret()).as_str());
    }

    ssh_cmd
  } else {
    cmd
  }
}

#[allow(dead_code)] // shut up
#[derive(Debug, Clone)]
pub enum EnvAction {
  /// Set an environment variable to a specific value
  Set(String),

  /// Preserve an environment variable from the current environment
  Preserve,

  /// Remove/unset an environment variable
  Remove,
}

/// Strategy for choosing a privilege elevation program.
/// - `Auto`: try supported programs in fallback order.
/// - `Prefer(PathBuf)`: try the specified program, then fallback.
/// - `Force(&'static str)`: use only the specified program, error if not
///   available.
#[allow(dead_code)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ElevationStrategy {
  Auto,
  Prefer(PathBuf),
  Force(&'static str),
}

impl ElevationStrategy {
  pub fn resolve(&self) -> Result<PathBuf> {
    match self {
      ElevationStrategy::Auto => Self::choice(),
      ElevationStrategy::Prefer(program) => {
        which(program).or_else(|_| {
          let auto = Self::choice()?;
          warn!(
            "{} not found. Using {} instead",
            program.to_string_lossy(),
            auto.to_string_lossy()
          );
          Ok(auto)
        })
      },
      ElevationStrategy::Force(program) => Ok(program.into()),
    }
  }

  /// Gets a path to a privilege elevation program based on what is available in
  /// the system.
  ///
  /// This funtion checks for the existence of common privilege elevation
  /// program names in the `PATH` using the `which` crate and returns a Ok
  /// result with the `OsString` of the path to the binary. In the case none
  /// of the checked programs are found a Err result is returned.
  ///
  /// The search is done in this order:
  ///
  /// 1. `doas`
  /// 2. `sudo`
  /// 3. `run0`
  /// 4. `pkexec`
  ///
  /// The logic for choosing this order is that a person with `doas` installed
  /// is more likely to be using it as their main privilege elevation program.
  /// `run0` and `pkexec` are preinstalled in any `NixOS` system with polkit
  /// support installed, so they have been placed lower as it's easier to
  /// deactivate sudo than it is to remove `run0`/`pkexec`
  ///
  /// # Returns
  ///
  /// * `Result<PathBuf>` - The absolute path to the privilege elevation program
  ///   binary or an error if a program can't be found.
  fn choice() -> Result<PathBuf> {
    const STRATEGIES: [&str; 4] = ["doas", "sudo", "run0", "pkexec"];

    for strategy in STRATEGIES {
      if let Ok(path) = which(strategy) {
        debug!(?path, "{strategy} path found");
        return Ok(path);
      }
    }

    Err(eyre::eyre!(
      "No elevation strategy found. Checked: {}",
      STRATEGIES.join(", ")
    ))
  }
}

#[derive(Debug)]
pub struct Command {
  dry:         bool,
  message:     Option<String>,
  command:     OsString,
  args:        Vec<OsString>,
  elevate:     Option<ElevationStrategy>,
  ssh:         Option<String>,
  show_output: bool,
  env_vars:    HashMap<String, EnvAction>,
}

impl Command {
  pub fn new<S: AsRef<OsStr>>(command: S) -> Self {
    Self {
      dry:         false,
      message:     None,
      command:     command.as_ref().to_os_string(),
      args:        vec![],
      elevate:     None,
      ssh:         None,
      show_output: false,
      env_vars:    HashMap::new(),
    }
  }

  /// Set whether to run the command with elevated privileges.
  #[must_use]
  pub fn elevate(mut self, elevate: Option<ElevationStrategy>) -> Self {
    self.elevate = elevate;
    self
  }

  /// Set whether to perform a dry run.
  #[must_use]
  pub fn dry(mut self, dry: bool) -> Self {
    self.dry = dry;
    self
  }

  /// Set whether to show command output.
  #[must_use]
  pub fn show_output(mut self, show_output: bool) -> Self {
    self.show_output = show_output;
    self
  }

  /// Set the SSH target for remote command execution.
  #[must_use]
  pub fn ssh(mut self, ssh: Option<String>) -> Self {
    self.ssh = ssh;
    self
  }

  /// Add a single argument to the command.
  #[must_use]
  pub fn arg<S: AsRef<OsStr>>(mut self, arg: S) -> Self {
    self.args.push(arg.as_ref().to_os_string());
    self
  }

  /// Add multiple arguments to the command.
  #[must_use]
  pub fn args<I>(mut self, args: I) -> Self
  where
    I: IntoIterator,
    I::Item: AsRef<OsStr>,
  {
    for elem in args {
      self.args.push(elem.as_ref().to_os_string());
    }
    self
  }

  /// Set a message to display before running the command.
  #[must_use]
  pub fn message<S: AsRef<str>>(mut self, message: S) -> Self {
    self.message = Some(message.as_ref().to_string());
    self
  }

  /// Preserve multiple environment variables from the current environment
  #[must_use]
  pub fn preserve_envs<I, K>(mut self, keys: I) -> Self
  where
    I: IntoIterator<Item = K>,
    K: AsRef<str>,
  {
    for key in keys {
      let key_str = key.as_ref().to_string();
      self.env_vars.insert(key_str, EnvAction::Preserve);
    }
    self
  }

  /// Set an environment variable to a specific value
  #[must_use]
  pub fn set_env<K, V>(mut self, key: K, value: V) -> Self
  where
    K: AsRef<str>,
    V: AsRef<str>,
  {
    self.env_vars.insert(
      key.as_ref().to_string(),
      EnvAction::Set(value.as_ref().to_string()),
    );
    self
  }

  /// Configure environment for Nix and NH operations
  #[must_use]
  pub fn with_required_env(mut self) -> Self {
    // Centralized list of environment variables to preserve
    // This is not a part of Nix's environment, but it might be necessary.
    // nixos-rebuild preserves it, so we do too.
    const PRESERVE_ENV: &[&str] = &[
      "LOCALE_ARCHIVE",
      // PATH needs to be preserved so that NH can invoke CLI utilities.
      "PATH",
      // Make sure NIX_SSHOPTS applies to nix commands that invoke ssh, such as
      // `nix copy`
      "NIX_SSHOPTS",
      // This is relevant for Home-Manager systems
      "HOME_MANAGER_BACKUP_EXT",
      // Preserve other Nix-related environment variables
      // TODO: is this everything we need? Previously we only preserved *some*
      // variables and nh continued to work, but any missing vars might
      // break functionality completely unexpectedly. This list could
      // change at any moment. This better be enough. Ugh.
      "NIX_CONFIG",
      "NIX_PATH",
      "NIX_REMOTE",
      "NIX_SSL_CERT_FILE",
      "NIX_USER_CONF_FILES",
    ];

    // Always explicitly set USER if present
    if let Ok(user) = std::env::var("USER") {
      self
        .env_vars
        .insert("USER".to_string(), EnvAction::Set(user));
    }

    // Only propagate HOME for non-elevated commands
    if self.elevate.is_none() {
      if let Ok(home) = std::env::var("HOME") {
        self
          .env_vars
          .insert("HOME".to_string(), EnvAction::Set(home));
      }
    }

    // Preserve all variables in PRESERVE_ENV if present
    for &key in PRESERVE_ENV {
      if std::env::var(key).is_ok() {
        self.env_vars.insert(key.to_string(), EnvAction::Preserve);
      }
    }

    // Explicitly set NH_* variables
    for (key, value) in std::env::vars() {
      if key.starts_with("NH_") {
        self.env_vars.insert(key, EnvAction::Set(value));
      }
    }

    debug!(
      "Configured envs: {}",
      self
        .env_vars
        .iter()
        .map(|(key, action)| {
          match action {
            EnvAction::Set(value) => format!("{key}={value}"),
            EnvAction::Preserve => format!("{key}=<preserved>"),
            EnvAction::Remove => format!("{key}=<removed>"),
          }
        })
        .collect::<Vec<_>>()
        .join(", ")
    );

    self
  }

  fn apply_env_to_exec(&self, mut cmd: Exec) -> Exec {
    for (key, action) in &self.env_vars {
      match action {
        EnvAction::Set(value) => {
          cmd = cmd.env(key, value);
        },
        EnvAction::Preserve => {
          // Only preserve if present in current environment
          if let Ok(value) = std::env::var(key) {
            cmd = cmd.env(key, value);
          }
        },
        EnvAction::Remove => {
          // For remove, we'll handle this in the sudo construction
          // by not including it in preserved variables
        },
      }
    }
    cmd
  }

  /// Creates a Exec that contains elevates the program with proper environment
  /// handling.
  ///
  /// Panics: If called when `self.elevate` is `None`
  fn build_sudo_cmd(&self) -> Result<Exec> {
    let elevation_program = self
      .elevate
      .as_ref()
      .ok_or_else(|| eyre::eyre!("Command not found for elevation"))?
      .resolve()
      .context("Failed to resolve elevation program")?;

    let mut cmd = Exec::cmd(&elevation_program);

    // Use NH_SUDO_ASKPASS program for sudo if present
    let program_name = elevation_program
      .file_name()
      .and_then(|name| name.to_str())
      .ok_or_else(|| {
        eyre::eyre!("Failed to determine elevation program name")
      })?;
    if program_name == "sudo" {
      if let Ok(askpass) = std::env::var("NH_SUDO_ASKPASS") {
        cmd = cmd.env("SUDO_ASKPASS", askpass).arg("-A");
      }
    }

    // NH_PRESERVE_ENV: set to "0" to disable preserving environment variables,
    // "1" to force, unset defaults to force
    let preserve_env = std::env::var("NH_PRESERVE_ENV")
      .as_deref()
      .map(|x| !matches!(x, "0"))
      .unwrap_or(true);

    // Insert 'env' command to explicitly pass environment variables to the
    // elevated command
    cmd = cmd.arg("env");
    for arg in self.env_vars.iter().filter_map(|(key, action)| {
      match action {
        EnvAction::Set(value) => Some(format!("{key}={value}")),
        EnvAction::Preserve if preserve_env => {
          match std::env::var(key) {
            Ok(value) => Some(format!("{key}={value}")),
            Err(_) => None,
          }
        },
        _ => None,
      }
    }) {
      cmd = cmd.arg(arg);
    }

    Ok(cmd)
  }

  /// Create a sudo command for self-elevation with proper environment handling
  ///
  /// # Errors
  ///
  /// Returns an error if the current executable path cannot be determined or
  /// sudo command cannot be built.
  pub fn self_elevate_cmd(
    strategy: ElevationStrategy,
  ) -> Result<std::process::Command> {
    // Get the current executable path
    let current_exe = std::env::current_exe()
      .context("Failed to get current executable path")?;

    // Self-elevation with proper environment handling
    let cmd_builder = Self::new(&current_exe)
      .elevate(Some(strategy))
      .with_required_env();

    let sudo_exec = cmd_builder.build_sudo_cmd()?;

    // Add the target executable and arguments to the sudo command
    let exec_with_args = sudo_exec.arg(&current_exe);
    let args: Vec<String> = std::env::args().skip(1).collect();
    let final_exec = exec_with_args.args(&args);

    // Convert Exec to std::process::Command by parsing the command line
    let cmdline = final_exec.to_cmdline_lossy();
    let parts: Vec<&str> = cmdline.split_whitespace().collect();

    if parts.is_empty() {
      bail!("Failed to build sudo command");
    }

    let mut std_cmd = std::process::Command::new(parts[0]);
    if parts.len() > 1 {
      std_cmd.args(&parts[1..]);
    }

    Ok(std_cmd)
  }

  /// Run the configured command.
  ///
  /// # Errors
  ///
  /// Returns an error if the command fails to execute or returns a non-zero
  /// exit status.
  ///
  /// # Panics
  ///
  /// Panics if the command result is unexpectedly None.
  pub fn run(&self) -> Result<()> {
    // Prompt for sudo password if needed for remote deployment
    // FIXME: this implementation only covers Sudo. I *think* doas and run0 are
    // able to read from stdin, but needs to be tested and possibly
    // mitigated.
    let sudo_password = if self.ssh.is_some() && self.elevate.is_some() {
      let host = self.ssh.as_ref().unwrap();
      if let Some(cached_password) = get_cached_password(host) {
        Some(cached_password)
      } else {
        let password =
          inquire::Password::new(&format!("[sudo] password for {host}:"))
            .without_confirmation()
            .prompt()
            .context("Failed to read sudo password")?;
        let secret_password = SecretString::new(password.into());
        cache_password(host, secret_password.clone());
        Some(secret_password)
      }
    } else {
      None
    };

    let cmd = if self.elevate.is_some() && self.ssh.is_none() {
      // Local elevation
      self.build_sudo_cmd()?.arg(&self.command).args(&self.args)
    } else if self.elevate.is_some() && self.ssh.is_some() {
      // Build elevation command
      let elevation_program = self
        .elevate
        .as_ref()
        .unwrap()
        .resolve()
        .context("Failed to resolve elevation program")?;

      let program_name = elevation_program
        .file_name()
        .and_then(|name| name.to_str())
        .ok_or_else(|| {
          eyre::eyre!("Failed to determine elevation program name")
        })?;

      let mut elev_cmd = Exec::cmd(&elevation_program);

      // Add program-specific arguments
      if program_name == "sudo" {
        elev_cmd = elev_cmd.arg("--prompt=").arg("--stdin");
      }

      // Add env command to handle environment variables
      elev_cmd = elev_cmd.arg("env");
      for (key, action) in &self.env_vars {
        match action {
          EnvAction::Set(value) => {
            elev_cmd = elev_cmd.arg(format!("{key}={value}"));
          },
          EnvAction::Preserve => {
            if let Ok(value) = std::env::var(key) {
              elev_cmd = elev_cmd.arg(format!("{key}={value}"));
            }
          },
          _ => {},
        }
      }

      elev_cmd.arg(&self.command).args(&self.args)
    } else {
      // No elevation
      self.apply_env_to_exec(Exec::cmd(&self.command).args(&self.args))
    };

    // Configure output redirection based on show_output setting
    let cmd = ssh_wrap(
      if self.show_output {
        cmd.stderr(Redirection::Merge)
      } else {
        cmd.stderr(Redirection::None).stdout(Redirection::None)
      },
      self.ssh.as_deref(),
      sudo_password.as_ref(),
    );

    if let Some(m) = &self.message {
      info!("{m}");
    }

    debug!(?cmd);

    if self.dry {
      return Ok(());
    }

    let msg = self
      .message
      .clone()
      .unwrap_or_else(|| "Command failed".to_string());
    let res = cmd.capture();
    match res {
      Ok(capture) => {
        let status = &capture.exit_status;
        if !status.success() {
          let stderr = capture.stderr_str();
          if stderr.trim().is_empty() {
            return Err(eyre::eyre!(format!(
              "{} (exit status {:?})",
              msg, status
            )));
          }
          return Err(eyre::eyre!(format!(
            "{} (exit status {:?})\nstderr:\n{}",
            msg, status, stderr
          )));
        }
        Ok(())
      },
      Err(e) => Err(e).wrap_err(msg),
    }
  }

  /// Run the configured command and capture its output.
  ///
  /// # Errors
  ///
  /// Returns an error if the command fails to execute.
  pub fn run_capture(&self) -> Result<Option<String>> {
    let cmd = self.apply_env_to_exec(
      Exec::cmd(&self.command)
        .args(&self.args)
        .stderr(Redirection::None)
        .stdout(Redirection::Pipe),
    );

    if let Some(m) = &self.message {
      info!("{m}");
    }

    debug!(?cmd);

    if self.dry {
      return Ok(None);
    }
    Ok(Some(cmd.capture()?.stdout_str()))
  }
}

#[derive(Debug)]
pub struct Build {
  message:     Option<String>,
  installable: Installable,
  extra_args:  Vec<OsString>,
  nom:         bool,
  builder:     Option<String>,
}

impl Build {
  #[must_use]
  pub const fn new(installable: Installable) -> Self {
    Self {
      message: None,
      installable,
      extra_args: vec![],
      nom: false,
      builder: None,
    }
  }

  #[must_use]
  pub fn message<S: AsRef<str>>(mut self, message: S) -> Self {
    self.message = Some(message.as_ref().to_string());
    self
  }

  #[must_use]
  pub fn extra_arg<S: AsRef<OsStr>>(mut self, arg: S) -> Self {
    self.extra_args.push(arg.as_ref().to_os_string());
    self
  }

  #[must_use]
  pub const fn nom(mut self, yes: bool) -> Self {
    self.nom = yes;
    self
  }

  #[must_use]
  pub fn builder(mut self, builder: Option<String>) -> Self {
    self.builder = builder;
    self
  }

  #[must_use]
  pub fn extra_args<I>(mut self, args: I) -> Self
  where
    I: IntoIterator,
    I::Item: AsRef<OsStr>,
  {
    for elem in args {
      self.extra_args.push(elem.as_ref().to_os_string());
    }
    self
  }

  #[must_use]
  pub fn passthrough(self, passthrough: &NixBuildPassthroughArgs) -> Self {
    self.extra_args(passthrough.generate_passthrough_args())
  }

  /// Run the build command.
  ///
  /// # Errors
  ///
  /// Returns an error if the build command fails to execute.
  pub fn run(&self) -> Result<()> {
    if let Some(m) = &self.message {
      info!("{m}");
    }

    let installable_args = self.installable.to_args();

    let base_command = Exec::cmd("nix")
      .arg("build")
      .args(&installable_args)
      .args(&match &self.builder {
        Some(host) => {
          vec!["--builders".to_string(), format!("ssh://{host} - - - 100")]
        },
        None => vec![],
      })
      .args(&self.extra_args);

    let exit = if self.nom {
      let cmd = {
        base_command
          .args(&["--log-format", "internal-json", "--verbose"])
          .stderr(Redirection::Merge)
          .stdout(Redirection::Pipe)
          | Exec::cmd("nom").args(&["--json"])
      }
      .stdout(Redirection::None);
      debug!(?cmd);
      cmd.join()
    } else {
      let cmd = base_command
        .stderr(Redirection::Merge)
        .stdout(Redirection::None);

      debug!(?cmd);
      cmd.join()
    };

    match exit? {
      ExitStatus::Exited(0) => (),
      other => bail!(ExitError(other)),
    }

    Ok(())
  }
}

#[derive(Debug, Error)]
#[error("Command exited with status {0:?}")]
pub struct ExitError(ExitStatus);

#[cfg(test)]
mod tests {
  use std::{env, ffi::OsString};

  use serial_test::serial;

  use super::*;

  // Safely manage environment variables in tests
  struct EnvGuard {
    key:      String,
    original: Option<String>,
  }

  impl EnvGuard {
    fn new(key: &str, value: &str) -> Self {
      let original = env::var(key).ok();
      unsafe {
        env::set_var(key, value);
      }
      EnvGuard {
        key: key.to_string(),
        original,
      }
    }
  }

  impl Drop for EnvGuard {
    fn drop(&mut self) {
      unsafe {
        match &self.original {
          Some(val) => env::set_var(&self.key, val),
          None => env::remove_var(&self.key),
        }
      }
    }
  }

  #[test]
  fn test_env_action_variants() {
    // Test that all EnvAction variants are correctly created
    let set_action = EnvAction::Set("test_value".to_string());
    let preserve_action = EnvAction::Preserve;
    let remove_action = EnvAction::Remove;

    match set_action {
      EnvAction::Set(val) => assert_eq!(val, "test_value"),
      _ => panic!("Expected Set variant"),
    }

    assert!(matches!(preserve_action, EnvAction::Preserve));
    assert!(matches!(remove_action, EnvAction::Remove));
  }

  #[test]
  fn test_command_new() {
    let cmd = Command::new("test-command");

    assert_eq!(cmd.command, OsString::from("test-command"));
    assert!(!cmd.dry);
    assert!(cmd.message.is_none());
    assert!(cmd.args.is_empty());
    assert!(cmd.elevate.is_none());
    assert!(cmd.ssh.is_none());
    assert!(!cmd.show_output);
    assert!(cmd.env_vars.is_empty());
  }

  #[test]
  fn test_command_builder_pattern() {
    let cmd = Command::new("test")
      .dry(true)
      .show_output(true)
      .elevate(Some(ElevationStrategy::Force("sudo")))
      .ssh(Some("host".to_string()))
      .message("test message")
      .arg("arg1")
      .args(["arg2", "arg3"]);

    assert!(cmd.dry);
    assert!(cmd.show_output);
    assert_eq!(cmd.elevate, Some(ElevationStrategy::Force("sudo")));
    assert_eq!(cmd.ssh, Some("host".to_string()));
    assert_eq!(cmd.message, Some("test message".to_string()));
    assert_eq!(cmd.args, vec![
      OsString::from("arg1"),
      OsString::from("arg2"),
      OsString::from("arg3")
    ]);
  }

  #[test]
  fn test_preserve_envs() {
    let cmd = Command::new("test").preserve_envs(["VAR1", "VAR2", "VAR3"]);

    assert_eq!(cmd.env_vars.len(), 3);
    assert!(matches!(
      cmd.env_vars.get("VAR1"),
      Some(EnvAction::Preserve)
    ));
    assert!(matches!(
      cmd.env_vars.get("VAR2"),
      Some(EnvAction::Preserve)
    ));
    assert!(matches!(
      cmd.env_vars.get("VAR3"),
      Some(EnvAction::Preserve)
    ));
  }

  #[test]
  #[serial]
  fn test_with_required_env_home_user() {
    let _home_guard = EnvGuard::new("HOME", "/test/home");
    let _user_guard = EnvGuard::new("USER", "testuser");

    let cmd = Command::new("test").with_required_env();

    // Should preserve HOME and USER as Set actions
    assert!(
      matches!(cmd.env_vars.get("HOME"), Some(EnvAction::Set(val)) if val == "/test/home")
    );
    assert!(
      matches!(cmd.env_vars.get("USER"), Some(EnvAction::Set(val)) if val == "testuser")
    );

    // Should preserve all Nix-related variables if present
    for key in [
      "PATH",
      "NIX_CONFIG",
      "NIX_PATH",
      "NIX_REMOTE",
      "NIX_SSHOPTS",
      "NIX_SSL_CERT_FILE",
      "NIX_USER_CONF_FILES",
      "LOCALE_ARCHIVE",
      "HOME_MANAGER_BACKUP_EXT",
    ] {
      if cmd.env_vars.contains_key(key) {
        assert!(matches!(cmd.env_vars.get(key), Some(EnvAction::Preserve)));
      }
    }
  }

  #[test]
  #[serial]
  fn test_with_required_env_missing_home_user() {
    // Test behavior when HOME/USER are not set
    unsafe {
      env::remove_var("HOME");
      env::remove_var("USER");
    }

    let cmd = Command::new("test").with_required_env();

    // Should not have HOME or USER in env_vars if they're not set
    assert!(!cmd.env_vars.contains_key("HOME"));
    assert!(!cmd.env_vars.contains_key("USER"));

    // Should preserve Nix-related variables if present
    for key in [
      "PATH",
      "NIX_CONFIG",
      "NIX_PATH",
      "NIX_REMOTE",
      "NIX_SSHOPTS",
      "NIX_SSL_CERT_FILE",
      "NIX_USER_CONF_FILES",
      "LOCALE_ARCHIVE",
      "HOME_MANAGER_BACKUP_EXT",
    ] {
      if let Some(action) = cmd.env_vars.get(key) {
        assert!(matches!(action, EnvAction::Preserve));
      }
    }
  }

  #[test]
  #[serial]
  fn test_with_required_env_nh_vars() {
    let _guard1 = EnvGuard::new("NH_TEST_VAR", "test_value");
    let _guard2 = EnvGuard::new("NH_ANOTHER_VAR", "another_value");
    let _guard3 = EnvGuard::new("NOT_NH_VAR", "should_not_be_included");

    let cmd = Command::new("test").with_required_env();

    // Should include NH_* variables as Set actions
    assert!(
      matches!(cmd.env_vars.get("NH_TEST_VAR"), Some(EnvAction::Set(val)) if val == "test_value")
    );
    assert!(
      matches!(cmd.env_vars.get("NH_ANOTHER_VAR"), Some(EnvAction::Set(val)) if val == "another_value")
    );

    // Should not include non-NH variables
    assert!(!cmd.env_vars.contains_key("NOT_NH_VAR"));
  }

  #[test]
  #[serial]
  fn test_combined_env_methods() {
    let _home_guard = EnvGuard::new("HOME", "/test/home");
    let _nh_guard = EnvGuard::new("NH_TEST", "nh_value");

    let cmd = Command::new("test")
      .with_required_env()
      .preserve_envs(["EXTRA_VAR"]);

    // Should have HOME from with_nix_env
    assert!(
      matches!(cmd.env_vars.get("HOME"), Some(EnvAction::Set(val)) if val == "/test/home")
    );

    // Should have NH variables from with_nh_env
    assert!(
      matches!(cmd.env_vars.get("NH_TEST"), Some(EnvAction::Set(val)) if val == "nh_value")
    );

    // Should have Nix variables preserved
    assert!(matches!(
      cmd.env_vars.get("PATH"),
      Some(EnvAction::Preserve)
    ));

    // Should have extra preserved variable
    assert!(matches!(
      cmd.env_vars.get("EXTRA_VAR"),
      Some(EnvAction::Preserve)
    ));
  }

  #[test]
  fn test_env_vars_override_behavior() {
    let mut cmd = Command::new("test");

    // First add a variable as Preserve
    cmd
      .env_vars
      .insert("TEST_VAR".to_string(), EnvAction::Preserve);
    assert!(matches!(
      cmd.env_vars.get("TEST_VAR"),
      Some(EnvAction::Preserve)
    ));

    // Then override it as Set
    cmd.env_vars.insert(
      "TEST_VAR".to_string(),
      EnvAction::Set("new_value".to_string()),
    );
    assert!(
      matches!(cmd.env_vars.get("TEST_VAR"), Some(EnvAction::Set(val)) if val == "new_value")
    );
  }

  #[test]
  fn test_build_sudo_cmd_basic() {
    let cmd =
      Command::new("test").elevate(Some(ElevationStrategy::Force("sudo")));
    let sudo_exec = cmd.build_sudo_cmd().unwrap();

    // Platform-agnostic: 'sudo' may not be the first token if env vars are
    // injected (e.g., NH_SUDO_ASKPASS). Accept any command line where
    // 'sudo' is present as a token.
    let cmdline = sudo_exec.to_cmdline_lossy();
    assert!(cmdline.split_whitespace().any(|tok| tok == "sudo"));
  }

  #[test]
  #[serial]
  fn test_build_sudo_cmd_with_preserve_vars() {
    let _preserve_env_guard = EnvGuard::new("NH_PRESERVE_ENV", "1");
    let _var1_guard = EnvGuard::new("VAR1", "1");
    let _var2_guard = EnvGuard::new("VAR2", "2");

    let cmd = Command::new("test")
      .preserve_envs(["VAR1", "VAR2"])
      .elevate(Some(ElevationStrategy::Force("sudo")));

    let sudo_exec = cmd.build_sudo_cmd().unwrap();
    let cmdline = sudo_exec.to_cmdline_lossy();

    assert!(cmdline.contains("env"));
    assert!(cmdline.contains("VAR1=1"));
    assert!(cmdline.contains("VAR2=2"));
  }

  #[test]
  #[serial]
  fn test_build_sudo_cmd_with_disabled_preserve_vars() {
    let _preserve_env_guard = EnvGuard::new("NH_PRESERVE_ENV", "0");
    let _var1_guard = EnvGuard::new("VAR1", "1");
    let _var2_guard = EnvGuard::new("VAR2", "2");

    let cmd = Command::new("test")
      .preserve_envs(["VAR1", "VAR2"])
      .elevate(Some(ElevationStrategy::Force("sudo")));

    let sudo_exec = cmd.build_sudo_cmd().unwrap();
    let cmdline = sudo_exec.to_cmdline_lossy();

    assert!(cmdline.contains("env"));
    assert!(!cmdline.contains("VAR1=1"));
    assert!(!cmdline.contains("VAR2=2"));
  }

  #[test]
  #[serial]
  fn test_build_sudo_cmd_with_set_vars() {
    let mut cmd =
      Command::new("test").elevate(Some(ElevationStrategy::Force("sudo")));
    cmd.env_vars.insert(
      "TEST_VAR".to_string(),
      EnvAction::Set("test_value".to_string()),
    );

    let sudo_exec = cmd.build_sudo_cmd().unwrap();
    let cmdline = sudo_exec.to_cmdline_lossy();

    // Should contain env command with variable
    assert!(cmdline.contains("env"));
    assert!(cmdline.contains("TEST_VAR=test_value"));
  }

  #[test]
  #[serial]
  fn test_build_sudo_cmd_with_remove_vars() {
    let _preserve_guard = EnvGuard::new("VAR_TO_PRESERVE", "preserve");
    let _remove_guard = EnvGuard::new("VAR_TO_REMOVE", "remove");

    let mut cmd =
      Command::new("test").elevate(Some(ElevationStrategy::Force("sudo")));
    cmd
      .env_vars
      .insert("VAR_TO_PRESERVE".to_string(), EnvAction::Preserve);
    cmd
      .env_vars
      .insert("VAR_TO_REMOVE".to_string(), EnvAction::Remove);

    let sudo_exec = cmd.build_sudo_cmd().unwrap();
    let cmdline = sudo_exec.to_cmdline_lossy();

    assert!(cmdline.contains("env"));
    assert!(cmdline.contains("VAR_TO_PRESERVE=preserve"));
    assert!(!cmdline.contains("VAR_TO_REMOVE"));
  }

  #[test]
  #[serial]
  fn test_build_sudo_cmd_with_askpass() {
    let _guard = EnvGuard::new("NH_SUDO_ASKPASS", "/path/to/askpass");

    let cmd =
      Command::new("test").elevate(Some(ElevationStrategy::Force("sudo")));
    let sudo_exec = cmd.build_sudo_cmd().unwrap();
    let cmdline = sudo_exec.to_cmdline_lossy();

    // Should contain -A flag for askpass
    assert!(cmdline.contains("-A"));
  }

  #[test]
  #[serial]
  fn test_build_sudo_cmd_env_added_once() {
    let _preserve_guard = EnvGuard::new("PRESERVE_VAR", "preserve");

    let mut cmd =
      Command::new("test").elevate(Some(ElevationStrategy::Force("sudo")));
    cmd.env_vars.insert(
      "TEST_VAR1".to_string(),
      EnvAction::Set("value1".to_string()),
    );
    cmd.env_vars.insert(
      "TEST_VAR2".to_string(),
      EnvAction::Set("value2".to_string()),
    );
    cmd
      .env_vars
      .insert("PRESERVE_VAR".to_string(), EnvAction::Preserve);

    let sudo_exec = cmd.build_sudo_cmd().unwrap();
    let cmdline = sudo_exec.to_cmdline_lossy();

    // Count occurrences of "env" in the command line
    let env_count = cmdline.matches(" env ").count()
      + usize::from(cmdline.starts_with("env "))
      + usize::from(cmdline.ends_with(" env"));

    // Should contain env command exactly once when there are explicit
    // environment variables
    assert_eq!(
      env_count, 1,
      "env command should appear exactly once in: {cmdline}"
    );

    // Should contain our explicit environment variables
    assert!(cmdline.contains("TEST_VAR1=value1"));
    assert!(cmdline.contains("TEST_VAR2=value2"));
    // and the preserved too
    assert!(cmdline.contains("PRESERVE_VAR=preserve"));
  }

  #[test]
  fn test_build_new() {
    let installable = Installable::Flake {
      reference: "github:user/repo".to_string(),
      attribute: vec!["package".to_string()],
    };

    let build = Build::new(installable.clone());

    assert!(build.message.is_none());
    assert_eq!(build.installable.to_args(), installable.to_args());
    assert!(build.extra_args.is_empty());
    assert!(!build.nom);
    assert!(build.builder.is_none());
  }

  #[test]
  fn test_build_builder_pattern() {
    let installable = Installable::Flake {
      reference: "github:user/repo".to_string(),
      attribute: vec!["package".to_string()],
    };

    let build = Build::new(installable)
      .message("Building package")
      .extra_arg("--verbose")
      .extra_args(["--option", "setting", "value"])
      .nom(true)
      .builder(Some("build-host".to_string()));

    assert_eq!(build.message, Some("Building package".to_string()));
    assert_eq!(build.extra_args, vec![
      OsString::from("--verbose"),
      OsString::from("--option"),
      OsString::from("setting"),
      OsString::from("value")
    ]);
    assert!(build.nom);
    assert_eq!(build.builder, Some("build-host".to_string()));
  }

  #[test]
  fn test_ssh_wrap_with_ssh() {
    let cmd = subprocess::Exec::cmd("echo").arg("hello");
    let wrapped = ssh_wrap(cmd, Some("user@host"), None);

    let cmdline = wrapped.to_cmdline_lossy();
    assert!(cmdline.starts_with("ssh"));
    assert!(cmdline.contains("-T"));
    assert!(cmdline.contains("user@host"));
  }

  #[test]
  fn test_ssh_wrap_without_ssh() {
    let cmd = subprocess::Exec::cmd("echo").arg("hello");
    let wrapped = ssh_wrap(cmd.clone(), None, None);

    // Should return the original command unchanged
    assert_eq!(wrapped.to_cmdline_lossy(), cmd.to_cmdline_lossy());
  }

  #[test]
  fn test_ssh_wrap_with_password() {
    let cmd = subprocess::Exec::cmd("echo").arg("hello");
    let password = SecretString::new("testpass".into());
    let wrapped = ssh_wrap(cmd, Some("user@host"), Some(&password));

    let cmdline = wrapped.to_cmdline_lossy();
    assert!(cmdline.starts_with("ssh"));
    assert!(cmdline.contains("-T"));
    assert!(cmdline.contains("user@host"));
  }

  #[test]
  #[serial]
  fn test_apply_env_to_exec() {
    let _guard = EnvGuard::new("EXISTING_VAR", "existing_value");

    let mut cmd = Command::new("test");
    cmd.env_vars.insert(
      "SET_VAR".to_string(),
      EnvAction::Set("set_value".to_string()),
    );
    cmd
      .env_vars
      .insert("EXISTING_VAR".to_string(), EnvAction::Preserve);
    cmd
      .env_vars
      .insert("MISSING_VAR".to_string(), EnvAction::Preserve);
    cmd
      .env_vars
      .insert("REMOVE_VAR".to_string(), EnvAction::Remove);

    let exec = subprocess::Exec::cmd("echo");
    let result = cmd.apply_env_to_exec(exec);

    // We *can't* easily test the exact environment variables set on Exec,
    // but we *can* verify the method doesn't panic and returns an Exec
    let cmdline = result.to_cmdline_lossy();
    assert!(
      cmdline.contains("echo"),
      "Command line should contain 'echo': {cmdline}"
    );
  }

  #[test]
  fn test_exit_error_display() {
    let exit_status = subprocess::ExitStatus::Exited(1);
    let error = ExitError(exit_status);

    let error_string = format!("{error}");
    assert!(error_string.contains("Command exited with status"));
    assert!(error_string.contains("Exited(1)"));
  }

  #[test]
  fn test_env_action_debug() {
    let set_action = EnvAction::Set("value".to_string());
    let preserve_action = EnvAction::Preserve;
    let remove_action = EnvAction::Remove;

    // Test that Debug is implemented (this will compile-fail if not)
    let _debug_set = format!("{set_action:?}");
    let _debug_preserve = format!("{preserve_action:?}");
    let _debug_remove = format!("{remove_action:?}");
  }

  #[test]
  fn test_env_action_clone() {
    let original = EnvAction::Set("value".to_string());
    let cloned = original.clone();

    match (original, cloned) {
      (EnvAction::Set(orig_val), EnvAction::Set(cloned_val)) => {
        assert_eq!(orig_val, cloned_val);
      },
      _ => panic!("Clone should preserve variant and value"),
    }
  }
}
</file>

<file path="Cargo.toml">
[workspace]
members = [ ".", "xtask" ]

[workspace.package]
edition      = "2024"
rust-version = "1.86.0"
version      = "4.2.0"

[workspace.dependencies.clap]
features = [ "cargo", "color", "derive", "env", "unstable-styles" ]
version  = "4.5.48"

[package]
name                   = "nh"
license                = "EUPL-1.2"
repository             = "https://github.com/nix-community/nh"
description            = "Yet Another Nix Helper"
keywords               = [ "nix", "nixos", "nix-darwin", "helper", "CLI" ]
readme                 = "README.md"
version.workspace      = true
edition.workspace      = true
rust-version.workspace = true

[lib]
path = "src/lib.rs"

[dependencies]
anstyle = "1.0.13"
chrono = "0.4.42"
clap.workspace = true
clap-verbosity-flag = { version = "3.0.4", features = [ "tracing" ], default-features = false }
clap_complete = "4.5.58"
color-eyre = { default-features = false, features = [ "track-caller" ], version = "0.6.5" }
dix = "1.3.0"
elasticsearch-dsl = "0.4.23"
hostname = "0.4.1"
humantime = "2.3.0"
inquire = { default-features = false, version = "0.9.1", features = [ "crossterm" ] }
nix = { default-features = false, features = [ "fs", "user" ], version = "0.30.1" }
regex = "1.11.3"
reqwest = { default-features = false, features = [
  "rustls-tls-native-roots",
  "blocking",
  "json",
], version = "0.12.23" }
secrecy = { version = "0.10.3", features = [ "serde" ] }
semver = "1.0.27"
serde = { features = [ "derive" ], version = "1.0.228" }
serde_json = "1.0.145"
subprocess = "0.2.9"
supports-hyperlinks = "3.1.0"
tempfile = "3.23.0"
textwrap = { features = [ "terminal_size" ], version = "0.16.2" }
thiserror = "2.0.17"
tracing = "0.1.41"
tracing-subscriber = { features = [ "env-filter", "registry", "std" ], version = "0.3.20" }
which = "8.0.0"
yansi = "1.0.1"

[target.'cfg(target_os="macos")'.dependencies]
system-configuration = "0.6.1"

[dev-dependencies]
clap_mangen = "0.2.29"
proptest    = "1.8.0"
serial_test = "3.2.0"

[profile.release]
lto       = true
opt-level = 3
strip     = true
</file>

<file path="src/nixos.rs">
use std::{
  env,
  fs,
  path::{Path, PathBuf},
};

use color_eyre::eyre::{Context, Result, bail, eyre};
use tracing::{debug, info, warn};

use crate::{
  commands::{self, Command, ElevationStrategy},
  generations,
  installable::Installable,
  interface::{
    self,
    DiffType,
    OsBuildVmArgs,
    OsGenerationsArgs,
    OsRebuildArgs,
    OsReplArgs,
    OsRollbackArgs,
    OsSubcommand::{self},
  },
  update::update,
  util::{ensure_ssh_key_login, get_hostname, print_dix_diff},
};

const SYSTEM_PROFILE: &str = "/nix/var/nix/profiles/system";
const CURRENT_PROFILE: &str = "/run/current-system";

const SPEC_LOCATION: &str = "/etc/specialisation";

impl interface::OsArgs {
  pub fn run(self, elevation: ElevationStrategy) -> Result<()> {
    use OsRebuildVariant::{Boot, Build, Switch, Test};
    match self.subcommand {
      OsSubcommand::Boot(args) => args.rebuild(&Boot, None, elevation),
      OsSubcommand::Test(args) => args.rebuild(&Test, None, elevation),
      OsSubcommand::Switch(args) => args.rebuild(&Switch, None, elevation),
      OsSubcommand::Build(args) => {
        if args.common.ask || args.common.dry {
          warn!("`--ask` and `--dry` have no effect for `nh os build`");
        }
        args.rebuild(&Build, None, elevation)
      },
      OsSubcommand::BuildVm(args) => args.build_vm(elevation),
      OsSubcommand::Repl(args) => args.run(),
      OsSubcommand::Info(args) => args.info(),
      OsSubcommand::Rollback(args) => args.rollback(elevation),
    }
  }
}

#[derive(Debug)]
enum OsRebuildVariant {
  Build,
  Switch,
  Boot,
  Test,
  BuildVm,
}

impl OsBuildVmArgs {
  fn build_vm(self, elevation: ElevationStrategy) -> Result<()> {
    let attr = if self.with_bootloader {
      "vmWithBootLoader".to_owned()
    } else {
      "vm".to_owned()
    };
    let out_path = self
      .common
      .common
      .out_link
      .clone()
      .unwrap_or_else(|| PathBuf::from("result"));

    debug!("Building VM with attribute: {}", attr);
    self
      .common
      .rebuild(&OsRebuildVariant::BuildVm, Some(&attr), elevation)?;

    // If --run flag is set, execute the VM
    if self.run {
      run_vm(&out_path)?;
    }

    Ok(())
  }
}

impl OsRebuildArgs {
  // final_attr is the attribute of config.system.build.X to evaluate.
  fn rebuild(
    self,
    variant: &OsRebuildVariant,
    final_attr: Option<&String>,
    elevation: ElevationStrategy,
  ) -> Result<()> {
    use OsRebuildVariant::{Build, BuildVm};

    let (elevate, target_hostname) = self.setup_build_context()?;

    // Only show the warning if we're explicitly building a VM
    // and no hostname was explicitly provided (--hostname was None)
    if self.hostname.is_none()
      && matches!(variant, OsRebuildVariant::BuildVm)
      && final_attr
        .is_some_and(|attr| attr == "vm" || attr == "vmWithBootLoader")
    {
      tracing::warn!(
        "Guessing system is {} for a VM image. If this isn't intended, use \
         --hostname to change.",
        target_hostname
      );
    }

    let (out_path, _tempdir_guard) = self.determine_output_path(variant)?;

    let toplevel =
      self.resolve_installable_and_toplevel(&target_hostname, final_attr)?;

    let message = match variant {
      BuildVm => "Building NixOS VM image",
      _ => "Building NixOS configuration",
    };

    self.execute_build_command(toplevel, &out_path, message)?;

    let target_profile = self.resolve_specialisation_and_profile(&out_path)?;

    self.handle_dix_diff(&target_profile);

    if self.common.dry || matches!(variant, Build | BuildVm) {
      if self.common.ask {
        warn!("--ask has no effect as dry run was requested");
      }

      // For VM builds, print instructions on how to run the VM
      if matches!(variant, BuildVm) && !self.common.dry {
        print_vm_instructions(&out_path);
      }

      return Ok(());
    }

    self.activate_rebuilt_config(
      variant,
      &out_path,
      &target_profile,
      elevate,
      elevation,
    )?;

    Ok(())
  }

  /// Performs initial setup and gathers context for an OS rebuild operation.
  ///
  /// This includes:
  /// - Ensuring SSH key login if a remote build/target host is involved.
  /// - Checking and determining elevation status.
  /// - Performing updates to Nix inputs if specified.
  /// - Resolving the target hostname for the build.
  ///
  /// # Returns
  /// A `Result` containing a tuple:
  /// - `bool`: `true` if elevation is required, `false` otherwise.
  /// - `String`: The resolved target hostname.
  fn setup_build_context(&self) -> Result<(bool, String)> {
    if self.build_host.is_some() || self.target_host.is_some() {
      // This can fail, we only care about prompting the user
      // for ssh key login beforehand.
      let _ = ensure_ssh_key_login();
    }

    let elevate = has_elevation_status(self.bypass_root_check)?;

    if self.update_args.update_all || self.update_args.update_input.is_some() {
      update(
        &self.common.installable,
        self.update_args.update_input.clone(),
      )?;
    }

    let target_hostname = get_hostname(self.hostname.clone())?;
    Ok((elevate, target_hostname))
  }

  fn determine_output_path(
    &self,
    variant: &OsRebuildVariant,
  ) -> Result<(PathBuf, Option<tempfile::TempDir>)> {
    use OsRebuildVariant::{Build, BuildVm};
    if let Some(p) = self.common.out_link.clone() {
      Ok((p, None))
    } else {
      let (path, guard) = if matches!(variant, BuildVm | Build) {
        (PathBuf::from("result"), None)
      } else {
        let dir = tempfile::Builder::new().prefix("nh-os").tempdir()?;
        (dir.as_ref().join("result"), Some(dir))
      };
      Ok((path, guard))
    }
  }

  fn resolve_installable_and_toplevel(
    &self,
    target_hostname: &str,
    final_attr: Option<&String>,
  ) -> Result<Installable> {
    let installable = (get_nh_os_flake_env()?).map_or_else(
      || self.common.installable.clone(),
      |flake_installable| flake_installable,
    );

    Ok(toplevel_for(
      target_hostname,
      installable,
      final_attr.map_or("toplevel", |v| v),
    ))
  }

  fn execute_build_command(
    &self,
    toplevel: Installable,
    out_path: &Path,
    message: &str,
  ) -> Result<()> {
    commands::Build::new(toplevel)
      .extra_arg("--out-link")
      .extra_arg(out_path)
      .extra_args(&self.extra_args)
      .passthrough(&self.common.passthrough)
      .builder(self.build_host.clone())
      .message(message)
      .nom(!self.common.no_nom)
      .run()
      .wrap_err("Failed to build configuration")
  }

  fn resolve_specialisation_and_profile(
    &self,
    out_path: &Path,
  ) -> Result<PathBuf> {
    let current_specialisation = std::fs::read_to_string(SPEC_LOCATION).ok();

    let target_specialisation = if self.no_specialisation {
      None
    } else {
      current_specialisation.or_else(|| self.specialisation.clone())
    };

    debug!("Target specialisation: {target_specialisation:?}");

    let target_profile = target_specialisation.as_ref().map_or_else(
      || out_path.to_path_buf(),
      |spec| out_path.join("specialisation").join(spec),
    );

    debug!("Output path: {out_path:?}");
    debug!("Target profile path: {}", target_profile.display());
    debug!("Target profile exists: {}", target_profile.exists());

    if !target_profile
      .try_exists()
      .context("Failed to check if target profile exists")?
    {
      return Err(eyre!(
        "Target profile path does not exist: {}",
        target_profile.display()
      ));
    }

    Ok(target_profile)
  }

  fn handle_dix_diff(&self, target_profile: &Path) {
    match self.common.diff {
      DiffType::Always => {
        let _ = print_dix_diff(&PathBuf::from(CURRENT_PROFILE), target_profile);
      },
      DiffType::Never => {
        debug!("Not running dix as the --diff flag is set to never.");
      },
      DiffType::Auto => {
        // Only run dix if no explicit hostname was provided and no remote
        // build/target host is specified, implying a local system build.
        if self.hostname.is_none()
          && self.target_host.is_none()
          && self.build_host.is_none()
        {
          debug!(
            "Comparing with target profile: {}",
            target_profile.display()
          );
          let _ =
            print_dix_diff(&PathBuf::from(CURRENT_PROFILE), target_profile);
        } else {
          debug!(
            "Not running dix as a remote host is involved or an explicit \
             hostname was provided."
          );
        }
      },
    }
  }

  fn activate_rebuilt_config(
    &self,
    variant: &OsRebuildVariant,
    out_path: &Path,
    target_profile: &Path,
    elevate: bool,
    elevation: ElevationStrategy,
  ) -> Result<()> {
    use OsRebuildVariant::{Boot, Switch, Test};

    if self.common.ask {
      let confirmation = inquire::Confirm::new("Apply the config?")
        .with_default(false)
        .prompt()?;

      if !confirmation {
        bail!("User rejected the new config");
      }
    }

    if let Some(target_host) = &self.target_host {
      Command::new("nix")
        .args([
          "copy",
          "--to",
          format!("ssh://{target_host}").as_str(),
          match target_profile.to_str() {
            Some(s) => s,
            None => {
              return Err(eyre!("target_profile path is not valid UTF-8"));
            },
          },
        ])
        .message("Copying configuration to target")
        .with_required_env()
        .run()?;
    }

    let switch_to_configuration = target_profile
      .canonicalize()
      .context("Failed to resolve output path")?
      .join("bin")
      .join("switch-to-configuration")
      .canonicalize()
      .context("Failed to resolve switch-to-configuration path")?;

    if !switch_to_configuration.exists() {
      return Err(missing_switch_to_configuration_error());
    }

    let canonical_out_path =
      switch_to_configuration.to_str().ok_or_else(|| {
        eyre!("switch-to-configuration path contains invalid UTF-8")
      })?;

    if let Test | Switch = variant {
      Command::new(canonical_out_path)
        .arg("test")
        .ssh(self.target_host.clone())
        .message("Activating configuration")
        .elevate(elevate.then_some(elevation.clone()))
        .preserve_envs(["NIXOS_INSTALL_BOOTLOADER"])
        .with_required_env()
        .run()
        .wrap_err("Activation (test) failed")?;

      debug!("Completed {variant:?} operation with output path: {out_path:?}");
    }

    if let Boot | Switch = variant {
      Command::new("nix")
        .elevate(elevate.then_some(elevation.clone()))
        .args(["build", "--no-link", "--profile", SYSTEM_PROFILE])
        .arg(canonical_out_path)
        .ssh(self.target_host.clone())
        .with_required_env()
        .run()
        .wrap_err("Failed to set system profile")?;

      let mut cmd = Command::new(switch_to_configuration)
        .arg("boot")
        .ssh(self.target_host.clone())
        .elevate(elevate.then_some(elevation))
        .message("Adding configuration to bootloader")
        .preserve_envs(["NIXOS_INSTALL_BOOTLOADER"]);

      if self.install_bootloader {
        cmd = cmd.set_env("NIXOS_INSTALL_BOOTLOADER", "1");
      }

      cmd
        .with_required_env()
        .run()
        .wrap_err("Bootloader activation failed")?;
    }

    debug!("Completed {variant:?} operation with output path: {out_path:?}");
    Ok(())
  }
}

impl OsRollbackArgs {
  #[expect(clippy::too_many_lines)]
  fn rollback(&self, elevation: ElevationStrategy) -> Result<()> {
    let elevate = has_elevation_status(self.bypass_root_check)?;

    // Find previous generation or specific generation
    let target_generation = if let Some(gen_number) = self.to {
      find_generation_by_number(gen_number)?
    } else {
      find_previous_generation()?
    };

    info!("Rolling back to generation {}", target_generation.number);

    // Construct path to the generation
    let profile_dir = Path::new(SYSTEM_PROFILE).parent().unwrap_or_else(|| {
      tracing::warn!(
        "SYSTEM_PROFILE has no parent, defaulting to /nix/var/nix/profiles"
      );
      Path::new("/nix/var/nix/profiles")
    });
    let generation_link =
      profile_dir.join(format!("system-{}-link", target_generation.number));

    // Handle specialisations
    let current_specialisation = fs::read_to_string(SPEC_LOCATION).ok();

    let target_specialisation = if self.no_specialisation {
      None
    } else {
      self.specialisation.clone().or(current_specialisation)
    };

    debug!("target_specialisation: {target_specialisation:?}");

    // Compare changes between current and target generation
    if matches!(self.diff, DiffType::Never) {
      debug!(
        "Not running dix as the target hostname is different from the system \
         hostname."
      );
    } else {
      debug!(
        "Comparing with target profile: {}",
        generation_link.display()
      );
      let _ = print_dix_diff(&PathBuf::from(CURRENT_PROFILE), &generation_link);
    }

    if self.dry {
      info!(
        "Dry run: would roll back to generation {}",
        target_generation.number
      );
      return Ok(());
    }

    if self.ask {
      let confirmation = inquire::Confirm::new(&format!(
        "Roll back to generation {}?",
        target_generation.number
      ))
      .with_default(false)
      .prompt()?;

      if !confirmation {
        bail!("User rejected the rollback");
      }
    }

    // Get current generation number for potential rollback
    let current_gen_number = match get_current_generation_number() {
      Ok(num) => num,
      Err(e) => {
        warn!("Failed to get current generation number: {}", e);
        0
      },
    };

    // Set the system profile
    info!("Setting system profile...");

    // Instead of direct symlink operations, use a command with proper elevation
    Command::new("ln")
            .arg("-sfn") // force, symbolic link
            .arg(&generation_link)
            .arg(SYSTEM_PROFILE)
            .elevate(elevate.then_some(elevation.clone()))
            .message("Setting system profile")
            .with_required_env()
            .run()
            .wrap_err("Failed to set system profile during rollback")?;

    // Determine the correct profile to use with specialisations
    let final_profile = match &target_specialisation {
      None => generation_link,
      Some(spec) => {
        let spec_path = generation_link.join("specialisation").join(spec);
        if spec_path.exists() {
          spec_path
        } else {
          warn!(
            "Specialisation '{}' does not exist in generation {}",
            spec, target_generation.number
          );
          warn!("Using base configuration without specialisations");
          generation_link
        }
      },
    };

    // Activate the configuration
    info!("Activating...");

    let switch_to_configuration =
      final_profile.join("bin").join("switch-to-configuration");

    if !switch_to_configuration.exists() {
      return Err(missing_switch_to_configuration_error());
    }

    match Command::new(&switch_to_configuration)
      .arg("switch")
      .elevate(elevate.then_some(elevation.clone()))
      .preserve_envs(["NIXOS_INSTALL_BOOTLOADER"])
      .with_required_env()
      .run()
    {
      Ok(()) => {
        info!(
          "Successfully rolled back to generation {}",
          target_generation.number
        );
      },
      Err(e) => {
        // If activation fails, rollback the profile
        if current_gen_number > 0 {
          let current_gen_link =
            profile_dir.join(format!("system-{current_gen_number}-link"));

          Command::new("ln")
                        .arg("-sfn") // Force, symbolic link
                        .arg(&current_gen_link)
                        .arg(SYSTEM_PROFILE)
                        .elevate(elevate.then_some(elevation))
                        .message("Rolling back system profile")
                        .with_required_env()
                        .run()
                        .wrap_err("NixOS: Failed to restore previous system profile after failed activation")?;
        }

        return Err(eyre!("Activation (switch) failed: {}", e))
          .context("Failed to activate configuration");
      },
    }

    Ok(())
  }
}

/// Finds the VM runner script in the given build output directory.
///
/// Searches for a file matching `run-*-vm` in the `bin` subdirectory of
/// `out_path`.
///
/// # Arguments
///
/// * `out_path` - The path to the build output directory (usually `result`).
///
/// # Returns
///
/// * `Ok(PathBuf)` with the path to the VM runner script if found.
/// * `Err` if the script cannot be found or the bin directory is missing.
///
/// # Errors
///
/// Returns an error if the bin directory does not exist or if no matching
/// script is found.
fn find_vm_script(out_path: &Path) -> Result<PathBuf> {
  let bin_dir = out_path.join("bin");

  if !bin_dir.is_dir() {
    bail!(
      "VM build output missing bin directory at {}",
      bin_dir.display()
    );
  }

  let vm_script = fs::read_dir(&bin_dir)
    .wrap_err_with(|| {
      format!("Failed to read directory {}", bin_dir.display())
    })?
    .filter_map(|entry_result| {
      match entry_result {
        Ok(entry) => Some(entry),
        Err(e) => {
          warn!("Error reading entry in {}: {}", bin_dir.display(), e);
          None
        },
      }
    })
    .find_map(|entry| {
      let fname = entry.file_name();
      if fname
        .to_str()
        .is_some_and(|name| name.starts_with("run-") && name.ends_with("-vm"))
      {
        Some(entry.path())
      } else {
        None
      }
    })
    .ok_or_else(|| {
      eyre!("Could not find VM runner script in {}", bin_dir.display())
    })?;

  Ok(vm_script)
}

/// Prints instructions for running the built VM to the user.
///
/// Attempts to locate the VM runner script in the build output directory and
/// prints a message with the path to the script. If the script cannot be found,
/// prints a warning and a generic path pattern.
///
/// # Arguments
///
/// * `out_path` - The path to the build output directory (usually `result`).
///
/// # Returns
///
/// * `Ok(())` on success.
/// * `Err` if there is an error searching for the VM script.
fn print_vm_instructions(out_path: &Path) {
  match find_vm_script(out_path) {
    Ok(script) => {
      info!(
        "Done. The virtual machine can be started by running {}",
        script.display()
      );
    },
    Err(e) => {
      warn!("VM build completed, but could not find run script: {}", e);
      info!(
        "Done. The virtual machine script should be at {}/bin/run-*-vm",
        out_path.display()
      );
    },
  }
}

/// Runs the built NixOS VM by executing the VM runner script.
///
/// Locates the VM runner script in the build output directory and executes it,
/// streaming its output to the user. Returns an error if the script cannot be
/// found or if execution fails.
///
/// # Arguments
///
/// * `out_path` - The path to the build output directory (usually `result`).
///
/// # Returns
///
/// * `Ok(())` if the VM was started successfully.
/// * `Err` if the script cannot be found or execution fails.
fn run_vm(out_path: &Path) -> Result<()> {
  let vm_script = find_vm_script(out_path)?;

  info!(
    "Running VM... Starting virtual machine with {}",
    vm_script.display()
  );

  Command::new(&vm_script)
    .message("Running VM")
    .show_output(true)
    .with_required_env()
    .run()
    .wrap_err_with(|| {
      format!("Failed to run VM script at {}", vm_script.display())
    })?;

  Ok(())
}

/// Returns an error indicating that the 'switch-to-configuration' binary is
/// missing, along with common reasons and solutions.
fn missing_switch_to_configuration_error() -> color_eyre::eyre::Report {
  eyre!(
    "The 'switch-to-configuration' binary is missing from the built \
     configuration.\n\nThis typically happens when 'system.switch.enable' is \
     set to false in your\nNixOS configuration. To fix this, please \
     either:\n1. Remove 'system.switch.enable = false' from your \
     configuration, or\n2. Set 'system.switch.enable = true' explicitly\n\nIf \
     the problem persists, please open an issue on our issue tracker!"
  )
}

/// Parses the `NH_OS_FLAKE` environment variable into an `Installable::Flake`.
///
/// If `NH_OS_FLAKE` is not set, it returns `Ok(None)`.
/// If `NH_OS_FLAKE` is set but invalid, it returns an `Err`.
fn get_nh_os_flake_env() -> Result<Option<Installable>> {
  if let Ok(os_flake) = env::var("NH_OS_FLAKE") {
    debug!("Using NH_OS_FLAKE: {}", os_flake);

    let mut elems = os_flake.splitn(2, '#');
    let reference = elems
      .next()
      .ok_or_else(|| eyre!("NH_OS_FLAKE missing reference part"))?
      .to_owned();
    let attribute = elems
      .next()
      .map(crate::installable::parse_attribute)
      .unwrap_or_default();

    Ok(Some(Installable::Flake {
      reference,
      attribute,
    }))
  } else {
    Ok(None)
  }
}

/// Checks if the current user is root and returns whether elevation is needed.
///
/// Returns `true` if elevation is required (not root and `bypass_root_check` is
/// false). Returns `false` if elevation is not required (root or
/// `bypass_root_check` is true).
///
/// # Arguments
/// * `bypass_root_check` - If true, bypasses the root check and assumes no
///   elevation is needed.
///
/// # Errors
/// Returns an error if `bypass_root_check` is false and the user is root,
/// as `nh os` subcommands should not be run directly as root.
fn has_elevation_status(bypass_root_check: bool) -> Result<bool> {
  if bypass_root_check {
    warn!("Bypassing root check, now running nix as root");
    Ok(false)
  } else {
    if nix::unistd::Uid::effective().is_root() {
      bail!(
        "Don't run nh os as root. It will escalate its privileges internally \
         as needed."
      );
    }
    Ok(true)
  }
}

fn find_previous_generation() -> Result<generations::GenerationInfo> {
  let generations = list_generations()?;
  if generations.is_empty() {
    bail!("No generations found");
  }

  let current_idx = get_current_generation_number()? as usize;

  if current_idx == 0 {
    bail!("No generation older than the current one exists");
  }

  Ok(generations[current_idx - 1].clone())
}

fn find_generation_by_number(
  number: u64,
) -> Result<generations::GenerationInfo> {
  list_generations()?
    .into_iter()
    .find(|g| g.number == number.to_string())
    .ok_or_else(|| eyre!("Generation {} not found", number))
}

fn get_current_generation_number() -> Result<u64> {
  let generations = list_generations()?;
  let current_gen = generations
    .iter()
    .find(|g| g.current)
    .ok_or_else(|| eyre!("Current generation not found"))?;

  current_gen
    .number
    .parse::<u64>()
    .wrap_err("Invalid generation number")
}

fn list_generations() -> Result<Vec<generations::GenerationInfo>> {
  let profile_path = PathBuf::from(SYSTEM_PROFILE);
  let profiles_dir = profile_path
    .parent()
    .unwrap_or_else(|| Path::new("/nix/var/nix/profiles"));

  let mut generations = Vec::new();
  for entry in fs::read_dir(profiles_dir)? {
    let entry = match entry {
      Ok(e) => e,
      Err(e) => {
        warn!("Failed to read entry in profile directory: {}", e);
        continue;
      },
    };

    let path = entry.path();
    if let Some(name) = path.file_name().and_then(|s| s.to_str()) {
      if name.starts_with("system-") && name.ends_with("-link") {
        if let Some(gen_info) = generations::describe(&path) {
          generations.push(gen_info);
        }
      }
    }
  }

  if generations.is_empty() {
    bail!("No generations found");
  }

  generations.sort_by_key(|g| g.number.parse::<u64>().unwrap_or(0));

  Ok(generations)
}

pub fn toplevel_for<S: AsRef<str>>(
  hostname: S,
  installable: Installable,
  final_attr: &str,
) -> Installable {
  let mut res = installable;
  let hostname_str = hostname.as_ref();

  let toplevel = ["config", "system", "build", final_attr]
    .into_iter()
    .map(String::from);

  match res {
    Installable::Flake {
      ref mut attribute, ..
    } => {
      // If user explicitly selects some other attribute, don't push
      // nixosConfigurations
      if attribute.is_empty() {
        attribute.push(String::from("nixosConfigurations"));
        attribute.push(hostname_str.to_owned());
      }
      attribute.extend(toplevel);
    },
    Installable::File {
      ref mut attribute, ..
    }
    | Installable::Expression {
      ref mut attribute, ..
    } => attribute.extend(toplevel),

    Installable::Store { .. } => {},
  }

  res
}

impl OsReplArgs {
  fn run(self) -> Result<()> {
    // Use NH_OS_FLAKE if available, otherwise use the provided installable
    let mut target_installable =
      if let Some(flake_installable) = get_nh_os_flake_env()? {
        flake_installable
      } else {
        self.installable
      };

    if matches!(target_installable, Installable::Store { .. }) {
      bail!("Nix doesn't support nix store installables.");
    }

    let hostname = get_hostname(self.hostname)?;

    if let Installable::Flake {
      ref mut attribute, ..
    } = target_installable
    {
      if attribute.is_empty() {
        attribute.push(String::from("nixosConfigurations"));
        attribute.push(hostname);
      }
    }

    Command::new("nix")
      .arg("repl")
      .args(target_installable.to_args())
      .with_required_env()
      .show_output(true)
      .run()?;

    Ok(())
  }
}

impl OsGenerationsArgs {
  fn info(&self) -> Result<()> {
    let profile = match self.profile {
      Some(ref p) => PathBuf::from(p),
      None => bail!("Profile path is required"),
    };

    if !profile.is_symlink() {
      return Err(eyre!(
        "No profile `{:?}` found",
        profile.file_name().unwrap_or_default()
      ));
    }

    let profile_dir = profile.parent().unwrap_or_else(|| Path::new("."));

    let generations: Vec<_> = fs::read_dir(profile_dir)?
      .filter_map(|entry| {
        entry.ok().and_then(|e| {
          let path = e.path();
          if path
            .file_name()?
            .to_str()?
            .starts_with(profile.file_name()?.to_str()?)
          {
            Some(path)
          } else {
            None
          }
        })
      })
      .collect();

    let descriptions: Vec<generations::GenerationInfo> = generations
      .iter()
      .filter_map(|gen_dir| generations::describe(gen_dir))
      .collect();

    generations::print_info(descriptions, &self.fields)?;

    Ok(())
  }
}
</file>

</files>
