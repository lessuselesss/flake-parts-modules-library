This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    flake-check.yaml
  FUNDING.yml
dev/
  modules/
    _lib/
      default.nix
    unit-tests/
      inputsExpr.nix
    dendritic.nix
    devshell.nix
    formatter.nix
    nix-unit.nix
    regen.nix
  flake.lock
  flake.nix
modules/
  dendritic/
    basic.nix
    default.nix
    dendritic.nix
    formatter.nix
    nixpkgs.nix
    systems.nix
  flake-parts-builder/
    _bootstrap.nix
    default.nix
  options/
    check-hooks.nix
    default.nix
    do-not-edit.nix
    flake-file.nix
    formatter.nix
    inputs.nix
    outputs.nix
    prune-lock.nix
    write-hooks.nix
  prune-lock/
    _nothing.nix
    allfollow.nix
    nix-auto-follow.nix
  default.nix
  import-tree.nix
  write-flake.nix
templates/
  default/
    modules/
      default.nix
    flake.nix
    outputs.nix
  dendritic/
    modules/
      dendritic.nix
    flake.nix
  parts/
    flake-parts/
      _meta/
        flake-root.nix
        systems.nix
        treefmt.nix
      flake-root.nix
      systems.nix
    flake.nix
    outputs.nix
  .gitignore
flake.nix
LICENSE
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/flake-check.yaml">
name: flake-check
on:
  push:
    branches: ["main"]
  pull_request:
jobs:
  find-templates:
    name: Find templates
    runs-on: ubuntu-latest
    outputs:
      templates: ${{ steps.templates.outputs.templates }}
    steps:
      - uses: actions/checkout@v4
      - id: templates
        run: |
          templates=$(find templates -mindepth 2 -maxdepth 2  -name flake.nix -print0 | xargs -0 dirname | xargs -n 1 basename | jq -R | jq -sc)
          echo "$templates"
          echo "templates=$templates" >> $GITHUB_OUTPUT
  template:
    name: Check template ${{matrix.template}}
    needs: [find-templates]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        template: ${{ fromJSON(needs.find-templates.outputs.templates) }}
    steps:
      - uses: wimpysworld/nothing-but-nix@main
      - uses: DeterminateSystems/nix-installer-action@main
      - uses: DeterminateSystems/magic-nix-cache-action@main
      - run: |
          set -uveo pipefail
          cat <<EOF | tee forced.nix
          { lib, ... }:
          {
            flake-file.inputs.flake-file.url = lib.mkForce "github:$GITHUB_REPOSITORY/$GITHUB_SHA";
          }
          EOF
          mkdir templated; cd templated
          nix flake init -t github:$GITHUB_REPOSITORY/$GITHUB_SHA#${{ matrix.template }}
          nix run .#write-flake -L --show-trace
          if test -d ./modules; then cp ../forced.nix ./modules/; fi;
          if test -d ./flake-parts; then cp ../forced.nix ./flake-parts/; fi;
          nix run .#write-flake -L --show-trace
          nix flake metadata
          nix run .#write-flake -L --show-trace
          nix flake check -L --show-trace
  dev:
    name: Check flake dev
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: wimpysworld/nothing-but-nix@main
      - uses: DeterminateSystems/nix-installer-action@main
      - uses: DeterminateSystems/magic-nix-cache-action@main
      - run: cd dev && nix flake check && nix flake metadata && nix flake check
  nix-fmt:
    name: Nix Format
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: wimpysworld/nothing-but-nix@main
      - uses: DeterminateSystems/nix-installer-action@main
      - uses: DeterminateSystems/magic-nix-cache-action@main
      - run: nix run -L ./dev#fmt -- --ci
</file>

<file path=".github/FUNDING.yml">
# These are supported funding model platforms

github: [vic] # Replace with up to 4 GitHub Sponsors-enabled usernames e.g., [user1, user2]
patreon: # Replace with a single Patreon username
open_collective: # Replace with a single Open Collective username
ko_fi: oeiuwq # Replace with a single Ko-fi username
tidelift: # Replace with a single Tidelift platform-name/package-name e.g., npm/babel
community_bridge: # Replace with a single Community Bridge project-name e.g., cloud-foundry
liberapay: # Replace with a single Liberapay username
issuehunt: # Replace with a single IssueHunt username
lfx_crowdfunding: # Replace with a single LFX Crowdfunding project-name e.g., cloud-foundry
polar: # Replace with a single Polar username
buy_me_a_coffee: # Replace with a single Buy Me a Coffee username
thanks_dev: # Replace with a single thanks.dev username
custom: # Replace with up to 4 custom sponsorship URLs e.g., ['link1', 'link2']
</file>

<file path="dev/modules/_lib/default.nix">
lib:
let

  isNonEmptyString = s: lib.isStringLike s && lib.stringLength (lib.trim s) > 0;

  isEmpty =
    x:
    (
      (builtins.isNull x)
      || (lib.isStringLike x && lib.stringLength (lib.trim x) == 0)
      || (lib.isList x && lib.length x == 0)
      || (lib.isAttrs x && x == { })
    );

  mergeNonEmpty =
    from: name:
    {
      testEmpty ? isEmpty,
      onEmptyMerge ? { },
      nonEmptyMerge ? {
        ${name} = from.${name};
      },
    }:
    acc: acc // (if (!from ? ${name}) || testEmpty from.${name} then onEmptyMerge else nonEmptyMerge);

  mergeNonEmptyAttrs =
    from: attrs:
    let
      m = mergeNonEmpty from;
      ops = lib.mapAttrsToList (name: spec: (m name spec)) attrs;
    in
    lib.pipe { } ops;

  nonEmptyInputs = input: {
    nonEmptyMerge = {
      inputs = inputsFollow input.inputs;
    };
  };

  inputsFollow = lib.mapAttrs (
    _: input:
    mergeNonEmptyAttrs input {
      follows = { };
      inputs = nonEmptyInputs input;
    }
  );

  inputsExpr = lib.mapAttrs (
    _name: input:
    mergeNonEmptyAttrs input {
      url = { };
      type = { };
      owner = { };
      repo = { };
      path = { };
      id = { };
      dir = { };
      narHash = { };
      rev = { };
      ref = { };
      host = { };
      flake = {
        testEmpty = v: v;
        nonEmptyMerge = {
          flake = false;
        };
      };
      follows = { };
      inputs = nonEmptyInputs input;
    }
  );

in
{
  inherit inputsExpr isNonEmptyString;
}
</file>

<file path="dev/modules/unit-tests/inputsExpr.nix">
{ lib, ... }:
let
  inherit (import ./../_lib lib) inputsExpr;

  tests.inputsExpr."test on empty inputs" = {
    expr = inputsExpr { };
    expected = { };
  };

  tests.inputsExpr."test on input without follows" = {
    expr = inputsExpr {
      foo.url = "foo";
    };
    expected = {
      foo.url = "foo";
    };
  };

  tests.inputsExpr."test on input without flake=true" = {
    expr = inputsExpr {
      foo.url = "foo";
      foo.flake = true;
    };
    expected = {
      foo.url = "foo";
    };
  };

  tests.inputsExpr."test on input without flake=false" = {
    expr = inputsExpr {
      foo.url = "foo";
      foo.flake = false;
    };
    expected = {
      foo.url = "foo";
      foo.flake = false;
    };
  };

  tests.inputsExpr."test on input with follows" = {
    expr = inputsExpr {
      foo.url = "foo";
      foo.inputs.bar.follows = "baz";
    };
    expected = {
      foo.url = "foo";
      foo.inputs.bar.follows = "baz";
    };
  };

  tests.inputsExpr."test on input with self follows" = {
    expr = inputsExpr {
      foo.follows = "bar";
    };
    expected = {
      foo.follows = "bar";
    };
  };

in
{
  flake = { inherit tests; };
}
</file>

<file path="dev/modules/dendritic.nix">
{ inputs, ... }:
{
  imports = [ inputs.flake-file.flakeModules.dendritic ];
  flake-file.inputs.flake-file.url = "path:..";
}
</file>

<file path="dev/modules/devshell.nix">
{ inputs, ... }:
{
  flake-file.inputs.devshell.url = "github:numtide/devshell";

  imports = [
    inputs.devshell.flakeModule
  ];

  perSystem =
    { pkgs, self', ... }:
    {
      devshells.default.commands = [
        {
          help = "regen all flake.nix on this repo";
          package = self'.packages.regen;
        }
        {
          help = "run a command on each sub flake";
          package = self'.packages.each;
        }
        {
          name = "fmt";
          help = "format all files in repo";
          command = "nix run ./dev#fmt --override-input flake-file .";
        }
        {
          name = "update";
          help = "update all flakes and prune locks";
          command = ''
            ${pkgs.lib.getExe self'.packages.each} nix run .#write-flake
            ${pkgs.lib.getExe self'.packages.each} nix flake update
            ${pkgs.lib.getExe self'.packages.each} nix run .#write-flake
          '';
        }
        {
          name = "check";
          help = "run flake check";
          command = "nix flake check ./dev --override-input flake-file .";
        }
      ];
    };
}
</file>

<file path="dev/modules/formatter.nix">
{ inputs, ... }:
{
  perSystem.treefmt.projectRoot = inputs.flake-file;
}
</file>

<file path="dev/modules/nix-unit.nix">
{ inputs, ... }:
{
  flake-file.inputs.nix-unit = {
    url = "github:nix-community/nix-unit";
    inputs.flake-parts.follows = "flake-parts";
    inputs.nixpkgs.follows = "nixpkgs";
    inputs.treefmt-nix.follows = "treefmt-nix";
  };

  imports = [ inputs.nix-unit.modules.flake.default ];

  perSystem.nix-unit = {
    inherit inputs;
    allowNetwork = true;
  };

  flake.tests.testTruth = {
    expr = true;
    expected = true;
  };
}
</file>

<file path="dev/modules/regen.nix">
{ inputs, ... }:
{
  perSystem =
    { pkgs, ... }:
    let
      exe = name: pkgs.lib.getExe inputs.self.packages.${pkgs.system}.${name};
      puke = exe "puke";
      oneach = exe "oneach";
      each = exe "each";
    in
    {
      packages.oneach = pkgs.writeShellApplication {
        name = "oneach";
        text = ''
          (
            pushd "$1"
            # shellcheck disable=SC2068
            ''${@:2}
            popd
          )
        '';
      };

      packages.each = pkgs.writeShellApplication {
        name = "each";
        text = ''
          set -e -o pipefail
          find . -mindepth 2 -name flake.nix -print0 | xargs -0 -n 1 dirname | xargs -n 1 -I FLAKE_DIR ${oneach} FLAKE_DIR "$@"
        '';
      };

      packages.puke = pkgs.writeShellApplication {
        name = "puke";
        text = ''
          set -e
          nix run .#write-flake "$@"
          nix flake check "$@"
        '';
      };

      packages.regen = pkgs.writeShellApplication {
        name = "regen";
        text = ''
          ${each} ${puke} --accept-flake-config -L --override-input flake-file "$PWD"
        '';
      };

      packages.check = pkgs.writeShellApplication {
        name = "check";
        text = ''
          ${each} nix flake check --accept-flake-config -L --override-input flake-file "$PWD"
        '';
      };
    };
}
</file>

<file path="dev/flake.lock">
{
  "nodes": {
    "devshell": {
      "inputs": {
        "nixpkgs": "nixpkgs"
      },
      "locked": {
        "lastModified": 1741473158,
        "narHash": "sha256-kWNaq6wQUbUMlPgw8Y+9/9wP0F8SHkjy24/mN3UAppg=",
        "owner": "numtide",
        "repo": "devshell",
        "rev": "7c9e793ebe66bcba8292989a68c0419b737a22a0",
        "type": "github"
      },
      "original": {
        "owner": "numtide",
        "repo": "devshell",
        "type": "github"
      }
    },
    "flake-aspects": {
      "locked": {
        "lastModified": 1760735761,
        "narHash": "sha256-UsqYUaLAQvpC8+9ylFcnCaAw4e+sx7qgPQvt9wLHRyE=",
        "owner": "vic",
        "repo": "flake-aspects",
        "rev": "89dfd9491ed9253625d713e226b49b1acf781155",
        "type": "github"
      },
      "original": {
        "owner": "vic",
        "repo": "flake-aspects",
        "type": "github"
      }
    },
    "flake-file": {
      "locked": {
        "path": "..",
        "type": "path"
      },
      "original": {
        "path": "..",
        "type": "path"
      },
      "parent": []
    },
    "flake-parts": {
      "inputs": {
        "nixpkgs-lib": "nixpkgs-lib"
      },
      "locked": {
        "lastModified": 1760948891,
        "narHash": "sha256-TmWcdiUUaWk8J4lpjzu4gCGxWY6/Ok7mOK4fIFfBuU4=",
        "owner": "hercules-ci",
        "repo": "flake-parts",
        "rev": "864599284fc7c0ba6357ed89ed5e2cd5040f0c04",
        "type": "github"
      },
      "original": {
        "owner": "hercules-ci",
        "repo": "flake-parts",
        "type": "github"
      }
    },
    "import-tree": {
      "locked": {
        "lastModified": 1752730890,
        "narHash": "sha256-GES8fapSLGz36MMPRVNkSUWXUTtqvGQNXHjRmRLfJUY=",
        "owner": "vic",
        "repo": "import-tree",
        "rev": "6ebb8cb87987b20264c09296166543fd3761d274",
        "type": "github"
      },
      "original": {
        "owner": "vic",
        "repo": "import-tree",
        "type": "github"
      }
    },
    "nix-auto-follow": {
      "inputs": {
        "nixpkgs": "nixpkgs_2"
      },
      "locked": {
        "lastModified": 1754073254,
        "narHash": "sha256-CQp/v2HQ7AtGJQqFGRZLHt4MZAK3NF94I6GDaRyhbsc=",
        "owner": "fzakaria",
        "repo": "nix-auto-follow",
        "rev": "5baa00b79d4cc46523da0b8b3532c5163d151be4",
        "type": "github"
      },
      "original": {
        "owner": "fzakaria",
        "repo": "nix-auto-follow",
        "type": "github"
      }
    },
    "nix-unit": {
      "inputs": {
        "flake-parts": [
          "flake-parts"
        ],
        "nixpkgs": [
          "nixpkgs"
        ],
        "treefmt-nix": [
          "treefmt-nix"
        ]
      },
      "locked": {
        "lastModified": 1757781724,
        "narHash": "sha256-DP5SCFx0AsbPnT7KzEl3gQNWPF70Tlcc+jtLkqupabI=",
        "owner": "nix-community",
        "repo": "nix-unit",
        "rev": "7a952131cbef9cb21953ae70ad09249541848f07",
        "type": "github"
      },
      "original": {
        "owner": "nix-community",
        "repo": "nix-unit",
        "type": "github"
      }
    },
    "nixpkgs": {
      "locked": {
        "lastModified": 1760934318,
        "narHash": "sha256-/oUYsC0lUCBory65VK+UHqCCsCspbL1Vgfcf1KUYqVw=",
        "owner": "nixos",
        "repo": "nixpkgs",
        "rev": "87848bf0cc4f87717fc813a4575f07330c3e743c",
        "type": "github"
      },
      "original": {
        "owner": "nixos",
        "ref": "nixpkgs-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "nixpkgs-lib": {
      "locked": {
        "lastModified": 1754788789,
        "narHash": "sha256-x2rJ+Ovzq0sCMpgfgGaaqgBSwY+LST+WbZ6TytnT9Rk=",
        "owner": "nix-community",
        "repo": "nixpkgs.lib",
        "rev": "a73b9c743612e4244d865a2fdee11865283c04e6",
        "type": "github"
      },
      "original": {
        "owner": "nix-community",
        "repo": "nixpkgs.lib",
        "type": "github"
      }
    },
    "nixpkgs_2": {
      "locked": {
        "lastModified": 1760934318,
        "narHash": "sha256-/oUYsC0lUCBory65VK+UHqCCsCspbL1Vgfcf1KUYqVw=",
        "owner": "nixos",
        "repo": "nixpkgs",
        "rev": "87848bf0cc4f87717fc813a4575f07330c3e743c",
        "type": "github"
      },
      "original": {
        "owner": "nixos",
        "ref": "nixpkgs-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "nixpkgs_3": {
      "locked": {
        "lastModified": 1760934318,
        "narHash": "sha256-/oUYsC0lUCBory65VK+UHqCCsCspbL1Vgfcf1KUYqVw=",
        "owner": "nixos",
        "repo": "nixpkgs",
        "rev": "87848bf0cc4f87717fc813a4575f07330c3e743c",
        "type": "github"
      },
      "original": {
        "owner": "nixos",
        "ref": "nixpkgs-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "nixpkgs_4": {
      "locked": {
        "lastModified": 1760934318,
        "narHash": "sha256-/oUYsC0lUCBory65VK+UHqCCsCspbL1Vgfcf1KUYqVw=",
        "owner": "nixos",
        "repo": "nixpkgs",
        "rev": "87848bf0cc4f87717fc813a4575f07330c3e743c",
        "type": "github"
      },
      "original": {
        "owner": "nixos",
        "ref": "nixpkgs-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "devshell": "devshell",
        "flake-aspects": "flake-aspects",
        "flake-file": "flake-file",
        "flake-parts": "flake-parts",
        "import-tree": "import-tree",
        "nix-auto-follow": "nix-auto-follow",
        "nix-unit": "nix-unit",
        "nixpkgs": "nixpkgs_3",
        "nixpkgs-lib": [
          "nixpkgs"
        ],
        "systems": "systems",
        "treefmt-nix": "treefmt-nix"
      }
    },
    "systems": {
      "locked": {
        "lastModified": 1681028828,
        "narHash": "sha256-Vy1rq5AaRuLzOxct8nz4T6wlgyUR7zLU309k9mBC768=",
        "owner": "nix-systems",
        "repo": "default",
        "rev": "da67096a3b9bf56a91d16901293e51ba5b49a27e",
        "type": "github"
      },
      "original": {
        "owner": "nix-systems",
        "repo": "default",
        "type": "github"
      }
    },
    "treefmt-nix": {
      "inputs": {
        "nixpkgs": "nixpkgs_4"
      },
      "locked": {
        "lastModified": 1760945191,
        "narHash": "sha256-ZRVs8UqikBa4Ki3X4KCnMBtBW0ux1DaT35tgsnB1jM4=",
        "owner": "numtide",
        "repo": "treefmt-nix",
        "rev": "f56b1934f5f8fcab8deb5d38d42fd692632b47c2",
        "type": "github"
      },
      "original": {
        "owner": "numtide",
        "repo": "treefmt-nix",
        "type": "github"
      }
    }
  },
  "root": "root",
  "version": 7
}
</file>

<file path="dev/flake.nix">
# DO-NOT-EDIT. This file was auto-generated using github:vic/flake-file.
# Use `nix run .#write-flake` to regenerate it.
{

  outputs = inputs: inputs.flake-parts.lib.mkFlake { inherit inputs; } (inputs.import-tree ./modules);

  inputs = {
    devshell = {
      url = "github:numtide/devshell";
    };
    flake-aspects = {
      url = "github:vic/flake-aspects";
    };
    flake-file = {
      url = "path:..";
    };
    flake-parts = {
      url = "github:hercules-ci/flake-parts";
    };
    import-tree = {
      url = "github:vic/import-tree";
    };
    nix-auto-follow = {
      url = "github:fzakaria/nix-auto-follow";
    };
    nix-unit = {
      inputs = {
        flake-parts = {
          follows = "flake-parts";
        };
        nixpkgs = {
          follows = "nixpkgs";
        };
        treefmt-nix = {
          follows = "treefmt-nix";
        };
      };
      url = "github:nix-community/nix-unit";
    };
    nixpkgs = {
      url = "github:nixos/nixpkgs/nixpkgs-unstable";
    };
    nixpkgs-lib = {
      follows = "nixpkgs";
    };
    systems = {
      url = "github:nix-systems/default";
    };
    treefmt-nix = {
      url = "github:numtide/treefmt-nix";
    };
  };

}
</file>

<file path="modules/dendritic/basic.nix">
{ inputs, lib, ... }:
{

  imports = [
    inputs.flake-file.flakeModules.default
  ];

  flake-file.inputs = {
    flake-file.url = lib.mkDefault "github:vic/flake-file";
  };
}
</file>

<file path="modules/dendritic/default.nix">
{ inputs, ... }:
{
  imports = [
    inputs.flake-file.flakeModules.default
    inputs.flake-file.flakeModules.import-tree
    inputs.flake-file.flakeModules.nix-auto-follow
    ./dendritic.nix
    ./basic.nix
    ./formatter.nix
    ./nixpkgs.nix
    ./systems.nix
  ];
}
</file>

<file path="modules/dendritic/dendritic.nix">
{ inputs, lib, ... }:
{

  imports = [
    (inputs.flake-parts.flakeModules.modules or { })
    (inputs.flake-file.flakeModules.import-tree or { })
    (inputs.flake-aspects.flakeModule or { })
  ];

  flake-file.inputs = {
    flake-parts.url = lib.mkDefault "github:hercules-ci/flake-parts";
    flake-aspects.url = lib.mkDefault "github:vic/flake-aspects";
  };

  flake-file.outputs = ''
    inputs: inputs.flake-parts.lib.mkFlake { inherit inputs; }
    (inputs.import-tree ./modules)
  '';

}
</file>

<file path="modules/dendritic/formatter.nix">
{ inputs, lib, ... }:
{

  imports = [
    inputs.treefmt-nix.flakeModule
  ];

  flake-file.inputs = {
    treefmt-nix.url = lib.mkDefault "github:numtide/treefmt-nix";
  };

  perSystem =
    { self', ... }:
    {
      packages.fmt = self'.formatter;
      treefmt = {
        programs = {
          nixfmt.enable = true;
          deadnix.enable = true;
          nixf-diagnose.enable = true;
          prettier.enable = true;
        };
        settings.on-unmatched = lib.mkDefault "fatal";
        settings.global.excludes = [
          "LICENSE"
          "flake.lock"
          "*/flake.lock"
          ".envrc"
          ".direnv/*"
          "*/.gitignore"
        ];
      };
    };

}
</file>

<file path="modules/dendritic/nixpkgs.nix">
{ lib, ... }:
{

  flake-file.inputs = {
    nixpkgs.url = lib.mkDefault "github:nixos/nixpkgs/nixpkgs-unstable";
    nixpkgs-lib.follows = lib.mkDefault "nixpkgs";
  };

}
</file>

<file path="modules/dendritic/systems.nix">
{ inputs, lib, ... }:
{

  flake-file.inputs = {
    systems.url = lib.mkDefault "github:nix-systems/default";
  };

  systems = lib.mkDefault (import inputs.systems);

}
</file>

<file path="modules/flake-parts-builder/_bootstrap.nix">
# --- flake-parts/_bootstrap.nix
{ lib }:
rec {
  # This nix file is used to minimally set up and bootstrap the `loadParts`
  # function which is then used to load all the modules in the
  #  `./flake-parts` directory. The user also has the option to remove
  # this file and directly load the `loadParts` function from
  # the `lib` attribute of the `github:tsandrini/flake-parts-builder`
  # flake, however, that brings an additional dependency to the project,
  # which may be undesirable for some and isn't really necessary.

  /*
    Main function for recursively traversing and loading all the modules
    in a provided flake-parts  directory.

    For more information and specifics on how this function works, see the
    doccomment of the `loadModules` function below.

    *Type*: `loadParts :: Path -> { name :: String; value :: AttrSet a; }`
  */
  loadParts = dir: flatten (mapModules dir (x: x));

  /*
    Recursively flattens a nested attrset into a list of just its values.

    *Type*: `flatten :: AttrSet a -> [a]`

    Example:
    ```nix title="Example" linenums="1"
    flatten {
      keyA = 10;
      keyB = "str20";
      keyC = {
        keyD = false;
        keyE = {
          a = 10;
          b = "20";
          c = false;
        };
      };
    }
     => [ 10 "str20" false 10 "20" false ]
    ```
  */
  flatten = attrs: lib.collect (x: !lib.isAttrs x) attrs;

  /*
    Apply a map to every attribute of an attrset and then filter the resulting
    attrset based on a given predicate function.

    *Type*: `mapFilterAttrs :: (AttrSet b -> Bool) -> (AttrSet a -> AttrSet b) -> AttrSet a -> AttrSet b`
  */
  mapFilterAttrs =
    pred: f: attrs:
    lib.filterAttrs pred (lib.mapAttrs' f attrs);

  /*
    Recursively read a directory and apply a provided function to every `.nix`
    file. Returns an attrset that reflects the filenames and directory
    structure of the root.

    Notes:

     1. Files and directories starting with the `_` or `.git` prefix will be
        completely ignored.

     2. If a directory with a `myDir/default.nix` file will be encountered,
        the function will be applied to the `myDir/default.nix` file
        instead of recursively loading `myDir` and applying it to every file.

    *Type*: `mapModules :: Path -> (Path -> AttrSet a) -> { name :: String; value :: AttrSet a; }`

    Example:
    ```nix title="Example" linenums="1"
    mapModules ./modules import
      => { hardware = { moduleA = { ... }; }; system = { moduleB = { ... }; }; }

    mapModules ./hosts (host: mkHostCustomFunction myArg host)
      => { hostA = { ... }; hostB = { ... }; }
    ```
  */
  mapModules =
    dir: fn:
    mapFilterAttrs (n: v: v != null && !(lib.hasPrefix "_" n) && !(lib.hasPrefix ".git" n)) (
      n: v:
      let
        path = "${toString dir}/${n}";
      in
      if v == "directory" && builtins.pathExists "${path}/default.nix" then
        lib.nameValuePair n (fn path)
      else if v == "directory" then
        lib.nameValuePair n (mapModules path fn)
      else if v == "regular" && n != "default.nix" && lib.hasSuffix ".nix" n then
        lib.nameValuePair (lib.removeSuffix ".nix" n) (fn path)
      else
        lib.nameValuePair "" null
    ) (builtins.readDir dir);
}
</file>

<file path="modules/flake-parts-builder/default.nix">
flake-parts-path:
{ lib, ... }:
let
  imports = lib.flatten (parts ++ meta);

  parts = bootstrap.loadParts flake-parts-path;
  bootstrap = import ./_bootstrap.nix { inherit lib; };

  meta = lib.pipe "${flake-parts-path}/_meta" [
    bootstrap.loadParts
    (lib.map importMeta)
  ];

  importMeta = f: metaToConfig (import f);

  metaToConfig = meta: {
    flake-file = {
      inputs = if meta ? inputs then meta.inputs else { };
      nixConfig = {
        extraSubstituters = if meta ? extraSubstituters then meta.extraSubstituters else [ ];
        extraTrustedPublicKeys = if meta ? extraTrustedPublicKeys then meta.extraTrustedPublicKeys else [ ];
      };
    };
  };

in
{
  inherit imports;
}
</file>

<file path="modules/options/check-hooks.nix">
{
  lib,
  ...
}:
let
  description = ''
    Hooks to run on check-flake-file

    Ordered by their index field before being run.
    Run on outside flake root, any changes at pwd
    are temporary.
  '';
  hook = lib.types.submodule {
    options = {
      # we use this as poor-man's DAG.
      index = lib.mkOption {
        description = "Index of this hook to run. For user hooks use >100.";
        type = lib.types.int;
        default = 100;
      };
      program = lib.mkOption {
        description = ''
          Function from pkgs to program (derivation with meta.mainProgram).

          Takes the path to the flake root directory as first argument.
        '';
        type = lib.types.functionTo lib.types.unspecified;
      };
    };
  };

in
{
  options.flake-file.check-hooks = lib.mkOption {
    inherit description;
    default = [ ];
    type = lib.types.listOf hook;
  };

}
</file>

<file path="modules/options/default.nix">
{
  imports = [
    ./flake-file.nix
    ./inputs.nix
    ./outputs.nix
    ./do-not-edit.nix
    ./formatter.nix
    ./prune-lock.nix
    ./write-hooks.nix
    ./check-hooks.nix
  ];
}
</file>

<file path="modules/options/do-not-edit.nix">
{ lib, ... }:
{
  options.flake-file.do-not-edit = lib.mkOption {
    default = ''
      # DO-NOT-EDIT. This file was auto-generated using github:vic/flake-file.
      # Use `nix run .#write-flake` to regenerate it.
    '';
    description = "header comment";
    type = lib.types.str;
    apply =
      value:
      lib.pipe value [
        (s: if lib.hasPrefix "#" s then s else "# " + s)
        (s: if lib.hasSuffix "\n" s then s else s + "\n")
      ];
    example = lib.literalExample ''
      "DO-NOT-EDIT"
    '';
  };
}
</file>

<file path="modules/options/flake-file.nix">
{ lib, ... }:
{
  options.flake-file = lib.mkOption {
    description = "A nix flake.";
    default = { };
    type = lib.types.submodule {
      options = {
        description = lib.mkOption {
          default = "";
          description = "Flake description";
          type = lib.types.str;
        };
        nixConfig = lib.mkOption {
          default = { };
          description = "nix config";
          type = lib.types.attrs;
        };
      };
    };
  };
}
</file>

<file path="modules/options/formatter.nix">
{ lib, ... }:
{
  options.flake-file.formatter = lib.mkOption {
    description = ''
      Formatter for flake.nix file.

      It is a function from pkgs to a program (package with meta.mainProgram).

      The command takes flake.nix as first argument.
    '';
    type = lib.types.functionTo lib.types.unspecified;
    default = pkgs: pkgs.nixfmt-rfc-style;
    example = lib.literalExample ''
      pkgs: pkgs.nixfmt-rfc-style
    '';
  };
}
</file>

<file path="modules/options/inputs.nix">
{ lib, ... }:
let
  follows-option = lib.mkOption {
    description = "flake input path to follow";
    default = "";
    type = lib.types.str;
  };

  inputs-follow-option = lib.mkOption {
    description = "input dependencies";
    default = { };
    type = lib.types.lazyAttrsOf (
      lib.types.submodule {
        options = {
          follows = follows-option;
          inputs = inputs-follow-option;
        };
      }
    );
  };

  inputs-option = lib.mkOption {
    default = { };
    description = "Flake inputs";
    type = lib.types.lazyAttrsOf (
      lib.types.submodule {
        options = {
          url = lib.mkOption {
            description = "source url";
            default = "";
            type = lib.types.str;
          };
          type = lib.mkOption {
            description = "type of flake reference";
            default = null;
            type = lib.types.nullOr (
              lib.types.enum [
                "indirect"
                "path"
                "git"
                "mercurial"
                "tarball"
                "file"
                "github"
                "gitlab"
                "sourcehut"
              ]
            );
          };
          owner = lib.mkOption {
            description = "owner of the repository";
            default = "";
            type = lib.types.str;
          };
          repo = lib.mkOption {
            description = "name of the repository";
            default = "";
            type = lib.types.str;
          };
          path = lib.mkOption {
            description = "path of the flake";
            default = "";
            type = lib.types.str;
          };
          id = lib.mkOption {
            description = "flake registry id";
            default = "";
            type = lib.types.str;
          };
          dir = lib.mkOption {
            description = "subdirectory of the flake";
            default = "";
            type = lib.types.str;
          };
          narHash = lib.mkOption {
            description = "NAR hash of the flake";
            default = "";
            type = lib.types.str;
          };
          rev = lib.mkOption {
            description = "Git/Mercurial commit hash";
            default = "";
            type = lib.types.str;
          };
          ref = lib.mkOption {
            description = "Git/Mercurial branch or tag name";
            default = "";
            type = lib.types.str;
          };
          host = lib.mkOption {
            description = "custom host for github/gitlab/sourcehut";
            default = "";
            type = lib.types.str;
          };
          flake = lib.mkOption {
            description = "is it a flake?";
            type = lib.types.bool;
            default = true;
          };
          follows = follows-option;
          inputs = inputs-follow-option;
        };
      }
    );
  };

in
{
  options.flake-file.inputs = inputs-option;
}
</file>

<file path="modules/options/outputs.nix">
{ lib, ... }:
{
  options.flake-file.outputs = lib.mkOption {
    description = ''
      Nix code for outputs function.

      We recommend this function code to be short, used only to import a file.
    '';
    type = lib.types.str;
    default = ''
      inputs: import ./outputs.nix inputs
    '';
    example = lib.literalExample ''
      inputs: inputs.flake-parts.lib.mkFlake { inherit inputs; } ./modules
    '';
  };
}
</file>

<file path="modules/options/prune-lock.nix">
{ lib, config, ... }:
let
  HOOK_INDEX = 1;

  prune-lock-option = lib.mkOption {
    default = { };
    type = lib.types.submodule {
      options = {
        enable = lib.mkEnableOption "Should we automatically prune flake.lock";
        program = lib.mkOption {
          description = ''
            Function from pkgs to an exe derivation used to prune flake.lock.

            The program takes the flake.lock location as first positional argument
            and is expected to produce a pruned version into the second argument.

            The output is expected to be deterministic.
          '';
          example = lib.literalExample (builtins.readFile ./../prune-lock/_nothing.nix);
          type = lib.types.functionTo lib.types.unspecified;
          default = import ./../prune-lock/_nothing.nix;
        };
      };
    };
  };

  prune-lock = config.flake-file.prune-lock;
  prune-cmd = pkgs: pkgs.lib.getExe (prune-lock.program pkgs);
  prune-lock-run =
    pkgs:
    pkgs.writeShellApplication {
      name = "prune-lock";
      text = ''
        nix flake metadata > /dev/null
        ${prune-cmd pkgs} flake.lock pruned.lock
        mv pruned.lock flake.lock
      '';
    };

  prune-lock-check =
    pkgs:
    pkgs.writeShellApplication {
      name = "prune-lock-check";
      runtimeInputs = [ pkgs.diffutils ];
      text = ''
        ${prune-cmd pkgs} "$1"/flake.lock pruned.lock
        diff -u pruned.lock "$1"/flake.lock
      '';
    };

  write-hooks = lib.optionals prune-lock.enable [
    {
      index = HOOK_INDEX;
      program = prune-lock-run;
    }
  ];

  check-hooks = lib.optionals prune-lock.enable [
    {
      index = HOOK_INDEX;
      program = prune-lock-check;
    }
  ];
in
{
  options.flake-file.prune-lock = prune-lock-option;
  config.flake-file = { inherit write-hooks check-hooks; };
}
</file>

<file path="modules/options/write-hooks.nix">
{ lib, ... }:
let
  description = ''
    Hooks to run on .#write-flake

    Ordered by their index field before being run.
    Run on the working copy, so any changes will be
    seen by version control.
  '';
  hook = lib.types.submodule {
    options = {
      # we use this as poor-man's DAG.
      index = lib.mkOption {
        description = "Index of this hook to run. For user hooks use >100.";
        type = lib.types.int;
        default = 100;
      };
      program = lib.mkOption {
        description = ''
          Function from pkgs to program (package with meta.mainProgram).
        '';
        type = lib.types.functionTo lib.types.unspecified;
      };
    };
  };

in
{
  options.flake-file.write-hooks = lib.mkOption {
    inherit description;
    default = [ ];
    type = lib.types.listOf hook;
  };

}
</file>

<file path="modules/prune-lock/_nothing.nix">
# Example pruning app that does nothing.
pkgs:
pkgs.writeShellApplication {
  name = "cp";
  text = ''
    cp "$1" "$2"
  '';
}
</file>

<file path="modules/prune-lock/allfollow.nix">
{ lib, inputs, ... }:
{
  flake-file.inputs.allfollow.url = lib.mkDefault "github:spikespaz/allfollow";
  flake-file.prune-lock.enable = lib.mkDefault (inputs ? allfollow);
  flake-file.prune-lock.program =
    pkgs:
    pkgs.writeShellApplication {
      name = "allfollow";
      runtimeInputs = [ inputs.allfollow.packages.${pkgs.system}.default ];
      text = ''
        allfollow prune --pretty "$1" -o "$2"
      '';
    };
}
</file>

<file path="modules/prune-lock/nix-auto-follow.nix">
{ lib, inputs, ... }:
{
  flake-file.inputs.nix-auto-follow.url = lib.mkDefault "github:fzakaria/nix-auto-follow";
  flake-file.prune-lock.enable = lib.mkDefault (inputs ? nix-auto-follow);
  flake-file.prune-lock.program =
    pkgs:
    pkgs.writeShellApplication {
      name = "nix-auto-follow";
      runtimeInputs = [ inputs.nix-auto-follow.packages.${pkgs.system}.default ];
      text = ''
        auto-follow "$1" > "$2"
      '';
    };
}
</file>

<file path="modules/default.nix">
let
  flakeModules = {
    inherit
      default
      allfollow
      nix-auto-follow
      dendritic
      import-tree
      ;
  };

  default.imports = [
    ./options
    ./write-flake.nix
  ];

  allfollow.imports = [ ./prune-lock/allfollow.nix ];

  nix-auto-follow.imports = [ ./prune-lock/nix-auto-follow.nix ];

  import-tree.imports = [ ./import-tree.nix ];

  dendritic.imports = [ ./dendritic ];

  lib.flakeModules.flake-parts-builder =
    path:
    { flake-parts-lib, ... }:
    {
      imports = [
        (flake-parts-lib.importApply ./flake-parts-builder path)
      ];
    };

  templates.default = {
    description = "default template";
    path = ./../templates/default;
  };

  templates.dendritic = {
    description = "dendritic template";
    path = ./../templates/dendritic;
  };

  templates.parts = {
    description = "flake-parts-builder template";
    path = ./../templates/parts;
  };
in
{
  inherit flakeModules templates lib;
}
</file>

<file path="modules/import-tree.nix">
{ lib, ... }:
{
  flake-file.inputs.import-tree.url = lib.mkDefault "github:vic/import-tree";
}
</file>

<file path="modules/write-flake.nix">
{
  lib,
  config,
  inputs,
  ...
}:
let
  inherit (import ./../dev/modules/_lib lib) inputsExpr isNonEmptyString;

  flake-file = config.flake-file;

  template = ''
    {
      <description>
      <outputs>
      <nixConfig>
      <inputs>
    }
  '';

  unformatted = lib.pipe template [
    (lib.replaceString "<description>" description)
    (lib.replaceString "<outputs>" outputs)
    (lib.replaceString "<nixConfig>" nixConfig)
    (lib.replaceString "<inputs>" flakeInputs)
    addHeader
  ];

  # expr to code
  nixCode =
    x:
    if lib.isStringLike x then
      lib.strings.escapeNixString x
    else if lib.isAttrs x then
      lib.pipe x [
        (lib.mapAttrsToList (name: value: ''${name} = ${nixCode value}; ''))
        (values: ''{ ${lib.concatStringsSep " " values} }'')
      ]
    else if lib.isList x then
      lib.pipe x [
        (lib.map nixCode)
        (values: ''[ ${lib.concatStringsSep " " values} ]'')
      ]
    else if x == true then
      "true"
    else if x == false then
      "false"
    else
      toString x;

  description =
    if isNonEmptyString flake-file.description then
      ''
        description = ${nixCode flake-file.description};
      ''
    else
      "";

  outputs = ''
    outputs = ${flake-file.outputs};
  '';

  nixConfig =
    if flake-file.nixConfig != { } then
      ''
        nixConfig = ${nixCode flake-file.nixConfig};
      ''
    else
      "";

  flakeInputs = ''
    inputs = ${nixCode (inputsExpr flake-file.inputs)};
  '';

  addHeader =
    code: if isNonEmptyString flake-file.do-not-edit then flake-file.do-not-edit + code else code;

  formatted =
    pkgs:
    pkgs.stdenvNoCC.mkDerivation {
      name = "flake-formatted";
      passAsFile = [ "unformatted" ];
      inherit unformatted;
      phases = [ "format" ];
      format = ''
        cp $unformattedPath flake.nix
        ${pkgs.lib.getExe (flake-file.formatter pkgs)} flake.nix
        cp flake.nix $out
      '';
    };

in
{
  config.perSystem =
    { pkgs, ... }:
    {
      packages.write-flake =
        let
          hooks = lib.pipe config.flake-file.write-hooks [
            (lib.sortOn (i: i.index))
            (map (i: pkgs.lib.getExe (i.program pkgs)))
            (lib.concatStringsSep "\n")
          ];
        in
        pkgs.writeShellApplication {
          name = "write-flake";
          text = ''
            cp ${formatted pkgs} flake.nix
            ${hooks}
          '';
        };

      checks.check-flake-file =
        let
          hooks = lib.pipe config.flake-file.check-hooks [
            (lib.sortOn (i: i.index))
            (map (i: pkgs.lib.getExe (i.program pkgs)))
            (map (p: "${p} ${inputs.self}"))
            (lib.concatStringsSep "\n")
          ];
        in
        pkgs.runCommand "check-flake-file"
          {
            nativeBuildInputs = [ pkgs.diffutils ];
          }
          ''
            set -e
            diff -u ${formatted pkgs} ${inputs.self}/flake.nix
            ${hooks}
            touch $out
          '';

    };

}
</file>

<file path="templates/default/modules/default.nix">
{ inputs, ... }:
{

  imports = [
    inputs.flake-file.flakeModules.default
  ];

  systems = import inputs.systems;

  flake-file.inputs = {
    flake-file.url = "github:vic/flake-file";
    flake-parts.url = "github:hercules-ci/flake-parts";
    nixpkgs.url = "github:nixos/nixpkgs/nixpkgs-unstable";
    systems.url = "github:nix-systems/default";
  };

}
</file>

<file path="templates/default/flake.nix">
# DO-NOT-EDIT. This file was auto-generated using github:vic/flake-file.
# Use `nix run .#write-flake` to regenerate it.
{

  outputs = inputs: import ./outputs.nix inputs;

  inputs = {
    flake-file = {
      url = "github:vic/flake-file";
    };
    flake-parts = {
      url = "github:hercules-ci/flake-parts";
    };
    nixpkgs = {
      url = "github:nixos/nixpkgs/nixpkgs-unstable";
    };
    systems = {
      url = "github:nix-systems/default";
    };
  };

}
</file>

<file path="templates/default/outputs.nix">
inputs: inputs.flake-parts.lib.mkFlake { inherit inputs; } ./modules
</file>

<file path="templates/dendritic/modules/dendritic.nix">
{ inputs, ... }:
{
  imports = [
    inputs.flake-file.flakeModules.dendritic
  ];
}
</file>

<file path="templates/dendritic/flake.nix">
# DO-NOT-EDIT. This file was auto-generated using github:vic/flake-file.
# Use `nix run .#write-flake` to regenerate it.
{

  outputs = inputs: inputs.flake-parts.lib.mkFlake { inherit inputs; } (inputs.import-tree ./modules);

  inputs = {
    flake-aspects = {
      url = "github:vic/flake-aspects";
    };
    flake-file = {
      url = "github:vic/flake-file";
    };
    flake-parts = {
      url = "github:hercules-ci/flake-parts";
    };
    import-tree = {
      url = "github:vic/import-tree";
    };
    nix-auto-follow = {
      url = "github:fzakaria/nix-auto-follow";
    };
    nixpkgs = {
      url = "github:nixos/nixpkgs/nixpkgs-unstable";
    };
    nixpkgs-lib = {
      follows = "nixpkgs";
    };
    systems = {
      url = "github:nix-systems/default";
    };
    treefmt-nix = {
      url = "github:numtide/treefmt-nix";
    };
  };

}
</file>

<file path="templates/parts/flake-parts/_meta/flake-root.nix">
{
  description = "Provides `config.flake-root` variable pointing to the root of the flake project.";

  inputs = { };
  extraTrustedPublicKeys = [ ];
  extraSubstituters = [ ];
}
</file>

<file path="templates/parts/flake-parts/_meta/systems.nix">
{
  description = "Sets up the default `systems` of flake-parts using `github:nix-systems/default`.";

  inputs = {
    systems.url = "github:nix-systems/default";
  };

  extraTrustedPublicKeys = [ ];
  extraSubstituters = [ ];
}
</file>

<file path="templates/parts/flake-parts/_meta/treefmt.nix">
{
  description = "Bindings for the treefmt formatter and a basic treefmt configuration.";

  inputs = {
    treefmt-nix.url = "github:numtide/treefmt-nix";
  };

  dependencies = [ "flake-root" ];
  #extraTrustedPublicKeys = [ "numtide.cachix.org-1:2ps1kLBUWjxIneOy1Ik6cQjb41X0iXVXeHigGmycPPE=" ];
  #extraSubstituters = [ "https://numtide.cachix.org" ];
}
</file>

<file path="templates/parts/flake-parts/flake-root.nix">
# --- flake-parts/flake-root.nix
{ lib, ... }:
{
  # NOTE This is probably conflicting with https://github.com/srid/flake-root/
  # however it essentially fully replaces that functionality with a simple
  # option (thanks to the known structure) so it should be probably fine.
  options.flake-root = lib.mkOption {
    type = lib.types.path;
    description = ''
      Provides `config.flake-root` with the path to the flake root.
    '';
    default = ../.;
  };
}
</file>

<file path="templates/parts/flake-parts/systems.nix">
# --- flake-parts/systems.nix
{ inputs, ... }:
{
  # NOTE We use the default `systems` defined by the `nix-systems` flake, if
  # you need any additional systems, simply add them in the following manner
  #
  # `systems = (import inputs.systems) ++ [ "armv7l-linux" ];`
  systems = import inputs.systems;
}
</file>

<file path="templates/parts/flake.nix">
# DO-NOT-EDIT. This file was auto-generated using github:vic/flake-file.
# Use `nix run .#write-flake` to regenerate it.
{

  outputs = inputs: import ./outputs.nix inputs;

  nixConfig = {
    extraSubstituters = [ ];
    extraTrustedPublicKeys = [ ];
  };

  inputs = {
    flake-file = {
      url = "github:vic/flake-file";
    };
    flake-parts = {
      url = "github:hercules-ci/flake-parts";
    };
    nixpkgs = {
      url = "github:nixos/nixpkgs/nixpkgs-unstable";
    };
    systems = {
      url = "github:nix-systems/default";
    };
    treefmt-nix = {
      url = "github:numtide/treefmt-nix";
    };
  };

}
</file>

<file path="templates/parts/outputs.nix">
inputs:
inputs.flake-parts.lib.mkFlake { inherit inputs; } {
  flake-file.inputs = {
    flake-file.url = "github:vic/flake-file";
    flake-parts.url = "github:hercules-ci/flake-parts";
    nixpkgs.url = "github:nixos/nixpkgs/nixpkgs-unstable";
  };

  imports = [
    inputs.flake-file.flakeModules.default
    (inputs.flake-file.lib.flakeModules.flake-parts-builder ./flake-parts)
  ];
}
</file>

<file path="templates/.gitignore">
*/flake.lock
</file>

<file path="flake.nix">
{
  outputs = _: import ./modules;
}
</file>

<file path="LICENSE">
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
</file>

<file path="README.md">
<!-- Badges -->
<p align="right">
  <a href="https://nixos.org/"> <img src="https://img.shields.io/badge/Nix-Flake-informational?logo=nixos&logoColor=white" alt="Nix Flake"/> </a>
  <a href="https://github.com/vic/flake-file/actions">
  <img src="https://github.com/vic/flake-file/workflows/flake-check/badge.svg" alt="CI Status"/> </a>
  <a href="LICENSE"> <img src="https://img.shields.io/github/license/vic/flake-file" alt="License"/> </a>
</p>

# flake-file — Generate flake.nix from flake-parts modules.

**flake-file** lets you generate a clean, maintainable `flake.nix` from modular options, using [flake-parts](https://flake.parts/).

It makes your flake configuration modular and based on the Nix module system. This means you can use
`lib.mkDefault` or anything you normally do with Nix modules, and have them reflected in flake schema values.

<table><tr><td>
  
## Features

- Flake definition aggregated from all flake-parts modules.
- Schema as [options](https://github.com/vic/flake-file/blob/main/modules/options/default.nix).
- Syntax for nixConfig and follows is the same as in flakes.
- `flake check` ensures files are up to date.
- App for generator: `nix run .#write-flake`
- Custom do-not-edit header.
- Automatic flake.lock [flattening](#automatic-flakelock-flattening).
- Incrementally add [flake-parts-builder](#parts_templates) templates.
- Pick flakeModules for different feature sets.
- [Dendritic](https://vic.github.io/dendrix/Dendritic.html) flake template.

</td><td>

<img width="400" height="400" alt="image" src="https://github.com/user-attachments/assets/2c0b2208-2f65-4fb3-b9df-5cf78dcad0e7" />

> this cute ouroboros is puking itself out.

</td></tr></table>

---

## Table of Contents

- [Who?](#who-is-this-for)
- [What?](#what-is-flake-file)
- [Getting Started](#getting-started-try-it-now)
- [Usage](#usage)
- [Available Options](#available-options)
- [About the Flake `output` function](#about-the-flake-output-function)
- [Automatic flake.lock flattening](#automatic-flakelock-flattening)
- [Migration Guide](#migration-guide)
- [Development](#development)

---

## Who is this for?

- Nix users who want to keep their `flake.nix` modular and maintainable
- Anyone using [flake-parts](https://flake.parts/) and looking to automate or simplify flake input management
- Teams or individuals who want to share and reuse flake modules across projects

---

## What is flake-file?

flake-file lets you make your `flake.nix` dynamic and modular. Instead of maintaining a single, monolithic `flake.nix`, you define your flake inputs in separate modules _close_ to where their inputs are used. flake-file then automatically generates a clean, up-to-date `flake.nix` for you.

- **Keep your flake modular:** Manage flake inputs just like the rest of your Nix configuration.
- **Automatic updates:** Regenerate your `flake.nix` with a single command whenever your options change.
- **Flake as dependency manifest:** Use `flake.nix` only for declaring dependencies, not for complex Nix code.
- **Share and reuse modules:** Teams can collaborate on and share flake modules across projects, including their dependencies.

> Real-world examples: [vic/vix](https://github.com/vic/vix) uses flake-file. Our [`dev/`](https://github.com/vic/flake-file/blob/main/dev) directory also uses flake-file to test this repo. [More examples on GitHub](https://github.com/search?q=%22vic%2Fflake-file%22+language%3ANix&type=code).

---

## Getting Started (try it now!)

To get started quickly, create a new flake based on our [dendritic](https://github.com/vic/flake-file/tree/main/templates/dendritic) template:

```shell
nix flake init -t github:vic/flake-file#dendritic
nix run ".#write-flake"       # regenerate flake.nix and flake.lock
cat flake.nix                 # flake.nix built from your options
nix flake check               # check that flake.nix is up to date
```

> [!TIP]
> See the [Migration Guide](#migration-guide) if you're moving from an existing flake.

---

## Usage

The following is a complete example from our [`templates/dendritic`](https://github.com/vic/flake-file/blob/main/templates/dendritic) template. It imports all modules from [`flake-file.flakeModules.dendritic`](https://github.com/vic/flake-file/tree/main/modules/dendritic).

```nix
{ inputs, lib, ... }:
{
  # That's it! Importing this module will add dendritic-setup inputs to your flake.
  imports = [ inputs.flake-file.flakeModules.dendritic ];

  # Define flake attributes on any flake-pars module:
  flake-file = {
    description = "My Awesome Flake";
    inputs.nixpkgs.url = lib.mkDefault "github:NixOS/nixpkgs/nixpkgs-unstable";
    inputs.nixpkgs-lib.follows = "nixpkgs";
  };
}
```

### Available flakeModules

#### [`flakeModules.default`](https://github.com/vic/flake-file/tree/main/modules/default.nix)

- Defines `flake-file` options.
- Exposes `packages.write-flake`.
- Exposes flake checks for generated files.

#### [`flakeModules.import-tree`](https://github.com/vic/flake-file/tree/main/modules/import-tree.nix)

- Adds [import-tree](https://github.com/vic/import-tree)

#### [`lib.flakeModules.flake-parts-builder`](https://github.com/vic/flake-file/tree/main/modules/flake-parts-builder/default.nix)

- Includes flake-parts-builder's `_bootstrap.nix`.
- Uses bootstrap to load parts from ./flake-parts
- Uses bootstrap to load ./flake-parts/\_meta as flake-file configs.

#### [`flakeModules.allfollow`](https://github.com/vic/flake-file/tree/main/modules/prune-lock/allfollow.nix)

- Enables [automatic flake.lock flattening](#automatic-flakelock-flattening) using [spikespaz/allfollow](https://github.com/spikespaz/allfollow)

#### [`flakeModules.nix-auto-follow`](https://github.com/vic/flake-file/tree/main/modules/prune-lock/nix-auto-follow.nix)

- Enables [automatic flake.lock flattening](#automatic-flakelock-flattening) using [fzakaria/nix-auto-follow](https://github.com/fzakaria/nix-auto-follow)

#### [`flakeModules.dendritic`](https://github.com/vic/flake-file/tree/main/modules/dendritic/default.nix)

- Includes flakeModules.default.
- Includes flakeModules.import-tree.
- Includes flakeModules.nix-auto-follow.
- Enables [`flake-parts`](https://github.com/hercules-ci/flake-parts).
- Enables [`flake-aspects`](https://github.com/vic/flake-aspects).
- Sets `output` function to `import-tree ./modules`.
- Adds `treefmt-nix` input.
- Enables formatters: `nixfmt`, `deadnix`, and `nixf-diagnose`.

### Flake Templates

#### `default` template

A more basic, explicit setup.

```nix
# See templates/default
{ inputs, ... }: {
  imports = [
    inputs.flake-file.flakeModules.default
  ];

  flake-file.inputs = {
    flake-file.url = "github:vic/flake-file";
    flake-parts.url = "github:hercules-ci/flake-parts";
    nixpkgs.url = "github:nixos/nixpkgs/nixpkgs-unstable";
    systems.url = "github:nix-systems/default";
  };

  systems = import inputs.systems;
}
```

> [!IMPORTANT]
> Use `nix run .#write-flake` to generate.

> [!TIP]
> You can use the `write-flake` app as part of a devshell or git hook.

#### `dendritic` template

A template for dendritic setups; includes `flakeModules.dendritic`.

#### `parts` template

A template that uses `lib.flakeModules.flake-parts-builder`.

---

## Available Options

Options use the same attributes as the flake schema. See below for details.

| Option                                          | Description                       |
| ----------------------------------------------- | --------------------------------- |
| `flake-file.description`                        | Sets the flake description        |
| `flake-file.nixConfig`                          | Attrset for flake-level nixConfig |
| `flake-file.inputs.<name>.url`                  | URL for a flake input             |
| `flake-file.inputs.<name>.flake`                | Boolean, is input a flake?        |
| `flake-file.inputs.<name>.inputs.<dep>.follows` | Tree of dependencies to follow    |

Example:

```nix
flake-file = {
  description = "my awesome flake";
  nixConfig = {}; # an attrset. currently not typed.
  inputs.<name>.url = "github:foo/bar";
  inputs.<name>.flake = false;
  inputs.<name>.inputs.nixpkgs.follows = "nixpkgs";
};
```

> [!TIP]
> See also, [options.nix](https://github.com/vic/flake-file/blob/main/modules/options/default.nix).

---

## About the Flake `output` function

The `flake-file.output` option is a literal Nix expression. You cannot convert a Nix function value into a string for including in the generated flake file.

It defaults to:

```nix
inputs: import ./outputs.nix inputs
```

We recommend using this default, as it keeps your flake file focused on definitions of inputs and nixConfig. All Nix logic is moved to `outputs.nix`. Set this option only if you want to load another file with [a Nix one-liner](https://github.com/vic/flake-file/blob/main/modules/dendritic/dendritic.nix), but not for including a large Nix code string in it.

---

<a name="parts_templates"></a>

## Add flake-parts-builder templates

Tired of endlessly repeating tiny flake-parts modules or copy-pasting
snippets between your projects? No more!

[flake-parts-builder](https://github.com/tsandrini/flake-parts-builder)
lets you _incrementally_ add templated parts.
This is much better than normal flake templates, since flake-parts templates
can be added or removed at any time, not only at project initialization.

```nix
{ inputs, ... }: {
  imports = [
    (inputs.flake-file.lib.flakeModules.flake-parts-builder ./flake-parts)
  ];
}
```

> [!IMPORTANT]
> Use `github:vic/flake-parts-builder/write-meta` until [flake-parts-builder#60](https://github.com/tsandrini/flake-parts-builder/pull/60) gets merged. This branch will also write each parts meta.nix file, so it can be used by flake-file to manage your flake.nix.

> [!WARNING]
> Only use `flake-parts-builder add` subcommand, since `init` will _overwrite_ the flake.nix file that is already being managed by flake-file.

```shell
nix run github:vic/flake-parts-builder/write-meta -- add --write-meta --parts systems,treefmt $PWD
```

## Hooks for write-flake and checks

You can add custom commands to be run whenever your flake.nix has been
written or checked.

> [!TIP]
> See `flake-file.write-hooks` and `flake-file.check-hooks` options.

## Automatic flake.lock flattening

You can use the `prune-lock` [options](https://github.com/vic/flake-file/blob/main/modules/options.nix)
to specify a command that `flake-file` will use whenever your flake.nix file is generated
to flatten your flake.lock dependency tree.

For flattening mechanisms we provide:

- [`flakeModules.allfollow`](https://github.com/vic/flake-file/blob/main/modules/prune-lock/allfollow.nix) that enables this using [`spikespaz/allfollow`](https://github.com/spikespaz/allfollow)
- [`flakeModules.nix-auto-follow`](https://github.com/vic/flake-file/blob/main/modules/prune-lock/nix-auto-follow.nix) that enables this using [`fzakaria/nix-auto-follow`](https://github.com/fzakaria/nix-auto-follow)

```nix
{ inputs, ... }:
{
  imports = [
    inputs.flake-file.flakeModules.nix-auto-follow
    # or optionally
    #inputs.flake-file.flakeModules.allfollow
  ];
}
```

---

## Migration Guide

This section outlines the recommended steps for adopting `flake-file` in your own repository.

1. **Prerequisite:** Ensure you have already adopted [flake-parts](https://flake.parts).
2. **Add Inputs:** In your current `flake.nix`, add the following input:

   ```nix
   flake-file.url = "github:vic/flake-file";
   ```

3. **Move Outputs:** Copy the contents of your `outputs` function into a file `./outputs.nix`:

   ```nix
   # outputs.nix -- this is the contents of your `outputs` function from the original flake.nix file.
   inputs: inputs.flake-parts.lib.mkFlake { inherit inputs; } {
     imports = [
       ./modules/inputs.nix # Add this for step 4.
       # Feel free to split ./modules/inputs.nix into other modules as you see fit.
       # If you end having lots of modules, consider using import-tree for auto importing them.
     ];
   }
   ```

4. **Move Inputs:** Copy your current flake.nix file as a flake-parts module (e.g., `modules/inputs.nix`):

> [!IMPORTANT]
> Make sure you `git add` so that new files are visible to Nix.

```nix
# modules/inputs.nix
{ inputs, ... }:
{
  imports = [
   inputs.flake-file.flakeModules.default # flake-file options.
  ];
  flake-file = {
    inputs = {
      flake-file.url = "github:vic/flake-file";
      # ... all your other original flake inputs here.
    };
    nixConfig = { }; # if you had any.
    description = "Your flake description";
  };
}
```

5. **Backup:** Back up your flake.nix into flake.nix.bak before regenerating it.
6. **Generate:** Execute `nix run .#write-flake` to generate flake.nix.
7. **Verify:** Check flake.nix and if everything is okay, remove the backup file.

You are done! Now you can split dependencies from `modules/inputs.nix` into other flake-part modules as you see fit:

```nix
# ./modules/<name>.nix -- Replace `<name>` with some dependency.
{ inputs, lib, ... }: {
  flake-file.inputs.<name>.url = ...;

  # Example usage: include the flakeModule once it has been added to flake.nix.
  imports = lib.optionals (inputs ? <name>) [ inputs.<name>.flakeModule ];
}
```

---

## Development

Use `nix develop ./dev` or with direnv: `use flake ./dev`.

```shell
[[general commands]]

  check - run flake check
  fmt   - format all files in repo
  menu  - prints this menu
  regen - regenerate all flake.nix files in this repo
```

---

## Contributing & Support

- Found a bug or have a feature request? [Open an issue](https://github.com/vic/flake-file/issues).
- Contributions are welcome!

---

Made with <3 by [@vic](https://x.com/oeiuwq)
</file>

</files>
