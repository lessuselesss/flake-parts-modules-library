This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    ci.yml
create-directories.bash
flake.nix
home-manager.nix
lib.nix
LICENSE
mount-file.bash
nixos.nix
README.org
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/ci.yml">
name: CI
on: [push, pull_request, merge_group]
jobs:
  nix_parsing:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: cachix/install-nix-action@v12
      - name: Check Nix parsing
        run: |
          find . -name "*.nix" -exec nix-instantiate --parse --quiet {} >/dev/null +
  nix_formatting:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: cachix/install-nix-action@v12
        with:
          nix_path: nixpkgs=channel:nixos-unstable
      - name: Check Nix formatting
        run: |
          nix-shell -p nixpkgs-fmt --run "nixpkgs-fmt --check ."
  shell_formatting:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: cachix/install-nix-action@v12
        with:
          nix_path: nixpkgs=channel:nixos-unstable
      - name: Check shell script formatting
        run: |
          find . -name "*.*sh" -exec nix-shell -p shfmt --run "shfmt -i 4 -d {}" \;
  shell_error_checking:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: cachix/install-nix-action@v12
        with:
          nix_path: nixpkgs=channel:nixos-unstable
      - name: Check for shell script errors
        run: |
          find . -name "*.*sh" -exec nix-shell -p shellcheck --run "shellcheck {}" \;
</file>

<file path="create-directories.bash">
#!/usr/bin/env bash

set -o nounset            # Fail on use of unset variable.
set -o errexit            # Exit on command failure.
set -o pipefail           # Exit on failure of any command in a pipeline.
set -o errtrace           # Trap errors in functions and subshells.
set -o noglob             # Disable filename expansion (globbing),
                          # since it could otherwise happen during
                          # path splitting.
shopt -s inherit_errexit  # Inherit the errexit option status in subshells.

# Print a useful trace when an error occurs
trap 'echo Error when executing ${BASH_COMMAND} at line ${LINENO}! >&2' ERR

# Given a source directory, /source, and a target directory,
# /target/foo/bar/bazz, we want to "clone" the target structure
# from source into the target. Essentially, we want both
# /source/target/foo/bar/bazz and /target/foo/bar/bazz to exist
# on the filesystem. More concretely, we'd like to map
# /state/etc/ssh/example.key to /etc/ssh/example.key
#
# To achieve this, we split the target's path into parts -- target, foo,
# bar, bazz -- and iterate over them while accumulating the path
# (/target/, /target/foo/, /target/foo/bar, and so on); then, for each of
# these increasingly qualified paths we:
#   1. Ensure both /source/qualifiedPath and qualifiedPath exist
#   2. Copy the ownership of the source path to the target path
#   3. Copy the mode of the source path to the target path

# Get inputs from command line arguments
if [[ $# != 6 ]]; then
    printf "Error: 'create-directories.bash' requires *six* args.\n" >&2
    exit 1
fi
sourceBase="$1"
target="$2"
user="$3"
group="$4"
mode="$5"
debug="$6"

if (( debug )); then
    set -o xtrace
fi

# check that the source exists and warn the user if it doesn't, then
# create them with the specified permissions
realSource="$(realpath -m "$sourceBase$target")"
if [[ ! -d $realSource ]]; then
    printf "Warning: Source directory '%s' does not exist; it will be created for you with the following permissions: owner: '%s:%s', mode: '%s'.\n" "$realSource" "$user" "$group" "$mode"
    mkdir --mode="$mode" "$realSource"
    chown "$user:$group" "$realSource"
fi

if [[ $sourceBase ]]; then
    [[ -d $target ]] || mkdir "$target"

    # synchronize perms between source and target
    chown --reference="$realSource" "$target"
    chmod --reference="$realSource" "$target"
fi
</file>

<file path="flake.nix">
{
  outputs = { self }: {
    nixosModules.default = self.nixosModules.impermanence;
    nixosModules.impermanence = import ./nixos.nix;

    homeManagerModules.default = self.homeManagerModules.impermanence;
    homeManagerModules.impermanence = import ./home-manager.nix;

    # Deprecated
    nixosModule = self.nixosModules.impermanence;
    nixosModules.home-manager.impermanence = self.homeManagerModules.impermanence;
  };
}
</file>

<file path="home-manager.nix">
{ pkgs, config, lib, ... }:

with lib;
let
  cfg = config.home.persistence;

  persistentStorageNames = (filter (path: cfg.${path}.enable) (attrNames cfg));

  inherit (pkgs.callPackage ./lib.nix { })
    splitPath
    dirListToPath
    concatPaths
    sanitizeName
    ;

  mount = "${pkgs.util-linux}/bin/mount";
  unmountScript = mountPoint: tries: sleep: ''
    triesLeft=${toString tries}
    if ${mount} | grep -F ${mountPoint}' ' >/dev/null; then
        while (( triesLeft > 0 )); do
            if fusermount -u ${mountPoint}; then
                break
            else
                (( triesLeft-- ))
                if (( triesLeft == 0 )); then
                    echo "Couldn't perform regular unmount of ${mountPoint}. Attempting lazy unmount."
                    fusermount -uz ${mountPoint}
                else
                    sleep ${toString sleep}
                fi
            fi
        done
    fi
  '';
in
{
  options = {

    home.persistence = mkOption {
      default = { };
      type = with types; attrsOf (
        submodule ({ name, config, ... }: {
          options =
            {
              persistentStoragePath = mkOption {
                type = path;
                default = name;
                description = ''
                  The path to persistent storage where the real
                  files and directories should be stored.
                '';
              };

              enable = mkOption {
                type = bool;
                default = true;
                description = "Whether to enable this persistent storage location.";
              };

              defaultDirectoryMethod = mkOption {
                type = types.enum [ "bindfs" "symlink" ];
                default = "bindfs";
                description = ''
                  The linking method that should be used for directories.

                  - bindfs is very transparent, and thus used as a safe
                  default. It has, however, a significant performance impact in
                  IO-heavy situations.

                  - symlinks have great performance but may be treated
                  specially by some programs that may e.g. generate
                  errors/warnings, or replace them.

                  This can be overridden on a per entry basis.
                '';
              };

              directories = mkOption {
                type = types.listOf (
                  types.coercedTo types.str (directory: { inherit directory; }) (submodule {
                    options = {
                      directory = mkOption {
                        type = str;
                        description = "The directory path to be linked.";
                      };
                      method = mkOption {
                        type = types.enum [ "bindfs" "symlink" ];
                        default = config.defaultDirectoryMethod;
                        description = ''
                          The linking method to be used for this specific
                          directory entry. See
                          <literal>defaultDirectoryMethod</literal> for more
                          information on the tradeoffs.
                        '';
                      };
                    };
                  })
                );
                default = [ ];
                example = [
                  "Downloads"
                  "Music"
                  "Pictures"
                  "Documents"
                  "Videos"
                  "VirtualBox VMs"
                  ".gnupg"
                  ".ssh"
                  ".local/share/keyrings"
                  ".local/share/direnv"
                  {
                    directory = ".local/share/Steam";
                    method = "symlink";
                  }
                ];
                description = ''
                  A list of directories in your home directory that
                  you want to link to persistent storage. You may optionally
                  specify the linking method each directory should use.
                '';
              };

              files = mkOption {
                type = with types; listOf str;
                default = [ ];
                example = [
                  ".screenrc"
                ];
                description = ''
                  A list of files in your home directory you want to
                  link to persistent storage.
                '';
              };

              allowOther = mkOption {
                type = with types; nullOr bool;
                default = null;
                example = true;
                apply = x:
                  if x == null then
                    warn ''
                      home.persistence."${name}".allowOther not set; assuming 'false'.
                      See https://github.com/nix-community/impermanence#home-manager for more info.
                    ''
                      false
                  else
                    x;
                description = ''
                  Whether to allow other users, such as
                  <literal>root</literal>, access to files through the
                  bind mounted directories listed in
                  <literal>directories</literal>. Requires the NixOS
                  configuration parameter
                  <literal>programs.fuse.userAllowOther</literal> to
                  be <literal>true</literal>.
                '';
              };

              removePrefixDirectory = mkOption {
                type = types.bool;
                default = false;
                example = true;
                description = ''
                  Note: This is mainly useful if you have a dotfiles
                  repo structured for use with GNU Stow; if you don't,
                  you can likely ignore it.

                  Whether to remove the first directory when linking
                  or mounting; e.g. for the path
                  <literal>"screen/.screenrc"</literal>, the
                  <literal>screen/</literal> is ignored for the path
                  linked to in your home directory.
                '';
              };
            };
        })
      );
      description = ''
        A set of persistent storage location submodules listing the
        files and directories to link to their respective persistent
        storage location.

        Each attribute name should be the path relative to the user's
        home directory.

        For detailed usage, check the <link
        xlink:href="https://github.com/nix-community/impermanence">documentation</link>.
      '';
      example = literalExpression ''
        {
          "/persistent/home/talyz" = {
            directories = [
              "Downloads"
              "Music"
              "Pictures"
              "Documents"
              "Videos"
              "VirtualBox VMs"
              ".gnupg"
              ".ssh"
              ".nixops"
              ".local/share/keyrings"
              ".local/share/direnv"
              {
                directory = ".local/share/Steam";
                method = "symlink";
              }
            ];
            files = [
              ".screenrc"
            ];
            allowOther = true;
          };
        }
      '';
    };

  };

  config = {
    home.file =
      let
        link = file:
          pkgs.runCommand
            "${sanitizeName file}"
            { }
            "ln -s '${file}' $out";

        mkLinkNameValuePair = persistentStorageName: fileOrDir: {
          name =
            if cfg.${persistentStorageName}.removePrefixDirectory then
              dirListToPath (tail (splitPath [ fileOrDir ]))
            else
              fileOrDir;
          value = { source = link (concatPaths [ cfg.${persistentStorageName}.persistentStoragePath fileOrDir ]); };
        };

        mkLinksToPersistentStorage = persistentStorageName:
          listToAttrs (map
            (mkLinkNameValuePair persistentStorageName)
            (cfg.${persistentStorageName}.files ++ (map (v: v.directory)
              (filter (v: v.method == "symlink") cfg.${persistentStorageName}.directories)))
          );
      in
      foldl' recursiveUpdate { } (map mkLinksToPersistentStorage persistentStorageNames);

    systemd.user.services =
      let
        mkBindMountService = persistentStorageName: dir:
          let
            mountDir =
              if cfg.${persistentStorageName}.removePrefixDirectory then
                dirListToPath (tail (splitPath [ dir ]))
              else
                dir;
            targetDir = escapeShellArg (concatPaths [ cfg.${persistentStorageName}.persistentStoragePath dir ]);
            mountPoint = escapeShellArg (concatPaths [ config.home.homeDirectory mountDir ]);
            name = "bindMount-${sanitizeName targetDir}";
            bindfsOptions = concatStringsSep "," (
              optional (!cfg.${persistentStorageName}.allowOther) "no-allow-other"
              ++ optional (versionAtLeast pkgs.bindfs.version "1.14.9") "fsname=${targetDir}"
            );
            bindfsOptionFlag = optionalString (bindfsOptions != "") (" -o " + bindfsOptions);
            bindfs = "bindfs" + bindfsOptionFlag;
            startScript = pkgs.writeShellScript name ''
              set -eu
              if ! mount | grep -F ${mountPoint}' ' && ! mount | grep -F ${mountPoint}/; then
                  mkdir -p ${mountPoint}
                  exec ${bindfs} ${targetDir} ${mountPoint}
              else
                  echo "There is already an active mount at or below ${mountPoint}!" >&2
                  exit 1
              fi
            '';
            stopScript = pkgs.writeShellScript "unmount-${name}" ''
              set -eu
              ${unmountScript mountPoint 6 5}
            '';
          in
          {
            inherit name;
            value = {
              Unit = {
                Description = "Bind mount ${targetDir} at ${mountPoint}";

                # Don't restart the unit, it could corrupt data and
                # crash programs currently reading from the mount.
                X-RestartIfChanged = false;

                # Don't add an implicit After=basic.target.
                DefaultDependencies = false;

                Before = [
                  "bluetooth.target"
                  "basic.target"
                  "default.target"
                  "paths.target"
                  "sockets.target"
                  "timers.target"
                ];
              };

              Install.WantedBy = [ "paths.target" ];

              Service = {
                Type = "forking";
                ExecStart = "${startScript}";
                ExecStop = "${stopScript}";
                Environment = "PATH=${makeBinPath [ pkgs.coreutils pkgs.util-linux pkgs.gnugrep pkgs.bindfs ]}:/run/wrappers/bin";
              };
            };
          };

        mkBindMountServicesForPath = persistentStorageName:
          listToAttrs (map
            (mkBindMountService persistentStorageName)
            (map (v: v.directory) (filter (v: v.method == "bindfs") cfg.${persistentStorageName}.directories))
          );
      in
      builtins.foldl'
        recursiveUpdate
        { }
        (map mkBindMountServicesForPath persistentStorageNames);

    home.activation =
      let
        dag = config.lib.dag;
        mount = "${pkgs.util-linux}/bin/mount";

        # The name of the activation script entry responsible for
        # reloading systemd user services. The name was initially
        # `reloadSystemD` but has been changed to `reloadSystemd`.
        reloadSystemd =
          if config.home.activation ? reloadSystemD then
            "reloadSystemD"
          else
            "reloadSystemd";

        mkBindMount = persistentStorageName: dir:
          let
            mountDir =
              if cfg.${persistentStorageName}.removePrefixDirectory then
                dirListToPath (tail (splitPath [ dir ]))
              else
                dir;
            targetDir = escapeShellArg (concatPaths [ cfg.${persistentStorageName}.persistentStoragePath dir ]);
            mountPoint = escapeShellArg (concatPaths [ config.home.homeDirectory mountDir ]);
            bindfsOptions = concatStringsSep "," (
              optional (!cfg.${persistentStorageName}.allowOther) "no-allow-other"
              ++ optional (versionAtLeast pkgs.bindfs.version "1.14.9") "fsname=${targetDir}"
            );
            bindfsOptionFlag = optionalString (bindfsOptions != "") (" -o " + bindfsOptions);
            bindfs = "${pkgs.bindfs}/bin/bindfs" + bindfsOptionFlag;
            systemctl = "XDG_RUNTIME_DIR=\${XDG_RUNTIME_DIR:-/run/user/$(id -u)} ${config.systemd.user.systemctlPath}";
          in
          ''
            mkdir -p ${targetDir}
            mkdir -p ${mountPoint}

            if ${mount} | grep -F ${mountPoint}' ' >/dev/null; then
                if ! ${mount} | grep -F ${mountPoint}' ' | grep -F bindfs; then
                    if ! ${mount} | grep -F ${mountPoint}' ' | grep -F ${targetDir}' ' >/dev/null; then
                        # The target directory changed, so we need to remount
                        echo "remounting ${mountPoint}"
                        ${systemctl} --user stop bindMount-${sanitizeName targetDir}
                        ${bindfs} ${targetDir} ${mountPoint}
                        mountedPaths[${mountPoint}]=1
                    fi
                fi
            elif ${mount} | grep -F ${mountPoint}/ >/dev/null; then
                echo "Something is mounted below ${mountPoint}, not creating bind mount to ${targetDir}" >&2
            else
                ${bindfs} ${targetDir} ${mountPoint}
                mountedPaths[${mountPoint}]=1
            fi
          '';

        mkBindMountsForPath = persistentStorageName:
          concatMapStrings
            (mkBindMount persistentStorageName)
            (map (v: v.directory) (filter (v: v.method == "bindfs") cfg.${persistentStorageName}.directories));

        mkUnmount = persistentStorageName: dir:
          let
            mountDir =
              if cfg.${persistentStorageName}.removePrefixDirectory then
                dirListToPath (tail (splitPath [ dir ]))
              else
                dir;
            mountPoint = escapeShellArg (concatPaths [ config.home.homeDirectory mountDir ]);
          in
          ''
            if [[ -n ''${mountedPaths[${mountPoint}]+x} ]]; then
              ${unmountScript mountPoint 3 1}
            fi
          '';

        mkUnmountsForPath = persistentStorageName:
          concatMapStrings
            (mkUnmount persistentStorageName)
            (map (v: v.directory) (filter (v: v.method == "bindfs") cfg.${persistentStorageName}.directories));

        mkLinkCleanup = persistentStorageName: dir:
          let
            mountDir =
              if cfg.${persistentStorageName}.removePrefixDirectory then
                dirListToPath (tail (splitPath [ dir ]))
              else
                dir;
            mountPoint = escapeShellArg (concatPaths [ config.home.homeDirectory mountDir ]);
          in
          ''
            # Unmount if it's mounted. Ensures smooth transition: bindfs -> symlink
            ${unmountScript mountPoint 3 1}

            # If it is a directory and it's empty
            if [ -d ${mountPoint} ] && [ -z "$(ls -A ${mountPoint})" ]; then
              echo "Removing empty directory ${mountPoint}"
              rm -d ${mountPoint}
            fi
          '';

        mkLinkCleanupForPath = persistentStorageName:
          concatMapStrings
            (mkLinkCleanup persistentStorageName)
            (map (v: v.directory) (filter (v: v.method == "symlink") cfg.${persistentStorageName}.directories));


      in
      mkMerge [
        (mkIf (any (path: (filter (v: v.method == "symlink") cfg.${path}.directories) != [ ]) persistentStorageNames) {
          # Clean up existing empty directories in the way of links
          cleanEmptyLinkTargets =
            dag.entryBefore
              [ "checkLinkTargets" ]
              ''
                ${concatMapStrings mkLinkCleanupForPath persistentStorageNames}
              '';
        })
        (mkIf (any (path: (filter (v: v.method == "bindfs") cfg.${path}.directories) != [ ]) persistentStorageNames) {
          createAndMountPersistentStoragePaths =
            dag.entryBefore
              [ "writeBoundary" ]
              ''
                declare -A mountedPaths
                ${(concatMapStrings mkBindMountsForPath persistentStorageNames)}
              '';

          unmountPersistentStoragePaths =
            dag.entryBefore
              [ "createAndMountPersistentStoragePaths" ]
              ''
                PATH=$PATH:/run/wrappers/bin
                unmountBindMounts() {
                ${concatMapStrings mkUnmountsForPath persistentStorageNames}
                }

                # Run the unmount function on error to clean up stray
                # bind mounts
                trap "unmountBindMounts" ERR
              '';

          runUnmountPersistentStoragePaths =
            dag.entryBefore
              [ reloadSystemd ]
              ''
                unmountBindMounts
              '';
        })
        (mkIf (any (path: (cfg.${path}.files != [ ]) || ((filter (v: v.method == "symlink") cfg.${path}.directories) != [ ])) persistentStorageNames) {
          createTargetFileDirectories =
            dag.entryBefore
              [ "writeBoundary" ]
              (concatMapStrings
                (persistentStorageName:
                  concatMapStrings
                    (targetFilePath: ''
                      mkdir -p ${escapeShellArg (concatPaths [ cfg.${persistentStorageName}.persistentStoragePath (dirOf targetFilePath) ])}
                    '')
                    (cfg.${persistentStorageName}.files ++ (map (v: v.directory) (filter (v: v.method == "symlink") cfg.${persistentStorageName}.directories))))
                persistentStorageNames);
        })
      ];
  };

}
</file>

<file path="lib.nix">
{ lib }:
let
  inherit (lib)
    filter
    concatMap
    concatStringsSep
    hasPrefix
    head
    replaceStrings
    optionalString
    removePrefix
    foldl'
    elem
    take
    length
    last
    ;
  inherit (lib.strings)
    sanitizeDerivationName
    ;

  # ["/home/user/" "/.screenrc"] -> ["home" "user" ".screenrc"]
  splitPath = paths:
    (filter
      (s: builtins.typeOf s == "string" && s != "")
      (concatMap (builtins.split "/") paths)
    );

  # ["home" "user" ".screenrc"] -> "home/user/.screenrc"
  dirListToPath = dirList: (concatStringsSep "/" dirList);

  # ["/home/user/" "/.screenrc"] -> "/home/user/.screenrc"
  concatPaths = paths:
    let
      prefix = optionalString (hasPrefix "/" (head paths)) "/";
      path = dirListToPath (splitPath paths);
    in
    prefix + path;


  parentsOf = path:
    let
      prefix = optionalString (hasPrefix "/" path) "/";
      split = splitPath [ path ];
      parents = take ((length split) - 1) split;
    in
    foldl'
      (state: item:
        state ++ [
          (concatPaths [
            (if state != [ ] then last state else prefix)
            item
          ])
        ])
      [ ]
      parents;

  sanitizeName = name:
    replaceStrings
      [ "." ] [ "" ]
      (sanitizeDerivationName (removePrefix "/" name));

  duplicates = list:
    let
      result =
        foldl'
          (state: item:
            if elem item state.items then
              {
                items = state.items ++ [ item ];
                duplicates = state.duplicates ++ [ item ];
              }
            else
              state // {
                items = state.items ++ [ item ];
              })
          { items = [ ]; duplicates = [ ]; }
          list;
    in
    result.duplicates;
in
{
  inherit
    splitPath
    dirListToPath
    concatPaths
    parentsOf
    sanitizeName
    duplicates
    ;
}
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2020 Nix Community Projects

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="mount-file.bash">
#!/usr/bin/env bash

set -o nounset            # Fail on use of unset variable.
set -o errexit            # Exit on command failure.
set -o pipefail           # Exit on failure of any command in a pipeline.
set -o errtrace           # Trap errors in functions and subshells.
shopt -s inherit_errexit  # Inherit the errexit option status in subshells.

# Print a useful trace when an error occurs
trap 'echo Error when executing ${BASH_COMMAND} at line ${LINENO}! >&2' ERR

# Get inputs from command line arguments
if [[ $# != 3 ]]; then
    echo "Error: 'mount-file.bash' requires *three* args." >&2
    exit 1
fi

mountPoint="$1"
targetFile="$2"
debug="$3"

trace() {
    if (( debug )); then
      echo "$@"
    fi
}
if (( debug )); then
    set -o xtrace
fi

if [[ -L $mountPoint && $(readlink -f "$mountPoint") == "$targetFile" ]]; then
    trace "$mountPoint already links to $targetFile, ignoring"
elif findmnt "$mountPoint" >/dev/null; then
    trace "mount already exists at $mountPoint, ignoring"
elif [[ -s $mountPoint ]]; then
    echo "A file already exists at $mountPoint!" >&2
    exit 1
elif [[ -e $targetFile ]]; then
    touch "$mountPoint"
    mount -o bind "$targetFile" "$mountPoint"
elif [[ $mountPoint == "/etc/machine-id" ]]; then
    # Work around an issue with persisting /etc/machine-id. For more
    # details, see https://github.com/nix-community/impermanence/pull/242
    echo "Creating initial /etc/machine-id"
    echo "uninitialized" > "$targetFile"
    touch "$mountPoint"
    mount -o bind "$targetFile" "$mountPoint"
else
    ln -s "$targetFile" "$mountPoint"
fi
</file>

<file path="nixos.nix">
{ pkgs, config, lib, utils, ... }:

let
  inherit (lib)
    attrNames
    attrValues
    zipAttrsWith
    flatten
    mkAfter
    mkOption
    mkDefault
    mkIf
    mkMerge
    mapAttrsToList
    types
    foldl'
    unique
    concatMap
    concatMapStrings
    listToAttrs
    escapeShellArg
    escapeShellArgs
    recursiveUpdate
    all
    filter
    filterAttrs
    concatStringsSep
    concatMapStringsSep
    catAttrs
    optional
    optionalString
    literalExpression
    elem
    mapAttrs
    intersectLists
    any
    id
    head
    ;

  inherit (utils)
    escapeSystemdPath
    fsNeededForBoot
    ;

  inherit (pkgs.callPackage ./lib.nix { })
    splitPath
    concatPaths
    parentsOf
    duplicates
    ;

  cfg = config.environment.persistence;
  users = config.users.users;
  allPersistentStoragePaths = zipAttrsWith (_name: flatten) (filter (v: v.enable) (attrValues cfg));
  inherit (allPersistentStoragePaths) files directories;
  mountFile = pkgs.runCommand "impermanence-mount-file" { buildInputs = [ pkgs.bash ]; } ''
    cp ${./mount-file.bash} $out
    patchShebangs $out
  '';

  defaultPerms = {
    mode = "0755";
    user = "root";
    group = "root";
  };

  # Create fileSystems bind mount entry.
  mkBindMountNameValuePair = { dirPath, persistentStoragePath, hideMount, ... }: {
    name = concatPaths [ "/" dirPath ];
    value = {
      device = concatPaths [ persistentStoragePath dirPath ];
      noCheck = true;
      options = [ "bind" "X-fstrim.notrim" ]
        ++ optional hideMount "x-gvfs-hide";
      depends = [ persistentStoragePath ];
    };
  };

  # Create all fileSystems bind mount entries for a specific
  # persistent storage path.
  bindMounts = listToAttrs (map mkBindMountNameValuePair directories);
in
{
  options = {

    environment.persistence = mkOption {
      default = { };
      type =
        let
          inherit (types)
            attrsOf
            bool
            listOf
            submodule
            nullOr
            path
            str
            coercedTo
            ;
        in
        attrsOf (
          submodule (
            { name, config, ... }:
            let
              commonOpts = {
                options = {
                  persistentStoragePath = mkOption {
                    type = path;
                    default = config.persistentStoragePath;
                    defaultText = "environment.persistence.‹name›.persistentStoragePath";
                    description = ''
                      The path to persistent storage where the real
                      file or directory should be stored.
                    '';
                  };
                  home = mkOption {
                    type = nullOr path;
                    default = null;
                    internal = true;
                    description = ''
                      The path to the home directory the file is
                      placed within.
                    '';
                  };
                  enableDebugging = mkOption {
                    type = bool;
                    default = config.enableDebugging;
                    defaultText = "environment.persistence.‹name›.enableDebugging";
                    internal = true;
                    description = ''
                      Enable debug trace output when running
                      scripts. You only need to enable this if asked
                      to.
                    '';
                  };
                };
              };
              dirPermsOpts = {
                user = mkOption {
                  type = str;
                  description = ''
                    If the directory doesn't exist in persistent
                    storage it will be created and owned by the user
                    specified by this option.
                  '';
                };
                group = mkOption {
                  type = str;
                  description = ''
                    If the directory doesn't exist in persistent
                    storage it will be created and owned by the
                    group specified by this option.
                  '';
                };
                mode = mkOption {
                  type = str;
                  example = "0700";
                  description = ''
                    If the directory doesn't exist in persistent
                    storage it will be created with the mode
                    specified by this option.
                  '';
                };
              };
              fileOpts = {
                options = {
                  file = mkOption {
                    type = str;
                    description = ''
                      The path to the file.
                    '';
                  };
                  parentDirectory =
                    commonOpts.options //
                    mapAttrs
                      (_: x:
                        if x._type or null == "option" then
                          x // { internal = true; }
                        else
                          x)
                      dirOpts.options;
                  filePath = mkOption {
                    type = path;
                    internal = true;
                  };
                };
              };
              dirOpts = {
                options = {
                  directory = mkOption {
                    type = str;
                    description = ''
                      The path to the directory.
                    '';
                  };
                  hideMount = mkOption {
                    type = bool;
                    default = config.hideMounts;
                    defaultText = "environment.persistence.‹name›.hideMounts";
                    example = true;
                    description = ''
                      Whether to hide bind mounts from showing up as
                      mounted drives.
                    '';
                  };
                  # Save the default permissions at the level the
                  # directory resides. This used when creating its
                  # parent directories, giving them reasonable
                  # default permissions unaffected by the
                  # directory's own.
                  defaultPerms = mapAttrs (_: x: x // { internal = true; }) dirPermsOpts;
                  dirPath = mkOption {
                    type = path;
                    internal = true;
                  };
                } // dirPermsOpts;
              };
              rootFile = submodule [
                commonOpts
                fileOpts
                ({ config, ... }: {
                  parentDirectory = mkDefault (defaultPerms // rec {
                    directory = dirOf config.file;
                    dirPath = directory;
                    inherit (config) persistentStoragePath;
                    inherit defaultPerms;
                  });
                  filePath = mkDefault config.file;
                })
              ];
              rootDir = submodule ([
                commonOpts
                dirOpts
                ({ config, ... }: {
                  defaultPerms = mkDefault defaultPerms;
                  dirPath = mkDefault config.directory;
                })
              ] ++ (mapAttrsToList (n: v: { ${n} = mkDefault v; }) defaultPerms));
            in
            {
              options =
                {
                  enable = mkOption {
                    type = bool;
                    default = true;
                    description = "Whether to enable this persistent storage location.";
                  };

                  persistentStoragePath = mkOption {
                    type = path;
                    default = name;
                    defaultText = "‹name›";
                    description = ''
                      The path to persistent storage where the real
                      files and directories should be stored.
                    '';
                  };

                  users = mkOption {
                    type = attrsOf (
                      submodule (
                        { name, config, ... }:
                        let
                          userDefaultPerms = {
                            inherit (defaultPerms) mode;
                            user = name;
                            group = users.${userDefaultPerms.user}.group;
                          };
                          fileConfig =
                            { config, ... }:
                            {
                              parentDirectory = rec {
                                directory = dirOf config.file;
                                dirPath = concatPaths [ config.home directory ];
                                inherit (config) persistentStoragePath home;
                                defaultPerms = userDefaultPerms;
                              };
                              filePath = concatPaths [ config.home config.file ];
                            };
                          userFile = submodule [
                            commonOpts
                            fileOpts
                            { inherit (config) home; }
                            {
                              parentDirectory = mkDefault userDefaultPerms;
                            }
                            fileConfig
                          ];
                          dirConfig =
                            { config, ... }:
                            {
                              defaultPerms = mkDefault userDefaultPerms;
                              dirPath = concatPaths [ config.home config.directory ];
                            };
                          userDir = submodule ([
                            commonOpts
                            dirOpts
                            { inherit (config) home; }
                            dirConfig
                          ] ++ (mapAttrsToList (n: v: { ${n} = mkDefault v; }) userDefaultPerms));
                        in
                        {
                          options =
                            {
                              # Needed because defining fileSystems
                              # based on values from users.users
                              # results in infinite recursion.
                              home = mkOption {
                                type = path;
                                default = "/home/${userDefaultPerms.user}";
                                defaultText = "/home/<username>";
                                description = ''
                                  The user's home directory. Only
                                  useful for users with a custom home
                                  directory path.

                                  Cannot currently be automatically
                                  deduced due to a limitation in
                                  nixpkgs.
                                '';
                              };

                              files = mkOption {
                                type = listOf (coercedTo str (f: { file = f; }) userFile);
                                default = [ ];
                                example = [
                                  ".screenrc"
                                ];
                                description = ''
                                  Files that should be stored in
                                  persistent storage.
                                '';
                              };

                              directories = mkOption {
                                type = listOf (coercedTo str (d: { directory = d; }) userDir);
                                default = [ ];
                                example = [
                                  "Downloads"
                                  "Music"
                                  "Pictures"
                                  "Documents"
                                  "Videos"
                                ];
                                description = ''
                                  Directories to bind mount to
                                  persistent storage.
                                '';
                              };
                            };
                        }
                      )
                    );
                    default = { };
                    description = ''
                      A set of user submodules listing the files and
                      directories to link to their respective user's
                      home directories.

                      Each attribute name should be the name of the
                      user.

                      For detailed usage, check the <link
                      xlink:href="https://github.com/nix-community/impermanence">documentation</link>.
                    '';
                    example = literalExpression ''
                      {
                        talyz = {
                          directories = [
                            "Downloads"
                            "Music"
                            "Pictures"
                            "Documents"
                            "Videos"
                            "VirtualBox VMs"
                            { directory = ".gnupg"; mode = "0700"; }
                            { directory = ".ssh"; mode = "0700"; }
                            { directory = ".nixops"; mode = "0700"; }
                            { directory = ".local/share/keyrings"; mode = "0700"; }
                            ".local/share/direnv"
                          ];
                          files = [
                            ".screenrc"
                          ];
                        };
                      }
                    '';
                  };

                  files = mkOption {
                    type = listOf (coercedTo str (f: { file = f; }) rootFile);
                    default = [ ];
                    example = [
                      "/etc/machine-id"
                      "/etc/nix/id_rsa"
                    ];
                    description = ''
                      Files that should be stored in persistent storage.
                    '';
                  };

                  directories = mkOption {
                    type = listOf (coercedTo str (d: { directory = d; }) rootDir);
                    default = [ ];
                    example = [
                      "/var/log"
                      "/var/lib/bluetooth"
                      "/var/lib/nixos"
                      "/var/lib/systemd/coredump"
                      "/etc/NetworkManager/system-connections"
                    ];
                    description = ''
                      Directories to bind mount to persistent storage.
                    '';
                  };

                  hideMounts = mkOption {
                    type = bool;
                    default = false;
                    example = true;
                    description = ''
                      Whether to hide bind mounts from showing up as mounted drives.
                    '';
                  };

                  enableDebugging = mkOption {
                    type = bool;
                    default = false;
                    internal = true;
                    description = ''
                      Enable debug trace output when running
                      scripts. You only need to enable this if asked
                      to.
                    '';
                  };

                  enableWarnings = mkOption {
                    type = bool;
                    default = true;
                    description = ''
                      Enable non-critical warnings.
                    '';
                  };
                };
              config =
                let
                  allUsers = zipAttrsWith (_name: flatten) (attrValues config.users);
                in
                {
                  files = allUsers.files or [ ];
                  directories = allUsers.directories or [ ];
                };
            }
          )
        );
      description = ''
        A set of persistent storage location submodules listing the
        files and directories to link to their respective persistent
        storage location.

        Each attribute name should be the full path to a persistent
        storage location.

        For detailed usage, check the <link
        xlink:href="https://github.com/nix-community/impermanence">documentation</link>.
      '';
      example = literalExpression ''
        {
          "/persistent" = {
            directories = [
              "/var/log"
              "/var/lib/bluetooth"
              "/var/lib/nixos"
              "/var/lib/systemd/coredump"
              "/etc/NetworkManager/system-connections"
              { directory = "/var/lib/colord"; user = "colord"; group = "colord"; mode = "u=rwx,g=rx,o="; }
            ];
            files = [
              "/etc/machine-id"
              { file = "/etc/nix/id_rsa"; parentDirectory = { mode = "u=rwx,g=,o="; }; }
            ];
          };
          users.talyz = { ... }; # See the dedicated example
        }
      '';
    };

    # Forward declare a dummy option for VM filesystems since the real one won't exist
    # unless the VM module is actually imported.
    virtualisation.fileSystems = mkOption { };
  };

  config = mkIf (allPersistentStoragePaths != { })
    (mkMerge [
      {
        systemd.services =
          let
            mkPersistFileService = { filePath, persistentStoragePath, enableDebugging, ... }:
              let
                targetFile = escapeShellArg (concatPaths [ persistentStoragePath filePath ]);
                mountPoint = escapeShellArg filePath;
              in
              {
                "persist-${escapeSystemdPath targetFile}" = {
                  description = "Bind mount or link ${targetFile} to ${mountPoint}";
                  wantedBy = [ "local-fs.target" ];
                  before = [ "local-fs.target" ];
                  path = [ pkgs.util-linux ];
                  unitConfig.DefaultDependencies = false;
                  serviceConfig = {
                    Type = "oneshot";
                    RemainAfterExit = true;
                    ExecStart = "${mountFile} ${mountPoint} ${targetFile} ${escapeShellArg enableDebugging}";
                    ExecStop = pkgs.writeShellScript "unbindOrUnlink-${escapeSystemdPath targetFile}" ''
                      set -eu
                      if [[ -L ${mountPoint} ]]; then
                          rm ${mountPoint}
                      else
                          umount ${mountPoint}
                          rm ${mountPoint}
                      fi
                    '';
                  };
                };
              };
          in
          foldl' recursiveUpdate { } (map mkPersistFileService files);

        fileSystems = mkIf (directories != [ ]) bindMounts;
        # So the mounts still make it into a VM built from `system.build.vm`
        virtualisation.fileSystems = mkIf (directories != [ ]) bindMounts;

        system.activationScripts =
          let
            # Script to create directories in persistent and ephemeral
            # storage. The directory structure's mode and ownership mirror
            # those of persistentStoragePath/dir.
            createDirectories = pkgs.runCommand "impermanence-create-directories" { buildInputs = [ pkgs.bash ]; } ''
              cp ${./create-directories.bash} $out
              patchShebangs $out
            '';

            mkDirWithPerms =
              { dirPath
              , persistentStoragePath
              , user
              , group
              , mode
              , enableDebugging
              , ...
              }:
              let
                args = [
                  persistentStoragePath
                  dirPath
                  user
                  group
                  mode
                  enableDebugging
                ];
              in
              ''
                ${createDirectories} ${escapeShellArgs args}
              '';

            # Build an activation script which creates all persistent
            # storage directories we want to bind mount.
            dirCreationScript =
              let
                # The parent directories of files.
                fileDirs = unique (catAttrs "parentDirectory" files);

                # All the directories actually listed by the user and the
                # parent directories of listed files.
                explicitDirs = directories ++ fileDirs;

                # Home directories have to be handled specially, since
                # they're at the permissions boundary where they
                # themselves should be owned by the user and have stricter
                # permissions than regular directories, whereas its parent
                # should be owned by root and have regular permissions.
                #
                # This simply collects all the home directories and sets
                # the appropriate permissions and ownership.
                homeDirs =
                  foldl'
                    (state: dir:
                      let
                        homeDir = {
                          directory = dir.home;
                          dirPath = dir.home;
                          home = null;
                          mode = "0700";
                          user = dir.user;
                          group = users.${dir.user}.group;
                          inherit defaultPerms;
                          inherit (dir) persistentStoragePath enableDebugging;
                        };
                      in
                      if dir.home != null then
                        if !(elem homeDir state) then
                          state ++ [ homeDir ]
                        else
                          state
                      else
                        state
                    )
                    [ ]
                    explicitDirs;

                # Persistent storage directories. These need to be created
                # unless they're at the root of a filesystem.
                persistentStorageDirs =
                  foldl'
                    (state: dir:
                      let
                        persistentStorageDir = {
                          directory = dir.persistentStoragePath;
                          dirPath = dir.persistentStoragePath;
                          persistentStoragePath = "";
                          home = null;
                          inherit (dir) defaultPerms enableDebugging;
                          inherit (dir.defaultPerms) user group mode;
                        };
                      in
                      if dir.home == null && !(elem persistentStorageDir state) then
                        state ++ [ persistentStorageDir ]
                      else
                        state
                    )
                    [ ]
                    (explicitDirs ++ homeDirs);

                # Generate entries for all parent directories of the
                # argument directories, listed in the order they need to
                # be created. The parent directories are assigned default
                # permissions.
                mkParentDirs = dirs:
                  let
                    # Create a new directory item from `dir`, the child
                    # directory item to inherit properties from and
                    # `path`, the parent directory path.
                    mkParent = dir: path: {
                      directory = path;
                      dirPath =
                        if dir.home != null then
                          concatPaths [ dir.home path ]
                        else
                          path;
                      inherit (dir) persistentStoragePath home enableDebugging;
                      inherit (dir.defaultPerms) user group mode;
                    };
                    # Create new directory items for all parent
                    # directories of a directory.
                    mkParents = dir:
                      map (mkParent dir) (parentsOf dir.directory);
                  in
                  unique (flatten (map mkParents dirs));

                persistentStorageDirParents = mkParentDirs persistentStorageDirs;

                # Parent directories of home folders. This is usually only
                # /home, unless the user's home is in a non-standard
                # location.
                homeDirParents = mkParentDirs homeDirs;

                # Parent directories of all explicitly listed directories.
                parentDirs = mkParentDirs explicitDirs;

                # All directories in the order they should be created.
                allDirs =
                  persistentStorageDirParents
                  ++ persistentStorageDirs
                  ++ homeDirParents
                  ++ homeDirs
                  ++ parentDirs
                  ++ explicitDirs;
              in
              pkgs.writeShellScript "impermanence-run-create-directories" ''
                _status=0
                trap "_status=1" ERR
                ${concatMapStrings mkDirWithPerms allDirs}
                exit $_status
              '';

            mkPersistFile = { filePath, persistentStoragePath, enableDebugging, ... }:
              let
                mountPoint = filePath;
                targetFile = concatPaths [ persistentStoragePath filePath ];
                args = escapeShellArgs [
                  mountPoint
                  targetFile
                  enableDebugging
                ];
              in
              ''
                ${mountFile} ${args}
              '';

            persistFileScript =
              pkgs.writeShellScript "impermanence-persist-files" ''
                _status=0
                trap "_status=1" ERR
                ${concatMapStrings mkPersistFile files}
                exit $_status
              '';
          in
          {
            "createPersistentStorageDirs" = {
              deps = [ "users" "groups" ];
              text = "${dirCreationScript}";
            };
            "persist-files" = {
              deps = [ "createPersistentStorageDirs" ];
              text = "${persistFileScript}";
            };
          };

        # Create the mountpoints of directories marked as needed for boot
        # which are also persisted. For this to work, it has to run at
        # early boot, before NixOS' filesystem mounting runs. Without
        # this, initial boot fails when for example /var/lib/nixos is
        # persisted but not created in persistent storage.
        boot.initrd =
          let
            neededForBootFs = catAttrs "mountPoint" (filter fsNeededForBoot (attrValues config.fileSystems));
            neededForBootDirs = filter (dir: elem dir.dirPath neededForBootFs) directories;
            getDevice = fs:
              if fs.device != null then
                fs.device
              else if fs.label != null then
                "/dev/disk/by-label/${fs.label}"
              else
                "none";
            mkMount = fs:
              let
                mountPoint = concatPaths [ "/persist-tmp-mnt" fs.mountPoint ];
                device = getDevice fs;
                options = filter (o: (builtins.match "(x-.*\.mount)" o) == null) fs.options;
                optionsFlag = optionalString (options != [ ]) ("-o " + escapeShellArg (concatStringsSep "," options));
              in
              ''
                mkdir -p ${escapeShellArg mountPoint}
                mount -t ${escapeShellArgs [ fs.fsType device mountPoint ]} ${optionsFlag}
              '';
            mkDir = { persistentStoragePath, dirPath, ... }: ''
              mkdir -p ${escapeShellArg (concatPaths [ "/persist-tmp-mnt" persistentStoragePath dirPath ])}
            '';
            mkUnmount = fs: ''
              umount ${escapeShellArg (concatPaths [ "/persist-tmp-mnt" fs.mountPoint ])}
            '';
            fileSystems =
              let
                persistentStoragePaths = unique (catAttrs "persistentStoragePath" directories);
                all = config.fileSystems // config.virtualisation.fileSystems;
                matchFileSystems = fs: attrValues (filterAttrs (_: v: v.mountPoint or null == fs) all);
              in
              concatMap matchFileSystems persistentStoragePaths;
            deviceUnits = unique
              (concatMap
                (fs:
                  # If the device path starts with “dev” or “sys”,
                  # it's a real device and should have an associated
                  # .device unit. If not, it's probably either a
                  # temporary file system lacking a backing device, a
                  # ZFS pool or a bind mount.
                  let
                    device = getDevice fs;
                  in
                  if elem (head (splitPath [ device ])) [ "dev" "sys" ] then
                    [ "${escapeSystemdPath device}.device" ]
                  else if device == "none" || device == fs.fsType then
                    [ ]
                  else if fs.fsType == "zfs" then
                    [ "zfs-import.target" ]
                  else
                    [ "${escapeSystemdPath device}.mount" ])
                fileSystems);
            createNeededForBootDirs = ''
              ${concatMapStrings mkMount fileSystems}
              ${concatMapStrings mkDir neededForBootDirs}
              ${concatMapStrings mkUnmount fileSystems}
            '';
          in
          {
            systemd.services = mkIf config.boot.initrd.systemd.enable {
              create-needed-for-boot-dirs = {
                wantedBy = [ "initrd-root-device.target" ];
                requires = deviceUnits;
                after = deviceUnits;
                before = [ "sysroot.mount" ];
                serviceConfig.Type = "oneshot";
                unitConfig.DefaultDependencies = false;
                script = createNeededForBootDirs;
              };
            };
            postResumeCommands = mkIf (!config.boot.initrd.systemd.enable)
              (mkAfter createNeededForBootDirs);
          };
      }

      # Work around an issue with persisting /etc/machine-id where the
      # systemd-machine-id-commit.service unit fails if the final
      # /etc/machine-id is bind mounted from persistent storage. For
      # more details, see
      # https://github.com/nix-community/impermanence/issues/229 and
      # https://github.com/nix-community/impermanence/pull/242
      (mkIf (any (f: f == "/etc/machine-id") (catAttrs "filePath" files)) {
        boot.initrd.systemd.suppressedUnits = [ "systemd-machine-id-commit.service" ];
        systemd.services.systemd-machine-id-commit.unitConfig.ConditionFirstBoot = true;
      })

      # Assertions and warnings
      {
        assertions =
          let
            markedNeededForBoot = cond: fs:
              if config.fileSystems ? ${fs} then
                config.fileSystems.${fs}.neededForBoot == cond
              else
                cond;
            persistentStoragePaths = attrNames cfg;
            usersPerPath = allPersistentStoragePaths.users;
            homeDirOffenders =
              filterAttrs
                (n: v: (v.home != config.users.users.${n}.home));
          in
          [
            {
              # Assert that all persistent storage volumes we use are
              # marked with neededForBoot.
              assertion = all (markedNeededForBoot true) persistentStoragePaths;
              message =
                let
                  offenders = filter (markedNeededForBoot false) persistentStoragePaths;
                in
                ''
                  environment.persistence:
                      All filesystems used for persistent storage must
                      have the flag neededForBoot set to true.

                      Please fix or remove the following paths:
                        ${concatStringsSep "\n      " offenders}
                '';
            }
            {
              assertion = all (users: (homeDirOffenders users) == { }) usersPerPath;
              message =
                let
                  offendersPerPath = filter (users: (homeDirOffenders users) != { }) usersPerPath;
                  offendersText =
                    concatMapStringsSep
                      "\n      "
                      (offenders:
                        concatMapStringsSep
                          "\n      "
                          (n: "${n}: ${offenders.${n}.home} != ${config.users.users.${n}.home}")
                          (attrNames offenders))
                      offendersPerPath;
                in
                ''
                  environment.persistence:
                      Users and home doesn't match:
                        ${offendersText}

                      You probably want to set each
                      environment.persistence.<path>.users.<user>.home to
                      match the respective user's home directory as
                      defined by users.users.<user>.home.
                '';
            }
            {
              assertion = duplicates (catAttrs "filePath" files) == [ ];
              message =
                let
                  offenders = duplicates (catAttrs "filePath" files);
                in
                ''
                  environment.persistence:
                      The following files were specified two or more
                      times:
                        ${concatStringsSep "\n      " offenders}
                '';
            }
            {
              assertion = duplicates (catAttrs "dirPath" directories) == [ ];
              message =
                let
                  offenders = duplicates (catAttrs "dirPath" directories);
                in
                ''
                  environment.persistence:
                      The following directories were specified two or more
                      times:
                        ${concatStringsSep "\n      " offenders}
                '';
            }
          ];

        warnings =
          let
            usersWithoutUid = attrNames (filterAttrs (n: u: u.uid == null) config.users.users);
            groupsWithoutGid = attrNames (filterAttrs (n: g: g.gid == null) config.users.groups);
            varLibNixosPersistent =
              let
                varDirs = parentsOf "/var/lib/nixos" ++ [ "/var/lib/nixos" ];
                persistedDirs = catAttrs "dirPath" directories;
                mountedDirs = catAttrs "mountPoint" (attrValues config.fileSystems);
                persistedVarDirs = intersectLists varDirs persistedDirs;
                mountedVarDirs = intersectLists varDirs mountedDirs;
              in
              persistedVarDirs != [ ] || mountedVarDirs != [ ];
          in
          mkIf (any id allPersistentStoragePaths.enableWarnings)
            (mkMerge [
              (mkIf (!varLibNixosPersistent && (usersWithoutUid != [ ] || groupsWithoutGid != [ ])) [
                ''
                  environment.persistence:
                      Neither /var/lib/nixos nor any of its parents are
                      persisted. This means all users/groups without
                      specified uids/gids will have them reassigned on
                      reboot.
                      ${optionalString (usersWithoutUid != [ ]) ''
                      The following users are missing a uid:
                            ${concatStringsSep "\n      " usersWithoutUid}
                      ''}
                      ${optionalString (groupsWithoutGid != [ ]) ''
                      The following groups are missing a gid:
                            ${concatStringsSep "\n      " groupsWithoutGid}
                      ''}
                ''
              ])
            ]);
      }
    ]);

}
</file>

<file path="README.org">
#+TITLE: Impermanence

  Lets you choose what files and directories you want to keep between
  reboots - the rest are thrown away.

  Why would you want this?

  - It keeps your system clean by default.

  - It forces you to declare settings you want to keep.

  - It lets you experiment with new software without cluttering up
    your system.

  There are a few different things to set up for this to work:

  - A root filesystem which somehow gets wiped on reboot. There are a
    few ways to achieve this. See the [[#system-setup][System setup]] section for more info.

  - At least one mounted volume where the files and directories you
    want to keep are stored permanently.

  - At least one of the modules in this repository, which take care of
    linking or bind mounting files between the persistent storage
    mount point and the root file system. See the [[#module-usage][Module usage]] section
    for more info.

* Contact

  Join the [[https://matrix.to/#/#impermanence:nixos.org][matrix room]] to chat about the project.

* System setup

  There are many ways to wipe your root partition between boots. This
  section lists a few common ways to accomplish this, but is by no
  means an exhaustive list.

*** tmpfs

    The easiest method is to use a tmpfs filesystem for the
    root. This is the easiest way to set up impermanence on systems
    which currently use a traditional filesystem (ext4, xfs, etc) as
    the root filesystem, since you don't have to repartition.

    All data stored in tmpfs only resides in system memory, not on
    disk. This automatically takes care of cleaning up between boots,
    but also comes with some pretty significant drawbacks:

    - Downloading big files or trying programs that generate large
      amounts of data can easily result in either an out-of-memory or
      disk-full scenario.

    - If the system crashes or loses power before you've had a chance
      to move files you want to keep to persistent storage, they're
      gone forever.

    Using tmpfs as the root filesystem, the filesystem setup would
    look something like this:

    #+begin_src nix
      {
        fileSystems."/" = {
          device = "none";
          fsType = "tmpfs";
          options = [ "defaults" "size=25%" "mode=755" ];
        };

        fileSystems."/persistent" = {
          device = "/dev/root_vg/root";
          neededForBoot = true;
          fsType = "btrfs";
          options = [ "subvol=persistent" ];
        };

        fileSystems."/nix" = {
          device = "/dev/root_vg/root";
          fsType = "btrfs";
          options = [ "subvol=nix" ];
        };

        fileSystems."/boot" = {
          device = "/dev/disk/by-uuid/XXXX-XXXX";
          fsType = "vfat";
        };
      }
    #+end_src

    where the ~size~ option determines how much system memory is allowed
    to be used by the filesystem.

*** BTRFS subvolumes

    A more advanced solution which doesn't have the same drawbacks as
    using tmpfs is to use a regular filesystem, but clean it up
    between boots. A relatively easy way to do this is to use BTRFS
    and create a new subvolume to use as root on boot. This also
    allows you to keep a number of old roots around, in case of
    crashes, power outages or other accidents.

    A setup which would automatically remove roots that are
    older than 30 days could look like this:

    #+begin_src nix
      {
        fileSystems."/" = {
          device = "/dev/root_vg/root";
          fsType = "btrfs";
          options = [ "subvol=root" ];
        };

        boot.initrd.postResumeCommands = lib.mkAfter ''
          mkdir /btrfs_tmp
          mount /dev/root_vg/root /btrfs_tmp
          if [[ -e /btrfs_tmp/root ]]; then
              mkdir -p /btrfs_tmp/old_roots
              timestamp=$(date --date="@$(stat -c %Y /btrfs_tmp/root)" "+%Y-%m-%-d_%H:%M:%S")
              mv /btrfs_tmp/root "/btrfs_tmp/old_roots/$timestamp"
          fi

          delete_subvolume_recursively() {
              IFS=$'\n'
              for i in $(btrfs subvolume list -o "$1" | cut -f 9- -d ' '); do
                  delete_subvolume_recursively "/btrfs_tmp/$i"
              done
              btrfs subvolume delete "$1"
          }

          for i in $(find /btrfs_tmp/old_roots/ -maxdepth 1 -mtime +30); do
              delete_subvolume_recursively "$i"
          done

          btrfs subvolume create /btrfs_tmp/root
          umount /btrfs_tmp
        '';

        fileSystems."/persistent" = {
          device = "/dev/root_vg/root";
          neededForBoot = true;
          fsType = "btrfs";
          options = [ "subvol=persistent" ];
        };

        fileSystems."/nix" = {
          device = "/dev/root_vg/root";
          fsType = "btrfs";
          options = [ "subvol=nix" ];
        };

        fileSystems."/boot" = {
          device = "/dev/disk/by-uuid/XXXX-XXXX";
          fsType = "vfat";
        };
      }
    #+end_src

    This assumes the BTRFS filesystem can be found in an LVM volume
    group called ~root_vg~. Adjust the path as necessary.

* Module usage

  There are currently two modules: one for ~NixOS~ and one for ~home-manager~.

*** NixOS

    To use the module, import it into your configuration with

    #+begin_src nix
      {
        imports = [ /path/to/impermanence/nixos.nix ];
      }
    #+end_src

    or use the provided ~nixosModules.impermanence~ flake output:

    #+begin_src nix
      {
        inputs = {
          impermanence.url = "github:nix-community/impermanence";
        };

        outputs = { self, nixpkgs, impermanence, ... }:
          {
            nixosConfigurations.sythe = nixpkgs.lib.nixosSystem {
              system = "x86_64-linux";
              modules = [
                impermanence.nixosModules.impermanence
                ./machines/sythe/configuration.nix
              ];
            };
          };
      }
    #+end_src

    This adds the ~environment.persistence~ option, which is an
    attribute set of submodules, where the attribute name is the path
    to persistent storage.

    Usage is shown best with an example:

    #+begin_src nix
      {
        environment.persistence."/persistent" = {
          enable = true;  # NB: Defaults to true, not needed
          hideMounts = true;
          directories = [
            "/var/log"
            "/var/lib/bluetooth"
            "/var/lib/nixos"
            "/var/lib/systemd/coredump"
            "/etc/NetworkManager/system-connections"
            { directory = "/var/lib/colord"; user = "colord"; group = "colord"; mode = "u=rwx,g=rx,o="; }
          ];
          files = [
            "/etc/machine-id"
            { file = "/var/keys/secret_file"; parentDirectory = { mode = "u=rwx,g=,o="; }; }
          ];
          users.talyz = {
            directories = [
              "Downloads"
              "Music"
              "Pictures"
              "Documents"
              "Videos"
              "VirtualBox VMs"
              { directory = ".gnupg"; mode = "0700"; }
              { directory = ".ssh"; mode = "0700"; }
              { directory = ".nixops"; mode = "0700"; }
              { directory = ".local/share/keyrings"; mode = "0700"; }
              ".local/share/direnv"
            ];
            files = [
              ".screenrc"
            ];
          };
        };
      }
    #+end_src

    - ~"/persistent"~ is the path to your persistent storage location

      This allows for multiple different persistent storage
      locations. If you, for example, have one location you back up
      and one you don't, you can use both by defining two separate
      attributes under ~environment.persistence~.

    - ~enable~ determines whether the persistent storage location should
      be enabled or not. Useful when sharing configurations between
      systems with and without impermanence setups. Defaults to ~true~.

    - ~hideMounts~ allows you to specify whether to hide the
      bind mounts from showing up as mounted drives in the file
      manager. If enabled, it sets the mount option ~x-gvfs-hide~
      on all the bind mounts.

    - ~directories~ are all directories you want to bind mount to
      persistent storage. A directory can be represented either as a
      string, simply denoting its path, or as a submodule. The
      submodule representation is useful when the default assumptions,
      mainly regarding permissions, are incorrect. The available
      options are:

      - ~directory~, the path to the directory you want to bind mount
        to persistent storage. Only setting this option is
        equivalent to the string representation.

      - ~persistentStoragePath~, the path to persistent
        storage. Defaults to the ~environment.persistence~ submodule
        name, i.e. ~"/persistent"~ in the example. This should most
        likely be left to its default value - don't change it unless
        you're certain you really need to.

      - ~user~, the user who should own the directory. If the directory
        doesn't already exist in persistent storage, it will be
        created and this user will be its owner. This also applies to
        any parent directories which don't yet exist. Changing this
        once the directory has been created has no effect.

      - ~group~, the group who should own the directory. If the
        directory doesn't already exist in persistent storage, it will
        be created and this group will be its owner. This also applies
        to any parent directories which don't yet exist. Changing this
        once the directory has been created has no effect.

      - ~mode~, the permissions to set for the directory. If the
        directory doesn't already exist in persistent storage, it will
        be created with this mode. Can be either an octal mode
        (e.g. ~0700~) or a symbolic mode (e.g. ~u=rwx,g=,o=~). Parent
        directories that don't yet exist are created with default
        permissions. Changing this once the directory has been created
        has no effect.

    - ~files~ are all files you want to link or bind to persistent
      storage. A file can be represented either as a string, simply
      denoting its path, or as a submodule. The submodule
      representation is useful when the default assumptions, mainly
      regarding the permissions of its parent directory, are
      incorrect. The available options are:

      - ~file~, the path to the file you want to bind mount to
        persistent storage. Only setting this option is equivalent to
        the string representation.

      - ~persistentStoragePath~, the path to persistent
        storage. Defaults to the ~environment.persistence~ submodule
        name, i.e. ~"/persistent"~ in the example. This should most
        likely be left to its default value - don't change it unless
        you're certain you really need to.

      - ~parentDirectory~, the permissions that should be applied to the
        file's parent directory, if it doesn't already
        exist. Available options are ~user~, ~group~ and ~mode~. See their
        definition in ~directories~ above.

      If the file exists in persistent storage, it will be bind
      mounted to the target path; otherwise it will be symlinked.

    - ~users.talyz~ handles files and directories in ~talyz~'s home
      directory

      The ~users~ option defines a set of submodules which correspond to
      the users' names. The ~directories~ and ~files~ options of each
      submodule work like their root counterparts, but the paths are
      automatically prefixed with with the user's home directory.

      If the user has a non-standard home directory (i.e. not
      ~/home/<username>~), the ~users.<username>.home~ option has to be
      set to this path - it can't currently be automatically deduced
      due to a limitation in ~nixpkgs~.

    /Important note:/ Make sure your persistent volumes are marked with
    ~neededForBoot~, otherwise you will run into problems.

*** home-manager

    Usage of the ~home-manager~ module is very similar to the one of the
    ~NixOS~ module - the key differences are that the ~persistence~ option
    is now under ~home~, rather than ~environment~, and the addition of
    the submodule option ~removePrefixDirectory~.

    /Important note:/ You have to use the ~home-manager~ ~NixOS~ module (in
    the ~nixos~ directory of ~home-manager~'s repo) in order for this
    module to work as intended.

    To use the module, import it into your configuration with

    #+begin_src nix
      {
        imports = [ /path/to/impermanence/home-manager.nix ];
      }
    #+end_src

    or use the provided ~homeManagerModules.impermanence~ flake output:

    #+begin_src nix
      {
        inputs = {
          home-manager.url = "github:nix-community/home-manager";
          impermanence.url = "github:nix-community/impermanence";
        };

        outputs =
          {
            home-manager,
            nixpkgs,
            impermanence,
            ...
          }:
          {
            nixosConfigurations.sythe = nixpkgs.lib.nixosSystem {
              system = "x86_64-linux";
              modules = [
                {
                  imports = [ home-manager.nixosModules.home-manager ];

                  home-manager.users.username =
                    { ... }:
                    {
                      imports = [
                        impermanence.homeManagerModules.impermanence
                        ./home/impermanence.nix # Your home-manager impermanence-configuration
                      ];
                    };
                }
              ];
            };
          };
      }
    #+end_src

    This adds the ~home.persistence~ option, which is an attribute set
    of submodules, where the attribute name is the path to persistent
    storage.

    Usage is shown best with an example:

    #+begin_src nix
      {
        home.persistence."/persistent/home/talyz" = {
          directories = [
            "Downloads"
            "Music"
            "Pictures"
            "Documents"
            "Videos"
            "VirtualBox VMs"
            ".gnupg"
            ".ssh"
            ".nixops"
            ".local/share/keyrings"
            ".local/share/direnv"
            {
              directory = ".local/share/Steam";
              method = "symlink";
            }
          ];
          files = [
            ".screenrc"
          ];
          allowOther = true;
        };
      }
    #+end_src

    - ~"/persistent/home/talyz"~ is the path to your persistent storage location
    - ~directories~ are all directories you want to link to persistent storage
        - It is possible to switch the linking ~method~ between bindfs (the
          default) and symbolic links.
    - ~files~ are all files you want to link to persistent storage. These are
      symbolic links to their target location.
    - ~allowOther~ allows other users, such as ~root~, to access files
      through the bind mounted directories listed in
      ~directories~. Useful for ~sudo~ operations, Docker, etc. Requires
      the NixOS configuration ~programs.fuse.userAllowOther = true~.

    Additionally, the ~home-manager~ module allows for compatibility
    with ~dotfiles~ repos structured for use with [[https://www.gnu.org/software/stow/][GNU Stow]], where the
    files linked to are one level deeper than where they should end
    up. This can be achieved by setting ~removePrefixDirectory~ to ~true~:

    #+begin_src nix
      {
        home.persistence."/etc/nixos/home-talyz-nixpkgs/dotfiles" = {
          removePrefixDirectory = true;
          files = [
            "screen/.screenrc"
          ];
          directories = [
            "fish/.config/fish"
          ];
        };
      }
    #+end_src

    In the example, the ~.screenrc~ file and ~.config/fish~ directory
    should be linked to from the home directory; ~removePrefixDirectory~
    removes the first part of the path when deciding where to put the
    links.

    /Note:/ When using ~bindfs~ fuse filesystem for directories, the names of
    the directories you add will be visible in the ~/etc/mtab~ file and in the
    output of ~mount~ to all users.

** Further reading
   The following blog posts provide more information on the concept of ephemeral
   roots:

   - https://elis.nu/blog/2020/05/nixos-tmpfs-as-root/ --- [[https://github.com/etu/][@etu]]'s blog post walks
     the reader through a NixOS-on-tmpfs installation.
   - https://grahamc.com/blog/erase-your-darlings --- [[https://github.com/grahamc/][@grahamc]]'s blog post details
     why one would want to erase their state at every boot, as well as how to
     achieve this using ZFS snapshots.
   - https://willbush.dev/blog/impermanent-nixos/ --- [[https://github.com/willbush/][@willbush]]'s blog post
     provides a detailed NixOS-on-tmpfs guide with optional LUKS encryption, and
     utilizing nix flakes for an opinionated install.
</file>

</files>
