This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    check-up-to-date-generated-files.yml
    update-flake-lock.yml
    update-schemas.yml
json-schema-bundler/
  bin/
    index.mjs
  default.nix
  node-env.nix
  node-packages.nix
  package.json
  README.md
lib/
  arrays.ncl
  main.ncl
  numbers.ncl
  README.md
  records.ncl
  strings.ncl
.gitignore
extract-schemas.py
flake.lock
flake.nix
gh-actions.ncl
LICENSE
main.ncl
Nickel-pkg.ncl
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/check-up-to-date-generated-files.yml">
jobs:
  check-up-to-date-generated-files:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v2
    - name: Install Nix
      uses: cachix/install-nix-action@v26
      with:
        extra_nix_config: accept-flake-config = true
    - uses: cachix/cachix-action@v14
      with:
        authToken: ${{ secrets.CACHIX_AUTH_TOKEN }}
        name: nickel-schemastore
    - name: Check that the file generated by Organist are up-to-date
      run: |-
        nix run .#regenerate-files -L
        git diff --exit-code && echo "All files up-to-date ✅"
on:
  push: {}
</file>

<file path=".github/workflows/update-flake-lock.yml">
jobs:
  update-flake-lock:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v2
    - name: Install Nix
      uses: cachix/install-nix-action@v26
      with:
        extra_nix_config: accept-flake-config = true
    - uses: cachix/cachix-action@v14
      with:
        authToken: ${{ secrets.CACHIX_AUTH_TOKEN }}
        name: nickel-schemastore
    - name: Update flake.lock
      uses: DeterminateSystems/update-flake-lock@v21
on:
  schedule:
  - cron: 0 0 * * 0
</file>

<file path=".github/workflows/update-schemas.yml">
jobs:
  test:
    permissions:
      contents: write
      pull-requests: write
    runs-on: ubuntu-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v2
    - name: Install Nix
      uses: cachix/install-nix-action@v26
      with:
        extra_nix_config: accept-flake-config = true
    - uses: cachix/cachix-action@v14
      with:
        authToken: ${{ secrets.CACHIX_AUTH_TOKEN }}
        name: nickel-schemastore
    - env:
        GH_TOKEN: ${{ github.token }}
      name: Update the schemas from upstream
      run: |-
        nix develop --command python3 ./extract-schemas.py
        if ! git diff --exit-code; then
          BRANCH_NAME=update-schemas-from-$GITHUB_RUN_ID
          git checkout -b "$BRANCH_NAME"
          git add .
          git config user.name "Schemas update bot"
          git config user.email "noreply@schemaupdate.invalid"
          git commit --message="Re-generate the schema files"
          git push origin "$BRANCH_NAME"
          nix run --inputs-from . nixpkgs\#gh -- pr create \
            --head "$BRANCH_NAME" \
            --title "Re-generate the schema files" \
            --body "Automated update from $GITHUB_RUN_ID"
        fi
on:
  schedule:
  - cron: 0 0 * * 0
  workflow_dispatch: {}
</file>

<file path="json-schema-bundler/bin/index.mjs">
#! /usr/bin/env node
import $RefParser from "@apidevtools/json-schema-ref-parser"

// Pass a file path, URL, or string as the first argument
const input_schema = process.argv[2]
const schema = await $RefParser.bundle(input_schema)
console.log(JSON.stringify(schema, null, 2))
</file>

<file path="json-schema-bundler/default.nix">
# This file has been generated by node2nix 1.11.1. Do not edit!

{pkgs ? import <nixpkgs> {
    inherit system;
  }, system ? builtins.currentSystem, nodejs ? pkgs."nodejs-14_x"}:

let
  nodeEnv = import ./node-env.nix {
    inherit (pkgs) stdenv lib python2 runCommand writeTextFile writeShellScript;
    inherit pkgs nodejs;
    libtool = if pkgs.stdenv.isDarwin then pkgs.darwin.cctools else null;
  };
in
import ./node-packages.nix {
  inherit (pkgs) fetchurl nix-gitignore stdenv lib fetchgit;
  inherit nodeEnv;
}
</file>

<file path="json-schema-bundler/node-env.nix">
# This file originates from node2nix

{lib, stdenv, nodejs, python2, pkgs, libtool, runCommand, writeTextFile, writeShellScript}:

let
  # Workaround to cope with utillinux in Nixpkgs 20.09 and util-linux in Nixpkgs master
  utillinux = if pkgs ? utillinux then pkgs.utillinux else pkgs.util-linux;

  python = if nodejs ? python then nodejs.python else python2;

  # Create a tar wrapper that filters all the 'Ignoring unknown extended header keyword' noise
  tarWrapper = runCommand "tarWrapper" {} ''
    mkdir -p $out/bin

    cat > $out/bin/tar <<EOF
    #! ${stdenv.shell} -e
    $(type -p tar) "\$@" --warning=no-unknown-keyword --delay-directory-restore
    EOF

    chmod +x $out/bin/tar
  '';

  # Function that generates a TGZ file from a NPM project
  buildNodeSourceDist =
    { name, version, src, ... }:

    stdenv.mkDerivation {
      name = "node-tarball-${name}-${version}";
      inherit src;
      buildInputs = [ nodejs ];
      buildPhase = ''
        export HOME=$TMPDIR
        tgzFile=$(npm pack | tail -n 1) # Hooks to the pack command will add output (https://docs.npmjs.com/misc/scripts)
      '';
      installPhase = ''
        mkdir -p $out/tarballs
        mv $tgzFile $out/tarballs
        mkdir -p $out/nix-support
        echo "file source-dist $out/tarballs/$tgzFile" >> $out/nix-support/hydra-build-products
      '';
    };

  # Common shell logic
  installPackage = writeShellScript "install-package" ''
    installPackage() {
      local packageName=$1 src=$2

      local strippedName

      local DIR=$PWD
      cd $TMPDIR

      unpackFile $src

      # Make the base dir in which the target dependency resides first
      mkdir -p "$(dirname "$DIR/$packageName")"

      if [ -f "$src" ]
      then
          # Figure out what directory has been unpacked
          packageDir="$(find . -maxdepth 1 -type d | tail -1)"

          # Restore write permissions to make building work
          find "$packageDir" -type d -exec chmod u+x {} \;
          chmod -R u+w "$packageDir"

          # Move the extracted tarball into the output folder
          mv "$packageDir" "$DIR/$packageName"
      elif [ -d "$src" ]
      then
          # Get a stripped name (without hash) of the source directory.
          # On old nixpkgs it's already set internally.
          if [ -z "$strippedName" ]
          then
              strippedName="$(stripHash $src)"
          fi

          # Restore write permissions to make building work
          chmod -R u+w "$strippedName"

          # Move the extracted directory into the output folder
          mv "$strippedName" "$DIR/$packageName"
      fi

      # Change to the package directory to install dependencies
      cd "$DIR/$packageName"
    }
  '';

  # Bundle the dependencies of the package
  #
  # Only include dependencies if they don't exist. They may also be bundled in the package.
  includeDependencies = {dependencies}:
    lib.optionalString (dependencies != []) (
      ''
        mkdir -p node_modules
        cd node_modules
      ''
      + (lib.concatMapStrings (dependency:
        ''
          if [ ! -e "${dependency.packageName}" ]; then
              ${composePackage dependency}
          fi
        ''
      ) dependencies)
      + ''
        cd ..
      ''
    );

  # Recursively composes the dependencies of a package
  composePackage = { name, packageName, src, dependencies ? [], ... }@args:
    builtins.addErrorContext "while evaluating node package '${packageName}'" ''
      installPackage "${packageName}" "${src}"
      ${includeDependencies { inherit dependencies; }}
      cd ..
      ${lib.optionalString (builtins.substring 0 1 packageName == "@") "cd .."}
    '';

  pinpointDependencies = {dependencies, production}:
    let
      pinpointDependenciesFromPackageJSON = writeTextFile {
        name = "pinpointDependencies.js";
        text = ''
          var fs = require('fs');
          var path = require('path');

          function resolveDependencyVersion(location, name) {
              if(location == process.env['NIX_STORE']) {
                  return null;
              } else {
                  var dependencyPackageJSON = path.join(location, "node_modules", name, "package.json");

                  if(fs.existsSync(dependencyPackageJSON)) {
                      var dependencyPackageObj = JSON.parse(fs.readFileSync(dependencyPackageJSON));

                      if(dependencyPackageObj.name == name) {
                          return dependencyPackageObj.version;
                      }
                  } else {
                      return resolveDependencyVersion(path.resolve(location, ".."), name);
                  }
              }
          }

          function replaceDependencies(dependencies) {
              if(typeof dependencies == "object" && dependencies !== null) {
                  for(var dependency in dependencies) {
                      var resolvedVersion = resolveDependencyVersion(process.cwd(), dependency);

                      if(resolvedVersion === null) {
                          process.stderr.write("WARNING: cannot pinpoint dependency: "+dependency+", context: "+process.cwd()+"\n");
                      } else {
                          dependencies[dependency] = resolvedVersion;
                      }
                  }
              }
          }

          /* Read the package.json configuration */
          var packageObj = JSON.parse(fs.readFileSync('./package.json'));

          /* Pinpoint all dependencies */
          replaceDependencies(packageObj.dependencies);
          if(process.argv[2] == "development") {
              replaceDependencies(packageObj.devDependencies);
          }
          else {
              packageObj.devDependencies = {};
          }
          replaceDependencies(packageObj.optionalDependencies);
          replaceDependencies(packageObj.peerDependencies);

          /* Write the fixed package.json file */
          fs.writeFileSync("package.json", JSON.stringify(packageObj, null, 2));
        '';
      };
    in
    ''
      node ${pinpointDependenciesFromPackageJSON} ${if production then "production" else "development"}

      ${lib.optionalString (dependencies != [])
        ''
          if [ -d node_modules ]
          then
              cd node_modules
              ${lib.concatMapStrings (dependency: pinpointDependenciesOfPackage dependency) dependencies}
              cd ..
          fi
        ''}
    '';

  # Recursively traverses all dependencies of a package and pinpoints all
  # dependencies in the package.json file to the versions that are actually
  # being used.

  pinpointDependenciesOfPackage = { packageName, dependencies ? [], production ? true, ... }@args:
    ''
      if [ -d "${packageName}" ]
      then
          cd "${packageName}"
          ${pinpointDependencies { inherit dependencies production; }}
          cd ..
          ${lib.optionalString (builtins.substring 0 1 packageName == "@") "cd .."}
      fi
    '';

  # Extract the Node.js source code which is used to compile packages with
  # native bindings
  nodeSources = runCommand "node-sources" {} ''
    tar --no-same-owner --no-same-permissions -xf ${nodejs.src}
    mv node-* $out
  '';

  # Script that adds _integrity fields to all package.json files to prevent NPM from consulting the cache (that is empty)
  addIntegrityFieldsScript = writeTextFile {
    name = "addintegrityfields.js";
    text = ''
      var fs = require('fs');
      var path = require('path');

      function augmentDependencies(baseDir, dependencies) {
          for(var dependencyName in dependencies) {
              var dependency = dependencies[dependencyName];

              // Open package.json and augment metadata fields
              var packageJSONDir = path.join(baseDir, "node_modules", dependencyName);
              var packageJSONPath = path.join(packageJSONDir, "package.json");

              if(fs.existsSync(packageJSONPath)) { // Only augment packages that exist. Sometimes we may have production installs in which development dependencies can be ignored
                  console.log("Adding metadata fields to: "+packageJSONPath);
                  var packageObj = JSON.parse(fs.readFileSync(packageJSONPath));

                  if(dependency.integrity) {
                      packageObj["_integrity"] = dependency.integrity;
                  } else {
                      packageObj["_integrity"] = "sha1-000000000000000000000000000="; // When no _integrity string has been provided (e.g. by Git dependencies), add a dummy one. It does not seem to harm and it bypasses downloads.
                  }

                  if(dependency.resolved) {
                      packageObj["_resolved"] = dependency.resolved; // Adopt the resolved property if one has been provided
                  } else {
                      packageObj["_resolved"] = dependency.version; // Set the resolved version to the version identifier. This prevents NPM from cloning Git repositories.
                  }

                  if(dependency.from !== undefined) { // Adopt from property if one has been provided
                      packageObj["_from"] = dependency.from;
                  }

                  fs.writeFileSync(packageJSONPath, JSON.stringify(packageObj, null, 2));
              }

              // Augment transitive dependencies
              if(dependency.dependencies !== undefined) {
                  augmentDependencies(packageJSONDir, dependency.dependencies);
              }
          }
      }

      if(fs.existsSync("./package-lock.json")) {
          var packageLock = JSON.parse(fs.readFileSync("./package-lock.json"));

          if(![1, 2].includes(packageLock.lockfileVersion)) {
            process.stderr.write("Sorry, I only understand lock file versions 1 and 2!\n");
            process.exit(1);
          }

          if(packageLock.dependencies !== undefined) {
              augmentDependencies(".", packageLock.dependencies);
          }
      }
    '';
  };

  # Reconstructs a package-lock file from the node_modules/ folder structure and package.json files with dummy sha1 hashes
  reconstructPackageLock = writeTextFile {
    name = "reconstructpackagelock.js";
    text = ''
      var fs = require('fs');
      var path = require('path');

      var packageObj = JSON.parse(fs.readFileSync("package.json"));

      var lockObj = {
          name: packageObj.name,
          version: packageObj.version,
          lockfileVersion: 2,
          requires: true,
          packages: {
              "": {
                  name: packageObj.name,
                  version: packageObj.version,
                  license: packageObj.license,
                  bin: packageObj.bin,
                  dependencies: packageObj.dependencies,
                  engines: packageObj.engines,
                  optionalDependencies: packageObj.optionalDependencies
              }
          },
          dependencies: {}
      };

      function augmentPackageJSON(filePath, packages, dependencies) {
          var packageJSON = path.join(filePath, "package.json");
          if(fs.existsSync(packageJSON)) {
              var packageObj = JSON.parse(fs.readFileSync(packageJSON));
              packages[filePath] = {
                  version: packageObj.version,
                  integrity: "sha1-000000000000000000000000000=",
                  dependencies: packageObj.dependencies,
                  engines: packageObj.engines,
                  optionalDependencies: packageObj.optionalDependencies
              };
              dependencies[packageObj.name] = {
                  version: packageObj.version,
                  integrity: "sha1-000000000000000000000000000=",
                  dependencies: {}
              };
              processDependencies(path.join(filePath, "node_modules"), packages, dependencies[packageObj.name].dependencies);
          }
      }

      function processDependencies(dir, packages, dependencies) {
          if(fs.existsSync(dir)) {
              var files = fs.readdirSync(dir);

              files.forEach(function(entry) {
                  var filePath = path.join(dir, entry);
                  var stats = fs.statSync(filePath);

                  if(stats.isDirectory()) {
                      if(entry.substr(0, 1) == "@") {
                          // When we encounter a namespace folder, augment all packages belonging to the scope
                          var pkgFiles = fs.readdirSync(filePath);

                          pkgFiles.forEach(function(entry) {
                              if(stats.isDirectory()) {
                                  var pkgFilePath = path.join(filePath, entry);
                                  augmentPackageJSON(pkgFilePath, packages, dependencies);
                              }
                          });
                      } else {
                          augmentPackageJSON(filePath, packages, dependencies);
                      }
                  }
              });
          }
      }

      processDependencies("node_modules", lockObj.packages, lockObj.dependencies);

      fs.writeFileSync("package-lock.json", JSON.stringify(lockObj, null, 2));
    '';
  };

  # Script that links bins defined in package.json to the node_modules bin directory
  # NPM does not do this for top-level packages itself anymore as of v7
  linkBinsScript = writeTextFile {
    name = "linkbins.js";
    text = ''
      var fs = require('fs');
      var path = require('path');

      var packageObj = JSON.parse(fs.readFileSync("package.json"));

      var nodeModules = Array(packageObj.name.split("/").length).fill("..").join(path.sep);

      if(packageObj.bin !== undefined) {
          fs.mkdirSync(path.join(nodeModules, ".bin"))

          if(typeof packageObj.bin == "object") {
              Object.keys(packageObj.bin).forEach(function(exe) {
                  if(fs.existsSync(packageObj.bin[exe])) {
                      console.log("linking bin '" + exe + "'");
                      fs.symlinkSync(
                          path.join("..", packageObj.name, packageObj.bin[exe]),
                          path.join(nodeModules, ".bin", exe)
                      );
                  }
                  else {
                      console.log("skipping non-existent bin '" + exe + "'");
                  }
              })
          }
          else {
              if(fs.existsSync(packageObj.bin)) {
                  console.log("linking bin '" + packageObj.bin + "'");
                  fs.symlinkSync(
                      path.join("..", packageObj.name, packageObj.bin),
                      path.join(nodeModules, ".bin", packageObj.name.split("/").pop())
                  );
              }
              else {
                  console.log("skipping non-existent bin '" + packageObj.bin + "'");
              }
          }
      }
      else if(packageObj.directories !== undefined && packageObj.directories.bin !== undefined) {
          fs.mkdirSync(path.join(nodeModules, ".bin"))

          fs.readdirSync(packageObj.directories.bin).forEach(function(exe) {
              if(fs.existsSync(path.join(packageObj.directories.bin, exe))) {
                  console.log("linking bin '" + exe + "'");
                  fs.symlinkSync(
                      path.join("..", packageObj.name, packageObj.directories.bin, exe),
                      path.join(nodeModules, ".bin", exe)
                  );
              }
              else {
                  console.log("skipping non-existent bin '" + exe + "'");
              }
          })
      }
    '';
  };

  prepareAndInvokeNPM = {packageName, bypassCache, reconstructLock, npmFlags, production}:
    let
      forceOfflineFlag = if bypassCache then "--offline" else "--registry http://www.example.com";
    in
    ''
        # Pinpoint the versions of all dependencies to the ones that are actually being used
        echo "pinpointing versions of dependencies..."
        source $pinpointDependenciesScriptPath

        # Patch the shebangs of the bundled modules to prevent them from
        # calling executables outside the Nix store as much as possible
        patchShebangs .

        # Deploy the Node.js package by running npm install. Since the
        # dependencies have been provided already by ourselves, it should not
        # attempt to install them again, which is good, because we want to make
        # it Nix's responsibility. If it needs to install any dependencies
        # anyway (e.g. because the dependency parameters are
        # incomplete/incorrect), it fails.
        #
        # The other responsibilities of NPM are kept -- version checks, build
        # steps, postprocessing etc.

        export HOME=$TMPDIR
        cd "${packageName}"
        runHook preRebuild

        ${lib.optionalString bypassCache ''
          ${lib.optionalString reconstructLock ''
            if [ -f package-lock.json ]
            then
                echo "WARNING: Reconstruct lock option enabled, but a lock file already exists!"
                echo "This will most likely result in version mismatches! We will remove the lock file and regenerate it!"
                rm package-lock.json
            else
                echo "No package-lock.json file found, reconstructing..."
            fi

            node ${reconstructPackageLock}
          ''}

          node ${addIntegrityFieldsScript}
        ''}

        npm ${forceOfflineFlag} --nodedir=${nodeSources} ${npmFlags} ${lib.optionalString production "--production"} rebuild

        runHook postRebuild

        if [ "''${dontNpmInstall-}" != "1" ]
        then
            # NPM tries to download packages even when they already exist if npm-shrinkwrap is used.
            rm -f npm-shrinkwrap.json

            npm ${forceOfflineFlag} --nodedir=${nodeSources} --no-bin-links --ignore-scripts ${npmFlags} ${lib.optionalString production "--production"} install
        fi

        # Link executables defined in package.json
        node ${linkBinsScript}
    '';

  # Builds and composes an NPM package including all its dependencies
  buildNodePackage =
    { name
    , packageName
    , version ? null
    , dependencies ? []
    , buildInputs ? []
    , production ? true
    , npmFlags ? ""
    , dontNpmInstall ? false
    , bypassCache ? false
    , reconstructLock ? false
    , preRebuild ? ""
    , dontStrip ? true
    , unpackPhase ? "true"
    , buildPhase ? "true"
    , meta ? {}
    , ... }@args:

    let
      extraArgs = removeAttrs args [ "name" "dependencies" "buildInputs" "dontStrip" "dontNpmInstall" "preRebuild" "unpackPhase" "buildPhase" "meta" ];
    in
    stdenv.mkDerivation ({
      name = "${name}${if version == null then "" else "-${version}"}";
      buildInputs = [ tarWrapper python nodejs ]
        ++ lib.optional (stdenv.isLinux) utillinux
        ++ lib.optional (stdenv.isDarwin) libtool
        ++ buildInputs;

      inherit nodejs;

      inherit dontStrip; # Stripping may fail a build for some package deployments
      inherit dontNpmInstall preRebuild unpackPhase buildPhase;

      compositionScript = composePackage args;
      pinpointDependenciesScript = pinpointDependenciesOfPackage args;

      passAsFile = [ "compositionScript" "pinpointDependenciesScript" ];

      installPhase = ''
        source ${installPackage}

        # Create and enter a root node_modules/ folder
        mkdir -p $out/lib/node_modules
        cd $out/lib/node_modules

        # Compose the package and all its dependencies
        source $compositionScriptPath

        ${prepareAndInvokeNPM { inherit packageName bypassCache reconstructLock npmFlags production; }}

        # Create symlink to the deployed executable folder, if applicable
        if [ -d "$out/lib/node_modules/.bin" ]
        then
            ln -s $out/lib/node_modules/.bin $out/bin

            # Patch the shebang lines of all the executables
            ls $out/bin/* | while read i
            do
                file="$(readlink -f "$i")"
                chmod u+rwx "$file"
                patchShebangs "$file"
            done
        fi

        # Create symlinks to the deployed manual page folders, if applicable
        if [ -d "$out/lib/node_modules/${packageName}/man" ]
        then
            mkdir -p $out/share
            for dir in "$out/lib/node_modules/${packageName}/man/"*
            do
                mkdir -p $out/share/man/$(basename "$dir")
                for page in "$dir"/*
                do
                    ln -s $page $out/share/man/$(basename "$dir")
                done
            done
        fi

        # Run post install hook, if provided
        runHook postInstall
      '';

      meta = {
        # default to Node.js' platforms
        platforms = nodejs.meta.platforms;
      } // meta;
    } // extraArgs);

  # Builds a node environment (a node_modules folder and a set of binaries)
  buildNodeDependencies =
    { name
    , packageName
    , version ? null
    , src
    , dependencies ? []
    , buildInputs ? []
    , production ? true
    , npmFlags ? ""
    , dontNpmInstall ? false
    , bypassCache ? false
    , reconstructLock ? false
    , dontStrip ? true
    , unpackPhase ? "true"
    , buildPhase ? "true"
    , ... }@args:

    let
      extraArgs = removeAttrs args [ "name" "dependencies" "buildInputs" ];
    in
      stdenv.mkDerivation ({
        name = "node-dependencies-${name}${if version == null then "" else "-${version}"}";

        buildInputs = [ tarWrapper python nodejs ]
          ++ lib.optional (stdenv.isLinux) utillinux
          ++ lib.optional (stdenv.isDarwin) libtool
          ++ buildInputs;

        inherit dontStrip; # Stripping may fail a build for some package deployments
        inherit dontNpmInstall unpackPhase buildPhase;

        includeScript = includeDependencies { inherit dependencies; };
        pinpointDependenciesScript = pinpointDependenciesOfPackage args;

        passAsFile = [ "includeScript" "pinpointDependenciesScript" ];

        installPhase = ''
          source ${installPackage}

          mkdir -p $out/${packageName}
          cd $out/${packageName}

          source $includeScriptPath

          # Create fake package.json to make the npm commands work properly
          cp ${src}/package.json .
          chmod 644 package.json
          ${lib.optionalString bypassCache ''
            if [ -f ${src}/package-lock.json ]
            then
                cp ${src}/package-lock.json .
                chmod 644 package-lock.json
            fi
          ''}

          # Go to the parent folder to make sure that all packages are pinpointed
          cd ..
          ${lib.optionalString (builtins.substring 0 1 packageName == "@") "cd .."}

          ${prepareAndInvokeNPM { inherit packageName bypassCache reconstructLock npmFlags production; }}

          # Expose the executables that were installed
          cd ..
          ${lib.optionalString (builtins.substring 0 1 packageName == "@") "cd .."}

          mv ${packageName} lib
          ln -s $out/lib/node_modules/.bin $out/bin
        '';
      } // extraArgs);

  # Builds a development shell
  buildNodeShell =
    { name
    , packageName
    , version ? null
    , src
    , dependencies ? []
    , buildInputs ? []
    , production ? true
    , npmFlags ? ""
    , dontNpmInstall ? false
    , bypassCache ? false
    , reconstructLock ? false
    , dontStrip ? true
    , unpackPhase ? "true"
    , buildPhase ? "true"
    , ... }@args:

    let
      nodeDependencies = buildNodeDependencies args;
      extraArgs = removeAttrs args [ "name" "dependencies" "buildInputs" "dontStrip" "dontNpmInstall" "unpackPhase" "buildPhase" ];
    in
    stdenv.mkDerivation ({
      name = "node-shell-${name}${if version == null then "" else "-${version}"}";

      buildInputs = [ python nodejs ] ++ lib.optional (stdenv.isLinux) utillinux ++ buildInputs;
      buildCommand = ''
        mkdir -p $out/bin
        cat > $out/bin/shell <<EOF
        #! ${stdenv.shell} -e
        $shellHook
        exec ${stdenv.shell}
        EOF
        chmod +x $out/bin/shell
      '';

      # Provide the dependencies in a development shell through the NODE_PATH environment variable
      inherit nodeDependencies;
      shellHook = lib.optionalString (dependencies != []) ''
        export NODE_PATH=${nodeDependencies}/lib/node_modules
        export PATH="${nodeDependencies}/bin:$PATH"
      '';
    } // extraArgs);
in
{
  buildNodeSourceDist = lib.makeOverridable buildNodeSourceDist;
  buildNodePackage = lib.makeOverridable buildNodePackage;
  buildNodeDependencies = lib.makeOverridable buildNodeDependencies;
  buildNodeShell = lib.makeOverridable buildNodeShell;
}
</file>

<file path="json-schema-bundler/node-packages.nix">
# This file has been generated by node2nix 1.11.1. Do not edit!

{nodeEnv, fetchurl, fetchgit, nix-gitignore, stdenv, lib, globalBuildInputs ? []}:

let
  sources = {
    "@apidevtools/json-schema-ref-parser-11.5.4" = {
      name = "_at_apidevtools_slash_json-schema-ref-parser";
      packageName = "@apidevtools/json-schema-ref-parser";
      version = "11.5.4";
      src = fetchurl {
        url = "https://registry.npmjs.org/@apidevtools/json-schema-ref-parser/-/json-schema-ref-parser-11.5.4.tgz";
        sha512 = "o2fsypTGU0WxRxbax8zQoHiIB4dyrkwYfcm8TxZ+bx9pCzcWZbQtiMqpgBvWA/nJ2TrGjK5adCLfTH8wUeU/Wg==";
      };
    };
    "@jsdevtools/ono-7.1.3" = {
      name = "_at_jsdevtools_slash_ono";
      packageName = "@jsdevtools/ono";
      version = "7.1.3";
      src = fetchurl {
        url = "https://registry.npmjs.org/@jsdevtools/ono/-/ono-7.1.3.tgz";
        sha512 = "4JQNk+3mVzK3xh2rqd6RB4J46qUR19azEHBneZyTZM+c456qOrbbM/5xcR8huNCCcbVt7+UmizG6GuUvPvKUYg==";
      };
    };
    "@types/json-schema-7.0.15" = {
      name = "_at_types_slash_json-schema";
      packageName = "@types/json-schema";
      version = "7.0.15";
      src = fetchurl {
        url = "https://registry.npmjs.org/@types/json-schema/-/json-schema-7.0.15.tgz";
        sha512 = "5+fP8P8MFNC+AyZCDxrB2pkZFPGzqQWUzpSeuuVLvm8VMcorNYavBqoFcxK8bQz4Qsbn4oUEEem4wDLfcysGHA==";
      };
    };
    "argparse-2.0.1" = {
      name = "argparse";
      packageName = "argparse";
      version = "2.0.1";
      src = fetchurl {
        url = "https://registry.npmjs.org/argparse/-/argparse-2.0.1.tgz";
        sha512 = "8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==";
      };
    };
    "js-yaml-4.1.0" = {
      name = "js-yaml";
      packageName = "js-yaml";
      version = "4.1.0";
      src = fetchurl {
        url = "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.0.tgz";
        sha512 = "wpxZs9NoxZaJESJGIZTyDEaYpl0FKSA+FB9aJiyemKhMwkxQg63h4T1KJgUGHpTqPDNRcmmYLugrRjJlBtWvRA==";
      };
    };
  };
  args = {
    name = "json-schema-bundler";
    packageName = "json-schema-bundler";
    version = "1.0.0";
    src = ./.;
    dependencies = [
      sources."@apidevtools/json-schema-ref-parser-11.5.4"
      sources."@jsdevtools/ono-7.1.3"
      sources."@types/json-schema-7.0.15"
      sources."argparse-2.0.1"
      sources."js-yaml-4.1.0"
    ];
    buildInputs = globalBuildInputs;
    meta = {
      description = "CLI tool to make an offline bundle of a JSON schema by inlining all external references";
      license = "MIT";
    };
    production = true;
    bypassCache = true;
    reconstructLock = false;
  };
in
{
  args = args;
  sources = sources;
  tarball = nodeEnv.buildNodeSourceDist args;
  package = nodeEnv.buildNodePackage args;
  shell = nodeEnv.buildNodeShell args;
  nodeDependencies = nodeEnv.buildNodeDependencies (lib.overrideExisting args {
    src = stdenv.mkDerivation {
      name = args.name + "-package-json";
      src = nix-gitignore.gitignoreSourcePure [
        "*"
        "!package.json"
        "!package-lock.json"
      ] args.src;
      dontBuild = true;
      installPhase = "mkdir -p $out; cp -r ./* $out;";
    };
  });
}
</file>

<file path="json-schema-bundler/package.json">
{
  "name": "json-schema-bundler",
  "version": "1.0.0",
  "description": "CLI tool to make an offline bundle of a JSON schema by inlining all external references",
  "main": "./bin/index.mjs",
  "bin": {
    "json-schema-bundler": "./bin/index.mjs"
  },
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "json-schema",
    "ref",
    "bundle",
    "inline"
  ],
  "author": "Yann Hamdaoui <yann.hamdaoui@moduscreate.com>",
  "license": "MIT",
  "dependencies": {
    "@apidevtools/json-schema-ref-parser": "^11.5.4"
  }
}
</file>

<file path="json-schema-bundler/README.md">
# json-schema-bundler

**json-schema-bundler** is a CLI wrapper around `json-schema-ref-parser` that
simplifies the bundling process of JSON schemas. It takes a JSON schema file as
input and outputs a bundled version where all external references have been
inlined in the schema itself.

This is taken from [@hallettj](https://github.com/hallettj)'s [comment
json-schema-to-nickel
issue](https://github.com/nickel-lang/json-schema-to-nickel/issues/48#issuecomment-1901075634).

This is a very simple package currently used internally for `nickel-kubernetes`:
as such, there's no nice handling of errors, help message, etc. If this wrapper
could be useful to you though, contributions are welcome!

## Usage

```console
npm exec json-schema-bundler <input-schema-file>
```

- `<input-schema-file>`: path to the JSON schema file that you want to bundle.

The bundled JSON schema will be printed to the standard output.

## Example

```console
json-schema-bundler schema.json > schema-bundled.json
```

## License

This project is licensed under the MIT License - see the [LICENSE](../LICENSE)
file for details.
</file>

<file path="lib/arrays.ncl">
{
  ArrayOf
    | Dyn -> Dyn
    | doc m%"
      An eager version of `Array`. `value | ArrayOf C` will succeed if `value` is an array and all of
      its elements satisfy the eager part of the contract `C`.

      # Examples

      ```nickel multiline
      [1, 2, 3] | ArrayOf Number
      # => [1, 2, 3]

      [1, 2, 3] | ArrayOf String
      # => error

      ["a", "b", "c"] | ArrayOf std.enum.TagOrString
      # => ['a, 'b, 'c]
      ```
    "%
    = fun ctr =>
      std.contract.custom (fun label value =>
        if !std.is_array value then
          'Error { message = "expected an array" }
        else
          value
          |> std.array.try_fold_left
            (fun acc elt =>
              std.contract.check ctr label elt
              |> match {
                'Ok v => 'Ok (acc @ [v]),
                'Error e => 'Error e
              }
            )
            []
      ),

  Contains
    | Dyn -> Dyn
    | doc m%"
      A contract checking that an array contains something satisfying another contract.

      For example, `Contains Number` is a contract checking that the value is an array
      and that it contains at least one number.

      This is an eager contract, and it assumes that the inputs are also eager.
      Any lazy parts of the inputs will be ignored.

      # Examples

      ```nickel multiline
      ["hi", true, 1] | Contains Bool
      # => ["hi", true, 1]

      ["hi", true, 1] | Contains (Array Bool)
      # => error

      # Lazy parts of the inner contract are ignored: "hi" does not get transformed
      # to 'hi.
      ["hi", true, 1] | Contains std.enum.TagOrString
      # => ["hi", true, 1]
      ```
    "%
    = fun contract =>
      std.contract.custom (fun label value =>
        if !std.is_array value then
          'Error { message = "expected an array" }
        else
          let good_elt = (fun elt => std.contract.check contract label elt |> match { 'Ok _ => true, 'Error _ => false }) in
          if value |> std.array.any good_elt then
            'Ok value
          else
            'Error { message = "no elements matched" }
      ),

  Items
    | Array Dyn -> Dyn -> Dyn
    | doc m%"
      A contract checking that the first few elements of an array satisfy
      specific contracts, and the remaining elements satisfy another contract.
      For example, `Items [C1 C2] C3` is a contract checking that the value is
      an array, that its first two elements (if present) satisfy `C1` and `C2`
      respectively, and that any other elements satisfy `C3`.

      # Examples

      ```nickel multiline
      [1, 2, "foo", "bar"] | Items [Number, Number] String

      # The value is allowed to be shorter than the list of contracts.
      [1] | Items [Number, Number] String

      [1, "foo", "bar"] | Items [Number, Number] String
      # => error

      # Inner contracts are propagated, but note that the overall `Items` contract
      # is eager if and only if all the contracts you pass in are eager.
      [1, { foo = "str"}, "foo", "bar"] | Items [Number, { foo | Number }] String
      # => error
      ```
    "%
    = fun elt_contracts rest =>
      std.contract.custom (fun label value =>
        if !std.is_array value then
          'Error { message = "expected an array" }
        else
          let length_to_check = std.number.min (std.array.length elt_contracts) (std.array.length value) in
          let { left, right } = std.array.split_at length_to_check value in
          std.array.zip_with (fun contract elt => std.contract.check contract label elt) elt_contracts left
          |> std.array.try_fold_left
            (fun acc =>
              match {
                'Ok v => 'Ok (acc @ [v]),
                'Error e => 'Error e
              }
            )
            []
          |> match {
            'Error e => 'Error e,
            'Ok left_with_contracts =>
              # The individual elements succeeded. If there's anything left in the array, check the `rest` contract.
              right
              |> std.array.try_fold_left
                (fun acc elt =>
                  std.contract.check rest label elt
                  |> match {
                    'Ok v => 'Ok (acc @ [v]),
                    'Error e => 'Error e
                  }
                )
                left_with_contracts
          }
      ),

  UniqueItems
    | doc m%"
      Checks that the elements of an array are pairwise distinct.

      # Examples

      ```nickel multiline
      [1, 2, "3"] | UniqueItems

      [1, 3, 2, 3] | UniqueItems
      # => error: duplicate found: 3
      ```
    "%
    =
      let find_duplicate
        : Array Dyn -> { has_duplicate : Bool, duplicate : Dyn, seen : { _ : Bool } }
        | doc m%"
            Try to find a duplicate in an array of Nickel values. For
            efficiency, this function uses JSON serialization to index into
            a Nickel record. Consequently all values in the array must be
            serializable to JSON.
          "%
        =
          std.array.fold_right
            (fun elt acc =>
              if acc.has_duplicate then
                acc
              else
                let index = std.serialize 'Json elt in
                if std.record.has_field index acc.seen then
                  { has_duplicate = true, duplicate = elt, seen = acc.seen }
                else
                  { has_duplicate = false, duplicate = null, seen = std.record.insert index true acc.seen }
            )
            { has_duplicate = false, duplicate = null, seen = {} }
      in
      std.contract.from_validator (fun x =>
        if !std.is_array x then
          'Error { message = "expected an array" }
        else
          let { has_duplicate, duplicate, .. } = find_duplicate x
          in
          if has_duplicate then
            'Error { message = "duplicate found: %{std.serialize 'Json duplicate}" }
          else
            'Ok
      ),

  MinItems
    : Number -> Dyn
    | doc m%"
        A contract that checks whether an array has at least a certain number of items.

        # Examples

        ```nickel multiline
        [1, 2, 3] | MinItems 3

        [1, 2, 3] | MinItems 4
        # => error
        ```
      "%
    = fun n =>
      std.contract.from_predicate (fun arr => std.is_array arr && std.array.length (arr | Array Dyn) >= n),

  MaxItems
    : Number -> Dyn
    | doc m%"
        A contract that checks whether an array has at most a certain number of items.

        # Examples

        ```nickel multiline
        [1, 2, 3] | MaxItems 3

        [1, 2, 3] | MaxItems 2
        # => error
      "%
    = fun n =>
      std.contract.from_predicate (fun arr => std.is_array arr && std.array.length (arr | Array Dyn) <= n),
}
</file>

<file path="lib/main.ncl">
{
  Always
    | doc m%"
      A contract that always succeeds. The same as `Dyn`, but with a more JSON-schema name.

      # Examples

      ```nickel multiline
      "foo" | Always

      3 | Always
      ```
    "%
    = Dyn,

  Never
    | doc m%"
     A contract that always fails.

     # Examples

     ```nickel multiline
     "foo" | Never
     # => error

     3 | Never
     # => error
   "%
    = std.contract.from_predicate (fun _ => false),

  Null
    | doc m%"
      A contract asserting that a value is null.

      # Examples

      ```nickel multiline
      null | Null

      "foo" | Null
      # => error
   "%
    = std.contract.from_predicate ((==) null),

  Const
    | Dyn -> Dyn
    | doc m%"
      A more eager version of `std.contract.Equal`.

      # Examples

      ```nickel multiline
      5 | Const 5

      3 | Const 5
      # => error
      ```
    "%
    = fun expected =>
      std.contract.from_validator (fun value =>
        if value == expected then
          'Ok
        else
          'Error {
            message = "expected %{std.to_string expected}"
          }
      ),

  OneOf
    | Array Dyn -> Dyn
    | doc m%"
      Checks that exactly one of a list of contracts succeeds.

      # Examples

      ```nickel multiline
      "hi" | OneOf [Number, String, Bool]

      "hi" | OneOf [Number, String, std.enum.TagOrString]
      # => error: 2 of the contracts passed

      "hi" | OneOf [Number, std.enum.TagOrString]
      # => 'hi
      ```
    "%
    = fun contracts =>
      std.contract.custom (fun label value =>
        contracts
        |> std.array.fold_right
        # The accumulator is either `'Count n`, where `n != 1` is the number of contract
        # checks that succeeded, or it's `'Ok v`, where `v` is the value propagated by
        # the successful contract.
          (fun ctr acc =>
            std.contract.check ctr label value
            |> match {
              'Ok val =>
                acc
                |> match {
                  'Count 0 => 'Ok val,
                  'Count n => 'Count (n + 1),
                  'Ok _ => 'Count 2,
                },
              'Error e => acc
            }
          )
          ('Count 0)
        |> match {
          'Count n => 'Error { message = "%{std.to_string n} of the contracts passed, expected precisely one to pass" },
          'Ok v => 'Ok v
        }
      ),

  IfThenElse
    | Dyn -> Dyn -> Dyn -> Dyn
    | doc m%"
      `IfThenElse iph zen els` checks the `iph` contract (eagerly). If that
      succeeds, it checks the `zen` contract and otherwise checks the `els`
      contract.

      Only the eager part of the `iph` contract is used to decide which of the
      other contracts is applied. The lazy part of the `iph` contract will be
      applied if the eager part succeeds.

      # Examples

      ```nickel multiline
      6 | IfThenElse Number (number.MultipleOf 2) String

      "hi" | IfThenElse Number (number.MultipleOf 2) String

      true | IfThenElse Number (number.MultipleOf 2) String
      # => error

      # The `zen` branch gets the value that was normalized by TagOrString
      "hi" | IfThenElse std.enum.TagOrString (std.contract.Equal 'hi) Number
      ```
    "%
    = fun iph zen els =>
      std.contract.custom (fun label value =>
        std.contract.check iph label value
        |> match {
          'Ok v => std.contract.check zen label v,
          'Error _ => std.contract.check els label value,
        }
      ),

  Enum
    | Array Dyn -> Dyn
    | doc m%"
      `Enum values x` succeeds if and only if `x` is equal to one of the elements of `values`.

      # Examples

      ```nickel multiline
      "no" | Enum [false, "false", "no", "off"]

      "yes" | Enum [false, "false", "no", "off"]
      # => error
      ```
    "%
    = fun variants =>
      std.contract.from_validator (fun value =>
        let check_equal = fun input variant =>
          input == variant || (std.is_enum input && (std.string.from_enum input == variant | Bool))
        in
        if std.array.any (check_equal value) variants then
          'Ok
        else
          'Error { message = "expected one of %{std.serialize 'Json variants}" }
      ),

  Nullable
    : Dyn -> Dyn
    | doc m%"
      For a contract `C`, `Nullable C` returns a contract that allows either `C` or a null value.

      # Examples

      ```nickel multiline
      1 | Nullable Number

      null | Nullable Number

      "1" | Nullable Number
      # => error
      ```
    "%
    = fun Contract =>
      std.contract.custom (fun label value =>
        if value == null then
          'Ok value
        else
          std.contract.check Contract label value
      ),

  array = import "./arrays.ncl",
  record = import "./records.ncl",
  number = import "./numbers.ncl",
  string = import "./strings.ncl",
}
</file>

<file path="lib/numbers.ncl">
let from_predicate | (Number -> Bool) -> String -> Dyn = fun pred msg =>
  std.contract.from_validator (fun value =>
    if !std.is_number value then
      'Error { message = "expected a number" }
    else if pred (value | Number) then
      'Ok
    else
      'Error { message = msg }
  )
in
{
  MultipleOf
    | Number -> Dyn
    | doc m%"
      `MultipleOf n` is a contract checking whether a value is a multiple of `n`.

      # Examples

      ```nickel multiline
      4 | MultipleOf 2

      "4" | MultipleOf 2
      # => error: expected a number

      4 | MultipleOf 3
      # => error: expected a multiple of 3

      4 | MultipleOf 0
      # => error: expected a multiple of 0
      ```
    "%
    = fun n =>
      std.contract.from_validator (fun value =>
        if !std.is_number value then
          'Error { message = "expected a number" }
        else if n == 0 then
          'Error { message = "expected a multiple of 0" }
        else if std.number.is_integer (value / n) then
          'Ok
        else
          'Error { message = "expected a multiple of %{std.string.from_number n}" }
      ),

  Maximum
    | Number -> Dyn
    | doc m%"
      `Maximum n` is a contract checking that a number is at most `n`.

      # Examples

      ```nickel multiline
      5 | Maximum 5

      5 | Maximum 4
      # => error: expected a maximum of 4

      "5" | Maximum 5
      # => error: expected a number
      ```
    "%
    = fun limit => from_predicate (fun x => x <= limit) "expected a maximum of %{std.string.from_number limit}",

  ExclusiveMaximum
    | Number -> Dyn
    | doc m%"
      `ExclusiveMaximum n` is a contract checking that a number is at strictly less than `n`.

      # Examples

      ```nickel multiline
      5 | ExclusiveMaximum 5.1

      5 | ExclusiveMaximum 5
      # => error: expected an exclusive maximum of 5

      "5" | ExclusiveMaximum 5
      # => error: expected a number
      ```
    "%
    = fun limit => from_predicate (fun x => x < limit) "expected an exclusive maximum of %{std.string.from_number limit}",

  Minimum
    | Number -> Dyn
    | doc m%"
      `Minimum n` is a contract checking that a number is at least `n`.

      # Examples

      ```nickel multiline
      5 | Minimum 5

      5 | Minimum 6
      # => error: expected a minimum of 6

      "5" | Minimum 6
      # => error: expected a number
      ```
    "%
    = fun limit => from_predicate (fun x => x >= limit) "expected a minimum of %{std.string.from_number limit}",

  ExclusiveMinimum
    | Number -> Dyn
    | doc m%"
      `ExclusiveMinimum n` is a contract checking that a number is at strictly more than `n`.

      # Examples

      ```nickel multiline
      5 | ExclusiveMinimum 4.9

      5 | ExclusiveMinimum 5
      # => error: expected an exclusive minimum of 5

      "5" | ExclusiveMinimum 5
      # => error: expected a number
      ```
    "%
    = fun limit => from_predicate (fun x => x > limit) "expected an exclusive minimum of %{std.string.from_number limit}",
}
</file>

<file path="lib/README.md">
# json-schema-to-nickel

This library is just a vendored version of the same `lib` directory of
[json-schema-to-nickel](https://github.com/nickel-lang/json-schema-to-nickel/).
In a very near future, we'll rather put it on nickel-mine and use a central
version. This is just a work-around for the first release of nickel-schemastore.
</file>

<file path="lib/records.ncl">
let ErrData = { message | optional | String, notes | optional | Array String, blame_location | Dyn | optional } in
{
  MaxProperties
    | Number -> Dyn
    | doc m%"
      A contract that checks whether a record has at most a certain number of properties.

      # Examples

      ```nickel multiline
      { foo = 1, bar = 2 } | MaxProperties 2

      { foo = 1, bar = 2 } | MaxProperties 1
      # => error: expected a record with at most 1 fields
      ```
    "%
    = fun n =>
      std.contract.from_validator (fun value =>
        if !std.is_record value then
          'Error { message = "expected a record" }
        else if std.record.length value > n then
          'Error { message = "expected a record with at most %{std.string.from_number n} fields" }
        else
          'Ok
      ),

  MinProperties
    | Number -> Dyn
    | doc m%"
      A contract that checks whether a record has at least a certain number of properties.

      # Examples

      ```nickel multiline
      { foo = 1, bar = 2 } | MinProperties 2

      { foo = 1, bar = 2 } | MinProperties 3
      # => error: expected a record with at least 3 fields
      ```
    "%
    = fun n =>
      std.contract.from_validator (fun value =>
        if !std.is_record value then
          'Error { message = "expected a record" }
        else if std.record.length value < n then
          'Error { message = "expected a record with at least %{std.string.from_number n} fields" }
        else
          'Ok
      ),

  Required
    | Array String -> Dyn
    | doc m%"
      A contract asserting that a record has certain fields.

      # Examples


      ```nickel multiline
      { foo = 1, bar = 2 } | Required [ "foo" ]
      # => { foo = 1, bar = 2 }

      { foo = 1, bar = 2 } | Required [ "baz" ]
      # => error: missing required field baz

      "baz" | Required [ "baz" ]
      # => error: expected a record
      ```
    "%
    = fun fields =>
      std.contract.from_validator (fun value =>
        if !std.is_record value then
          'Error { message = "expected a record" }
        else
          fields
          |> std.array.try_fold_left
            (fun acc field =>
              if !std.record.has_field field value then
                'Error { message = "missing required field %{field}" }
              else
                'Ok acc
            )
            null
          |> match {
            'Error e => 'Error e,
            'Ok _ => 'Ok
          }
      ),

  Record
    | { properties | { _ | Dyn }, required | { _ | Dyn }, patterns | { _ | Dyn }, additional | [| 'None, 'Some Dyn |] } -> Dyn
    | doc m%"
      A contract for checking JSON Schema object properties.

      In `Record { properties, required, patterns, additional }`, properties and patterns
      should be dicts containing contracts as values. These contracts will be
      applied to the appropriate fields of your record. `additional` can be
      `None` (in which case fields not matching `properties` or `patterns` are
      forbidden) or `Some contract` (in which case `contract` will be applied to
      every field not matched by `properties` and `patterns`).

      The contract returned by `Record` is sort of eager: it will call
      `std.contract.check` on the appropriate field values, and then it will
      propagate any lazy contracts returned by `std.contract.check`. This makes
      `Record` a little more eager than standard record contracts, and if all
      the contracts you provide are eager then `Record` will be fully eager.

      Cf. [https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-validation-01#section-6.5]

      # Examples

      ```nickel multiline
      { foo = 1 } | Record { properties = { foo = Number }, required = {}, patterns = {}, additional = 'None }
      # => { foo = 1 }

      # Properties aren't required to be present.
      { } | Record { properties = { foo = Number }, required = {}, patterns = {}, additional = 'None }
      # => { }

      # Properties aren't required to be present.
      { } | Record { properties = { foo = Number }, required = { foo = null }, patterns = {}, additional = 'None }
      # => error

      # If something in properties also matches a pattern, both contracts are applied.
      { foo = 1.1 } | Record { properties = { foo = Number }, required = {}, patterns = { "." = std.number.Integer }, additional = 'None }
      # => error: expected an integer

      # additional being 'None means that unmatched fields are forbidden
      { bar = 1 } | Record { properties = { foo = Number }, required = {}, patterns = {}, additional = 'None }
      # => error: extra fields

      # fields that are matched by a pattern don't count as "additional"
      { bar = 1 } | Record { properties = { foo = Number }, required = {}, patterns = { "." = Number }, additional = 'None }
      # => { bar = 1 }

      # additional being 'Some applies the extra contract to unmatched fields
      { bar = 1 } | Record { properties = { foo = Number }, required = {}, patterns = {}, additional = 'Some String }
      # => error

      # Inner contracts are propagated
      { foo = { bar = 1 }} | Record { properties = { foo = { bar | String } }, required = {}, patterns = {}, additional = 'None }
      # => error: contract broken by the value of `bar`

      # Inner contracts aren't evaluated eagerly
      ({ foo = { bar = 1 }, baz = 2} | Record { properties = { foo = { bar | String } }, required = {}, patterns = {}, additional = 'Some Dyn }).baz
      # => 2
      ```
    "%
    = fun { properties, required, patterns, additional } =>
      std.contract.custom (fun label x =>
        if !std.is_record x then
          'Error { message = "expected a record" }
        else
          let x = x | { _ | Dyn } in
          let required = required | { _ | Dyn } in
          # Build a dict of everything checked by "properties". The field values
          # in this dict have any inner contracts applied.
          let checked_properties
            : [| 'Ok { _ | Dyn }, 'Error ErrData |]
            =
              std.record.to_array (properties | { _ : Dyn })
              |> std.array.try_fold_left
                (fun acc { field, value = contract } =>
                  if !std.record.has_field field x then
                    if std.record.has_field field required then
                      'Error ({ message = "missing required field `%{field}`" } | ErrData)
                    else
                      'Ok acc
                  else
                    std.contract.check contract label x."%{field}"
                    |> match {
                      'Ok checked_value => 'Ok (std.record.insert field checked_value acc),
                      'Error e => 'Error e,
                    }
                )
                ({} | { _ | Dyn })
          in
          let matching_fields : String -> { _ : Dyn } = fun pattern =>
            let matcher = std.string.is_match pattern
            in
            std.record.to_array x
            |> std.array.fold_left
              (fun acc { field, value } =>
                if matcher field then
                  std.record.insert field value acc
                else
                  acc
              )
              {}
          in
          # Build a dict of everything checked by "patterns". The field values
          # in this dict have any inner contracts applied. This can have overlap
          # with "checked_properties"; they'll get merged together later.
          let checked_pattern_properties
            : [| 'Ok { _ | Dyn }, 'Error ErrData |]
            =
              std.record.to_array (patterns | { _ : Dyn })
              |> std.array.try_fold_left
                (fun acc { field = pattern, value = contract } =>
                  matching_fields pattern
                  |> std.record.to_array
                  |> std.array.try_fold_left
                    (fun acc { field, value } =>
                      std.contract.check contract label value
                      |> match {
                        'Ok checked_value => 'Ok (std.record.insert field checked_value acc),
                        'Error e => 'Error e,
                      }
                    )
                    ({} | { _ | Dyn })
                  |> match {
                    'Ok checked_dict => 'Ok ((acc & checked_dict) | { _ | Dyn }),
                    'Error e => 'Error e,
                  }
                )
                ({} | { _ | Dyn })
          in
          [checked_properties, checked_pattern_properties]
          |> match {
            ['Error e, _] => 'Error e,
            [_, 'Error e] => 'Error e,
            ['Ok checked_properties, 'Ok checked_pattern_properties] =>
              let remaining_fields : { _ | Dyn } =
                (std.record.fields (checked_properties | { _ : Dyn }) @ std.record.fields (checked_pattern_properties | { _ : Dyn }))
                |> std.array.fold_left
                  (fun acc field =>
                    if !std.record.has_field field acc then
                      acc
                    else
                      std.record.remove field acc
                  )
                  x
              in
              let checked_additional
                : [| 'Ok { _ | Dyn }, 'Error ErrData |]
                =
                  (additional | [| 'None, 'Some Dyn |])
                  |> match {
                    'None =>
                      if !std.record.is_empty remaining_fields then
                        'Error ({ message = "extra fields %{std.serialize 'Json (std.record.fields remaining_fields | Dyn)}" } | ErrData)
                      else
                        'Ok ({} | { _ | Dyn }),
                    'Some contract =>
                      std.record.to_array remaining_fields
                      |> std.array.try_fold_left
                        (fun acc { field, value } =>
                          std.contract.check contract label value
                          |> match {
                            'Ok checked_value => 'Ok (std.record.insert field checked_value acc),
                            'Error e => 'Error e,
                          }
                        )
                        ({} | { _ | Dyn })
                  }
              in
              checked_additional
              |> match {
                'Error e => 'Error e,
                'Ok checked_additional => 'Ok (checked_properties & checked_pattern_properties & checked_additional)
              }
          }
      ),

  DependentFields
    | { _ | Array String } -> Dyn
    | doc m%"
      A contract for asserting that if some fields are present, other fields are
      also present.

      Specifically, `DependentFields { foo = ["bar", "baz"] }` is a contract
      asserting that if the field `foo` is present then the fields `bar` and
      `baz` are also present. This corresponds to the part of JSON schema's
      [dependencies](https://json-schema.org/draft-07/draft-handrews-json-schema-validation-01#rfc.section.6.5.7)
      keyword in which the values are arrays.

      This is an eager contract.

      ```nickel multiline
      { foo = 1, bar = 2 } | DependentFields { foo = ["bar"] }

      { foo = 1, baz = 2 } | DependentFields { foo = ["bar"] }
      # => error: expected field bar

      { baz = 2 } | DependentFields { foo = ["bar"] }
      ```
    "%
    = fun dependencies =>
      std.contract.from_validator (fun value =>
        if !std.is_record value then
          'Error { message = "expected a record" }
        else
          let must_have_fields : Array String -> { _ : Dyn } -> [| 'Ok, 'Error ErrData |] = fun fields x =>
            fields
            |> std.array.fold_right
              (fun field acc =>
                if !std.record.has_field field x then
                  'Error ({ message = "expected field %{field}" } | ErrData)
                else
                  acc
              )
              'Ok
          in
          dependencies
          |> std.record.to_array
          |> std.array.fold_right
            (fun { field, value = dependent_fields } acc =>
              if std.record.has_field field value then
                must_have_fields dependent_fields value
                |> match {
                  'Ok => acc,
                  'Error e => 'Error (e & { notes = ["because field %{field} was present"] }),
                }
              else
                acc
            )
            'Ok
      ),

  DependentContracts
    | { _ | Dyn } -> Dyn
    | doc m%"
      A contract for asserting that if some fields are present then the entire
      record satisfies a contract.

      Specifically, `DependentContracts { foo = C }` is a contract asserting that
      the value is a record, and if the value contains a field named `foo` then
      the entire record satisfies the contract `C`.

      `DependentContracts` calls `std.contract.check` for each of the provided
      contracts. In particular, if `C` is fully eager then so is
      `DependentContracts { foo = C }`.

      # Examples

      ```nickel multiline
      { foo = 1, bar = 2 } | DependentContracts { foo = { bar | Number, .. } }

      { foo = 1, bar = 2 } | DependentContracts { foo = { bar | Number } }
      # => error: extra field `foo`

      # This one doesn't fail: the inner contract never gets triggered because there's no `baz` field
      { foo = 1, bar = 2 } | DependentContracts { baz = { bar | Number } }

      1 | DependentContracts { baz = { bar | Number } }
      # => error: expected a record
      ```
    "%
    = fun deps =>
      std.contract.custom (fun label value =>
        if !std.is_record value then
          'Error { message = "expected a record" }
        else
          deps
          |> std.record.to_array
          # In this fold, the accumulator is `value` wrapped with whatever delayed
          # checks the dependent contracts have applied so far.
          |> std.array.try_fold_left
            (fun acc { field, value = contract } =>
              if std.record.has_field field value then
                std.contract.check contract label acc
              else
                'Ok acc
            )
            value
      ),

  # TODO: replace with std.record.FieldsMatch once that's in a nickel release
  FieldsMatch
    | String -> Dyn
    = fun regex =>
      let is_match = std.string.is_match regex in
      std.contract.from_validator (fun x =>
        if !std.is_record x then
          'Error { message = "expected a record" }
        else
          let bad_field_names =
            std.record.fields x
            |> std.array.filter (fun k => !(is_match k))
            |> std.array.map (fun k => m%""${k}""%)
          in
          if std.array.length bad_field_names > 0 then
            'Error {
              message = "invalid field names %{std.string.join "," bad_field_names}",
              notes = ["expected fields to match %{regex}"]
            }
          else
            'Ok
      ),

  PropertyNames
    | Dyn -> Dyn
    | doc m%"
      `PropertyNames C` is a contract asserting that a value is a record and all of
      its field names satisfy the contract `C`.

      `PropertyNames C` is an eager contract for any `C`. Any lazy parts of `C` will
      be ignored.

      ```nickel multiline
      { foo = 1 } | PropertyNames std.string.NonEmpty

      { "1" = 1 } | PropertyNames std.string.NumberLiteral

      { foo = 1 } | PropertyNames std.string.NumberLiteral
      # => error: invalid number literal
      ```
    "%
    = fun contract =>
      std.contract.custom (fun label value =>
        if !std.is_record value then
          'Error { message = "expected a record" }
        else
          std.record.fields value
          |> std.array.try_fold_left
            (fun acc field_name =>
              std.contract.check contract label field_name
              |> match {
                'Ok _ => 'Ok value,
                'Error e => 'Error e,
              }
            )
            ('Ok value)
      ),
}
</file>

<file path="lib/strings.ncl">
{
  MaxLength
    | Number -> Dyn
    | doc m%"
      `MaxLength n` is a contract that checks for a string of length at most `n`.

      Here, the "length" of a string is the number of extended grapheme clusters in the string.
      This may not agree with the JSON schema semantics, which counts the number of Unicode
      code points.

      # Examples

      ```nickel multiline
      "Hello" | MaxLength 5

      # 15 bytes, 3 code points, 1 extended grapheme cluster
      "👨‍🦰" | MaxLength 1

      "Hello" | MaxLength 4
      # => error
      ```
    "%
    = fun limit =>
      std.contract.from_validator (fun value =>
        if !std.is_string value then
          'Error { message = "expected a string" }
        else if std.string.length value <= limit then
          'Ok
        else
          'Error {
            message = "expected a string of length at most %{std.string.from_number limit}",
          }
      ),

  MinLength
    | Number -> Dyn
    | doc m%"
      `MinLength n` is a contract that checks for a string of length at least `n`.

      Here, the "length" of a string is the number of extended grapheme clusters in the string.
      This may not agree with the JSON schema semantics, which counts the number of Unicode
      code points.

      # Examples

      ```nickel multiline
      "Hello" | MinLength 5

      # 15 bytes, 3 code points, 1 extended grapheme cluster
      "👨‍🦰" | MinLength 3
      # => error

      "Hello" | MinLength 6
      # => error
      ```
    "%
    = fun limit =>
      std.contract.from_validator (fun value =>
        if !std.is_string value then
          'Error { message = "expected a string" }
        else if std.string.length value >= limit then
          'Ok
        else
          'Error {
            message = "expected a string of length at least %{std.string.from_number limit}",
          }
      ),

  # TODO: remove this after updating nickel to a version with std.string.Matches
  Matches
    | String -> Dyn
    | doc m%"
      Enforces that the value is a string matching the supplied regular expression.

      # Examples

      ```nickel multiline
      "hello" | Matches "^[a-z]+$"
      # => "hello"

      "42" | Matches "^[a-z]+$"
      # => error
      ```
    "%
    = fun regex =>
      let is_match = std.string.is_match regex in
      std.contract.custom (fun _label value =>
        if !(std.is_string value) then
          'Error { message = "expected a string" }
        else if is_match value then
          'Ok value
        else
          'Error { message = "expected a string matching `%{regex}`" }
      ),
}
</file>

<file path=".gitignore">
/tmp/
</file>

<file path="extract-schemas.py">
import urllib.request
import urllib.parse
import json
import subprocess
import os.path
import re
from multiprocessing import Pool

out_path = "out"
tmp_path = "tmp"
# Path to the json-schema-to-nickel library.
json_schema_to_nickel_lib = "lib/main.ncl"
# If set to `True`, the script won't process schemas that already exist in the
# output directory. Sometimes the script hangs in the middle (looks like
# a concurrency-related issue). To make it possible to regenerate contracts in
# multiple passes, enable this flag.
resume = False

def to_snake_case(description: str) -> str:
    """
    Converts a descriptive name (possibly with spaces and special characters) to
    a suitable filename for both Unix and Windows, mostly by converting to
    snake_case and getting rid of any special characters but alphanumeric and a
    few selected ones (dashes and dots).
    """
    s = re.sub(r"[ ,-]", "_", description)
    s = re.sub(r"[^a-zA-Z0-9._]", "", s)
    s = re.sub(r"__+", "_", s)
    return s.strip("_").lower()

def fetch_schema_list():
    with urllib.request.urlopen("https://www.schemastore.org/api/json/catalog.json") as response:
        return json.load(response)

def fetch_schema(schema_descr, dest_file):
    with urllib.request.urlopen(schema_descr["url"]) as response:
        data = response.read()
        with open(dest_file, "wb") as out:
            out.write(data)

def parse_attr_name(raw_url):
    url = urllib.parse.urlparse(raw_url)
    original_filename = os.path.basename(url.path)
    return os.path.splitext(original_filename)[0]

def bundle_schema(raw_schema_file, dest_file):
    with open(dest_file, "w+") as out:
        js2n = subprocess.run(["json-schema-bundler", raw_schema_file],
            stdout = out,
            check = True,
        )

def convert_to_nickel(bundled_schema_file, dest_file):
    with open(dest_file, "w+") as out:
        relative_lib_path = os.path.relpath(json_schema_to_nickel_lib, os.path.dirname(dest_file))
        js2n = subprocess.run(["json-schema-to-nickel", bundled_schema_file, "--library-path", relative_lib_path],
            stdout = out,
            check = True,
        )

def process_one_schema(schema_descr):
    name = schema_descr["name"]
    normalized_name = to_snake_case(name)
    attr_name = normalized_name

    raw_schema_file = os.path.join(tmp_path, normalized_name + ".json")
    bundled_file = os.path.join(tmp_path, normalized_name + ".bundled.json")
    dest_file = os.path.join(out_path, normalized_name + ".ncl")

    if resume and os.path.isfile(dest_file):
        print(f"{name}: skipping already converted schema")
        return f'"{attr_name}" = import "{dest_file}",'

    print(f"“{name}”: START (as {normalized_name})")

    try:
        print(f"“{name}”: Creating local files...")
        os.makedirs(os.path.dirname(raw_schema_file), exist_ok = True)
        os.makedirs(os.path.dirname(bundled_file), exist_ok = True)
        os.makedirs(os.path.dirname(dest_file), exist_ok = True)

        print(f"“{name}”: Fetching schema...")
        fetch_schema(schema_descr, raw_schema_file)

        print(f"“{name}”: Bundling schema...")
        bundle_schema(raw_schema_file, bundled_file)

        print(f"“{name}”: Converting schema...")
        convert_to_nickel(bundled_file, dest_file)

        print(f"“{name}”: OK")
    except Exception as e:
        with open(dest_file, "w+") as dest:
            print("null", file=dest)
        print(f"“{name}”: Failure")
        print(e)
    return f'"{attr_name}" = import "{dest_file}",'

def main():
    schemas = fetch_schema_list()["schemas"]

    with Pool(16) as p:
        record_fields = p.map(process_one_schema, schemas)

    with open("main.ncl", "w+") as entrypoint:
        print("{", file=entrypoint)
        for line in record_fields:
              print(line, file=entrypoint)
        print("}", file=entrypoint)

main()
</file>

<file path="flake.lock">
{
  "nodes": {
    "advisory-db": {
      "flake": false,
      "locked": {
        "lastModified": 1742638877,
        "narHash": "sha256-OVZyORVUkNR3WPv/UtZF+yf6xPLknQsfgg7RIxgJWfs=",
        "owner": "rustsec",
        "repo": "advisory-db",
        "rev": "0e75a0770bccba206f5162dc7dbe0ab66db5fc4e",
        "type": "github"
      },
      "original": {
        "owner": "rustsec",
        "repo": "advisory-db",
        "type": "github"
      }
    },
    "crane": {
      "locked": {
        "lastModified": 1746291859,
        "narHash": "sha256-DdWJLA+D5tcmrRSg5Y7tp/qWaD05ATI4Z7h22gd1h7Q=",
        "owner": "ipetkov",
        "repo": "crane",
        "rev": "dfd9a8dfd09db9aad544c4d3b6c47b12562544a5",
        "type": "github"
      },
      "original": {
        "owner": "ipetkov",
        "repo": "crane",
        "type": "github"
      }
    },
    "crane_2": {
      "locked": {
        "lastModified": 1746291859,
        "narHash": "sha256-DdWJLA+D5tcmrRSg5Y7tp/qWaD05ATI4Z7h22gd1h7Q=",
        "owner": "ipetkov",
        "repo": "crane",
        "rev": "dfd9a8dfd09db9aad544c4d3b6c47b12562544a5",
        "type": "github"
      },
      "original": {
        "owner": "ipetkov",
        "repo": "crane",
        "type": "github"
      }
    },
    "crane_3": {
      "locked": {
        "lastModified": 1742394900,
        "narHash": "sha256-vVOAp9ahvnU+fQoKd4SEXB2JG2wbENkpqcwlkIXgUC0=",
        "owner": "ipetkov",
        "repo": "crane",
        "rev": "70947c1908108c0c551ddfd73d4f750ff2ea67cd",
        "type": "github"
      },
      "original": {
        "owner": "ipetkov",
        "repo": "crane",
        "type": "github"
      }
    },
    "fenix": {
      "inputs": {
        "nixpkgs": [
          "json-schema-to-nickel",
          "nixpkgs"
        ],
        "rust-analyzer-src": "rust-analyzer-src"
      },
      "locked": {
        "lastModified": 1746254111,
        "narHash": "sha256-O7BzWR3DW85zUC2ex0WSX5UPmjM0VMDUQa1dvmd8p5Y=",
        "owner": "nix-community",
        "repo": "fenix",
        "rev": "63ff4f9bbe7dd9825b31b987c451ad272c32669f",
        "type": "github"
      },
      "original": {
        "owner": "nix-community",
        "repo": "fenix",
        "type": "github"
      }
    },
    "flake-compat": {
      "flake": false,
      "locked": {
        "lastModified": 1696426674,
        "narHash": "sha256-kvjfFW7WAETZlt09AgDn1MrtKzP7t90Vf7vypd3OL1U=",
        "owner": "edolstra",
        "repo": "flake-compat",
        "rev": "0f9255e01c2351cc7d116c072cb317785dd33b33",
        "type": "github"
      },
      "original": {
        "owner": "edolstra",
        "repo": "flake-compat",
        "type": "github"
      }
    },
    "flake-utils": {
      "inputs": {
        "systems": "systems"
      },
      "locked": {
        "lastModified": 1731533236,
        "narHash": "sha256-l0KFg5HjrsfsO/JpG+r7fRrqm12kzFHyUHqHCVpMMbI=",
        "owner": "numtide",
        "repo": "flake-utils",
        "rev": "11707dc2f618dd54ca8739b309ec4fc024de578b",
        "type": "github"
      },
      "original": {
        "owner": "numtide",
        "repo": "flake-utils",
        "type": "github"
      }
    },
    "flake-utils_2": {
      "inputs": {
        "systems": "systems_2"
      },
      "locked": {
        "lastModified": 1731533236,
        "narHash": "sha256-l0KFg5HjrsfsO/JpG+r7fRrqm12kzFHyUHqHCVpMMbI=",
        "owner": "numtide",
        "repo": "flake-utils",
        "rev": "11707dc2f618dd54ca8739b309ec4fc024de578b",
        "type": "github"
      },
      "original": {
        "owner": "numtide",
        "repo": "flake-utils",
        "type": "github"
      }
    },
    "gitignore": {
      "inputs": {
        "nixpkgs": [
          "json-schema-to-nickel",
          "nickel",
          "pre-commit-hooks",
          "nixpkgs"
        ]
      },
      "locked": {
        "lastModified": 1709087332,
        "narHash": "sha256-HG2cCnktfHsKV0s4XW83gU3F57gaTljL9KNSuG6bnQs=",
        "owner": "hercules-ci",
        "repo": "gitignore.nix",
        "rev": "637db329424fd7e46cf4185293b9cc8c88c95394",
        "type": "github"
      },
      "original": {
        "owner": "hercules-ci",
        "repo": "gitignore.nix",
        "type": "github"
      }
    },
    "json-schema-to-nickel": {
      "inputs": {
        "crane": "crane",
        "fenix": "fenix",
        "nickel": "nickel",
        "nixpkgs": "nixpkgs_2",
        "topiary": "topiary"
      },
      "locked": {
        "lastModified": 1747720472,
        "narHash": "sha256-lXjRrnV4SsyTmirDekatLzqc/+MVkvl2gh0IOU17bmM=",
        "owner": "nickel-lang",
        "repo": "json-schema-to-nickel",
        "rev": "67e6a31350d95c9dad560baa2310082246de34f0",
        "type": "github"
      },
      "original": {
        "owner": "nickel-lang",
        "repo": "json-schema-to-nickel",
        "type": "github"
      }
    },
    "nickel": {
      "inputs": {
        "crane": "crane_2",
        "flake-utils": "flake-utils_2",
        "nixpkgs": "nixpkgs",
        "pre-commit-hooks": "pre-commit-hooks",
        "rust-overlay": "rust-overlay"
      },
      "locked": {
        "lastModified": 1746323790,
        "narHash": "sha256-OM+HJIsf2IGwD8J/DBtkr2E1iWNrZFRr1SPOic8N1Ms=",
        "owner": "tweag",
        "repo": "nickel",
        "rev": "a5bdf87c0eef0fc6fc2246b3deed9a21229e2a83",
        "type": "github"
      },
      "original": {
        "owner": "tweag",
        "repo": "nickel",
        "type": "github"
      }
    },
    "nixpkgs": {
      "locked": {
        "lastModified": 1746232882,
        "narHash": "sha256-MHmBH2rS8KkRRdoU/feC/dKbdlMkcNkB5mwkuipVHeQ=",
        "owner": "nixos",
        "repo": "nixpkgs",
        "rev": "7a2622e2c0dbad5c4493cb268aba12896e28b008",
        "type": "github"
      },
      "original": {
        "owner": "nixos",
        "ref": "nixos-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "nixpkgs_2": {
      "locked": {
        "lastModified": 1746576598,
        "narHash": "sha256-FshoQvr6Aor5SnORVvh/ZdJ1Sa2U4ZrIMwKBX5k2wu0=",
        "owner": "nixos",
        "repo": "nixpkgs",
        "rev": "b3582c75c7f21ce0b429898980eddbbf05c68e55",
        "type": "github"
      },
      "original": {
        "owner": "nixos",
        "ref": "nixpkgs-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "nixpkgs_3": {
      "locked": {
        "lastModified": 1742578646,
        "narHash": "sha256-GiQ40ndXRnmmbDZvuv762vS+gew1uDpFwOfgJ8tLiEs=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "94c4dbe77c0740ebba36c173672ca15a7926c993",
        "type": "github"
      },
      "original": {
        "owner": "NixOS",
        "ref": "nixpkgs-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "nixpkgs_4": {
      "locked": {
        "lastModified": 1736320768,
        "narHash": "sha256-nIYdTAiKIGnFNugbomgBJR+Xv5F1ZQU+HfaBqJKroC0=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "4bc9c909d9ac828a039f288cf872d16d38185db8",
        "type": "github"
      },
      "original": {
        "owner": "NixOS",
        "ref": "nixpkgs-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "nixpkgs_5": {
      "locked": {
        "lastModified": 1748929857,
        "narHash": "sha256-lcZQ8RhsmhsK8u7LIFsJhsLh/pzR9yZ8yqpTzyGdj+Q=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "c2a03962b8e24e669fb37b7df10e7c79531ff1a4",
        "type": "github"
      },
      "original": {
        "id": "nixpkgs",
        "ref": "nixos-unstable",
        "type": "indirect"
      }
    },
    "pre-commit-hooks": {
      "inputs": {
        "flake-compat": "flake-compat",
        "gitignore": "gitignore",
        "nixpkgs": [
          "json-schema-to-nickel",
          "nickel",
          "nixpkgs"
        ]
      },
      "locked": {
        "lastModified": 1742649964,
        "narHash": "sha256-DwOTp7nvfi8mRfuL1escHDXabVXFGT1VlPD1JHrtrco=",
        "owner": "cachix",
        "repo": "pre-commit-hooks.nix",
        "rev": "dcf5072734cb576d2b0c59b2ac44f5050b5eac82",
        "type": "github"
      },
      "original": {
        "owner": "cachix",
        "repo": "pre-commit-hooks.nix",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "flake-utils": "flake-utils",
        "json-schema-to-nickel": "json-schema-to-nickel",
        "nixpkgs": "nixpkgs_5"
      }
    },
    "rust-analyzer-src": {
      "flake": false,
      "locked": {
        "lastModified": 1746218904,
        "narHash": "sha256-GQJFWnUbBqqcittTOrS131+OkeNki2dJTGJTdXM6bhk=",
        "owner": "rust-lang",
        "repo": "rust-analyzer",
        "rev": "6f9c62dfec1570e13ab625be0441510ed299843a",
        "type": "github"
      },
      "original": {
        "owner": "rust-lang",
        "ref": "nightly",
        "repo": "rust-analyzer",
        "type": "github"
      }
    },
    "rust-overlay": {
      "inputs": {
        "nixpkgs": [
          "json-schema-to-nickel",
          "nickel",
          "nixpkgs"
        ]
      },
      "locked": {
        "lastModified": 1746239644,
        "narHash": "sha256-wMvMBMlpS1H8CQdSSgpLeoCWS67ciEkN/GVCcwk7Apc=",
        "owner": "oxalica",
        "repo": "rust-overlay",
        "rev": "bd32e88bef6da0e021a42fb4120a8df2150e9b8c",
        "type": "github"
      },
      "original": {
        "owner": "oxalica",
        "repo": "rust-overlay",
        "type": "github"
      }
    },
    "rust-overlay_2": {
      "inputs": {
        "nixpkgs": "nixpkgs_4"
      },
      "locked": {
        "lastModified": 1742610648,
        "narHash": "sha256-9jWi3gw3fEIgEslnFjH/s1I+Iyf1+4t5B1Ed1FOiy8o=",
        "owner": "oxalica",
        "repo": "rust-overlay",
        "rev": "c60d41987df3c853e2a842de2c63ded40400979b",
        "type": "github"
      },
      "original": {
        "owner": "oxalica",
        "repo": "rust-overlay",
        "type": "github"
      }
    },
    "systems": {
      "locked": {
        "lastModified": 1681028828,
        "narHash": "sha256-Vy1rq5AaRuLzOxct8nz4T6wlgyUR7zLU309k9mBC768=",
        "owner": "nix-systems",
        "repo": "default",
        "rev": "da67096a3b9bf56a91d16901293e51ba5b49a27e",
        "type": "github"
      },
      "original": {
        "owner": "nix-systems",
        "repo": "default",
        "type": "github"
      }
    },
    "systems_2": {
      "locked": {
        "lastModified": 1681028828,
        "narHash": "sha256-Vy1rq5AaRuLzOxct8nz4T6wlgyUR7zLU309k9mBC768=",
        "owner": "nix-systems",
        "repo": "default",
        "rev": "da67096a3b9bf56a91d16901293e51ba5b49a27e",
        "type": "github"
      },
      "original": {
        "owner": "nix-systems",
        "repo": "default",
        "type": "github"
      }
    },
    "topiary": {
      "inputs": {
        "advisory-db": "advisory-db",
        "crane": "crane_3",
        "nixpkgs": "nixpkgs_3",
        "rust-overlay": "rust-overlay_2"
      },
      "locked": {
        "lastModified": 1745828502,
        "narHash": "sha256-/WQQRDV7+jGUeilEZOgSRxw/yCDwlsEs3+r6MS/43JA=",
        "owner": "tweag",
        "repo": "topiary",
        "rev": "8e7e300f8e86308a2979e59a638541c6b796c47f",
        "type": "github"
      },
      "original": {
        "owner": "tweag",
        "repo": "topiary",
        "type": "github"
      }
    }
  },
  "root": "root",
  "version": 7
}
</file>

<file path="flake.nix">
{
  inputs.nixpkgs.url = "nixpkgs/nixos-unstable";
  inputs.flake-utils.url = "github:numtide/flake-utils";
  inputs.json-schema-to-nickel.url = "github:nickel-lang/json-schema-to-nickel";

  nixConfig = {
    extra-substituters = ["https://tweag-nickel.cachix.org"];
    extra-trusted-public-keys = ["tweag-nickel.cachix.org-1:GIthuiK4LRgnW64ALYEoioVUQBWs0jexyoYVeLDBwRA="];
  };

  outputs = { nixpkgs, json-schema-to-nickel, flake-utils, ... }:
    let
      SYSTEMS = [
        "aarch64-darwin"
        "aarch64-linux"
        "x86_64-darwin"
        "x86_64-linux"
      ];
    in
    flake-utils.lib.eachSystem SYSTEMS (system:
      let pkgs = import nixpkgs { inherit system; };
      in
      {
        devShells.default = pkgs.mkShell {
          buildInputs = [
            json-schema-to-nickel.packages.${system}.default
            pkgs.python3
            (pkgs.callPackage (import ./json-schema-bundler) { }).package
          ];
        };
      });
}
</file>

<file path="gh-actions.ncl">
let gha = import "./out/GitHub Workflow.ncl" in

let setup = [
  {
    name = "Checkout",
    uses = "actions/checkout@v2",
  },
  {
    name = "Install Nix",
    uses = "cachix/install-nix-action@v26",
    with.extra_nix_config = "accept-flake-config = true",
  },
  {
    uses = "cachix/cachix-action@v14",
    with.name = "nickel-schemastore",
    with.authToken = "${{ secrets.CACHIX_AUTH_TOKEN }}",
  },
]
in

{
  update-flake-lock = {
    jobs.update-flake-lock = {
      runs-on = "ubuntu-latest",
      steps =
        setup
        @ [
          {
            name = "Update flake.lock",
            uses = "DeterminateSystems/update-flake-lock@v21",
          }
        ],
    },
    on.schedule = [{ cron = "0 0 * * 0" }],
  },

  update-schemas = {
    jobs.test = {
      permissions.pull-requests = "write-all",
      permissions.contents = "read-all",
      runs-on = "ubuntu-latest",
      steps =
        setup
        @ [
          {
            env.GH_TOKEN = "${{ github.token }}",
            name = "Update the schemas from upstream",
            run = m%"
              nix develop --command python3 ./extract-schemas.py
              if ! git diff --exit-code; then
                BRANCH_NAME=update-schemas-from-$GITHUB_RUN_ID
                git checkout -b "$BRANCH_NAME"
                git add .
                git config user.name "Schemas update bot"
                git config user.email "noreply@schemaupdate.invalid"
                git commit --message="Re-generate the schema files"
                git push origin "$BRANCH_NAME"
                nix run --inputs-from . nixpkgs\#gh -- pr create \
                  --head "$BRANCH_NAME" \
                  --title "Re-generate the schema files" \
                  --body "Automated update from $GITHUB_RUN_ID"
              fi
        "%,
          }
        ],
    },
    on.schedule = [{ cron = "0 0 * * 0" }],
    on.workflow_dispatch = {},
  },

  # check-up-to-date-generated-files = {
  #   on.push = {},
  #   jobs.check-up-to-date-generated-files = {
  #     runs-on = "ubuntu-latest",
  #     steps =
  #       setup
  #       @ [
  #         {
  #           name = "Check that the file generated by Organist are up-to-date",
  #           run = m%"
  #             nix run .#regenerate-files -L
  #             git diff --exit-code && echo "All files up-to-date ✅"
  #           "%
  #         }
  #       ],
  #   },
  # },
} | { _ | gha }
</file>

<file path="LICENSE">
MIT License

Copyright (c) Modus Create LLC and its affiliates.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="main.ncl">
{
"upsun_config" = import "out/upsun_config.ncl",
"platform.sh_application" = import "out/platform.sh_application.ncl",
"platform.sh_routes" = import "out/platform.sh_routes.ncl",
"platform.sh_services" = import "out/platform.sh_services.ncl",
"1password_ssh_agent_config" = import "out/1password_ssh_agent_config.ncl",
"application_accelerator" = import "out/application_accelerator.ncl",
"grpc_api_gateway_openapi_config" = import "out/grpc_api_gateway_openapi_config.ncl",
".net_aspire_8.0_manifest" = import "out/.net_aspire_8.0_manifest.ncl",
"anywork_automation_configuration" = import "out/anywork_automation_configuration.ncl",
"factorialdrupal_breakpoints_css" = import "out/factorialdrupal_breakpoints_css.ncl",
".adonisrc.json" = import "out/.adonisrc.json.ncl",
"aerleon.yml" = import "out/aerleon.yml.ncl",
"aerleon_network_service_definitions" = import "out/aerleon_network_service_definitions.ncl",
"aerleon_policy" = import "out/aerleon_policy.ncl",
".agripparc.json" = import "out/.agripparc.json.ncl",
"air" = import "out/air.ncl",
".aiproj.json" = import "out/.aiproj.json.ncl",
"abcinventorymoduledata" = import "out/abcinventorymoduledata.ncl",
"abcsupplyplan" = import "out/abcsupplyplan.ncl",
"aiconfig" = import "out/aiconfig.ncl",
"airlock_microgateway" = import "out/airlock_microgateway.ncl",
"angular.json" = import "out/angular.json.ncl",
".angular_cli.json" = import "out/.angular_cli.json.ncl",
"apple_app_site_association" = import "out/apple_app_site_association.ncl",
"app_config_spotify_backstage" = import "out/app_config_spotify_backstage.ncl",
"app_definition.yaml" = import "out/app_definition.yaml.ncl",
".appsemblerc.yaml" = import "out/.appsemblerc.yaml.ncl",
"appsscript.json" = import "out/appsscript.json.ncl",
"appsettings.json" = import "out/appsettings.json.ncl",
"appveyor.yml" = import "out/appveyor.yml.ncl",
"appsettings.stormpetrel.json" = import "out/appsettings.stormpetrel.json.ncl",
"aqua.yaml" = import "out/aqua.yaml.ncl",
"aqua_generate_registry.yaml" = import "out/aqua_generate_registry.yaml.ncl",
"aqua_policy.yaml" = import "out/aqua_policy.yaml.ncl",
"registry.yaml" = import "out/registry.yaml.ncl",
"arb.json" = import "out/arb.json.ncl",
"architect.yml" = import "out/architect.yml.ncl",
"arc.json" = import "out/arc.json.ncl",
"argo_events" = import "out/argo_events.ncl",
"argo_workflows" = import "out/argo_workflows.ncl",
"artifacthub_repo.yml" = import "out/artifacthub_repo.yml.ncl",
"asm_lsp" = import "out/asm_lsp.ncl",
"assemblyscript" = import "out/assemblyscript.ncl",
"asyncapi" = import "out/asyncapi.ncl",
"asyncapi_tool_file" = import "out/asyncapi_tool_file.ncl",
"atmos_manifests" = import "out/atmos_manifests.ncl",
"aurora_agile_meta_framework" = import "out/aurora_agile_meta_framework.ncl",
"avro_avsc" = import "out/avro_avsc.ncl",
"aws_appconfig_feature_flags_v1" = import "out/aws_appconfig_feature_flags_v1.ncl",
"azure_container_app_template_for_defining_an_immutable_revision" = import "out/azure_container_app_template_for_defining_an_immutable_revision.ncl",
"azure_device_update_for_iot_hub_import_manifest" = import "out/azure_device_update_for_iot_hub_import_manifest.ncl",
"azure_device_update_for_iot_hub_update_manifest" = import "out/azure_device_update_for_iot_hub_update_manifest.ncl",
"azure_devops_extension_manifest" = import "out/azure_devops_extension_manifest.ncl",
"azure_iot_edgeagent_deployment" = import "out/azure_iot_edgeagent_deployment.ncl",
"azure_iot_edgehub_deployment" = import "out/azure_iot_edgehub_deployment.ncl",
"azure_iot_edge_deployment" = import "out/azure_iot_edge_deployment.ncl",
"azure_iot_edge_deployment_template" = import "out/azure_iot_edge_deployment_template.ncl",
"azure_landing_zones_library_metadata" = import "out/azure_landing_zones_library_metadata.ncl",
"azure_landing_zones_library_policy_default_values" = import "out/azure_landing_zones_library_policy_default_values.ncl",
"azure_landing_zones_library_architecture_definition" = import "out/azure_landing_zones_library_architecture_definition.ncl",
"azure_landing_zones_library_archetype_definition" = import "out/azure_landing_zones_library_archetype_definition.ncl",
"azure_landing_zones_library_archetype_override" = import "out/azure_landing_zones_library_archetype_override.ncl",
"biome_formatter_config" = import "out/biome_formatter_config.ncl",
"bottom_configuration" = import "out/bottom_configuration.ncl",
"buf.yaml" = import "out/buf.yaml.ncl",
"buf.gen.yaml" = import "out/buf.gen.yaml.ncl",
"buf.plugin.yaml" = import "out/buf.plugin.yaml.ncl",
"buf.work.yaml" = import "out/buf.work.yaml.ncl",
"cargo_mutants_config.yaml" = import "out/cargo_mutants_config.yaml.ncl",
"cinnamon_spice_info.json" = import "out/cinnamon_spice_info.json.ncl",
"coderabbit" = import "out/coderabbit.ncl",
"codecv" = import "out/codecv.ncl",
"codifycli" = import "out/codifycli.ncl",
"cloudcannon_configuration" = import "out/cloudcannon_configuration.ncl",
"latexindent_configuration" = import "out/latexindent_configuration.ncl",
"lobe_ai_agent" = import "out/lobe_ai_agent.ncl",
"loki" = import "out/loki.ncl",
"azure_pipelines" = import "out/azure_pipelines.ncl",
"fasterci_configuration" = import "out/fasterci_configuration.ncl",
"foxx_manifest" = import "out/foxx_manifest.ncl",
"flagd_flag_configuration" = import "out/flagd_flag_configuration.ncl",
"fly.io_configuration" = import "out/fly.io_configuration.ncl",
"freifunk.de_community_api" = import "out/freifunk.de_community_api.ncl",
"frogbot_config" = import "out/frogbot_config.ncl",
".asmdef" = import "out/.asmdef.ncl",
"babelrc.json" = import "out/babelrc.json.ncl",
".backportrc.json" = import "out/.backportrc.json.ncl",
"batect.yml" = import "out/batect.yml.ncl",
"bamboo_spec" = import "out/bamboo_spec.ncl",
"beef_database_codegen" = import "out/beef_database_codegen.ncl",
"beef_entity_codegen" = import "out/beef_entity_codegen.ncl",
"beef_database_v5_codegen" = import "out/beef_database_v5_codegen.ncl",
"beef_entity_v5_codegen" = import "out/beef_entity_v5_codegen.ncl",
"bigquery_table" = import "out/bigquery_table.ncl",
"bigconfig" = import "out/bigconfig.ncl",
"bitbucket_pipelines" = import "out/bitbucket_pipelines.ncl",
"bitrise" = import "out/bitrise.ncl",
"bitrise_step" = import "out/bitrise_step.ncl",
".bootstraprc" = import "out/.bootstraprc.ncl",
"bower.json" = import "out/bower.json.ncl",
".bowerrc" = import "out/.bowerrc.ncl",
"bosh_cpi_config" = import "out/bosh_cpi_config.ncl",
"bosh_deploy_config" = import "out/bosh_deploy_config.ncl",
"boyka_framework" = import "out/boyka_framework.ncl",
"behat.yml" = import "out/behat.yml.ncl",
"partial_black.json" = import "out/partial_black.json.ncl",
"bozr.suite.json" = import "out/bozr.suite.json.ncl",
"browser.i18n.json" = import "out/browser.i18n.json.ncl",
"browsh_configuration" = import "out/browsh_configuration.ncl",
"bucklescript" = import "out/bucklescript.ncl",
"build_changelog" = import "out/build_changelog.ncl",
"build_info" = import "out/build_info.ncl",
"bukkit_plugin.yml" = import "out/bukkit_plugin.yml.ncl",
"buildkite" = import "out/buildkite.ncl",
".build.yml" = import "out/.build.yml.ncl",
"bun.lock" = import "out/bun.lock.ncl",
"bundleconfig.json" = import "out/bundleconfig.json.ncl",
"bunfig.toml" = import "out/bunfig.toml.ncl",
"bungeecord_plugin.yml" = import "out/bungeecord_plugin.yml.ncl",
"block.json" = import "out/block.json.ncl",
"block_protocol_metadata" = import "out/block_protocol_metadata.ncl",
"bx_ci" = import "out/bx_ci.ncl",
"better_scripts" = import "out/better_scripts.ncl",
"bleep" = import "out/bleep.ncl",
"cmake_presets" = import "out/cmake_presets.ncl",
"cache_warmup_config" = import "out/cache_warmup_config.ncl",
"calqulus_pipeline" = import "out/calqulus_pipeline.ncl",
"camel_yaml_dsl" = import "out/camel_yaml_dsl.ncl",
"cannon_toml" = import "out/cannon_toml.ncl",
"carafe" = import "out/carafe.ncl",
"cargo_manifest" = import "out/cargo_manifest.ncl",
"cargo_make" = import "out/cargo_make.ncl",
"catalog_info_backstage" = import "out/catalog_info_backstage.ncl",
"charmcraft" = import "out/charmcraft.ncl",
"chromia_model" = import "out/chromia_model.ncl",
"chromia_seeder_root_config" = import "out/chromia_seeder_root_config.ncl",
"chromia_seeder_module_config" = import "out/chromia_seeder_module_config.ncl",
"cibuildwheel" = import "out/cibuildwheel.ncl",
"cityjson" = import "out/cityjson.ncl",
"cloudevents_specification" = import "out/cloudevents_specification.ncl",
"conda_forge" = import "out/conda_forge.ncl",
"convex" = import "out/convex.ncl",
"conjure" = import "out/conjure.ncl",
"cnc_codes" = import "out/cnc_codes.ncl",
"cog_config_file" = import "out/cog_config_file.ncl",
"commandbox_box.json" = import "out/commandbox_box.json.ncl",
"commandbox_server.json" = import "out/commandbox_server.json.ncl",
"common_package_specification" = import "out/common_package_specification.ncl",
"cumulusci_config" = import "out/cumulusci_config.ncl",
"clawject_config" = import "out/clawject_config.ncl",
"cve_record_format" = import "out/cve_record_format.ncl",
"cycle_stack_file" = import "out/cycle_stack_file.ncl",
"cyclonedx" = import "out/cyclonedx.ncl",
"datayoga_connections" = import "out/datayoga_connections.ncl",
"datayoga_job" = import "out/datayoga_job.ncl",
"dbt_dependencies" = import "out/dbt_dependencies.ncl",
"dbt_project" = import "out/dbt_project.ncl",
"dbt_packages" = import "out/dbt_packages.ncl",
"dbt_selectors" = import "out/dbt_selectors.ncl",
"dbt_yaml_files" = import "out/dbt_yaml_files.ncl",
"dein_config" = import "out/dein_config.ncl",
"dependency_cruiser" = import "out/dependency_cruiser.ncl",
"deploystack_configuration" = import "out/deploystack_configuration.ncl",
"deta_spacefile" = import "out/deta_spacefile.ncl",
"devbox_config" = import "out/devbox_config.ncl",
"devbox_plugin" = import "out/devbox_plugin.ncl",
"drupal_breakpoints" = import "out/drupal_breakpoints.ncl",
"drupal_info" = import "out/drupal_info.ncl",
"drupal_layouts" = import "out/drupal_layouts.ncl",
"drupal_libraries" = import "out/drupal_libraries.ncl",
"drupal_links_action" = import "out/drupal_links_action.ncl",
"drupal_links_contextual" = import "out/drupal_links_contextual.ncl",
"drupal_links_menu" = import "out/drupal_links_menu.ncl",
"drupal_links_task" = import "out/drupal_links_task.ncl",
"drupal_migration" = import "out/drupal_migration.ncl",
"drupal_permissions" = import "out/drupal_permissions.ncl",
"drupal_recipe" = import "out/drupal_recipe.ncl",
"drupal_routing" = import "out/drupal_routing.ncl",
"drupal_config" = import "out/drupal_config.ncl",
"drupal_services" = import "out/drupal_services.ncl",
"helm_chart.yaml" = import "out/helm_chart.yaml.ncl",
"helm_chart.lock" = import "out/helm_chart.lock.ncl",
"helm_unittest_test_suite" = import "out/helm_unittest_test_suite.ncl",
"circleci_config.yml" = import "out/circleci_config.yml.ncl",
"code_climate" = import "out/code_climate.ncl",
".cirrus.yml" = import "out/.cirrus.yml.ncl",
".clasp.json" = import "out/.clasp.json.ncl",
"clangd" = import "out/clangd.ncl",
"clang_tidy" = import "out/clang_tidy.ncl",
"clib" = import "out/clib.ncl",
"cloudify" = import "out/cloudify.ncl",
"cloud_init_cloud_config_userdata" = import "out/cloud_init_cloud_config_userdata.ncl",
"codemagic" = import "out/codemagic.ncl",
"codux" = import "out/codux.ncl",
"devcontainer.json" = import "out/devcontainer.json.ncl",
"codecov_configuration_files" = import "out/codecov_configuration_files.ncl",
"codeship_pro_services_configuration_files" = import "out/codeship_pro_services_configuration_files.ncl",
"codeship_pro_steps_configuration_files" = import "out/codeship_pro_steps_configuration_files.ncl",
"vcpkg_manifest_file" = import "out/vcpkg_manifest_file.ncl",
"vcpkg_configuration_file" = import "out/vcpkg_configuration_file.ncl",
"vercel" = import "out/vercel.ncl",
"vscode_code_snippets" = import "out/vscode_code_snippets.ncl",
"compilerconfig.json" = import "out/compilerconfig.json.ncl",
"compile_commands.json" = import "out/compile_commands.json.ncl",
"commands.json" = import "out/commands.json.ncl",
"common_catalog_data" = import "out/common_catalog_data.ncl",
"cosmos.config.json" = import "out/cosmos.config.json.ncl",
"chrome_extension" = import "out/chrome_extension.ncl",
"chrome_extension_locales_messages.json" = import "out/chrome_extension_locales_messages.json.ncl",
"chutzpah.json" = import "out/chutzpah.json.ncl",
"contentmanifest.json" = import "out/contentmanifest.json.ncl",
"cloud_sdk_pipeline_configuration" = import "out/cloud_sdk_pipeline_configuration.ncl",
"cloudbuild.json" = import "out/cloudbuild.json.ncl",
"google_cloud_workflows" = import "out/google_cloud_workflows.ncl",
"aws_cdk_cdk.json" = import "out/aws_cdk_cdk.json.ncl",
"aws_cloudformation" = import "out/aws_cloudformation.ncl",
"aws_cloudformation_serverless_application_model_sam" = import "out/aws_cloudformation_serverless_application_model_sam.ncl",
"aws_sam_cli_samconfig" = import "out/aws_sam_cli_samconfig.ncl",
"landing_zone_accelerator_on_aws_accounts_config" = import "out/landing_zone_accelerator_on_aws_accounts_config.ncl",
"landing_zone_accelerator_on_aws_customizations_config" = import "out/landing_zone_accelerator_on_aws_customizations_config.ncl",
"landing_zone_accelerator_on_aws_global_config" = import "out/landing_zone_accelerator_on_aws_global_config.ncl",
"landing_zone_accelerator_on_aws_iam_config" = import "out/landing_zone_accelerator_on_aws_iam_config.ncl",
"landing_zone_accelerator_on_aws_network_config" = import "out/landing_zone_accelerator_on_aws_network_config.ncl",
"landing_zone_accelerator_on_aws_organization_config" = import "out/landing_zone_accelerator_on_aws_organization_config.ncl",
"landing_zone_accelerator_on_aws_replacements_config" = import "out/landing_zone_accelerator_on_aws_replacements_config.ncl",
"landing_zone_accelerator_on_aws_security_config" = import "out/landing_zone_accelerator_on_aws_security_config.ncl",
"changesets" = import "out/changesets.ncl",
"chisel_slices.json" = import "out/chisel_slices.json.ncl",
"citation_file_format" = import "out/citation_file_format.ncl",
"coffeelint.json" = import "out/coffeelint.json.ncl",
"committed.toml" = import "out/committed.toml.ncl",
"composer.json" = import "out/composer.json.ncl",
"component.json" = import "out/component.json.ncl",
"component_detection_manifest.json" = import "out/component_detection_manifest.json.ncl",
"contribute.json" = import "out/contribute.json.ncl",
"crowdin.yml" = import "out/crowdin.yml.ncl",
"crowdsec_collection_config" = import "out/crowdsec_collection_config.ncl",
"crowdsec_parser_config" = import "out/crowdsec_parser_config.ncl",
"crowdsec_scenario_config" = import "out/crowdsec_scenario_config.ncl",
"cypress.json" = import "out/cypress.json.ncl",
".creatomic" = import "out/.creatomic.ncl",
"cspell_cspell.json" = import "out/cspell_cspell.json.ncl",
"css_comb_.csscomb.json" = import "out/css_comb_.csscomb.json.ncl",
"css_lint_.csslintrc" = import "out/css_lint_.csslintrc.ncl",
"dart_build_config_dart_build.json" = import "out/dart_build_config_dart_build.json.ncl",
"dart_test_config_dart_test.json" = import "out/dart_test_config_dart_test.json.ncl",
"dashlord_configuration" = import "out/dashlord_configuration.ncl",
"data_contract_specification" = import "out/data_contract_specification.ncl",
"data_product_specification" = import "out/data_product_specification.ncl",
"datalogic_scan2deploy_android" = import "out/datalogic_scan2deploy_android.ncl",
"datalogic_scan2deploy_ce" = import "out/datalogic_scan2deploy_ce.ncl",
"ddev_global" = import "out/ddev_global.ncl",
"ddev_project" = import "out/ddev_project.ncl",
"debugsettings.json" = import "out/debugsettings.json.ncl",
"deno_config_deno.json" = import "out/deno_config_deno.json.ncl",
"dependabot.json" = import "out/dependabot.json.ncl",
"dependabot_v2.json" = import "out/dependabot_v2.json.ncl",
"deployer_recipe" = import "out/deployer_recipe.ncl",
"detekt_config_detekt.yml" = import "out/detekt_config_detekt.yml.ncl",
"discord_webhook" = import "out/discord_webhook.ncl",
"dockerd.json" = import "out/dockerd.json.ncl",
"docker_bake" = import "out/docker_bake.ncl",
"docker_sequencer" = import "out/docker_sequencer.ncl",
"docfx_config_docfx.json" = import "out/docfx_config_docfx.json.ncl",
"dofigen" = import "out/dofigen.ncl",
"dolittle_artifacts" = import "out/dolittle_artifacts.ncl",
"dolittle_bounded_context_configuration" = import "out/dolittle_bounded_context_configuration.ncl",
"dolittle_event_horizons_configuration" = import "out/dolittle_event_horizons_configuration.ncl",
"dolittle_resources_configuration" = import "out/dolittle_resources_configuration.ncl",
"dolittle_server_configuration" = import "out/dolittle_server_configuration.ncl",
"dolittle_tenants_configuration" = import "out/dolittle_tenants_configuration.ncl",
"dolittle_tenant_map_configuration" = import "out/dolittle_tenant_map_configuration.ncl",
"dolittle_topology" = import "out/dolittle_topology.ncl",
"dotnet_release_index_manifest" = import "out/dotnet_release_index_manifest.ncl",
"dotnet_tools.json" = import "out/dotnet_tools.json.ncl",
"dotnetcli.host.json" = import "out/dotnetcli.host.json.ncl",
"dprint.json" = import "out/dprint.json.ncl",
"drone.json" = import "out/drone.json.ncl",
"drush_site_aliases" = import "out/drush_site_aliases.ncl",
"dss_2.0.0.json" = import "out/dss_2.0.0.json.ncl",
"dstack_configuration" = import "out/dstack_configuration.ncl",
"dvc.yaml" = import "out/dvc.yaml.ncl",
"devfile" = import "out/devfile.ncl",
"dwp_exchange_gateway" = import "out/dwp_exchange_gateway.ncl",
"dwp_exchange_meta" = import "out/dwp_exchange_meta.ncl",
"dwp_exchange_catalogue_entry" = import "out/dwp_exchange_catalogue_entry.ncl",
"ecosystem.json" = import "out/ecosystem.json.ncl",
"eksctl" = import "out/eksctl.ncl",
"elgato_stream_deck" = import "out/elgato_stream_deck.ncl",
"enterprise_contract_policy_spec" = import "out/enterprise_contract_policy_spec.ncl",
".esmrc.json" = import "out/.esmrc.json.ncl",
"esquio" = import "out/esquio.ncl",
"epr_manifest.json" = import "out/epr_manifest.json.ncl",
"electron_builder_configuration_file" = import "out/electron_builder_configuration_file.ncl",
"evcc.yaml" = import "out/evcc.yaml.ncl",
"everyvoice_tts_toolkit_aligner_configuration" = import "out/everyvoice_tts_toolkit_aligner_configuration.ncl",
"everyvoice_tts_toolkit_data_configuration" = import "out/everyvoice_tts_toolkit_data_configuration.ncl",
"everyvoice_tts_toolkit_text_configuration" = import "out/everyvoice_tts_toolkit_text_configuration.ncl",
"everyvoice_tts_toolkit_vocoder_configuration" = import "out/everyvoice_tts_toolkit_vocoder_configuration.ncl",
"everyvoice_tts_toolkit_feature_prediction_configuration" = import "out/everyvoice_tts_toolkit_feature_prediction_configuration.ncl",
"everyvoice_tts_toolkit_e2e_configuration" = import "out/everyvoice_tts_toolkit_e2e_configuration.ncl",
"expo_sdk" = import "out/expo_sdk.ncl",
"eas_config" = import "out/eas_config.ncl",
"easyvcr_.net" = import "out/easyvcr_.net.ncl",
"ezd_task_runner" = import "out/ezd_task_runner.ncl",
".eslintrc" = import "out/.eslintrc.ncl",
"fabric.mod.json" = import "out/fabric.mod.json.ncl",
"f_droid_data_metadata" = import "out/f_droid_data_metadata.ncl",
".ffizer.yaml" = import "out/.ffizer.yaml.ncl",
"firebase" = import "out/firebase.ncl",
"google_chrome_related_website_sets" = import "out/google_chrome_related_website_sets.ncl",
"fiqus" = import "out/fiqus.ncl",
"flexget_config" = import "out/flexget_config.ncl",
"first_timers_bot" = import "out/first_timers_bot.ncl",
"foundry_vtt_base_package_manifest" = import "out/foundry_vtt_base_package_manifest.ncl",
"foundry_vtt_module_manifest" = import "out/foundry_vtt_module_manifest.ncl",
"foundry_vtt_system_manifest" = import "out/foundry_vtt_system_manifest.ncl",
"foundry_vtt_world_manifest" = import "out/foundry_vtt_world_manifest.ncl",
"foundry_vtt_system_data_template" = import "out/foundry_vtt_system_data_template.ncl",
"fossa_configuration_file" = import "out/fossa_configuration_file.ncl",
"fossas_fossa_deps_file" = import "out/fossas_fossa_deps_file.ncl",
"karakum_configuration_file" = import "out/karakum_configuration_file.ncl",
"knative_functions_func.yaml" = import "out/knative_functions_func.yaml.ncl",
"ksail" = import "out/ksail.ncl",
"function.json" = import "out/function.json.ncl",
"g2p_mapping_configuration" = import "out/g2p_mapping_configuration.ncl",
"gaspar" = import "out/gaspar.ncl",
"gatewaycore_api_gateway" = import "out/gatewaycore_api_gateway.ncl",
"gcp_blueprint_metadata" = import "out/gcp_blueprint_metadata.ncl",
"global_privacy_control" = import "out/global_privacy_control.ncl",
"gitversion" = import "out/gitversion.ncl",
"gitea_issue_template_configuration" = import "out/gitea_issue_template_configuration.ncl",
"gitea_issue_template_forms" = import "out/gitea_issue_template_forms.ncl",
"github_action" = import "out/github_action.ncl",
"github_discussion" = import "out/github_discussion.ncl",
"github_funding" = import "out/github_funding.ncl",
"github_issue_template_configuration" = import "out/github_issue_template_configuration.ncl",
"github_issue_template_forms" = import "out/github_issue_template_forms.ncl",
"github_workflow" = import "out/github_workflow.ncl",
"github_workflow_template_properties" = import "out/github_workflow_template_properties.ncl",
"github_automatically_generated_release_notes_configuration" = import "out/github_automatically_generated_release_notes_configuration.ncl",
"gitlab_ci" = import "out/gitlab_ci.ncl",
"gitpod_automations" = import "out/gitpod_automations.ncl",
"gitpod_configuration" = import "out/gitpod_configuration.ncl",
"ansible_execution_environment" = import "out/ansible_execution_environment.ncl",
"ansible_meta" = import "out/ansible_meta.ncl",
"ansible_meta_runtime" = import "out/ansible_meta_runtime.ncl",
"ansible_argument_specs" = import "out/ansible_argument_specs.ncl",
"ansible_requirements" = import "out/ansible_requirements.ncl",
"ansible_vars_file" = import "out/ansible_vars_file.ncl",
"ansible_tasks_file" = import "out/ansible_tasks_file.ncl",
"ansible_playbook" = import "out/ansible_playbook.ncl",
"ansible_rulebook" = import "out/ansible_rulebook.ncl",
"ansible_inventory" = import "out/ansible_inventory.ncl",
"ansible_collection_galaxy" = import "out/ansible_collection_galaxy.ncl",
"ansible_lint_configuration" = import "out/ansible_lint_configuration.ncl",
"ansible_navigator_configuration" = import "out/ansible_navigator_configuration.ncl",
"global.json" = import "out/global.json.ncl",
"golangci_lint_configuration" = import "out/golangci_lint_configuration.ncl",
"golangci_lint_custom_plugins_configuration" = import "out/golangci_lint_custom_plugins_configuration.ncl",
"go_feature_flag_flag_configuration" = import "out/go_feature_flag_flag_configuration.ncl",
"goreleaser" = import "out/goreleaser.ncl",
"goreleaser_pro" = import "out/goreleaser_pro.ncl",
"goss" = import "out/goss.ncl",
"grafana_5.x_dashboard" = import "out/grafana_5.x_dashboard.ncl",
"tree_sitter_grammar.json" = import "out/tree_sitter_grammar.json.ncl",
"graphql_mesh" = import "out/graphql_mesh.ncl",
"graphql_config" = import "out/graphql_config.ncl",
"graphql_code_generator" = import "out/graphql_code_generator.ncl",
"grunt_copy_task" = import "out/grunt_copy_task.ncl",
"grunt_clean_task" = import "out/grunt_clean_task.ncl",
"grunt_cssmin_task" = import "out/grunt_cssmin_task.ncl",
"grunt_jshint_task" = import "out/grunt_jshint_task.ncl",
"grunt_watch_task" = import "out/grunt_watch_task.ncl",
"grunt_base_task" = import "out/grunt_base_task.ncl",
"haxelib.json" = import "out/haxelib.json.ncl",
"hayson" = import "out/hayson.ncl",
"haystack_pipeline" = import "out/haystack_pipeline.ncl",
"hazelcast_5_configuration" = import "out/hazelcast_5_configuration.ncl",
"home_assistant_integration_manifest" = import "out/home_assistant_integration_manifest.ncl",
"homer_dashboard_configuration" = import "out/homer_dashboard_configuration.ncl",
"host.json" = import "out/host.json.ncl",
"host_meta.json" = import "out/host_meta.json.ncl",
".htmlhintrc" = import "out/.htmlhintrc.ncl",
".htmlvalidate" = import "out/.htmlvalidate.ncl",
"ory_hydra_configuration" = import "out/ory_hydra_configuration.ncl",
"hyperfoil_benchmark_configuration" = import "out/hyperfoil_benchmark_configuration.ncl",
"ibm_zapp_document" = import "out/ibm_zapp_document.ncl",
"ibm_zcodeformatsettings" = import "out/ibm_zcodeformatsettings.ncl",
"ide.host.json" = import "out/ide.host.json.ncl",
"ifstate.conf" = import "out/ifstate.conf.ncl",
"imageoptimizer.json" = import "out/imageoptimizer.json.ncl",
".imgbotconfig" = import "out/.imgbotconfig.ncl",
"img_catapult_psp" = import "out/img_catapult_psp.ncl",
"importmap.json" = import "out/importmap.json.ncl",
"infrahub" = import "out/infrahub.ncl",
"iobroker_configuration" = import "out/iobroker_configuration.ncl",
"iobroker_json_ui" = import "out/iobroker_json_ui.ncl",
"iobroker_package_manifest" = import "out/iobroker_package_manifest.ncl",
"jasmine" = import "out/jasmine.ncl",
"jekyll" = import "out/jekyll.ncl",
"jenkins_x_pipelines" = import "out/jenkins_x_pipelines.ncl",
"jenkins_x_requirements" = import "out/jenkins_x_requirements.ncl",
"jest" = import "out/jest.ncl",
"jdownloader2_crawler_single_rules" = import "out/jdownloader2_crawler_single_rules.ncl",
"jdownloader2_crawler_multi_rules" = import "out/jdownloader2_crawler_multi_rules.ncl",
"jfrog_applications_config" = import "out/jfrog_applications_config.ncl",
"jfrog_file_spec" = import "out/jfrog_file_spec.ncl",
"jmeter_dsl_cli_config" = import "out/jmeter_dsl_cli_config.ncl",
"jovo_language_models" = import "out/jovo_language_models.ncl",
"jreleaser" = import "out/jreleaser.ncl",
"jsr_package_config_jsr.json" = import "out/jsr_package_config_jsr.json.ncl",
".jsbeautifyrc" = import "out/.jsbeautifyrc.ncl",
".jsbeautifyrc_nested" = import "out/.jsbeautifyrc_nested.ncl",
".jscsrc" = import "out/.jscsrc.ncl",
".jshintrc" = import "out/.jshintrc.ncl",
".jsinspectrc" = import "out/.jsinspectrc.ncl",
"json_api" = import "out/json_api.ncl",
"json_document_transform" = import "out/json_document_transform.ncl",
"json_feed" = import "out/json_feed.ncl",
".jsonld" = import "out/.jsonld.ncl",
"jsonpatch" = import "out/jsonpatch.ncl",
"jsconfig.json" = import "out/jsconfig.json.ncl",
"k3d.yaml" = import "out/k3d.yaml.ncl",
"kas" = import "out/kas.ncl",
"k9s_aliases.yaml" = import "out/k9s_aliases.yaml.ncl",
"k9s_config.yaml" = import "out/k9s_config.yaml.ncl",
"k9s_cluster_config.yaml" = import "out/k9s_cluster_config.yaml.ncl",
"k9s_hotkeys.yaml" = import "out/k9s_hotkeys.yaml.ncl",
"k9s_plugins.yaml" = import "out/k9s_plugins.yaml.ncl",
"k9s_skin.yaml" = import "out/k9s_skin.yaml.ncl",
"k9s_views.yaml" = import "out/k9s_views.yaml.ncl",
"kimmdy_config_file" = import "out/kimmdy_config_file.ncl",
"kestra_flow_file" = import "out/kestra_flow_file.ncl",
"kometa_config_file" = import "out/kometa_config_file.ncl",
"kometa_nightly_config_file" = import "out/kometa_nightly_config_file.ncl",
"krakend" = import "out/krakend.ncl",
"datadog_service_definition" = import "out/datadog_service_definition.ncl",
"datadog_software_catalog" = import "out/datadog_software_catalog.ncl",
"ory_keto_configuration" = import "out/ory_keto_configuration.ncl",
"kontinuous_values.yaml" = import "out/kontinuous_values.yaml.ncl",
"kontinuous_config.yaml" = import "out/kontinuous_config.yaml.ncl",
"kubri_configuration" = import "out/kubri_configuration.ncl",
"kustomization.yaml" = import "out/kustomization.yaml.ncl",
"label_commenter_config.yml" = import "out/label_commenter_config.yml.ncl",
"launchsettings.json" = import "out/launchsettings.json.ncl",
"lefthook" = import "out/lefthook.ncl",
"lego.json" = import "out/lego.json.ncl",
"lerna.json" = import "out/lerna.json.ncl",
"lgtm.yml" = import "out/lgtm.yml.ncl",
"liblab.config.json" = import "out/liblab.config.json.ncl",
"libman.json" = import "out/libman.json.ncl",
"license_report_config.json" = import "out/license_report_config.json.ncl",
"liferay_client_extension.yaml" = import "out/liferay_client_extension.yaml.ncl",
"linkinator.config.json" = import "out/linkinator.config.json.ncl",
"linkml_metamodel" = import "out/linkml_metamodel.ncl",
"lively_properties" = import "out/lively_properties.ncl",
"loobin" = import "out/loobin.ncl",
"lotus.yaml" = import "out/lotus.yaml.ncl",
"local.settings.json" = import "out/local.settings.json.ncl",
"localazy.json" = import "out/localazy.json.ncl",
"lsdlschema.json" = import "out/lsdlschema.json.ncl",
".luaurc" = import "out/.luaurc.ncl",
"mapehr_mapping" = import "out/mapehr_mapping.ncl",
"a_micro_editor_config" = import "out/a_micro_editor_config.ncl",
"megalinter_configuration" = import "out/megalinter_configuration.ncl",
"megalinter_descriptor" = import "out/megalinter_descriptor.ncl",
"meltano_project_definition" = import "out/meltano_project_definition.ncl",
"metadata_for_a_bazel_module" = import "out/metadata_for_a_bazel_module.ncl",
"metatype_configuration" = import "out/metatype_configuration.ncl",
"metricshub_configuration" = import "out/metricshub_configuration.ncl",
"metricshub_connector_configuration" = import "out/metricshub_connector_configuration.ncl",
"microsoft_band_web_tile" = import "out/microsoft_band_web_tile.ncl",
"mimetypes.json" = import "out/mimetypes.json.ncl",
"minecraft_data_pack_advancement" = import "out/minecraft_data_pack_advancement.ncl",
"minecraft_data_pack_biome" = import "out/minecraft_data_pack_biome.ncl",
"minecraft_data_pack_configured_carver" = import "out/minecraft_data_pack_configured_carver.ncl",
"minecraft_data_pack_damage_type" = import "out/minecraft_data_pack_damage_type.ncl",
"minecraft_data_pack_dimension_type" = import "out/minecraft_data_pack_dimension_type.ncl",
"minecraft_data_pack_dimension" = import "out/minecraft_data_pack_dimension.ncl",
"minecraft_data_pack_item_modifier" = import "out/minecraft_data_pack_item_modifier.ncl",
"minecraft_data_pack_loot_table" = import "out/minecraft_data_pack_loot_table.ncl",
"minecraft_data_pack_metadata" = import "out/minecraft_data_pack_metadata.ncl",
"minecraft_data_pack_predicate" = import "out/minecraft_data_pack_predicate.ncl",
"minecraft_data_pack_recipe" = import "out/minecraft_data_pack_recipe.ncl",
"minecraft_data_pack_tag" = import "out/minecraft_data_pack_tag.ncl",
"minecraft_data_pack_template_pool" = import "out/minecraft_data_pack_template_pool.ncl",
"minecraft_resource_pack_lang" = import "out/minecraft_resource_pack_lang.ncl",
"minecraft_resource_pack_particle" = import "out/minecraft_resource_pack_particle.ncl",
"minecraft_resourcepack_sounds" = import "out/minecraft_resourcepack_sounds.ncl",
"minecraft_resource_pack_texture_mcmeta" = import "out/minecraft_resource_pack_texture_mcmeta.ncl",
"minecraft_data_pack_trim_material" = import "out/minecraft_data_pack_trim_material.ncl",
"minecraft_data_pack_trim_pattern" = import "out/minecraft_data_pack_trim_pattern.ncl",
"mkdocs.yml" = import "out/mkdocs.yml.ncl",
"mrdocs.yml" = import "out/mrdocs.yml.ncl",
"mlos_config_.mlos.jsonc_.mlos.json5_.mlos.json" = import "out/mlos_config_.mlos.jsonc_.mlos.json5_.mlos.json.ncl",
"monospace.yml" = import "out/monospace.yml.ncl",
"monoweave_configuration" = import "out/monoweave_configuration.ncl",
"ms2rescore_configuration" = import "out/ms2rescore_configuration.ncl",
"mergify_configuration" = import "out/mergify_configuration.ncl",
".mocharc" = import "out/.mocharc.ncl",
".modernizrrc" = import "out/.modernizrrc.ncl",
"monade_cli_stack_configuration" = import "out/monade_cli_stack_configuration.ncl",
"mycode.json" = import "out/mycode.json.ncl",
"napari_plugin_manifest" = import "out/napari_plugin_manifest.ncl",
"netlify_config" = import "out/netlify_config.ncl",
"network_as_code_data_model" = import "out/network_as_code_data_model.ncl",
"nfpm" = import "out/nfpm.ncl",
"nightwatch.js" = import "out/nightwatch.js.ncl",
"ninjs_news_in_json" = import "out/ninjs_news_in_json.ncl",
"nest_cli" = import "out/nest_cli.ncl",
"nlu.json" = import "out/nlu.json.ncl",
".nodehawkrc" = import "out/.nodehawkrc.ncl",
"nodemon.json" = import "out/nodemon.json.ncl",
"notebook.mod.json" = import "out/notebook.mod.json.ncl",
"nox_framework_service" = import "out/nox_framework_service.ncl",
".npmpackagejsonlintrc" = import "out/.npmpackagejsonlintrc.ncl",
"npm_badges" = import "out/npm_badges.ncl",
"nuclei_template.yaml" = import "out/nuclei_template.yaml.ncl",
"nuget_project.json" = import "out/nuget_project.json.ncl",
"nuejs_configuration_file" = import "out/nuejs_configuration_file.ncl",
"nswag.json" = import "out/nswag.json.ncl",
"nullstone_config" = import "out/nullstone_config.ncl",
"ntangle" = import "out/ntangle.ncl",
"ory_oathkeeper_configuration" = import "out/ory_oathkeeper_configuration.ncl",
"ocelot.json" = import "out/ocelot.json.ncl",
"october_cms_columns" = import "out/october_cms_columns.ncl",
"october_cms_fields" = import "out/october_cms_fields.ncl",
"okteto" = import "out/okteto.ncl",
"omnisharp.json" = import "out/omnisharp.json.ncl",
"openapi.json" = import "out/openapi.json.ncl",
"openrpc.json" = import "out/openrpc.json.ncl",
"openutau_character_yaml" = import "out/openutau_character_yaml.ncl",
"openutau_ustx" = import "out/openutau_ustx.ncl",
"ops.yaml" = import "out/ops.yaml.ncl",
"ones_service_descriptor" = import "out/ones_service_descriptor.ncl",
"ones_changelog_entry" = import "out/ones_changelog_entry.ncl",
"openfin.json" = import "out/openfin.json.ncl",
"openrewrite_resource" = import "out/openrewrite_resource.ncl",
"open_data_contract_standard_odcs" = import "out/open_data_contract_standard_odcs.ncl",
"outblocks_project_configuration" = import "out/outblocks_project_configuration.ncl",
"outblocks_app_configuration" = import "out/outblocks_app_configuration.ncl",
"outblocks_database_table" = import "out/outblocks_database_table.ncl",
"ort_server_repository_environment_configuration" = import "out/ort_server_repository_environment_configuration.ncl",
"ory_kratos_configuration" = import "out/ory_kratos_configuration.ncl",
"oscal_assessment_plan_ap" = import "out/oscal_assessment_plan_ap.ncl",
"oscal_assessment_results_ar" = import "out/oscal_assessment_results_ar.ncl",
"oscal_catalog" = import "out/oscal_catalog.ncl",
"oscal_component_definition_cdef" = import "out/oscal_component_definition_cdef.ncl",
"oscal_plan_of_action_and_milestones_poam" = import "out/oscal_plan_of_action_and_milestones_poam.ncl",
"oscal_profile" = import "out/oscal_profile.ncl",
"oscal_system_security_plan_ssp" = import "out/oscal_system_security_plan_ssp.ncl",
"oss_review_toolkit_configuration" = import "out/oss_review_toolkit_configuration.ncl",
"oss_review_toolkit_curation" = import "out/oss_review_toolkit_curation.ncl",
"oss_review_toolkit_package_configuration" = import "out/oss_review_toolkit_package_configuration.ncl",
"oss_review_toolkit_repository_configuration" = import "out/oss_review_toolkit_repository_configuration.ncl",
"oss_review_toolkit_resolutions" = import "out/oss_review_toolkit_resolutions.ncl",
"package.json" = import "out/package.json.ncl",
"package.manifest" = import "out/package.manifest.ncl",
"packer" = import "out/packer.ncl",
"paper_paper_plugin.yml" = import "out/paper_paper_plugin.yml.ncl",
"pathfinder.yml" = import "out/pathfinder.yml.ncl",
"pdm" = import "out/pdm.ncl",
"pgap_yaml_input_reader" = import "out/pgap_yaml_input_reader.ncl",
"pattern.json" = import "out/pattern.json.ncl",
"pixi.toml" = import "out/pixi.toml.ncl",
".pmbot.yml" = import "out/.pmbot.yml.ncl",
"pocketmine_plugin.yml" = import "out/pocketmine_plugin.yml.ncl",
"plagiarize.yaml" = import "out/plagiarize.yaml.ncl",
"plagiarize_me.yaml" = import "out/plagiarize_me.yaml.ncl",
"plex_prerolls" = import "out/plex_prerolls.ncl",
"podbard.yaml" = import "out/podbard.yaml.ncl",
"portman.json" = import "out/portman.json.ncl",
".postcssrc" = import "out/.postcssrc.ncl",
"postman_collection" = import "out/postman_collection.ncl",
".powerpages_web_template_manifest" = import "out/.powerpages_web_template_manifest.ncl",
".pre_commit_config.yml" = import "out/.pre_commit_config.yml.ncl",
".pre_commit_hooks.yml" = import "out/.pre_commit_hooks.yml.ncl",
".phrase.yml" = import "out/.phrase.yml.ncl",
".phraseapp.yml" = import "out/.phraseapp.yml.ncl",
"prefect.toml" = import "out/prefect.toml.ncl",
"prettierrc.json" = import "out/prettierrc.json.ncl",
"prisma.yml" = import "out/prisma.yml.ncl",
"proactions_ai_kit_configuration" = import "out/proactions_ai_kit_configuration.ncl",
"proactions_ai_kit_configuration_for_services" = import "out/proactions_ai_kit_configuration_for_services.ncl",
"proactions_ai_kit_configuration_for_menus" = import "out/proactions_ai_kit_configuration_for_menus.ncl",
"proactions_ai_kit_configuration_for_templates" = import "out/proactions_ai_kit_configuration_for_templates.ncl",
"proactions_ai_kit_configuration_for_sections" = import "out/proactions_ai_kit_configuration_for_sections.ncl",
"proactions_ai_kit_configuration_for_steps" = import "out/proactions_ai_kit_configuration_for_steps.ncl",
"problem_package_generators" = import "out/problem_package_generators.ncl",
"project.json" = import "out/project.json.ncl",
"project_1.0.0_beta3.json" = import "out/project_1.0.0_beta3.json.ncl",
"project_1.0.0_beta4.json" = import "out/project_1.0.0_beta4.json.ncl",
"project_1.0.0_beta5.json" = import "out/project_1.0.0_beta5.json.ncl",
"project_1.0.0_beta6.json" = import "out/project_1.0.0_beta6.json.ncl",
"project_1.0.0_beta8.json" = import "out/project_1.0.0_beta8.json.ncl",
"project_1.0.0_rc1.json" = import "out/project_1.0.0_rc1.json.ncl",
"project_1.0.0_rc2.json" = import "out/project_1.0.0_rc2.json.ncl",
"project.owasp.yaml" = import "out/project.owasp.yaml.ncl",
"prometheus.json" = import "out/prometheus.json.ncl",
"prometheus.rules.json" = import "out/prometheus.rules.json.ncl",
"prometheus.rules.test.json" = import "out/prometheus.rules.test.json.ncl",
"proxies.json" = import "out/proxies.json.ncl",
"publiccode.yml" = import "out/publiccode.yml.ncl",
"pubspec.yaml" = import "out/pubspec.yaml.ncl",
"pull_request_labeler" = import "out/pull_request_labeler.ncl",
".putout.json" = import "out/.putout.json.ncl",
"pyrseas_0.8.json" = import "out/pyrseas_0.8.json.ncl",
"radiohound" = import "out/radiohound.ncl",
"pygta_config" = import "out/pygta_config.ncl",
"rancher_fleet" = import "out/rancher_fleet.ncl",
"config.yaml" = import "out/config.yaml.ncl",
"read_the_docs" = import "out/read_the_docs.ncl",
"pulumi" = import "out/pulumi.ncl",
"pyproject" = import "out/pyproject.ncl",
"pyright" = import "out/pyright.ncl",
"pytest" = import "out/pytest.ncl",
"qgoda" = import "out/qgoda.ncl",
"railway" = import "out/railway.ncl",
"rattler_build" = import "out/rattler_build.ncl",
"rc3_auth" = import "out/rc3_auth.ncl",
"rc3_collection" = import "out/rc3_collection.ncl",
"rc3_environment" = import "out/rc3_environment.ncl",
"rc3_folder" = import "out/rc3_folder.ncl",
"rc3_request" = import "out/rc3_request.ncl",
"rc3_settings" = import "out/rc3_settings.ncl",
"red_discordbot_cog" = import "out/red_discordbot_cog.ncl",
"red_discordbot_cog_repo" = import "out/red_discordbot_cog_repo.ncl",
"red_discordbot_trivia" = import "out/red_discordbot_trivia.ncl",
".rehyperc" = import "out/.rehyperc.ncl",
"release_please_config.json" = import "out/release_please_config.json.ncl",
"release_please_manifest.json" = import "out/release_please_manifest.json.ncl",
"release_plz.toml" = import "out/release_plz.toml.ncl",
".remarkrc" = import "out/.remarkrc.ncl",
"replit_config" = import "out/replit_config.ncl",
".resjson" = import "out/.resjson.ncl",
"ruff" = import "out/ruff.ncl",
"rust_project" = import "out/rust_project.ncl",
"json_resume" = import "out/json_resume.ncl",
"renovate" = import "out/renovate.ncl",
"rendercv" = import "out/rendercv.ncl",
"renv.lock" = import "out/renv.lock.ncl",
"roadrunner" = import "out/roadrunner.ncl",
"rockcraft" = import "out/rockcraft.ncl",
"roo_coder_custom_modes" = import "out/roo_coder_custom_modes.ncl",
"runny" = import "out/runny.ncl",
"rustfmt" = import "out/rustfmt.ncl",
"rust_toolchain" = import "out/rust_toolchain.ncl",
"samt" = import "out/samt.ncl",
"samtrc" = import "out/samtrc.ncl",
"sapphire_cli_config" = import "out/sapphire_cli_config.ncl",
"sarif_1.0.0.json" = import "out/sarif_1.0.0.json.ncl",
"sarif_2.0.0.json" = import "out/sarif_2.0.0.json.ncl",
"sarif_2.1.0_rtm.2" = import "out/sarif_2.1.0_rtm.2.ncl",
"sarif_external_property_file_2.1.0_rtm.2" = import "out/sarif_external_property_file_2.1.0_rtm.2.ncl",
"sarif_2.1.0_rtm.3" = import "out/sarif_2.1.0_rtm.3.ncl",
"sarif_external_property_file_2.1.0_rtm.3" = import "out/sarif_external_property_file_2.1.0_rtm.3.ncl",
"sarif_2.1.0_rtm.4" = import "out/sarif_2.1.0_rtm.4.ncl",
"sarif_external_property_file_2.1.0_rtm.4" = import "out/sarif_external_property_file_2.1.0_rtm.4.ncl",
"sarif_2.1.0_rtm.5" = import "out/sarif_2.1.0_rtm.5.ncl",
"sarif_2.1.0_rtm.6" = import "out/sarif_2.1.0_rtm.6.ncl",
"sarif_external_property_file_2.1.0_rtm.5" = import "out/sarif_external_property_file_2.1.0_rtm.5.ncl",
"sarif_2.1.0" = import "out/sarif_2.1.0.ncl",
"sarif_external_property_file_2.1.0" = import "out/sarif_external_property_file_2.1.0.ncl",
"scalingo.json_configuration" = import "out/scalingo.json_configuration.ncl",
"schema_catalog" = import "out/schema_catalog.ncl",
"schema.org_action" = import "out/schema.org_action.ncl",
"schema.org_contactpoint" = import "out/schema.org_contactpoint.ncl",
"schema.org_place" = import "out/schema.org_place.ncl",
"schema.org_thing" = import "out/schema.org_thing.ncl",
"scoop_manifest" = import "out/scoop_manifest.ncl",
"sdmx_structure_message" = import "out/sdmx_structure_message.ncl",
"sdmx_metadata_message" = import "out/sdmx_metadata_message.ncl",
"sdmx_data_message" = import "out/sdmx_data_message.ncl",
"semantic_data_fabric_sdf_file" = import "out/semantic_data_fabric_sdf_file.ncl",
"semantic_release" = import "out/semantic_release.ncl",
"semgrep_rule" = import "out/semgrep_rule.ncl",
"serenity_code_generator_sergen" = import "out/serenity_code_generator_sergen.ncl",
"settings.job" = import "out/settings.job.ncl",
"settings.paf" = import "out/settings.paf.ncl",
"sfdx_hardis_configuration" = import "out/sfdx_hardis_configuration.ncl",
"sigma_detection_rule" = import "out/sigma_detection_rule.ncl",
"sigrid_scope_configuration_file" = import "out/sigrid_scope_configuration_file.ncl",
"sil_kit_participant_configuration" = import "out/sil_kit_participant_configuration.ncl",
"sil_kit_registry_configuration" = import "out/sil_kit_registry_configuration.ncl",
"size_limit_configuration" = import "out/size_limit_configuration.ncl",
"slack_app_manifest" = import "out/slack_app_manifest.ncl",
"skyuxconfig.json" = import "out/skyuxconfig.json.ncl",
"snapcraft" = import "out/snapcraft.ncl",
"snowflake_config" = import "out/snowflake_config.ncl",
"snowflake_connections" = import "out/snowflake_connections.ncl",
"solidarity" = import "out/solidarity.ncl",
"solution_filters" = import "out/solution_filters.ncl",
"source_maps_v3" = import "out/source_maps_v3.ncl",
"sourcery" = import "out/sourcery.ncl",
"speakeasy_lint_configuration_file" = import "out/speakeasy_lint_configuration_file.ncl",
"speakeasy_test_generation_configuration_file" = import "out/speakeasy_test_generation_configuration_file.ncl",
"speakeasy_workflow_file" = import "out/speakeasy_workflow_file.ncl",
"speakeasy_generation_config_file" = import "out/speakeasy_generation_config_file.ncl",
"specif" = import "out/specif.ncl",
"sponge_mixin_configuration" = import "out/sponge_mixin_configuration.ncl",
".sprite_files" = import "out/.sprite_files.ncl",
"spdx_2.3" = import "out/spdx_2.3.ncl",
"sqlc_configuration" = import "out/sqlc_configuration.ncl",
"azure_static_web_apps_configuration_file" = import "out/azure_static_web_apps_configuration_file.ncl",
"azure_static_web_apps_cli_configuration_file" = import "out/azure_static_web_apps_cli_configuration_file.ncl",
"stackblitz" = import "out/stackblitz.ncl",
"stale" = import "out/stale.ncl",
"starship" = import "out/starship.ncl",
"statamic_blueprint" = import "out/statamic_blueprint.ncl",
"stella_configuration_file" = import "out/stella_configuration_file.ncl",
"stripe_app.json" = import "out/stripe_app.json.ncl",
"stripe_app_local.json" = import "out/stripe_app_local.json.ncl",
"stryker_mutator" = import "out/stryker_mutator.ncl",
"stylecop_analyzers_configuration" = import "out/stylecop_analyzers_configuration.ncl",
"stylelint_.stylelintrc" = import "out/stylelint_.stylelintrc.ncl",
"swadl" = import "out/swadl.ncl",
"swagger_api_2.0" = import "out/swagger_api_2.0.ncl",
"synadia_connect_component" = import "out/synadia_connect_component.ncl",
"tach" = import "out/tach.ncl",
"tach_domain" = import "out/tach_domain.ncl",
"task.json" = import "out/task.json.ncl",
"talhelper" = import "out/talhelper.ncl",
"talisman_configuration" = import "out/talisman_configuration.ncl",
"taurus" = import "out/taurus.ncl",
"tauticord" = import "out/tauticord.ncl",
"template.json" = import "out/template.json.ncl",
"templatsources.json" = import "out/templatsources.json.ncl",
"tier.run_pricing.json" = import "out/tier.run_pricing.json.ncl",
"tikibase" = import "out/tikibase.ncl",
"theme.json" = import "out/theme.json.ncl",
"tizen_workspace.json" = import "out/tizen_workspace.json.ncl",
"tldr" = import "out/tldr.ncl",
"tombi" = import "out/tombi.ncl",
"textmate_grammar" = import "out/textmate_grammar.ncl",
"testenvironment.json" = import "out/testenvironment.json.ncl",
"turborepo" = import "out/turborepo.ncl",
"travis_ci_.travis.yml" = import "out/travis_ci_.travis.yml.ncl",
"traefik_v2" = import "out/traefik_v2.ncl",
"traefik_v2_file_provider" = import "out/traefik_v2_file_provider.ncl",
"traefik_v3" = import "out/traefik_v3.ncl",
"traefik_v3_file_provider" = import "out/traefik_v3_file_provider.ncl",
"transcend.yml" = import "out/transcend.yml.ncl",
"trime.yaml" = import "out/trime.yaml.ncl",
"truescript_for_.tscript_files" = import "out/truescript_for_.tscript_files.ncl",
"trunk.yaml" = import "out/trunk.yaml.ncl",
"tsconfig.json" = import "out/tsconfig.json.ncl",
"tsd.json" = import "out/tsd.json.ncl",
"tsdoc.json" = import "out/tsdoc.json.ncl",
"tsdrc.json" = import "out/tsdrc.json.ncl",
"ts_force_config.json" = import "out/ts_force_config.json.ncl",
"tslint.json" = import "out/tslint.json.ncl",
"tson" = import "out/tson.ncl",
"tstyche" = import "out/tstyche.ncl",
"tsup" = import "out/tsup.ncl",
"tusk.yml" = import "out/tusk.yml.ncl",
"typewiz.json" = import "out/typewiz.json.ncl",
"typo3.json" = import "out/typo3.json.ncl",
"typst_manifest" = import "out/typst_manifest.ncl",
"typos.toml" = import "out/typos.toml.ncl",
"typings.json" = import "out/typings.json.ncl",
"typingsrc.json" = import "out/typingsrc.json.ncl",
"ubuntu_server_autoinstall" = import "out/ubuntu_server_autoinstall.ncl",
"up.json" = import "out/up.json.ncl",
"ui5_manifest" = import "out/ui5_manifest.ncl",
"ui5.yaml" = import "out/ui5.yaml.ncl",
"ui5_workspace.yaml" = import "out/ui5_workspace.yaml.ncl",
"utam_page_object" = import "out/utam_page_object.ncl",
"uncors_configuration" = import "out/uncors_configuration.ncl",
"universal_schedule_format" = import "out/universal_schedule_format.ncl",
"uv" = import "out/uv.ncl",
"vector" = import "out/vector.ncl",
"vega.json" = import "out/vega.json.ncl",
"vega_lite.json" = import "out/vega_lite.json.ncl",
"vela_pipeline_configuration" = import "out/vela_pipeline_configuration.ncl",
"venvironment.yaml" = import "out/venvironment.yaml.ncl",
"venvironment_basic.yaml" = import "out/venvironment_basic.yaml.ncl",
"venvplus.yaml" = import "out/venvplus.yaml.ncl",
"venvplus_basic.yaml" = import "out/venvplus_basic.yaml.ncl",
"version_bumper_config" = import "out/version_bumper_config.ncl",
"version.json" = import "out/version.json.ncl",
".versionrc.json" = import "out/.versionrc.json.ncl",
"vhwdebugger_binding.yaml" = import "out/vhwdebugger_binding.yaml.ncl",
"vim_addon_info" = import "out/vim_addon_info.ncl",
"vsls.json" = import "out/vsls.json.ncl",
"vs_2017.3.host.json" = import "out/vs_2017.3.host.json.ncl",
"vs_nesting.json" = import "out/vs_nesting.json.ncl",
".vsconfig" = import "out/.vsconfig.ncl",
".vsext" = import "out/.vsext.ncl",
"vsix_cli_publishing" = import "out/vsix_cli_publishing.ncl",
"vss_extension.json" = import "out/vss_extension.json.ncl",
"vtesttree.yaml" = import "out/vtesttree.yaml.ncl",
"vtestunit.yaml" = import "out/vtestunit.yaml.ncl",
"v8r" = import "out/v8r.ncl",
"webextensions" = import "out/webextensions.ncl",
"web_app_manifest" = import "out/web_app_manifest.ncl",
"webjobs_list.json" = import "out/webjobs_list.json.ncl",
"webjobpublishsettings.json" = import "out/webjobpublishsettings.json.ncl",
"web_types" = import "out/web_types.ncl",
"wrangler_cli" = import "out/wrangler_cli.ncl",
"json_stat_2.0" = import "out/json_stat_2.0.ncl",
"ksp_avc" = import "out/ksp_avc.ncl",
"ksp_ckan" = import "out/ksp_ckan.ncl",
"ksp_netkan" = import "out/ksp_netkan.ncl",
"json_schema_draft_4" = import "out/json_schema_draft_4.ncl",
"json_schema_draft_7" = import "out/json_schema_draft_7.ncl",
"json_schema_draft_8_2019_09" = import "out/json_schema_draft_8_2019_09.ncl",
"json_schema_draft_2020_12" = import "out/json_schema_draft_2020_12.ncl",
"xunit.runner.json" = import "out/xunit.runner.json.ncl",
"servicehub.service.json" = import "out/servicehub.service.json.ncl",
"servicehub.config.json" = import "out/servicehub.config.json.ncl",
".cryproj_generic" = import "out/.cryproj_generic.ncl",
"typedoc.json" = import "out/typedoc.json.ncl",
"tmuxinator" = import "out/tmuxinator.ncl",
"huskyrc" = import "out/huskyrc.ncl",
"lint_staged_.lintstagedrc" = import "out/lint_staged_.lintstagedrc.ncl",
"mirrord_config" = import "out/mirrord_config.ncl",
"mise" = import "out/mise.ncl",
"mta.yaml" = import "out/mta.yaml.ncl",
"mtad.yaml" = import "out/mtad.yaml.ncl",
"motif_config" = import "out/motif_config.ncl",
".mtaext" = import "out/.mtaext.ncl",
"xs_app.json" = import "out/xs_app.json.ncl",
"opctl" = import "out/opctl.ncl",
"hemtt" = import "out/hemtt.ncl",
"node.js_configuration" = import "out/node.js_configuration.ncl",
"now" = import "out/now.ncl",
"taskcat" = import "out/taskcat.ncl",
"biztalkserverapplicationschema" = import "out/biztalkserverapplicationschema.ncl",
"httpmockrc" = import "out/httpmockrc.ncl",
"nitro.json" = import "out/nitro.json.ncl",
"neoload" = import "out/neoload.ncl",
"release_drafter" = import "out/release_drafter.ncl",
"zuul" = import "out/zuul.ncl",
"briefcase" = import "out/briefcase.ncl",
"httparchive" = import "out/httparchive.ncl",
"jsdoc" = import "out/jsdoc.ncl",
"ray" = import "out/ray.ncl",
"hadolint" = import "out/hadolint.ncl",
"hatch" = import "out/hatch.ncl",
"helmfile" = import "out/helmfile.ncl",
"helmwave" = import "out/helmwave.ncl",
"container_structure_test" = import "out/container_structure_test.ncl",
"inoma" = import "out/inoma.ncl",
"windows_package_manager_singleton_manifest" = import "out/windows_package_manager_singleton_manifest.ncl",
"windows_package_manager_installer_manifest" = import "out/windows_package_manager_installer_manifest.ncl",
"windows_package_manager_locale_manifest" = import "out/windows_package_manager_locale_manifest.ncl",
"winutil" = import "out/winutil.ncl",
"commitlint_.commitlintrc" = import "out/commitlint_.commitlintrc.ncl",
"uniswap_token_list" = import "out/uniswap_token_list.ncl",
"yamllint" = import "out/yamllint.ncl",
"yippee_ki_json_configuration_yml" = import "out/yippee_ki_json_configuration_yml.ncl",
"docker_compose.yml" = import "out/docker_compose.yml.ncl",
"devinit" = import "out/devinit.ncl",
"djlint" = import "out/djlint.ncl",
"tsoa" = import "out/tsoa.ncl",
"api_builder" = import "out/api_builder.ncl",
"gradle_enterprise" = import "out/gradle_enterprise.ncl",
"gradle_build_cache_node" = import "out/gradle_build_cache_node.ncl",
"yarn_config_.yarnrc.yml" = import "out/yarn_config_.yarnrc.yml.ncl",
"better_code_hub" = import "out/better_code_hub.ncl",
"starlake_data_pipeline" = import "out/starlake_data_pipeline.ncl",
"swcrc" = import "out/swcrc.ncl",
"openweather_road_risk_api" = import "out/openweather_road_risk_api.ncl",
"openweather_current_weather_api" = import "out/openweather_current_weather_api.ncl",
"json_e_templates" = import "out/json_e_templates.ncl",
"taskfile_config" = import "out/taskfile_config.ncl",
".taskrc.yaml" = import "out/.taskrc.yaml.ncl",
"hammerkit" = import "out/hammerkit.ncl",
"containerlab" = import "out/containerlab.ncl",
"user_journey_map" = import "out/user_journey_map.ncl",
"render_blueprints" = import "out/render_blueprints.ncl",
"rke_cluster_configuration_yaml" = import "out/rke_cluster_configuration_yaml.ncl",
"rke_cluster_configuration_json" = import "out/rke_cluster_configuration_json.ncl",
"liquibase" = import "out/liquibase.ncl",
"liquibase_flow_file" = import "out/liquibase_flow_file.ncl",
"pipeline_component" = import "out/pipeline_component.ncl",
"skaffold.yaml" = import "out/skaffold.yaml.ncl",
"markdownlint" = import "out/markdownlint.ncl",
"markdown_link_check" = import "out/markdown_link_check.ncl",
"maturin" = import "out/maturin.ncl",
"mason_registry" = import "out/mason_registry.ncl",
"saucectl_configuration" = import "out/saucectl_configuration.ncl",
"fulibworkflows" = import "out/fulibworkflows.ncl",
"woodpecker_pipeline_config" = import "out/woodpecker_pipeline_config.ncl",
"netin_diagnostic_system_template" = import "out/netin_diagnostic_system_template.ncl",
"noodl_config" = import "out/noodl_config.ncl",
"mboats" = import "out/mboats.ncl",
"stackhawk_scanner_configuration" = import "out/stackhawk_scanner_configuration.ncl",
"serverless_framework_configuration" = import "out/serverless_framework_configuration.ncl",
"alacritty_configuration" = import "out/alacritty_configuration.ncl",
"serverless_workflow" = import "out/serverless_workflow.ncl",
"shopware_6_configuration" = import "out/shopware_6_configuration.ncl",
"shopware_cli_extension_store_configuration" = import "out/shopware_cli_extension_store_configuration.ncl",
"shopware_cli_project_store_configuration" = import "out/shopware_cli_project_store_configuration.ncl",
"qodana" = import "out/qodana.ncl",
"tye" = import "out/tye.ncl",
"unist" = import "out/unist.ncl",
"hugo_theme" = import "out/hugo_theme.ncl",
"hugo" = import "out/hugo.ncl",
"cheatsheets" = import "out/cheatsheets.ncl",
"deployed_cli" = import "out/deployed_cli.ncl",
"xstate_machine" = import "out/xstate_machine.ncl",
"butane_config" = import "out/butane_config.ncl",
"updatecli_compose" = import "out/updatecli_compose.ncl",
"updatecli_policy_manifest" = import "out/updatecli_policy_manifest.ncl",
"updatecli_policy_metadata" = import "out/updatecli_policy_metadata.ncl",
"geojson.json_latest" = import "out/geojson.json_latest.ncl",
"clang_format_.clang_format" = import "out/clang_format_.clang_format.ncl",
"estuary_flow_catalog" = import "out/estuary_flow_catalog.ncl",
"v2ray" = import "out/v2ray.ncl",
"gherking" = import "out/gherking.ncl",
"cics_ts_region_tagging" = import "out/cics_ts_region_tagging.ncl",
"cics_ts_resource_import" = import "out/cics_ts_resource_import.ncl",
"cics_ts_resource_model" = import "out/cics_ts_resource_model.ncl",
"cics_ts_resource_overrides" = import "out/cics_ts_resource_overrides.ncl",
"webman_package_recipe" = import "out/webman_package_recipe.ncl",
"webhint.io" = import "out/webhint.io.ncl",
"ava_configuration" = import "out/ava_configuration.ncl",
"datahub_ingestion_recipe" = import "out/datahub_ingestion_recipe.ncl",
"quali_torque_blueprint_spec_2" = import "out/quali_torque_blueprint_spec_2.ncl",
"jscpd_configuration" = import "out/jscpd_configuration.ncl",
"pterodactyl" = import "out/pterodactyl.ncl",
"hardware_sentry_configuration" = import "out/hardware_sentry_configuration.ncl",
"devspace.yaml" = import "out/devspace.yaml.ncl",
"monika_configuration" = import "out/monika_configuration.ncl",
"istanbul" = import "out/istanbul.ncl",
"mongodb_atlas_search_index_definition" = import "out/mongodb_atlas_search_index_definition.ncl",
"kodeci_build.yaml" = import "out/kodeci_build.yaml.ncl",
"kong_dbless_config" = import "out/kong_dbless_config.ncl",
"embrace_config" = import "out/embrace_config.ncl",
"petstore_v1.0" = import "out/petstore_v1.0.ncl",
"jfrog_pipelines_yml_dsl" = import "out/jfrog_pipelines_yml_dsl.ncl",
"safebox_config" = import "out/safebox_config.ncl",
"sublime_syntax" = import "out/sublime_syntax.ncl",
"keycloak_rest_api" = import "out/keycloak_rest_api.ncl",
"ize.toml" = import "out/ize.toml.ncl",
"uplift" = import "out/uplift.ncl",
"queryfirst_config_file" = import "out/queryfirst_config_file.ncl",
"uet_buildconfig.json" = import "out/uet_buildconfig.json.ncl",
"unreal_engine_uplugin" = import "out/unreal_engine_uplugin.ncl",
"unreal_engine_uproject" = import "out/unreal_engine_uproject.ncl",
"pantsbuild" = import "out/pantsbuild.ncl",
"all_contributors_configuration_file" = import "out/all_contributors_configuration_file.ncl",
"es6_import_sorter_.es6importsorterrc.json" = import "out/es6_import_sorter_.es6importsorterrc.json.ncl",
"completely.yml" = import "out/completely.yml.ncl",
"madness_madness.yml" = import "out/madness_madness.yml.ncl",
"bashly_bashly.yml" = import "out/bashly_bashly.yml.ncl",
"bashly_settings_bashly_settings.yml" = import "out/bashly_settings_bashly_settings.yml.ncl",
"bashly_strings.yml" = import "out/bashly_strings.yml.ncl",
"bpkg" = import "out/bpkg.ncl",
"micro_settings.json" = import "out/micro_settings.json.ncl",
"quilt.mod.json" = import "out/quilt.mod.json.ncl",
"autoapicase" = import "out/autoapicase.ncl",
"secrethub.yml" = import "out/secrethub.yml.ncl",
"dynamic_bash_aliases_.aliases" = import "out/dynamic_bash_aliases_.aliases.ncl",
"micro_editor_syntax" = import "out/micro_editor_syntax.ncl",
"lazygit" = import "out/lazygit.ncl",
"lazydocker" = import "out/lazydocker.ncl",
"custom_elements.json" = import "out/custom_elements.json.ncl",
"warp_keysets.json" = import "out/warp_keysets.json.ncl",
"warp_themes.json" = import "out/warp_themes.json.ncl",
"warp_workflows.json" = import "out/warp_workflows.json.ncl",
"goblet" = import "out/goblet.ncl",
"databricks_asset_bundles" = import "out/databricks_asset_bundles.ncl",
"json_schema_draft_4_unofficial_with_ref_and_format" = import "out/json_schema_draft_4_unofficial_with_ref_and_format.ncl",
"json_schema_draft_7_unofficial_strict" = import "out/json_schema_draft_7_unofficial_strict.ncl",
"visivo" = import "out/visivo.ncl",
"endurica" = import "out/endurica.ncl",
"tunnelhub" = import "out/tunnelhub.ncl",
"ty" = import "out/ty.ncl",
"problem_object_rfc9457" = import "out/problem_object_rfc9457.ncl",
"apko" = import "out/apko.ncl",
"melange" = import "out/melange.ncl",
"minecraft_custom_main_menu_mod" = import "out/minecraft_custom_main_menu_mod.ncl",
"rivet.yaml_legacy" = import "out/rivet.yaml_legacy.ncl",
"rivet.json" = import "out/rivet.json.ncl",
"nixd_configuration" = import "out/nixd_configuration.ncl",
"rudder_techniques" = import "out/rudder_techniques.ncl",
"skypilot_task_json" = import "out/skypilot_task_json.ncl",
"adobe_uxp_manifest" = import "out/adobe_uxp_manifest.ncl",
"subsquid_squid_manifest" = import "out/subsquid_squid_manifest.ncl",
"gitlab_agent_for_kubernetes_configuration" = import "out/gitlab_agent_for_kubernetes_configuration.ncl",
"ivms101_by_code_protocol" = import "out/ivms101_by_code_protocol.ncl",
"glazewm_settings" = import "out/glazewm_settings.ncl",
"cgs_card_game_specification_cgs.json" = import "out/cgs_card_game_specification_cgs.json.ncl",
"custom_machinery_machine" = import "out/custom_machinery_machine.ncl",
"custom_machinery_recipe" = import "out/custom_machinery_recipe.ncl",
"nuitka.yaml" = import "out/nuitka.yaml.ncl",
"bioimageio_resource_description" = import "out/bioimageio_resource_description.ncl",
"flow.json_configurations" = import "out/flow.json_configurations.ncl",
"cwl" = import "out/cwl.ncl",
"shard.yml" = import "out/shard.yml.ncl",
"erda_pipeline" = import "out/erda_pipeline.ncl",
"erda_runtime" = import "out/erda_runtime.ncl",
"ksy" = import "out/ksy.ncl",
"cloud_foundry_application_manifest" = import "out/cloud_foundry_application_manifest.ncl",
".omletrc" = import "out/.omletrc.ncl",
"vcluster" = import "out/vcluster.ncl",
"well_known_fursona" = import "out/well_known_fursona.ncl",
"changelogging" = import "out/changelogging.ncl",
"configu_.cfgu_files" = import "out/configu_.cfgu_files.ncl",
"configu_.configu_file" = import "out/configu_.configu_file.ncl",
"qt_creator_workspace_file" = import "out/qt_creator_workspace_file.ncl",
"mprocs_configuration_file" = import "out/mprocs_configuration_file.ncl",
"language_configuration" = import "out/language_configuration.ncl",
"any" = import "out/any.ncl",
"zerops.io_config" = import "out/zerops.io_config.ncl",
"zerops.io_import" = import "out/zerops.io_import.ncl",
"microsoft_rulesengine_workflow_rules" = import "out/microsoft_rulesengine_workflow_rules.ncl",
"microsoft_rulesengine_workflow_rules_list" = import "out/microsoft_rulesengine_workflow_rules_list.ncl",
"spicepod.yaml" = import "out/spicepod.yaml.ncl",
"concord" = import "out/concord.ncl",
"crs_waf_test_file" = import "out/crs_waf_test_file.ncl",
"crs_waf_test_platform_overrides_file" = import "out/crs_waf_test_platform_overrides_file.ncl",
"dipdup" = import "out/dipdup.ncl",
"tycho" = import "out/tycho.ncl",
"elm" = import "out/elm.ncl",
"cloud_run_spec_v1" = import "out/cloud_run_spec_v1.ncl",
"youtrack_app" = import "out/youtrack_app.ncl",
"settings_for_a_cinnamon_spice" = import "out/settings_for_a_cinnamon_spice.ncl",
"metadata_for_a_cinnamon_spice" = import "out/metadata_for_a_cinnamon_spice.ncl",
"yandex_workflow_language" = import "out/yandex_workflow_language.ncl",
"application_list_for_a_winutil" = import "out/application_list_for_a_winutil.ncl",
"preset_list_for_a_winutil" = import "out/preset_list_for_a_winutil.ncl",
"github_actions_typing" = import "out/github_actions_typing.ncl",
"tab_list_for_a_linutil" = import "out/tab_list_for_a_linutil.ncl",
"tab_data_for_a_linutil" = import "out/tab_data_for_a_linutil.ncl",
"architectfx" = import "out/architectfx.ncl",
"eidolon_resource" = import "out/eidolon_resource.ncl",
"waku_config" = import "out/waku_config.ncl",
"ccmod.json" = import "out/ccmod.json.ncl",
"moon.yml" = import "out/moon.yml.ncl",
"wiremock_stub_mapping" = import "out/wiremock_stub_mapping.ncl",
"bitmovin_encoding_template" = import "out/bitmovin_encoding_template.ncl",
"dtool_dataset_metadata" = import "out/dtool_dataset_metadata.ncl",
"pnpm_workspace_pnpm_workspace.yaml" = import "out/pnpm_workspace_pnpm_workspace.yaml.ncl",
"chamaleon_template" = import "out/chamaleon_template.ncl",
"chamaleon_environment" = import "out/chamaleon_environment.ncl",
"chamaleon_properties" = import "out/chamaleon_properties.ncl",
"ctfd_setup_configuration_file" = import "out/ctfd_setup_configuration_file.ncl",
"amx_muse_program_descriptor" = import "out/amx_muse_program_descriptor.ncl",
"donatecasebettercasino_menu" = import "out/donatecasebettercasino_menu.ncl",
"gematik_health_care_patient_list" = import "out/gematik_health_care_patient_list.ncl",
"gematik_health_care_provider_list" = import "out/gematik_health_care_provider_list.ncl",
"gematik_health_care_provider_institution_list" = import "out/gematik_health_care_provider_institution_list.ncl",
"gematik_health_care_insurance_list" = import "out/gematik_health_care_insurance_list.ncl",
"gematik_tiger_test_environment_configuration" = import "out/gematik_tiger_test_environment_configuration.ncl",
"tugboat_qa_config.yml" = import "out/tugboat_qa_config.yml.ncl",
"c4interflow" = import "out/c4interflow.ncl",
"wake" = import "out/wake.ncl",
"trident" = import "out/trident.ncl",
"unified_tenant_configuration_management_utcm_monitor" = import "out/unified_tenant_configuration_management_utcm_monitor.ncl",
"restate" = import "out/restate.ncl",
"telefonistka" = import "out/telefonistka.ncl",
"version" = import "out/version.ncl",
"viash_component_config" = import "out/viash_component_config.ncl",
"viash_package_config" = import "out/viash_package_config.ncl",
"multiqc" = import "out/multiqc.ncl",
"tyk_gateway_open_source_v5.7" = import "out/tyk_gateway_open_source_v5.7.ncl",
"python_script_metadata" = import "out/python_script_metadata.ncl",
"vtcfg" = import "out/vtcfg.ncl",
"sake" = import "out/sake.ncl",
"open_know_how" = import "out/open_know_how.ncl",
"contextive_glossary" = import "out/contextive_glossary.ncl",
"google_digital_assetlinks" = import "out/google_digital_assetlinks.ncl",
"pylock" = import "out/pylock.ncl",
"stylua_config" = import "out/stylua_config.ncl",
"taplo" = import "out/taplo.ncl",
"aider" = import "out/aider.ncl",
"cdk_environment_manager_environment_definition" = import "out/cdk_environment_manager_environment_definition.ncl",
"cdk_environment_manager_concrete_environments_definition" = import "out/cdk_environment_manager_concrete_environments_definition.ncl",
"cdk_environment_manager_concrete_environment_configuration" = import "out/cdk_environment_manager_concrete_environment_configuration.ncl",
"tm_devices_configuration_file" = import "out/tm_devices_configuration_file.ncl",
"openstatus" = import "out/openstatus.ncl",
"power_pages_configuration" = import "out/power_pages_configuration.ncl",
}
</file>

<file path="Nickel-pkg.ncl">
{
  name = "nickel-schemastore",
  version = "0.4.0",
  description = "Nickel contracts autogenerated from the Schemastore JSON Schema repository via json-schema-to-nickel",
  authors = [
    "Théophane Hufschmitt",
    "Yann Hamdaoui <yann.hamdaoui@tweag.io>",
  ],
  license = "MIT",
  keywords = [
    "schemastore",
    "schemas",
    "json-schema",
    "contracts",
  ],
  minimal_nickel_version = "1.11.0",
} | std.package.Manifest
</file>

<file path="README.md">
# Nickel schemastore

Schemastore is a Nickel library containing contracts automatically generated
from the [schemastore](https://schemastore.org/json/)'s using
[json-schema-to-nickel](https://github.com/nickel-lang/json-schema-to-nickel/).
It is distributed through the (currently experimental) Nickel package manager.

## Usage

Add the following field to the dependencies of your [Nickel project
manifest](https://nickel-lang.org/user-manual/package-management/#the-manifest-file):

```nickel
schemastore = 'Index { "github:nickel-lang/nickel-schemastore", version = "0.4.0" }
```

Then import one of the available schema in any Nickel file of your project:

```nickel
let PlatformShRoutes = (import schemastore)."Platform.sh routes" in
...
```

The available contracts are visible in [main.ncl](./main.ncl).

## Regenerating the contracts

The contracts as well as the main entry point `main.ncl` are generated by the
`extract-schemas.py`. Use `nix develop` to enter a shell with the required
environment set up and run `python extract-schemas.py` to regenerate the
contracts and the main library file.
</file>

</files>
