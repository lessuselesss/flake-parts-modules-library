This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  ISSUE_TEMPLATE/
    bug.yml
    feature_request.yml
  workflows/
    build-and-test.yml
    release.yml
    site.yml
    update-flake.yml
  funding.yml
cmd/
  activate/
    activate.go
    fs.go
    run.go
    unit.go
    unsupported.go
    user.go
  apply/
    apply.go
  completion/
    completion.go
  enter/
    enter.go
    run.go
    unsupported.go
  features/
    features.go
  generation/
    delete/
      delete.go
      resolver_test.go
      resolver.go
    diff/
      diff.go
    list/
      list.go
      tui.go
    rollback/
      rollback.go
    shared/
      utils.go
    switch/
      switch.go
    generation.go
  info/
    info.go
  init/
    configuration.nix.txt
    cpuinfo.go
    devices.go
    filesystems.go
    flake.nix.txt
    generate.go
    hardware_configuration.nix.txt
    init.go
    run.go
    unsupported.go
  install/
    install.go
  manual/
    manual.go
  option/
    cache.go
    completion.go
    option.go
  repl/
    repl.go
  root/
    aliases.go
    root.go
doc/
  man/
    nixos-cli-activate.1.scd
    nixos-cli-apply.1.scd
    nixos-cli-enter.1.scd
    nixos-cli-env.5.scd
    nixos-cli-features.1.scd
    nixos-cli-generation-delete.1.scd
    nixos-cli-generation-diff.1.scd
    nixos-cli-generation-list.1.scd
    nixos-cli-generation-rollback.1.scd
    nixos-cli-generation-switch.1.scd
    nixos-cli-generation.1.scd
    nixos-cli-info.1.scd
    nixos-cli-init.1.scd
    nixos-cli-install.1.scd
    nixos-cli-manual.1.scd
    nixos-cli-option-tui.1.scd
    nixos-cli-option.1.scd
    nixos-cli-repl.1.scd
    nixos-cli-settings.5.scd.template
    nixos-cli.1.scd
  src/
    commands.md
    comparisons.md
    contributing.md
    faq.md
    installation.md
    introduction.md
    module.md
    overview.md
    roadmap.md
    settings.md
    SUMMARY.md
  .gitignore
  book.toml
  build.go
internal/
  activation/
    activation.go
  build/
    vars/
      vars.go
    build.go
  cmd/
    errors/
      errors.go
    nixopts/
      convert_test.go
      convert.go
      nixopts.go
    opts/
      opts.go
    utils/
      confirmation.go
      utils.go
  configuration/
    configuration_test.go
    configuration.go
    flake.go
    legacy.go
  constants/
    constants.go
  generation/
    completion.go
    diff.go
    generation.go
    specialisations.go
  logger/
    context.go
    logger.go
  settings/
    completion_test.go
    completion.go
    context.go
    errors.go
    settings_test.go
    settings.go
  system/
    local.go
    runner.go
    system.go
  systemd/
    time_test.go
    time.go
    unit_test.go
    unit.go
  utils/
    utils.go
.envrc
.gitignore
.prettierrc.json
default.nix
flake-compat.nix
flake.lock
flake.nix
go.mod
LICENSE
main.go
Makefile
module.nix
package.nix
README.md
shell.nix
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/ISSUE_TEMPLATE/bug.yml">
name: Bug Report
description: File a bug report
labels: ['bug']
body:
  - type: markdown
    attributes:
      value: |
        A bug is when something (a feature, behavior, etc.) does not work in a
        way that is otherwise expected. 

        ### Look through existing issues before filing!

        Please make an effort to look through the issue tracker before filing
        any bugs. Duplicates only create more work when triaging.
  - type: textarea
    id: what-happened
    attributes:
      label: What Happened?
      description: 'Explain what happened, in as much detail as necessary.'
      placeholder:
        'I encountered a bug, and this is what happened, in good detail.'
    validations:
      required: true
  - type: textarea
    id: reproduction
    attributes:
      label: How To Reproduce
      description: |
        How can one reproduce this bug? Include all relevant information, such as:

        - Logs (ideally ran with `--verbose` if applicable)
        - Operating system (i.e. the output from `nixos info -m`)
        - Potentially problematic env variables
      placeholder: |
        This is how to reproduce it. I am running NixOS 24.11 (Vicuna) on the stable branch.
    validations:
      required: true
  - type: textarea
    id: expected
    attributes:
      label: Expected Behavior
      description: 'What behavior was expected to occur?'
      placeholder:
        'I expected to be able to run ___ without a segmentation fault.'
    validations:
      required: true
  - type: textarea
    id: compiled-features
    attributes:
      label: Features
      description: |
        Please run `nixos features` and paste the output here.
        This will automatically formatted into code output.
      render: shell
    validations:
      required: true
</file>

<file path=".github/ISSUE_TEMPLATE/feature_request.yml">
name: Feature Request
description:
  Make a request for new functionality or enhancements to existing features
labels: ['enhancement']
body:
  - type: textarea
    id: feature-description
    attributes:
      label: Feature Description
      description: |
        A concise description of what functionality you would like to see.

        Include details such as what problems this feature will solve. Keep
        in mind the following food for thought:

        - Are there existing tools that can do this? If so, how will this tool be able
          to do this better?
        - How complex of a feature will this be?
        - How can we make sure that this does not contribute to feature creep? Keeping
          ideas within the scope of this tool is **extremely** important.
      placeholder: 'I want a TUI menu for searching through NixOS options.'
    validations:
      required: true
  - type: dropdown
    id: help
    attributes:
      label: 'Help'
      description:
        'Would you be able to implement this by submitting a pull request?'
      options:
        - 'Yes'
        - "Yes, but I don't know how to start; I would need guidance"
        - 'No'
    validations:
      required: true
  - type: checkboxes
    id: looked-through-existing-requests
    attributes:
      label: Issues
      options:
        - label:
            I have checked [existing
            issues](https://github.com/water-sucks/nixos/issues?q=is%3Aissue)
            and there are no existing ones with the same request.
          required: true
</file>

<file path=".github/workflows/build-and-test.yml">
name: Build/Test
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:

jobs:
  build-and-test:
    name: Build/Test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@main

      - name: Initialize Cachix
        uses: cachix/cachix-action@v14
        with:
          name: watersucks
          authToken: '${{ secrets.CACHIX_AUTH_TOKEN }}'
          skipPush: true

      - name: Check for compile errors
        run: |
          nix develop .# -c make
          nix develop .# -c make FLAKE=false

      - name: Run checks
        run: nix develop .# -c make check

      - name: Run tests
        run: nix develop .# -c make test

      - name: Build Nix packages
        run: nix build .#{nixos,nixosLegacy}
</file>

<file path=".github/workflows/release.yml">
name: Release
on:
  workflow_dispatch:
    inputs:
      git-ref:
        description: 'Git ref to publish to Cachix'
        required: true
        type: string
  release:
    types: [created]

jobs:
  publish-to-cachix:
    name: Publish to Cache
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.git-ref }}

      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@main

      - name: Initialize Cachix
        uses: cachix/cachix-action@v14
        with:
          name: watersucks
          authToken: '${{ secrets.CACHIX_AUTH_TOKEN }}'

      - name: Build Nix packages
        run: nix build .#{nixos,nixosLegacy}
</file>

<file path=".github/workflows/site.yml">
name: Deploy Website
on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pages: write
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@main

      - name: Initialize Cachix
        uses: cachix/cachix-action@v14
        with:
          name: watersucks
          authToken: '${{ secrets.CACHIX_AUTH_TOKEN }}'
          skipPush: true

      - name: Build Book
        run: |
          nix develop .# -c make site

      - name: Setup Pages
        uses: actions/configure-pages@v4

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: 'site'

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
</file>

<file path=".github/workflows/update-flake.yml">
name: Update Flake Inputs
on:
  workflow_dispatch:
  schedule:
    # The 1st of every month @ 0:00 UTC
    - cron: '0 0 1 * *'

jobs:
  update-flake-inputs:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@main

      - name: Update flake.lock
        uses: DeterminateSystems/update-flake-lock@main
        with:
          token: ${{ secrets.GH_TOKEN_FOR_UPDATES }}
          pr-title: 'chore(deps): update nix flake inputs'
          commit-msg: 'chore(deps): update nix flake inputs'
</file>

<file path=".github/funding.yml">
github: water-sucks
open_collective: nix-community
</file>

<file path="cmd/activate/activate.go">
package activate

import (
	"fmt"
	"os"

	"github.com/nix-community/nixos-cli/internal/activation"
	cmdOpts "github.com/nix-community/nixos-cli/internal/cmd/opts"
	cmdUtils "github.com/nix-community/nixos-cli/internal/cmd/utils"
	"github.com/spf13/cobra"
)

func ActivateCommand() *cobra.Command {
	var opts cmdOpts.ActivateOpts

	commands := map[string]string{
		"boot":         "Generate boot entries and make this the default configuration",
		"check":        "Run pre-activation checks and exit",
		"dry-activate": "Show what would be activated but do not perform it",
		"switch":       "Activate this configuration, generate entries, and make this the default configuration",
		"test":         "Activate this configuration, but do not generate boot entries",
	}

	cmd := cobra.Command{
		Use:   "activate <ACTION> [flags]",
		Short: "Run activation scripts for a NixOS system",
		Long:  "Run boot and activation scripts for NixOS generations.",
		Args: func(cmd *cobra.Command, args []string) error {
			if os.Getenv(NIXOS_STC_PARENT_EXE) != "" {
				return nil
			}

			if len(args) == 0 {
				return fmt.Errorf("missing required argument <ACTION>")
			}

			a, err := activation.ParseSwitchToConfigurationAction(args[0])
			if err != nil {
				return err
			}

			opts.Action = a

			return nil
		},
		ValidArgsFunction: func(_ *cobra.Command, _ []string, _ string) ([]string, cobra.ShellCompDirective) {
			results := make([]string, 0, len(commands))
			for command, desc := range commands {
				results = append(results, fmt.Sprintf("%v\t%v", command, desc))
			}

			return results, cobra.ShellCompDirectiveNoFileComp
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return cmdUtils.CommandErrorHandler(activateMain(cmd, &opts))
		},
	}

	if os.Getenv("NIXOS_CLI_ATTEMPTING_ACTIVATION") == "" {
		cmd.Flags().StringVarP(&opts.Specialisation, "specialisation", "s", "", "Activate specialisation `name`")
	}

	cmdUtils.SetHelpFlagText(&cmd)
	cmd.SetHelpTemplate(cmd.HelpTemplate() + "\nActions:\n" + cmdUtils.AlignedOptions(commands))

	return &cmd
}
</file>

<file path="cmd/activate/fs.go">
//go:build linux

package activate

import (
	"bufio"
	"os"
	"strings"
	"unsafe"

	"golang.org/x/sys/unix"
)

type Filesystem struct {
	Device  string
	Type    string
	Options string
}

type Swap struct {
	Options string
}

// Parse the contents of an fstab(5)-formatted file.
//
// If the file is unable to be opened, an error is returned.
// Errors inside the file itself (i.e. missing fields)
// are ignored if possible.
func parseFstab(filename string) (map[string]Filesystem, map[string]Swap, error) {
	filesystems := make(map[string]Filesystem)
	swapDevices := make(map[string]Swap)

	file, err := os.Open(filename)
	if err != nil {
		return filesystems, swapDevices, err
	}
	defer func() { _ = file.Close() }()

	s := bufio.NewScanner(file)
	for s.Scan() {
		line := strings.TrimSpace(s.Text())

		if strings.HasPrefix(line, "#") {
			continue
		}

		fields := strings.Fields(line)

		if len(fields) < 3 {
			continue
		}

		device, mountpoint, fsType := fields[0], fields[1], fields[2]

		var options string
		if len(fields) >= 4 {
			options = fields[3]
		}

		if fsType == "swap" {
			swapDevices[device] = Swap{
				Options: options,
			}
		} else {
			filesystems[mountpoint] = Filesystem{
				Device:  device,
				Type:    fsType,
				Options: options,
			}
		}
	}

	return filesystems, swapDevices, nil
}

// Invoke the swapoff(2) syscall on a device.
//
// This is not available in the x/sys/unix package, so
// we wrap this syscall in a Go-friendly manner ourselves.
func swapoff(device string) error {
	pathBytes, err := unix.BytePtrFromString(device)
	if err != nil {
		return err
	}

	_, _, errno := unix.Syscall(uintptr(unix.SYS_SWAPOFF), uintptr(unsafe.Pointer(pathBytes)), 0, 0)
	if errno != 0 {
		return errno
	}
	return nil
}
</file>

<file path="cmd/activate/run.go">
//go:build linux

package activate

import (
	"context"
	"errors"
	"fmt"
	"os"
	"os/exec"
	"os/signal"
	"path/filepath"
	"slices"
	"strings"
	"sync"
	"syscall"
	"time"

	systemdDbus "github.com/coreos/go-systemd/v22/dbus"
	"github.com/coreos/go-systemd/v22/login1"
	"github.com/google/shlex"

	"github.com/nix-community/nixos-cli/internal/activation"
	cmdOpts "github.com/nix-community/nixos-cli/internal/cmd/opts"
	"github.com/nix-community/nixos-cli/internal/constants"
	"github.com/nix-community/nixos-cli/internal/generation"
	"github.com/nix-community/nixos-cli/internal/logger"
	"github.com/nix-community/nixos-cli/internal/system"
	systemdUtils "github.com/nix-community/nixos-cli/internal/systemd"
	"github.com/spf13/cobra"
	"golang.org/x/sys/unix"
)

const (
	ACTIVATION_LOCKFILE = "/run/nixos/switch-to-configuration.lock"

	DRY_RESTART_BY_ACTIVATION_LIST_FILE = "/run/nixos/dry-activation-restart-list"
	DRY_RELOAD_BY_ACTIVATION_LIST_FILE  = "/run/nixos/dry-activation-reload-list"
	RELOAD_BY_ACTIVATION_LIST_FILE      = "/run/nixos/activation-reload-list"
	RESTART_BY_ACTIVATION_LIST_FILE     = "/run/nixos/activation-restart-list"

	NIXOS_STC_PARENT_EXE = "__NIXOS_SWITCH_TO_CONFIGURATION_PARENT_EXE"

	SYSINIT_REACTIVATION_TARGET = "sysinit-reactivation.target"
)

type RequiredVars struct {
	OutPath              string
	Toplevel             string
	PreSwitchCheckCmd    string
	InstallBootloaderCmd string
	LocaleArchive        string
	NewSystemd           string
}

type ErrorRequiredVarMissing struct {
	VarName string
}

func (e ErrorRequiredVarMissing) Error() string {
	return fmt.Sprintf("missing required environment variable $%s, this is a bug", e.VarName)
}

func getRequiredVars() (*RequiredVars, error) {
	outPath := os.Getenv("OUT")
	if outPath == "" {
		return nil, ErrorRequiredVarMissing{VarName: "OUT"}
	}

	toplevel := os.Getenv("TOPLEVEL")
	if toplevel == "" {
		return nil, ErrorRequiredVarMissing{VarName: "TOPLEVEL"}
	}

	preSwitchCheck := os.Getenv("PRE_SWITCH_CHECK")
	if preSwitchCheck == "" {
		return nil, ErrorRequiredVarMissing{VarName: "PRE_SWITCH_CHECK"}
	}

	installBootloaderCmd := os.Getenv("INSTALL_BOOTLOADER")
	if installBootloaderCmd == "" {
		return nil, ErrorRequiredVarMissing{VarName: "INSTALL_BOOTLOADER"}
	}

	localeArchive := os.Getenv("LOCALE_ARCHIVE")
	if localeArchive == "" {
		return nil, ErrorRequiredVarMissing{VarName: "LOCALE_ARCHIVE"}
	}

	newSystemd := os.Getenv("SYSTEMD")
	if newSystemd == "" {
		return nil, ErrorRequiredVarMissing{VarName: "SYSTEMD"}
	}

	return &RequiredVars{
		OutPath:              outPath,
		Toplevel:             toplevel,
		PreSwitchCheckCmd:    preSwitchCheck,
		InstallBootloaderCmd: installBootloaderCmd,
		LocaleArchive:        localeArchive,
		NewSystemd:           newSystemd,
	}, nil
}

func execInSwitchContext(
	s system.CommandRunner,
	log *logger.Logger,
	action activation.SwitchToConfigurationAction,
	specialisation string,
) error {
	if specialisation != "" {
		specialisations, err := generation.CollectSpecialisations(constants.CurrentSystem)
		if err != nil {
			log.Warnf("unable to access specialisations: %v", err)
		}

		if !slices.Contains(specialisations, specialisation) {
			err = fmt.Errorf("specialisation '%v' does not exist", specialisations)
			log.Error(err)
			return err
		}
	}

	err := activation.SwitchToConfiguration(s, constants.CurrentSystem, action, &activation.SwitchToConfigurationOptions{
		Specialisation: specialisation,
	})

	return err
}

func runPreSwitchCheck(
	s system.CommandRunner,
	cmdStr string,
	toplevel string,
	action activation.SwitchToConfigurationAction,
) error {
	args, err := shlex.Split(cmdStr)
	if err != nil {
		return err
	}

	args = append(args, toplevel)
	args = append(args, action.String())

	cmd := system.NewCommand(args[0], args[1:]...)
	_, err = s.Run(cmd)
	return err
}

func installBootloader(
	s system.CommandRunner,
	cmdStr string,
	toplevel string,
) error {
	args, err := shlex.Split(cmdStr)
	if err != nil {
		return err
	}
	args = append(args, toplevel)

	cmd := system.NewCommand(args[0], args[1:]...)
	_, err = s.Run(cmd)
	return err
}

var ErrMismatchedInterfaceVersion = errors.New("this NixOS configuration has an init that is incompatible with the current configuration")

func validateInterfaceVersion(toplevel string) error {
	currentInitInterfaceVersionFile := filepath.Join(constants.CurrentSystem, "init-interface-version")
	newInitInterfaceVersionFile := filepath.Join(toplevel, "init-interface-version")

	currentInitInterfaceVersion, err := os.ReadFile(currentInitInterfaceVersionFile)
	if err != nil {
		return fmt.Errorf("failed to read %s: %v", currentInitInterfaceVersionFile, err)
	}

	newInitInterfaceVersion, err := os.ReadFile(newInitInterfaceVersionFile)
	if err != nil {
		return fmt.Errorf("failed to read %s: %v", newInitInterfaceVersionFile, err)
	}

	if string(currentInitInterfaceVersion) != string(newInitInterfaceVersion) {
		return ErrMismatchedInterfaceVersion
	}

	return nil
}

var errActivateScriptNotExist = errors.New("activate script does not exist")

func runActivateScript(toplevel string, dry bool) error {
	var script string
	if dry {
		script = filepath.Join(toplevel, "dry-activate")
	} else {
		script = filepath.Join(toplevel, "activate")
	}

	if _, err := os.Stat(script); errors.Is(err, os.ErrNotExist) {
		return errActivateScriptNotExist
	}

	cmd := exec.Command(script)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	return cmd.Run()
}

type unitAction string

const (
	actionStart   unitAction = "start"
	actionStop    unitAction = "stop"
	actionRestart unitAction = "restart"
	actionReload  unitAction = "reload"
)

type unitActionResult struct {
	Action unitAction
	Unit   string
	Result string
	Err    error
}

// Run a specified action on a unit list, of either
// "start", "stop", "restart", or "reload".
//
// Returns a map of systemd job statuses for each unit
// name, with the following possible values:
//
// - "done" - success
// - "canceled" - context canceled before execution finished
// - "timeout" - job timeout reached
// - "failed" - job failed
// - "dependency" - a dependency failed, so this job was removed
// - "skipped" - action did not apply for unit, so nothing done
//
// along with a list of errors encountered
func runUnitAction(
	ctx context.Context,
	systemd *systemdDbus.Conn,
	units UnitList,
	action unitAction,
) []unitActionResult {
	var wg sync.WaitGroup

	results := make(chan unitActionResult, len(units))

	for unit := range units {
		wg.Go(func() {
			unit := unit
			ch := make(chan string, 1)

			var err error
			switch action {
			case actionReload:
				_, err = systemd.ReloadUnitContext(ctx, unit, "replace", ch)
			case actionRestart:
				_, err = systemd.RestartUnitContext(ctx, unit, "replace", ch)
			case actionStart:
				_, err = systemd.StartUnitContext(ctx, unit, "replace", ch)
			case actionStop:
				_, err = systemd.StopUnitContext(ctx, unit, "replace", ch)
			}

			select {
			case result := <-ch:
				results <- unitActionResult{
					Action: action,
					Unit:   unit,
					Result: result,
					Err:    err,
				}
			case <-ctx.Done():
			}
		})
	}

	wg.Wait()
	close(results)

	collected := make([]unitActionResult, 0, len(units))
	for result := range results {
		collected = append(collected, result)
	}

	return collected
}

func waitForSystemdToSettle(systemd *systemdDbus.Conn, idleTimeout time.Duration, maxTimeout time.Duration) {
	changes, _ := systemd.SubscribeUnits(idleTimeout)

	idleTimer := time.NewTimer(idleTimeout)
	overallTimer := time.NewTimer(maxTimeout)

	for {
		select {
		case <-changes:
			if !idleTimer.Stop() {
				<-idleTimer.C
			}
			idleTimer.Reset(idleTimeout)

		case <-idleTimer.C:
			return

		case <-overallTimer.C:
			return
		}
	}
}

func activateMain(cmd *cobra.Command, opts *cmdOpts.ActivateOpts) error {
	log := logger.FromContext(cmd.Context())
	s := system.NewLocalSystem(log)

	if !s.IsNixOS() {
		err := fmt.Errorf("the activate command is unsupported on non-NixOS systems")
		log.Error(err)
		return err
	}

	if opts.Action == activation.SwitchToConfigurationActionDryActivate {
		recordUnits = false
	}

	if parentExe := os.Getenv(NIXOS_STC_PARENT_EXE); parentExe != "" {
		return userSwitch(log, parentExe)
	}

	if os.Geteuid() != 0 {
		err := fmt.Errorf("this command must be ran as root")
		log.Errorf("%s", err)
		return err
	}

	if attemptingActivation := os.Getenv("NIXOS_CLI_ATTEMPTING_ACTIVATION"); attemptingActivation == "" {
		err := execInSwitchContext(s, log, opts.Action, opts.Specialisation)
		if err != nil {
			log.Errorf("failed to re-execute switch-to-configuration script: %v", err)
		}

		return err
	}

	vars, err := getRequiredVars()
	if err != nil {
		log.Errorf("%s", err)
		return err
	}

	err = os.Setenv("NIXOS_ACTION", opts.Action.String())
	if err != nil {
		log.Errorf("failed to set NIXOS_ACTION variable: %s", err)
		return err
	}

	err = os.Setenv("LOCALE_ARCHIVE", vars.LocaleArchive)
	if err != nil {
		log.Errorf("failed to set LOCALE_ARCHIVE variable: %s", err)
		return err
	}

	err = os.MkdirAll("/run/nixos", 0o755)
	if err != nil {
		log.Errorf("failed to create /run/nixos: %s", err)
		return err
	}

	lockfile, err := os.OpenFile(ACTIVATION_LOCKFILE, os.O_CREATE|os.O_RDWR, 0o600)
	if err != nil {
		log.Errorf("failed to create activation lockfile %s: %s", ACTIVATION_LOCKFILE, err)
		return err
	}
	defer func() { _ = lockfile.Close() }()

	if err := unix.Flock(int(lockfile.Fd()), unix.LOCK_EX|unix.LOCK_NB); err != nil {
		log.Errorf("failed to lock %s", ACTIVATION_LOCKFILE)
		log.Info("is another activation process running?")
		return err
	}
	defer func() { _ = unix.Flock(int(lockfile.Fd()), unix.LOCK_UN) }()

	// TODO: syslog init?

	if skipCheck := os.Getenv("NIXOS_NO_CHECK"); skipCheck == "" {
		log.Info("running pre-switch checks")

		err = runPreSwitchCheck(s, vars.PreSwitchCheckCmd, vars.Toplevel, opts.Action)
		if err != nil {
			log.Errorf("failed to run pre-switch check commands: %s", err)
			return err
		}
	}

	if opts.Action == activation.SwitchToConfigurationActionChecksOnly {
		return nil
	}

	if opts.Action == activation.SwitchToConfigurationActionBoot || opts.Action == activation.SwitchToConfigurationActionSwitch {
		log.Info("installing bootloader")

		if err := installBootloader(s, vars.InstallBootloaderCmd, vars.Toplevel); err != nil {
			log.Errorf("failed to install bootloader: %s", err)
			return err
		}
	}

	if skipSync := os.Getenv("NIXOS_NO_SYNC"); skipSync == "" {
		log.Info("syncing /nix/store to disk")

		dir, err := os.Open("/nix/store")
		if err != nil {
			log.Errorf("failed to sync /nix/store: %v", err)
			log.Info("will not proceed with activation")
			return err
		}
		defer func() { _ = dir.Close() }()

		if err := unix.Syncfs(int(dir.Fd())); err != nil {
			log.Errorf("failed to sync /nix/store: %v", err)
			log.Info("will not proceed with activation")
			return err
		}
	}

	if opts.Action == activation.SwitchToConfigurationActionBoot {
		return nil
	}

	if err = validateInterfaceVersion(vars.Toplevel); err != nil {
		log.Errorf("%v", err)
		if errors.Is(err, ErrMismatchedInterfaceVersion) {
			log.Info("the new configuration won't take effect until you reboot the system")
		}
		os.Exit(100)
	}

	// Prevent this process from getting killed if running
	// in a TTY and tty* systemd unit(s) are restarted.
	signal.Ignore(syscall.SIGHUP)

	ctx := context.Background()

	systemd, err := systemdDbus.NewWithContext(ctx)
	if err != nil {
		log.Errorf("failed to initialize systemd dbus connection: %v", err)
		return err
	}
	defer systemd.Close()

	logind, err := login1.New()
	if err != nil {
		log.Errorf("failed to initialize logind system dbus connection: %v", err)
	}
	defer logind.Close()

	unitLists := makeUnitLists(vars.Toplevel)

	currentActiveUnits, err := getActiveUnits(ctx, systemd)
	if err != nil {
		log.Errorf("failed to get active units: %s", err)
		return err
	}

	err = unitLists.ClassifyActiveUnits(ctx, currentActiveUnits)
	if err != nil {
		log.Errorf("%v", err)
		return err
	}

	currentFilesystems, currentSwapDevices, _ := parseFstab("/etc/fstab")
	newFilesystems, newSwapDevices, _ := parseFstab(filepath.Join(vars.Toplevel, "/etc/fstab"))

	unitLists.ClassifyFilesystemUnits(currentFilesystems, newFilesystems)

	for device := range currentSwapDevices {
		if _, ok := newSwapDevices[device]; !ok {
			// The swap entry has disappeared, so turn it off.
			//
			// Can't use "systemctl stop" here, since systemd has lots
			// of alias units that prevent a stop from actually calling
			// "swapoff", so we instead invoke the syscall ourselves.
			if opts.Action == activation.SwitchToConfigurationActionDryActivate {
				log.Infof("would stop swap device %s", device)
			} else {
				log.Infof("stopping swap device %s", device)
				err := swapoff(device)
				if err != nil {
					log.Warnf("failed to stop swapping to device %s, continuing activation anyway", device)
				}
			}
		}

		// FIXME: update swap options (i.e. its priority).
	}

	currentPID1Path, err := filepath.EvalSymlinks("/proc/1/exe")
	if err != nil {
		currentPID1Path = "/unknown"
	}

	newPID1Path, err := filepath.EvalSymlinks(filepath.Join(vars.NewSystemd, "lib/systemd/systemd"))
	if err != nil {
		err := fmt.Errorf("systemd binary in this system does not exist, cannot continue")
		log.Errorf("%s", err)
		return err
	}

	currentSystemdSystemConfig, err := filepath.EvalSymlinks("/etc/systemd/system.conf")
	if err != nil {
		currentSystemdSystemConfig = "/unknown"
	}

	newSystemdSystemConfig, err := filepath.EvalSymlinks(filepath.Join(vars.Toplevel, "etc/systemd/system.conf"))
	if err != nil {
		newSystemdSystemConfig = "/unknown"
	}

	restartSystemd := currentPID1Path != newPID1Path || currentSystemdSystemConfig != newSystemdSystemConfig

	if opts.Action == activation.SwitchToConfigurationActionDryActivate {
		unitsToStop := unitLists.Stop.Filter(unitLists.Filter)
		if len(unitsToStop) > 0 {
			log.Infof("would stop the following units: %s", strings.Join(unitsToStop.Sorted(), ", "))
		}

		if len(unitLists.Skip) > 0 {
			log.Infof("would NOT stop the following changed units: %s", strings.Join(unitLists.Skip.Sorted(), ", "))
		}

		log.Info("would run activate script...")

		// If the dry activate script fails, don't stop printing output
		// and just ignore the errors.
		err = runActivateScript(vars.Toplevel, true)
		if err != nil && !errors.Is(err, errActivateScriptNotExist) {
			log.Warnf("running activation script failed: %s", err)
		}

		dryRestartUnits := readUnitsListFile(DRY_RESTART_BY_ACTIVATION_LIST_FILE)
		for unit := range dryRestartUnits {
			resolvedUnit := resolveUnit(unit, vars.Toplevel)

			if _, ok := currentActiveUnits[unit]; !ok {
				unitLists.Start.Add(unit)
				continue
			}

			err = unitLists.ClassifyModifiedUnit(
				unit,
				resolvedUnit.BaseName,
				resolvedUnit.NewUnitFile,
				resolvedUnit.NewBaseFile,
				nil,
				currentActiveUnits,
			)
			if err != nil {
				log.Errorf("failed to classify unit %s: %s", unit, err)
				return err
			}
		}

		_ = os.RemoveAll(DRY_RESTART_BY_ACTIVATION_LIST_FILE)

		dryReloadUnits := readUnitsListFile(DRY_RELOAD_BY_ACTIVATION_LIST_FILE)
		for unit := range dryReloadUnits {
			if _, ok := currentActiveUnits[unit]; !ok {
				if !unitLists.Restart.Has(unit) && !unitLists.Stop.Has(unit) {
					unitLists.Reload.Add(unit)
				}
			}
		}

		_ = os.RemoveAll(DRY_RELOAD_BY_ACTIVATION_LIST_FILE)

		if restartSystemd {
			log.Info("would restart systemd")
		}

		if len(unitLists.Reload) > 0 {
			log.Infof("would reload the following units: %s", strings.Join(unitLists.Reload.Sorted(), ", "))
		}

		if len(unitLists.Restart) > 0 {
			log.Infof("would restart the following units: %s", strings.Join(unitLists.Restart.Sorted(), ", "))
		}

		unitsToStart := unitLists.Start.Filter(unitLists.Filter)
		if len(unitsToStart) > 0 {
			log.Infof("would start the following units: %s", strings.Join(unitsToStart.Sorted(), ", "))
		}

		return nil
	}

	log.Info("switching to system configuration")

	unitStatuses := make([]unitActionResult, 0)

	if len(unitLists.Stop) > 0 {
		filteredUnits := unitLists.Stop.Filter(unitLists.Filter)
		if len(filteredUnits) > 0 {
			log.Infof("stopping the following units: %s", strings.Join(filteredUnits.Sorted(), ", "))
		}

		statuses := runUnitAction(ctx, systemd, unitLists.Stop, actionStop)
		unitStatuses = append(unitStatuses, statuses...)
	}

	if len(unitLists.Skip) > 0 {
		log.Infof("NOT restarting the following changed units: %s", strings.Join(unitLists.Skip.Sorted(), ", "))
	}

	exitCode := 0

	log.Info("running activation script")
	err = runActivateScript(vars.Toplevel, false)
	if err != nil && !errors.Is(err, errActivateScriptNotExist) {
		log.Errorf("failed to run activate script: %v", err)
		exitCode = 2
	}

	activateRestartUnits := readUnitsListFile(RESTART_BY_ACTIVATION_LIST_FILE)
	for unit := range activateRestartUnits {
		resolvedUnit := resolveUnit(unit, vars.Toplevel)

		if _, ok := currentActiveUnits[unit]; !ok {
			unitLists.Start.Add(unit)
			continue
		}

		err = unitLists.ClassifyModifiedUnit(
			unit,
			resolvedUnit.BaseName,
			resolvedUnit.NewUnitFile,
			resolvedUnit.NewBaseFile,
			nil,
			currentActiveUnits,
		)
		if err != nil {
			log.Errorf("failed to classify unit %s: %s", unit, err)
			return err
		}
	}

	_ = os.RemoveAll(RESTART_BY_ACTIVATION_LIST_FILE)

	activateReloadUnits := readUnitsListFile(RELOAD_BY_ACTIVATION_LIST_FILE)
	for unit := range activateReloadUnits {
		if _, ok := currentActiveUnits[unit]; !ok {
			if !unitLists.Restart.Has(unit) && !unitLists.Stop.Has(unit) {
				unitLists.Reload.Add(unit)
			}
		}
	}

	_ = os.RemoveAll(RELOAD_BY_ACTIVATION_LIST_FILE)

	// Restart systemd if necessary. Note that this is done using the
	// current version of systemd, just in case the new one has trouble
	// communicating with the running pid 1.
	//
	// Basically the equivalent of `systemd daemon-reexec`.
	if restartSystemd {
		// A reply will not be received, so ignore errors.
		_ = systemd.ReexecuteContext(ctx)
	}

	// Forget about previously failed services and reload the
	// available systemd units; basically `systemctl daemon-reload`.
	_ = systemd.ReloadContext(ctx)

	users, err := logind.ListUsersContext(ctx)
	if err != nil {
		log.Errorf("failed to list users using logind: %s", err)
		return err
	}
	for _, user := range users {
		userProps, _ := logind.GetUserPropertiesContext(ctx, user.Path)

		var gid uint32
		err := userProps["GID"].Store(&gid)
		if err != nil {
			log.Warnf("failed to get GID for user %s, skipping", user.Name)
			continue
		}

		runtimePath := userProps["RuntimePath"].String()

		log.Infof("reloading units for user %s...", user.Name)

		err = execUserSwitchProcess(user.UID, gid, runtimePath)
		if err != nil {
			log.Errorf("failed to run user switch for user %s: %v", user.Name, err)
			return err
		}
	}

	// Restart sysinit-reactivation.target. This target only exists to
	// restart services ordered before sysinit.target. We cannot use
	// X-StopOnReconfiguration to restart sysinit.target because then
	// ALL services of the system would be restarted since all normal
	// services have a default dependency on sysinit.target.
	//
	// sysinit-reactivation.target ensures that services ordered BEFORE
	// sysinit.target get re-started in the correct order. Ordering between
	// these services is respected.
	log.Infof("restarting %s", SYSINIT_REACTIVATION_TARGET)

	sysinitReactivationStatus := make(chan string, 1)
	_, err = systemd.RestartUnitContext(ctx, SYSINIT_REACTIVATION_TARGET, "replace", sysinitReactivationStatus)
	if err != nil {
		log.Errorf("failed to restart %s: %s", SYSINIT_REACTIVATION_TARGET, err)
		exitCode = 4
	}
	unitStatuses = append(unitStatuses, unitActionResult{
		Action: actionRestart,
		Unit:   SYSINIT_REACTIVATION_TARGET,
		Result: <-sysinitReactivationStatus,
		Err:    err,
	})

	// Before reloading we need to ensure that the units are still active.
	//
	// They may have been deactivated because one of their requirements got
	// stopped. If they are inactive but should have been reloaded, the user
	// probably expects them to be started.
	if len(unitLists.Reload) > 0 {
		for unit := range unitLists.Reload {
			active, err := unitIsActive(ctx, systemd, unit)
			if err != nil {
				log.Errorf("failed to get state of unit %s: %v", unit, err)
				continue
			}

			if active {
				continue
			}

			unitPath := filepath.Join(vars.Toplevel, "etc/systemd/system", unit)
			unitInfo, err := systemdUtils.ParseUnit(unitPath, unitPath)
			if err != nil {
				log.Errorf("failed to parse unit file %s: %s", unitPath, err)
				continue
			}

			if !unitInfo.GetBoolean("Unit", "RefuseManualStart", false) &&
				!unitInfo.GetBoolean("Unit", "X-OnlyManualStart", false) {
				unitLists.Start.Add(unit)
				recordUnit(START_LIST_FILE, unit)
			}

			// Don't reload the unit, reloading would fail in this case.
			unitLists.Reload.Remove(unit)
			unrecordUnit(RELOAD_LIST_FILE, unit)
		}
	}

	// Reload units that need it.
	// This includes remounting changed mount units.
	if len(unitLists.Reload) > 0 {
		filteredUnits := unitLists.Reload.Filter(unitLists.Filter)
		if len(filteredUnits) > 0 {
			log.Infof("reloading the following units: %s", strings.Join(filteredUnits.Sorted(), ", "))
		}

		statuses := runUnitAction(ctx, systemd, unitLists.Reload, actionReload)
		unitStatuses = append(unitStatuses, statuses...)
	}
	_ = os.RemoveAll(RELOAD_LIST_FILE)

	// Restart changed services (aka those that have to be restarted,
	// rather than stopped and started).
	if len(unitLists.Restart) > 0 {
		filteredUnits := unitLists.Restart.Filter(unitLists.Filter)
		if len(filteredUnits) > 0 {
			log.Infof("restarting the following units: %s", strings.Join(filteredUnits.Sorted(), ", "))
		}

		statuses := runUnitAction(ctx, systemd, unitLists.Restart, actionRestart)
		unitStatuses = append(unitStatuses, statuses...)
	}
	_ = os.RemoveAll(RESTART_LIST_FILE)

	// Start all active targets, as well as changed units we stopped above.
	//
	// The latter is necessary because some may not be dependencies of the
	// targets (i.e. they were manually started).
	//
	// FIXME: detect units that are symlinks to other units. We shouldn't
	// start both at the same time because we'll get a "Failed to add path
	// to set" error from systemd.
	if len(unitLists.Start) > 0 {
		filteredUnits := unitLists.Start.Filter(unitLists.Filter)
		if len(filteredUnits) > 0 {
			log.Infof("starting the following units: %s", strings.Join(filteredUnits.Sorted(), ", "))
		}

		statuses := runUnitAction(ctx, systemd, unitLists.Start, actionStart)
		unitStatuses = append(unitStatuses, statuses...)
	}
	_ = os.RemoveAll(START_LIST_FILE)

	for _, s := range unitStatuses {
		switch s.Result {
		case "timeout", "failed", "dependency":
			log.Warnf("failed to %s %s", s.Action, s.Unit)
			exitCode = 4
		}

		if s.Err != nil {
			log.Warnf("service error for %s: %v", s.Unit, s.Err)
			exitCode = 4
		}
	}

	log.Info("waiting for systemd events to settle")
	waitForSystemdToSettle(systemd, 250*time.Millisecond, 90*time.Second)

	newActiveUnits, err := getActiveUnits(ctx, systemd)
	if err != nil {
		log.Errorf("failed to get new active units: %s", err)
		return err
	}

	failedUnits := make(UnitList)
	newUnits := make(UnitList)

	for unit, state := range newActiveUnits {
		if state.State == "failed" {
			failedUnits.Add(unit)
			continue
		}

		if state.SubState == "auto-restart" && strings.HasSuffix(unit, ".service") {
			prop, err := systemd.GetUnitTypePropertyContext(ctx, unit, "Service", "ExecMainStatus")
			if err != nil {
				log.Errorf("failed to get ExecMainStatus property for %s: %v", unit, err)
				continue
			}

			var execMainStatus int32
			err = prop.Value.Store(&execMainStatus)
			if err != nil {
				log.Errorf("failed to convert ExecMainStatus prop value to int32: %v", err)
			}

			if execMainStatus != 0 {
				failedUnits.Add(unit)
				continue
			}
		}

		if state.State != "failed" && strings.HasSuffix(unit, ".scope") {
			if _, exists := currentActiveUnits[unit]; !exists {
				newUnits.Add(unit)
			}
		}
	}

	if len(newUnits) > 0 {
		log.Infof("the following new units were started: %s", strings.Join(newUnits.Sorted(), ", "))
	}

	if len(failedUnits) > 0 {
		units := failedUnits.Sorted()
		log.Warnf("the following units failed: %s", strings.Join(units, ", "))

		systemctl := filepath.Join(vars.NewSystemd, "bin/systemctl")

		argv := []string{systemctl, "status", "--no-pager", "--full"}
		argv = append(argv, units...)

		cmd := exec.Command(argv[0], argv[1:]...)
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr

		_ = cmd.Run()

		exitCode = 4
	}

	if exitCode != 0 {
		log.Errorf("switching to system configuration failed (status %d)", exitCode)
		os.Exit(exitCode)
	} else {
		log.Info("finished switching to system configuration")
	}

	return nil
}
</file>

<file path="cmd/activate/unit.go">
//go:build linux

package activate

import (
	"bufio"
	"context"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"

	systemdDbus "github.com/coreos/go-systemd/v22/dbus"
	systemdUnit "github.com/coreos/go-systemd/v22/unit"
	systemdUtils "github.com/nix-community/nixos-cli/internal/systemd"
)

const (
	START_LIST_FILE   = "/run/nixos/start-list"
	RESTART_LIST_FILE = "/run/nixos/restart-list"
	RELOAD_LIST_FILE  = "/run/nixos/reload-list"
)

var (
	templateUnitPattern = regexp.MustCompile(`^(.*)@([^\.]*)\.(.*)$`)
	unitNamePattern     = regexp.MustCompile(`^(.*)\.[[:lower:]]*$`)
)

type UnitState struct {
	State    string
	SubState string
}

type UnitList map[string]struct{}

func (l UnitList) Add(unit string) {
	l[unit] = struct{}{}
}

func (l UnitList) Has(unit string) bool {
	_, ok := l[unit]
	return ok
}

func (l UnitList) Remove(unit string) {
	delete(l, unit)
}

type UnitLists struct {
	toplevel string

	Start   UnitList
	Stop    UnitList
	Restart UnitList
	Reload  UnitList
	Skip    UnitList
	Filter  UnitList
}

func makeUnitLists(toplevel string) *UnitLists {
	unitsToStart := readUnitsListFile(START_LIST_FILE)
	unitsToRestart := readUnitsListFile(RESTART_LIST_FILE)
	unitsToReload := readUnitsListFile(RELOAD_LIST_FILE)

	unitsToStop := make(UnitList)
	unitsToSkip := make(UnitList)
	unitsToFilter := make(UnitList)

	return &UnitLists{
		toplevel: toplevel,

		Start:   unitsToStart,
		Stop:    unitsToStop,
		Restart: unitsToRestart,
		Reload:  unitsToReload,
		Skip:    unitsToSkip,
		Filter:  unitsToFilter,
	}
}

func (l *UnitLists) ClassifyActiveUnits(ctx context.Context, units map[string]UnitState) error {
	for unit, state := range units {
		resolvedUnit := resolveUnit(unit, l.toplevel)

		// Only handle resolved units that actually exist and are in an
		// activated/activating state.
		_, err := os.Stat(resolvedUnit.CurrentBaseFile)
		if err != nil || (state.State != "active" && state.State != "activating") {
			continue
		}

		path, err := filepath.EvalSymlinks(resolvedUnit.NewBaseFile)
		treatAsNullUnit := err != nil || path == "/dev/null"

		if treatAsNullUnit {
			// Masked units (aka units that are symlinked to /dev/null) should be stopped
			// if they contain the X-StopOnRemoval attribute.
			unitInfo, err := systemdUtils.ParseUnit(resolvedUnit.CurrentUnitFile, resolvedUnit.CurrentBaseFile)
			if err != nil {
				return err
			}

			if unitInfo.GetBoolean("Unit", "X-StopOnRemoval", false) {
				l.Stop.Add(unit)
			}
		} else if strings.HasSuffix(unit, ".target") {
			newUnitInfo, err := systemdUtils.ParseUnit(resolvedUnit.NewUnitFile, resolvedUnit.NewBaseFile)
			if err != nil {
				return err
			}

			// FIXME: The suspend target is sometimes active after the system has
			// resumed, which should probably not be the case. Ignore for now.
			skipStart := unit == "suspend.target" ||
				unit == "hibernate.target" ||
				unit == "hybrid-sleep.target" ||
				newUnitInfo.GetBoolean("Unit", "RefuseManualStart", false) ||
				newUnitInfo.GetBoolean("Unit", "X-OnlyManualStart", false)

			// Restart all active target units. This should start most
			// changed units we stop here as well as any new dependencies
			// (including new mounts and swap devices).
			if !skipStart {
				l.Start.Add(unit)
				recordUnit(START_LIST_FILE, unit)
				if os.Getenv("STC_DISPLAY_ALL_UNITS") != "1" {
					l.Filter.Add(unit)
				}
			}

			// Stop targets that have X-StopOnReconfiguration set. This is necessary to respect
			// dependency orderings involving targets: if unit X starts after target Y and
			// target Y starts after unit Z, then if X and Z have both changed, then X should
			// be restarted after Z. However, if target Y is in the "active" state, X and Z
			// will be restarted at the same time because X's dependency on Y is already
			// satisfied. Thus, we need to stop Y first. Stopping a target generally has no
			// effect on other units (unless there is a PartOf dependency), so this is just a
			// bookkeeping thing to get systemd to do the right thing.
			if newUnitInfo.GetBoolean("Unit", "X-StopOnReconfiguration", false) {
				l.Stop.Add(unit)
			}
		} else {
			currentUnitInfo, err := systemdUtils.ParseUnit(resolvedUnit.CurrentUnitFile, resolvedUnit.CurrentBaseFile)
			if err != nil {
				return err
			}

			newUnitInfo, err := systemdUtils.ParseUnit(resolvedUnit.NewUnitFile, resolvedUnit.NewBaseFile)
			if err != nil {
				return err
			}

			switch systemdUtils.CompareUnits(currentUnitInfo, newUnitInfo) {
			case systemdUtils.UnitComparisonNeedsRestart:
				err := l.ClassifyModifiedUnit(
					unit,
					resolvedUnit.BaseName,
					resolvedUnit.NewUnitFile,
					resolvedUnit.NewBaseFile,
					newUnitInfo,
					units,
				)
				if err != nil {
					return err
				}
			case systemdUtils.UnitComparisonNeedsReload:
				if !l.Restart.Has(unit) {
					l.Reload.Add(unit)
					recordUnit(RELOAD_LIST_FILE, unit)
				}
			}
		}
	}

	return nil
}

func (l UnitList) Filter(unitsToFilter UnitList) UnitList {
	newList := make(UnitList)

	for unit := range l {
		if !unitsToFilter.Has(unit) {
			newList.Add(unit)
		}
	}

	return newList
}

func (l UnitList) Sorted() []string {
	keys := make([]string, 0, len(l))
	for unit := range l {
		keys = append(keys, strings.ToLower(unit))
	}

	sort.Strings(keys)
	return keys
}

func (l *UnitLists) ClassifyModifiedUnit(
	unit string,
	baseName string,
	newUnitFile string,
	newBaseUnitFile string,
	newUnitInfo systemdUtils.UnitInfo,
	activeUnits map[string]UnitState,
) error {
	// If the new unit info is not passed, then we are running after the
	// activation script has been executed. This means that services that
	// require stopping have already been stopped before this point.
	//
	// As such, for these units, just use the restart mechanism, instead
	// of adding it to the stop/start unit lists just for it to be
	// silently ignored.
	useRestartToStopStartUnit := newUnitInfo == nil

	// These units cannot be restarted directly, so do nothing.
	//
	// Slices and paths don't have to be restarted since properties
	// (resource limits, inotify watches) get applied on daemon-reload.
	if unit == "sysinit.target" ||
		unit == "basic.target" ||
		unit == "multi-user.target" ||
		unit == "graphical.target" ||
		strings.HasSuffix(unit, ".path") ||
		strings.HasSuffix(unit, ".slice") {
		return nil
	}

	// FIXME: do something?
	// Attempt to fix this: https://github.com/NixOS/nixpkgs/pull/141192
	// Revert of the attempt: https://github.com/NixOS/nixpkgs/pull/147609
	// More details: https://github.com/NixOS/nixpkgs/issues/74899#issuecomment-981142430
	if strings.HasSuffix(unit, ".socket") {
		return nil
	}

	// Just restart mount units. We wouldn't have gotten into this condition if only `Options`
	// was changed, in which case the unit would be reloaded. The only exception is / and /nix
	// because it's very unlikely we can safely unmount them so we reload them instead. This
	// means that we may not get all changes into the running system but it's better than
	// crashing it.
	if strings.HasSuffix(unit, ".mount") {
		if unit == "-.mount" || unit == "nix.mount" {
			l.Reload.Add(unit)
			recordUnit(RELOAD_LIST_FILE, unit)
		} else {
			l.Restart.Add(unit)
			recordUnit(RESTART_LIST_FILE, unit)
		}

		return nil
	}

	if newUnitInfo == nil {
		info, err := systemdUtils.ParseUnit(newUnitFile, newBaseUnitFile)
		if err != nil {
			return err
		}
		newUnitInfo = info
	}

	if newUnitInfo.GetBoolean("Service", "X-ReloadIfChanged", false) && !l.Restart.Has(unit) {
		var reloadUnit bool
		if useRestartToStopStartUnit {
			reloadUnit = !l.Restart.Has(unit)
		} else {
			reloadUnit = !l.Stop.Has(unit)
		}

		if reloadUnit {
			l.Reload.Add(unit)
			recordUnit(RELOAD_LIST_FILE, unit)
		}

		return nil
	}

	if !newUnitInfo.GetBoolean("Service", "X-RestartIfChanged", true) ||
		newUnitInfo.GetBoolean("Unit", "RefuseManualStop", false) ||
		newUnitInfo.GetBoolean("Unit", "X-OnlyManualStart", false) {
		l.Skip.Add(unit)
		return nil
	}

	// It doesn't make sense to stop and start non-services because they can't have
	// the `ExecStop` property.
	if !newUnitInfo.GetBoolean("Service", "X-StopIfChanged", true) || !strings.HasSuffix(unit, ".service") {
		l.Restart.Add(unit)
		recordUnit(RESTART_LIST_FILE, unit)

		if l.Reload.Has(unit) {
			l.Reload.Remove(unit)
			unrecordUnit(RELOAD_LIST_FILE, unit)
		}

		return nil
	}

	// If this unit is socket-activated, then stop the socket unit(s) as well, and
	// restart the socket(s) instead of the service.
	//
	// We count as "socket-activated" any unit that doesn't declare itself not so
	// via X-NotSocketActivated, that has any associated .socket units.
	socketActivated := false

	if strings.HasSuffix(unit, ".service") {
		var sockets []string
		if val := newUnitInfo.GetProperty("Service", "Sockets"); val != nil {
			sockets = strings.Fields(*val)
		}

		if len(sockets) == 0 {
			sockets = append(sockets, fmt.Sprintf("%s.socket", baseName))
		}

		for _, socket := range sockets {
			if _, ok := activeUnits[socket]; !ok {
				continue
			}

			if useRestartToStopStartUnit {
				l.Restart.Add(socket)
			} else {
				l.Stop.Add(socket)
			}

			socketUnitPath := filepath.Join(l.toplevel, "etc/systemd/system", socket)
			if _, err := os.Stat(socketUnitPath); err == nil {
				if useRestartToStopStartUnit {
					l.Restart.Add(socket)
					recordUnit(RESTART_LIST_FILE, socket)
				} else {
					l.Start.Add(socket)
					recordUnit(START_LIST_FILE, socket)
				}

				socketActivated = true
			}

			if l.Reload.Has(unit) {
				l.Reload.Remove(unit)
				unrecordUnit(RELOAD_LIST_FILE, unit)
			}
		}
	}

	if newUnitInfo.GetBoolean("Service", "X-NotSocketActivated", false) {
		// If the unit explicitly opts out of socket
		// activation, restart it as if it weren't (but do
		// restart its sockets, that's fine):
		socketActivated = false
	}

	// If the unit is not socket-activated, record that this unit
	// needs to be started below.
	if !socketActivated {
		if useRestartToStopStartUnit {
			l.Restart.Add(unit)
			recordUnit(RESTART_LIST_FILE, unit)
		} else {
			l.Start.Add(unit)
			recordUnit(START_LIST_FILE, unit)
		}

		// And then remove it from reload if need be,
		// to avoid restarting/starting and reloading
		// a service.
		if l.Reload.Has(unit) {
			l.Reload.Remove(unit)
			unrecordUnit(RELOAD_LIST_FILE, unit)
		}
	}

	return nil
}

// Given a map of currently mounted filesystems and the new map
// of filesystems to handle, classify whether or not their units
// should be restarted, reloaded, or stopped (aka unmounted).
func (l UnitLists) ClassifyFilesystemUnits(
	currentFilesystems map[string]Filesystem,
	newFilesystems map[string]Filesystem,
) {
	for mountpoint, currentFS := range currentFilesystems {
		unit := fmt.Sprintf("%s.mount", systemdUnit.UnitNamePathEscape(mountpoint))

		newFS, stillExists := newFilesystems[mountpoint]
		if !stillExists {
			// Unmount filesystem units that have disappeared from the
			// new system.
			l.Stop.Add(unit)
			continue
		}

		if currentFS.Type != newFS.Type || currentFS.Device != newFS.Device {
			// "/" and "/nix" mountpoints should never be restarted,
			// or these could cause a system crash.
			//
			// Only reload these special mountpoints if their
			// mount options have changed.
			if mountpoint == "/" || mountpoint == "/nix" {
				if currentFS.Options != newFS.Options {
					l.Reload.Add(unit)
					recordUnit(RELOAD_LIST_FILE, unit)
				} else {
					l.Skip.Add(unit)
				}
			} else {
				// Device and type changes require unmounting the existing
				// filesystem, which can only be achieved with a unit restart.
				l.Restart.Add(unit)
				recordUnit(RESTART_LIST_FILE, unit)
			}
		} else if currentFS.Options != newFS.Options {
			// Any units reloaded here will respect the soft "remount"
			// option, so there's no need to handle this specially.
			l.Reload.Add(unit)
			recordUnit(RELOAD_LIST_FILE, unit)
		}
	}
}

// Ask the currently running systemd instance via dbus which units are active.
//
// Returns a map where the key is the unit name and the value is the unit's
// state and substate.
func getActiveUnits(ctx context.Context, systemd *systemdDbus.Conn) (map[string]UnitState, error) {
	allUnits, err := systemd.ListUnitsContext(ctx)
	if err != nil {
		return nil, err
	}

	unitMap := make(map[string]UnitState, len(allUnits))

	for _, unit := range allUnits {
		if unit.ActiveState != "inactive" && unit.Followed == "" {
			unitMap[unit.Name] = UnitState{
				State:    unit.ActiveState,
				SubState: unit.SubState,
			}
		}
	}

	return unitMap, nil
}

func unitIsActive(ctx context.Context, systemd *systemdDbus.Conn, unit string) (bool, error) {
	prop, err := systemd.GetUnitPropertyContext(ctx, unit, "ActiveState")
	if err != nil {
		return false, err
	}

	state := prop.Value.Value().(string)

	return state == "active" || state == "activating", nil
}

type ResolvedUnit struct {
	// Original unit string (foo@bar.service)
	Unit string
	// Resolved base unit (foo@.service)
	BaseUnit string
	// Base name without extension (foo)
	BaseName string
	// Location of current unit file (/etc/systemd/system/<unit>)
	CurrentUnitFile string
	// Location of new generation unit file (<toplevel>/etc/systemd/system/<unit>)
	NewUnitFile string
	// Location of current base unit if templated (/etc/systemd/system/<base_unit>)
	CurrentBaseFile string
	// Location of new base file (<toplevel>/etc/systemd/system/<base_unit>)
	NewBaseFile string
}

// Construct the paths associated with a unit.
//
// If the unit is templated, then strip the template value from the unit name
// and use that in each base value.
func resolveUnit(unit, toplevel string) ResolvedUnit {
	currentUnitFile := filepath.Join("/etc/systemd/system", unit)
	newUnitFile := filepath.Join(toplevel, "etc/systemd/system", unit)

	baseUnit := unit
	currentBaseFile := currentUnitFile
	newBaseFile := newUnitFile

	// Detect template instances and strip the template name from the base
	// units and file paths.
	if matches := templateUnitPattern.FindStringSubmatch(unit); len(matches) > 3 {
		templateName, _, unitType := matches[1], matches[2], matches[3]

		if _, err := os.Stat(currentUnitFile); os.IsNotExist(err) {
			if _, err := os.Stat(newUnitFile); os.IsNotExist(err) {
				baseUnit = fmt.Sprintf("%s@.%s", templateName, unitType)
				currentBaseFile = filepath.Join("/etc/systemd/system", baseUnit)
				newBaseFile = filepath.Join(toplevel, "etc/systemd/system", baseUnit)
			}
		}
	}

	// Extract base name (strip the extension like .service, .mount)
	baseName := baseUnit
	if matches := unitNamePattern.FindStringSubmatch(baseUnit); len(matches) > 1 {
		baseName = matches[1]
	}

	return ResolvedUnit{
		Unit:            unit,
		BaseUnit:        baseUnit,
		BaseName:        baseName,
		CurrentUnitFile: currentUnitFile,
		NewUnitFile:     newUnitFile,
		CurrentBaseFile: currentBaseFile,
		NewBaseFile:     newBaseFile,
	}
}

// Read a list of units from a unit list file into a UnitList set.
//
// Units are split by newlines, and empty lines are ignored.
func readUnitsListFile(path string) UnitList {
	units := make(UnitList)

	file, err := os.Open(path)
	if err != nil {
		return units
	}
	defer func() { _ = file.Close() }()

	s := bufio.NewScanner(file)
	for s.Scan() {
		line := strings.TrimSpace(s.Text())
		if line != "" {
			units.Add(line)
		}
	}

	return units
}

// Whether or not to record units into files for more resilience
// if activation is terminated early.
//
// This should be disabled during dry activation.
var recordUnits = true

// Append a unit to a unit list file.
//
// If in dry activation mode, this is skipped.
func recordUnit(filename string, unit string) {
	if !recordUnits {
		return
	}

	file, err := os.OpenFile(filename, os.O_WRONLY|os.O_APPEND|os.O_CREATE, 0o644)
	if err != nil {
		return
	}
	defer func() { _ = file.Close() }()

	_, _ = file.WriteString(unit + "\n")
}

// Remove a unit from a unit list file by reading its
// contents, filtering the value out, and rewriting the
// file again.
//
// If in dry activation mode, this is skipped.
func unrecordUnit(filename string, unit string) {
	if !recordUnits {
		return
	}

	file, err := os.Open(filename)
	if err != nil {
		return
	}
	defer func() { _ = file.Close() }()

	var lines []string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		if line != unit && line != "" {
			lines = append(lines, line)
		}
	}

	_ = os.WriteFile(filename, []byte(strings.Join(lines, "\n")+"\n"), 0o644)
}
</file>

<file path="cmd/activate/unsupported.go">
//go:build !linux

package activate

import (
	"fmt"

	"github.com/nix-community/nixos-cli/internal/activation"
	"github.com/nix-community/nixos-cli/internal/logger"
	"github.com/spf13/cobra"
)

func activateMain(cmd *cobra.Command, _ activation.SwitchToConfigurationAction) error {
	log := logger.FromContext(cmd.Context())
	err := fmt.Errorf("the activate command is unsupported on non-NixOS systems")
	log.Error(err)
	return err
}
</file>

<file path="cmd/activate/user.go">
package activate

import (
	"context"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"syscall"

	systemdDbus "github.com/coreos/go-systemd/v22/dbus"
	"github.com/nix-community/nixos-cli/internal/logger"
)

func execUserSwitchProcess(uid uint32, gid uint32, runtimePath string) error {
	exe, err := filepath.EvalSymlinks("/proc/self/exe")
	if err != nil {
		return err
	}

	cmd := exec.Command(exe, os.Args[1:]...)

	cmd.Env = []string{
		fmt.Sprintf("XDG_RUNTIME_DIR=%s", runtimePath),
		fmt.Sprintf("%s=%s", NIXOS_STC_PARENT_EXE, exe),
	}

	cmd.SysProcAttr = &syscall.SysProcAttr{
		Credential: &syscall.Credential{
			Uid: uid,
			Gid: gid,
		},
	}

	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	return cmd.Run()
}

func userSwitch(log *logger.Logger, parentExe string) error {
	childExe, err := filepath.EvalSymlinks("/proc/self/exe")
	if err != nil {
		log.Errorf("failed to get path of exe: %v", err)
		return err
	}

	if childExe != parentExe {
		err := fmt.Errorf("this program is not meant to be called from outside of `nixos activate`")
		log.Error(err)
		return err
	}

	ctx := context.Background()

	systemd, err := systemdDbus.NewUserConnectionContext(ctx)
	if err != nil {
		log.Errorf("failed to initialize systemd dbus connection: %v", err)
		return err
	}
	defer systemd.Close()

	// The systemd user session seems to not send a Reloaded signal,
	// so we don't have anything to wait on here.
	//
	// Also, ignore errors, since the dbus session bus will probably
	// return an error here due to it running in the user's context.
	_ = systemd.ReexecuteContext(ctx)

	nixosActivationStatus := make(chan string, 1)

	_, err = systemd.RestartUnitContext(ctx, "nixos-activation.service", "replace", nixosActivationStatus)
	if err != nil {
		log.Errorf("failed to restart nixos-activation.service: %v", err)
		return err
	}

	status := <-nixosActivationStatus
	if status == "timeout" || status == "failed" || status == "dependency" {
		err := fmt.Errorf("restarting nixos-activation.service failed with status %s", status)
		log.Error(err)
		return err
	}

	return nil
}
</file>

<file path="cmd/apply/apply.go">
package apply

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/go-git/go-git/v5"
	"github.com/nix-community/nixos-cli/internal/activation"
	"github.com/nix-community/nixos-cli/internal/build"
	"github.com/nix-community/nixos-cli/internal/cmd/nixopts"
	"github.com/nix-community/nixos-cli/internal/cmd/opts"
	"github.com/nix-community/nixos-cli/internal/cmd/utils"
	"github.com/nix-community/nixos-cli/internal/configuration"
	"github.com/nix-community/nixos-cli/internal/constants"
	"github.com/nix-community/nixos-cli/internal/generation"
	"github.com/nix-community/nixos-cli/internal/logger"
	"github.com/nix-community/nixos-cli/internal/settings"
	"github.com/nix-community/nixos-cli/internal/system"
	"github.com/nix-community/nixos-cli/internal/utils"
	"github.com/spf13/cobra"
)

func ApplyCommand(cfg *settings.Settings) *cobra.Command {
	opts := cmdOpts.ApplyOpts{}

	usage := "apply"
	if build.Flake() {
		usage += " [FLAKE-REF]"
	}

	cmd := cobra.Command{
		Use:   usage,
		Short: "Build/activate a NixOS configuration",
		Long:  "Build and activate a NixOS system from a given configuration.",
		Args: func(cmd *cobra.Command, args []string) error {
			if build.Flake() {
				if err := cobra.MaximumNArgs(1)(cmd, args); err != nil {
					return err
				}
				if len(args) > 0 {
					opts.FlakeRef = args[0]
				}
			} else {
				if err := cobra.NoArgs(cmd, args); err != nil {
					return err
				}
			}
			return nil
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if opts.NoActivate && opts.NoBoot {
				if opts.InstallBootloader {
					return fmt.Errorf("--install-bootloader requires activation, remove --no-activate and/or --no-boot to use this option")
				}

				if opts.OutputPath == "" {
					return fmt.Errorf("if --no-activate and --no-boot are both specified, --output must be specified too")
				}
			}

			if build.Flake() && opts.GenerationTag != "" && !opts.NixOptions.Impure {
				if cfg.Apply.ImplyImpureWithTag {
					if err := cmd.Flags().Set("impure", "true"); err != nil {
						panic("failed to set --impure flag for apply command before exec with explicit generation tag")
					}
				} else {
					return fmt.Errorf("--impure is required when using --tag for flake configurations")
				}
			}
			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return cmdUtils.CommandErrorHandler(applyMain(cmd, &opts))
		},
	}

	cmd.Flags().BoolVarP(&opts.Dry, "dry", "d", false, "Show what would be built or ran")
	cmd.Flags().BoolVar(&opts.InstallBootloader, "install-bootloader", false, "(Re)install the bootloader on the configured device(s)")
	cmd.Flags().BoolVar(&opts.NoActivate, "no-activate", false, "Do not activate the built configuration")
	cmd.Flags().BoolVar(&opts.NoBoot, "no-boot", false, "Do not create boot entry for this generation")
	cmd.Flags().StringVarP(&opts.OutputPath, "output", "o", "", "Symlink the output to `location`")
	cmd.Flags().StringVarP(&opts.ProfileName, "profile-name", "p", "system", "Store generations using the profile `name`")
	cmd.Flags().StringVarP(&opts.Specialisation, "specialisation", "s", "", "Activate the specialisation with `name`")
	cmd.Flags().StringVarP(&opts.GenerationTag, "tag", "t", "", "Tag this generation with a `description`")
	cmd.Flags().BoolVar(&opts.UseNom, "use-nom", false, "Use 'nix-output-monitor' to build configuration")
	cmd.Flags().BoolVarP(&opts.Verbose, "verbose", "v", opts.Verbose, "Show verbose logging")
	cmd.Flags().BoolVar(&opts.BuildVM, "vm", false, "Build a NixOS VM script")
	cmd.Flags().BoolVar(&opts.BuildVMWithBootloader, "vm-with-bootloader", false, "Build a NixOS VM script with a bootloader")
	cmd.Flags().BoolVarP(&opts.AlwaysConfirm, "yes", "y", false, "Automatically confirm activation")

	nixopts.AddQuietNixOption(&cmd, &opts.NixOptions.Quiet)
	nixopts.AddPrintBuildLogsNixOption(&cmd, &opts.NixOptions.PrintBuildLogs)
	nixopts.AddNoBuildOutputNixOption(&cmd, &opts.NixOptions.NoBuildOutput)
	nixopts.AddShowTraceNixOption(&cmd, &opts.NixOptions.ShowTrace)
	nixopts.AddKeepGoingNixOption(&cmd, &opts.NixOptions.KeepGoing)
	nixopts.AddKeepFailedNixOption(&cmd, &opts.NixOptions.KeepFailed)
	nixopts.AddFallbackNixOption(&cmd, &opts.NixOptions.Fallback)
	nixopts.AddRefreshNixOption(&cmd, &opts.NixOptions.Refresh)
	nixopts.AddRepairNixOption(&cmd, &opts.NixOptions.Repair)
	nixopts.AddImpureNixOption(&cmd, &opts.NixOptions.Impure)
	nixopts.AddOfflineNixOption(&cmd, &opts.NixOptions.Offline)
	nixopts.AddNoNetNixOption(&cmd, &opts.NixOptions.NoNet)
	nixopts.AddMaxJobsNixOption(&cmd, &opts.NixOptions.MaxJobs)
	nixopts.AddCoresNixOption(&cmd, &opts.NixOptions.Cores)
	nixopts.AddBuildersNixOption(&cmd, &opts.NixOptions.Builders)
	nixopts.AddLogFormatNixOption(&cmd, &opts.NixOptions.LogFormat)
	nixopts.AddOptionNixOption(&cmd, &opts.NixOptions.Options)
	nixopts.AddIncludesNixOption(&cmd, &opts.NixOptions.Includes)

	if build.Flake() {
		nixopts.AddRecreateLockFileNixOption(&cmd, &opts.NixOptions.RecreateLockFile)
		nixopts.AddNoUpdateLockFileNixOption(&cmd, &opts.NixOptions.NoUpdateLockFile)
		nixopts.AddNoWriteLockFileNixOption(&cmd, &opts.NixOptions.NoWriteLockFile)
		nixopts.AddNoUseRegistriesNixOption(&cmd, &opts.NixOptions.NoUseRegistries)
		nixopts.AddCommitLockFileNixOption(&cmd, &opts.NixOptions.CommitLockFile)
		nixopts.AddUpdateInputNixOption(&cmd, &opts.NixOptions.UpdateInputs)
		nixopts.AddOverrideInputNixOption(&cmd, &opts.NixOptions.OverrideInputs)
	}

	if !build.Flake() {
		cmd.Flags().BoolVar(&opts.UpgradeChannels, "upgrade", false, "Upgrade the root user`s 'nixos' channel")
		cmd.Flags().BoolVar(&opts.UpgradeAllChannels, "upgrade-all", false, "Upgrade all the root user's channels")
	}

	_ = cmd.RegisterFlagCompletionFunc("profile-name", generation.CompleteProfileFlag)
	_ = cmd.RegisterFlagCompletionFunc("specialisation", generation.CompleteSpecialisationFlagFromConfig(opts.FlakeRef, opts.NixOptions.Includes))

	cmd.MarkFlagsMutuallyExclusive("dry", "output")
	cmd.MarkFlagsMutuallyExclusive("vm", "vm-with-bootloader")
	cmd.MarkFlagsMutuallyExclusive("no-activate", "specialisation")

	helpTemplate := cmd.HelpTemplate()
	if build.Flake() {
		helpTemplate += `
Arguments:
  [FLAKE-REF]  Flake ref to build configuration from (default: $NIXOS_CONFIG)
`
	}
	helpTemplate += `
This command also forwards Nix options passed here to all relevant Nix invocations.
Check the man page nixos-cli-apply(5) for more details on what options are available.
`

	cmdUtils.SetHelpFlagText(&cmd)
	cmd.SetHelpTemplate(helpTemplate)

	return &cmd
}

func applyMain(cmd *cobra.Command, opts *cmdOpts.ApplyOpts) error {
	log := logger.FromContext(cmd.Context())
	cfg := settings.FromContext(cmd.Context())
	s := system.NewLocalSystem(log)

	if !s.IsNixOS() {
		msg := "this command only is only supported on NixOS systems"
		log.Errorf(msg)
		return fmt.Errorf("%v", msg)
	}

	buildType := configuration.SystemBuildTypeSystemActivation
	if opts.BuildVM {
		buildType = configuration.SystemBuildTypeVM
	} else if opts.BuildVMWithBootloader {
		buildType = configuration.SystemBuildTypeVMWithBootloader
	} else if opts.NoActivate && opts.NoBoot {
		buildType = configuration.SystemBuildTypeSystem
	}

	if os.Geteuid() != 0 {
		err := utils.ExecAsRoot(cfg.RootCommand)
		if err != nil {
			log.Errorf("failed to re-exec command as root: %v", err)
			return err
		}
	}

	if opts.Verbose {
		log.Step("Looking for configuration...")
	}

	var nixConfig configuration.Configuration
	if opts.FlakeRef != "" {
		nixConfig = configuration.FlakeRefFromString(opts.FlakeRef)
		if err := nixConfig.(*configuration.FlakeRef).InferSystemFromHostnameIfNeeded(); err != nil {
			log.Errorf("failed to infer hostname: %v", err)
			return err
		}
	} else {
		c, err := configuration.FindConfiguration(log, cfg, opts.NixOptions.Includes, opts.Verbose)
		if err != nil {
			log.Errorf("failed to find configuration: %v", err)
			return err
		}
		nixConfig = c
	}

	nixConfig.SetBuilder(s)

	var configDirname string
	switch c := nixConfig.(type) {
	case *configuration.FlakeRef:
		configDirname = c.URI
	case *configuration.LegacyConfiguration:
		configDirname = c.ConfigDirname
	}

	configIsDirectory := true
	originalCwd, err := os.Getwd()
	if err != nil {
		log.Errorf("failed to get current directory: %v", err)
		return err
	}
	if configDirname != "" {
		// Change to the configuration directory, if it exists:
		// this will likely fail for remote configurations or
		// configurations accessed through the registry, which
		// should be a rare occurrence, but valid, so ignore any
		// errors in that case.
		err := os.Chdir(configDirname)
		if err != nil {
			configIsDirectory = false
		}
	}

	if !build.Flake() && (opts.UpgradeChannels || opts.UpgradeAllChannels) {
		log.Step("Upgrading channels...")

		if err := upgradeChannels(s, &upgradeChannelsOptions{
			UpgradeAll: opts.UpgradeAllChannels,
			Verbose:    opts.Verbose,
		}); err != nil {
			log.Warnf("failed to update channels: %v", err)
			log.Warnf("continuing with existing channels", err)
		}
	}

	if buildType.IsVM() {
		log.Step("Building VM...")
	} else {
		log.Step("Building configuration...")
	}

	useNom := cfg.Apply.UseNom || opts.UseNom
	nomPath, _ := exec.LookPath("nom")
	nomFound := nomPath != ""
	if opts.UseNom && !nomFound {
		log.Error("--use-nom was specified, but `nom` is not executable")
	} else if cfg.Apply.UseNom && !nomFound {
		log.Warn("apply.use_nom is specified in config, but `nom` is not executable")
		log.Warn("falling back to `nix` command for building")
		useNom = false
	}

	generationTag := opts.GenerationTag
	if generationTag == "" {
		if tagVar := os.Getenv("NIXOS_GENERATION_TAG"); tagVar != "" {
			if opts.Verbose {
				log.Info("using explicitly set NIXOS_GENERATION_TAG variable for generation tag")
			}
			generationTag = tagVar
		}
	}

	if generationTag == "" && cfg.Apply.UseGitCommitMsg {
		if !configIsDirectory {
			log.Warn("configuration is not a directory")
		} else {
			commitMsg, err := getLatestGitCommitMessage(configDirname, cfg.Apply.IgnoreDirtyTree)
			if err == errDirtyGitTree {
				log.Warn("git tree is dirty")
			} else if err != nil {
				log.Warnf("failed to get latest git commit message: %v", err)
			} else {
				generationTag = commitMsg
			}
		}
	}

	generationTag = strings.TrimSpace(generationTag)

	if generationTag != "" {
		// Make sure --impure is added to the Nix options if
		// an implicit commit message is used.
		if err := cmd.Flags().Set("impure", "true"); err != nil {
			panic("failed to set --impure flag for apply command before exec with implicit generation tag with git message")
		}
	}

	// Dry activation requires a real build, so --dry-run shouldn't be set
	// if --activate or --boot is set
	dryBuild := opts.Dry && buildType == configuration.SystemBuildTypeSystem

	outputPath := opts.OutputPath
	if outputPath != "" && !filepath.IsAbs(outputPath) {
		outputPath = filepath.Join(originalCwd, outputPath)
	}

	buildOptions := &configuration.SystemBuildOptions{
		ResultLocation: outputPath,
		DryBuild:       dryBuild,
		UseNom:         useNom,
		GenerationTag:  generationTag,
		Verbose:        opts.Verbose,

		CmdFlags: cmd.Flags(),
		NixOpts:  &opts.NixOptions,
	}

	resultLocation, err := nixConfig.BuildSystem(buildType, buildOptions)
	if err != nil {
		log.Errorf("failed to build configuration: %v", err)
		return err
	}

	if buildType.IsVM() && !dryBuild {
		matches, err := filepath.Glob(fmt.Sprintf("%v/bin/run-*-vm", resultLocation))
		if err != nil || len(matches) == 0 {
			msg := fmt.Sprintf("Failed to find VM binary; look in %v for the script to run the VM.", resultLocation)
			log.Errorf(msg)
			return fmt.Errorf("%v", msg)
		}
		log.Printf("Done. The virtual machine can be started by running `%v`.\n", matches[0])
		return nil
	}

	if buildType == configuration.SystemBuildTypeSystem {
		if opts.Verbose && dryBuild {
			log.Infof("this is a dry build, no activation will be performed")
		}
		return nil
	}

	log.Step("Comparing changes...")

	err = generation.RunDiffCommand(log, s, constants.CurrentSystem, resultLocation, &generation.DiffCommandOptions{
		UseNvd:  cfg.UseNvd,
		Verbose: opts.Verbose,
	})
	if err != nil {
		log.Errorf("failed to run diff command: %v", err)
	}

	if !opts.AlwaysConfirm {
		log.Printf("\n")
		confirm, err := cmdUtils.ConfirmationInput("Activate this configuration?")
		if err != nil {
			log.Errorf("failed to get confirmation: %v", err)
			return err
		}
		if !confirm {
			msg := "confirmation was not given, skipping activation"
			log.Warn(msg)
			return fmt.Errorf("%v", msg)
		}
	}

	specialisation := opts.Specialisation
	if specialisation == "" {
		defaultSpecialisation, err := activation.FindDefaultSpecialisationFromConfig(resultLocation)
		if err != nil {
			log.Warnf("unable to find default specialisation from config: %v", err)
		} else {
			specialisation = defaultSpecialisation
		}
	}

	if !activation.VerifySpecialisationExists(resultLocation, specialisation) {
		log.Warnf("specialisation '%v' does not exist", specialisation)
		log.Warn("using base configuration without specialisations")
		specialisation = ""
	}

	previousGenNumber, err := activation.GetCurrentGenerationNumber(opts.ProfileName)
	if err != nil {
		log.Errorf("%v", err)
		return err
	}

	// Do not create a generation for dry runs or for
	// testing generations using the --no-boot option.
	createGeneration := !opts.Dry && !opts.NoBoot

	if createGeneration {
		if opts.Verbose {
			log.Step("Setting system profile...")
		}

		if err := activation.AddNewNixProfile(s, opts.ProfileName, resultLocation, opts.Verbose); err != nil {
			log.Errorf("failed to set system profile: %v", err)
			return err
		}
	}

	// In case switch-to-configuration fails, rollback the profile.
	// This is to prevent accidental deletion of all working
	// generations in case the switch-to-configuration script
	// fails, since the active profile will not be rolled back
	// automatically.
	rollbackProfile := false
	if createGeneration {
		defer func(rollback *bool) {
			if !*rollback {
				return
			}

			if !cfg.AutoRollback {
				log.Warnf("automatic rollback is disabled, the currently active profile may have unresolved problems")
				log.Warnf("you are on your own!")
				return
			}

			log.Step("Rolling back system profile...")
			if err := activation.SetNixProfileGeneration(s, "system", previousGenNumber, opts.Verbose); err != nil {
				log.Errorf("failed to rollback system profile: %v", err)
				log.Info("make sure to rollback the system manually before deleting anything!")
			}
		}(&rollbackProfile)
	}

	log.Step("Activating...")

	var stcAction activation.SwitchToConfigurationAction
	if opts.Dry && !opts.NoActivate {
		stcAction = activation.SwitchToConfigurationActionDryActivate
	} else if !opts.NoActivate && !opts.NoBoot {
		stcAction = activation.SwitchToConfigurationActionSwitch
	} else if opts.NoActivate && !opts.NoBoot {
		stcAction = activation.SwitchToConfigurationActionBoot
	} else if !opts.NoActivate && opts.NoBoot {
		stcAction = activation.SwitchToConfigurationActionTest
	} else {
		panic("unknown switch to configuration action to take, this is a bug")
	}

	err = activation.SwitchToConfiguration(s, resultLocation, stcAction, &activation.SwitchToConfigurationOptions{
		InstallBootloader: opts.InstallBootloader,
		Verbose:           opts.Verbose,
		Specialisation:    specialisation,
	})
	if err != nil {
		rollbackProfile = true
		log.Errorf("failed to switch to configuration: %v", err)
		return err
	}

	return nil
}

const channelDirectory = constants.NixProfileDirectory + "/per-user/root/channels"

type upgradeChannelsOptions struct {
	Verbose    bool
	UpgradeAll bool
}

func upgradeChannels(s system.CommandRunner, opts *upgradeChannelsOptions) error {
	argv := []string{"nix-channel", "--update"}

	if !opts.UpgradeAll {
		// Always upgrade the `nixos` channel, as well as any channels that
		// have the ".update-on-nixos-rebuild" marker file in them.
		argv = append(argv, "nixos")

		entries, err := os.ReadDir(channelDirectory)
		if err != nil {
			return err
		}

		for _, entry := range entries {
			if entry.IsDir() {
				if _, err := os.Stat(filepath.Join(channelDirectory, entry.Name(), ".update-on-nixos-rebuild")); err == nil {
					argv = append(argv, entry.Name())
				}
			}
		}
	}

	if opts.Verbose {
		s.Logger().CmdArray(argv)
	}

	cmd := system.NewCommand(argv[0], argv[1:]...)
	_, err := s.Run(cmd)
	return err
}

var errDirtyGitTree = fmt.Errorf("git tree is dirty")

func getLatestGitCommitMessage(pathToRepo string, ignoreDirty bool) (string, error) {
	repo, err := git.PlainOpen(pathToRepo)
	if err != nil {
		return "", err
	}

	wt, err := repo.Worktree()
	if err != nil {
		return "", err
	}

	status, err := wt.Status()
	if err != nil {
		return "", err
	}

	if !status.IsClean() && !ignoreDirty {
		return "", errDirtyGitTree
	}

	head, err := repo.Head()
	if err != nil {
		return "", err
	}

	commit, err := repo.CommitObject(head.Hash())
	if err != nil {
		return "", err
	}

	return commit.Message, nil
}
</file>

<file path="cmd/completion/completion.go">
package completion

import (
	"fmt"
	"os"

	"github.com/carapace-sh/carapace"
	"github.com/spf13/cobra"
)

func CompletionCommand() *cobra.Command {
	cmd := cobra.Command{
		Use:                   "completion {bash|zsh|fish|nushell|elvish|xonsh}",
		Short:                 "Generate completion scripts",
		Long:                  "Generate completion scripts for use in shells.",
		Hidden:                true,
		DisableFlagsInUseLine: true,
		ValidArgs: []string{
			"bash",
			"zsh",
			"fish",
			"nushell",
			"elvish",
			"xonsh",
		},
		Args: cobra.MatchAll(cobra.ExactArgs(1), cobra.OnlyValidArgs),
		Run: func(cmd *cobra.Command, args []string) {
			completion_script, err := carapace.Gen(cmd.Root()).Snippet(args[0])
			if err != nil {
				fmt.Fprintln(os.Stderr, "error: failed to generate scripts:", err)
				return
			}
			fmt.Println(completion_script)
		},
	}

	return &cmd
}
</file>

<file path="cmd/enter/enter.go">
package enter

import (
	"github.com/spf13/cobra"

	cmdOpts "github.com/nix-community/nixos-cli/internal/cmd/opts"
	cmdUtils "github.com/nix-community/nixos-cli/internal/cmd/utils"
)

func EnterCommand() *cobra.Command {
	opts := cmdOpts.EnterOpts{}

	cmd := cobra.Command{
		Use:   "enter [flags] [-- ARGS...]",
		Short: "Chroot into a NixOS installation",
		Long:  "Enter a NixOS chroot environment.",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if len(args) > 0 {
				opts.CommandArray = args
			}

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return cmdUtils.CommandErrorHandler(enterMain(cmd, &opts))
		},
	}

	cmd.Flags().StringVarP(&opts.Command, "command", "c", "", "Command `string` to execute in bash")
	cmd.Flags().StringVarP(&opts.RootLocation, "root", "r", "/mnt", "NixOS system root `path` to enter")
	cmd.Flags().StringVar(&opts.System, "system", "", "NixOS system configuration to activate at `path`")
	cmd.Flags().BoolVarP(&opts.Silent, "silent", "s", false, "Suppress all system activation output")
	cmd.Flags().BoolVarP(&opts.Verbose, "verbose", "v", false, "Show verbose logging")

	cmd.MarkFlagsMutuallyExclusive("silent", "verbose")

	cmdUtils.SetHelpFlagText(&cmd)
	cmd.SetHelpTemplate(cmd.HelpTemplate() + `
Arguments:
  [ARGS...]  Interpret arguments as the command to run directly

If providing a command through positional arguments with flags, a preceding
double dash (--) is required. Otherwise, unexpected behavior may occur.
`)

	return &cmd
}
</file>

<file path="cmd/enter/run.go">
//go:build linux

package enter

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"syscall"

	cmdOpts "github.com/nix-community/nixos-cli/internal/cmd/opts"
	"github.com/nix-community/nixos-cli/internal/constants"
	"github.com/nix-community/nixos-cli/internal/logger"
	"github.com/nix-community/nixos-cli/internal/settings"
	"github.com/nix-community/nixos-cli/internal/system"
	"github.com/spf13/cobra"
)

func enterMain(cmd *cobra.Command, opts *cmdOpts.EnterOpts) error {
	log := logger.FromContext(cmd.Context())
	cfg := settings.FromContext(cmd.Context())

	if opts.Silent {
		log.SetLogLevel(logger.LogLevelError)
	}

	nixosMarker := filepath.Join(opts.RootLocation, constants.NixOSMarker)
	if _, err := os.Stat(nixosMarker); err != nil {
		err := fmt.Errorf("%v is not a valid NixOS system", opts.RootLocation)
		log.Error(err)
		return err
	}

	isReexec := os.Getenv(NIXOS_REEXEC) == "1"
	if !isReexec {
		err := execSandboxedEnterProcess(log, opts.Verbose)
		if err != nil {
			log.Errorf("failed to exec sandboxed process with unshare: %v", err)
		}
		return err
	}

	if opts.Verbose {
		log.Info("sandboxed process successfully")
		log.Print()
	}

	log.Step("Bind-mounting resources...")
	log.Info("remounting root privately for namespace")

	err := syscall.Mount("/", "/", "", syscall.MS_REMOUNT|syscall.MS_PRIVATE|syscall.MS_REC, "")
	if err != nil {
		log.Errorf("failed to remount root: %v", err)
		return err
	}

	log.Infof("bind-mounting /dev to %v", opts.RootLocation)
	err = bindMountDirectory(opts.RootLocation, "/dev")
	if err != nil {
		log.Errorf("failed to bind-mount /dev: %v", err)
		return err
	}

	log.Infof("bind-mounting /proc to %v", opts.RootLocation)
	err = bindMountDirectory(opts.RootLocation, "/proc")
	if err != nil {
		log.Errorf("failed to bind-mount /proc: %v", err)
		return err
	}

	var resolvConfErr error
	if cfg.Enter.MountResolvConf {
		if _, err := os.Stat("/etc/resolv.conf"); err == nil {
			log.Infof("bind-mounting /etc/resolv.conf to %v for Internet access", opts.RootLocation)

			targetResolvConf, err := findResolvConfLocation(opts.RootLocation)
			if err != nil {
				log.Warnf("failed to find resolv.conf location: %v", err)
				resolvConfErr = err
				goto resolvConfDone
			}

			// Ensure parent directory exists
			err = os.MkdirAll(filepath.Dir(targetResolvConf), 0o755)
			if err != nil {
				log.Warnf("failed to create parent dir for target resolv.conf: %v", err)
				resolvConfErr = err
				goto resolvConfDone
			}

			// Ensure the target file exists
			targetFile, err := os.OpenFile(targetResolvConf, os.O_CREATE, 0o644)
			if err != nil {
				log.Warnf("failed to create target resolv.conf: %v", err)
				resolvConfErr = err
				goto resolvConfDone
			}
			_ = targetFile.Close()

			// Do the bind mount
			err = syscall.Mount("/etc/resolv.conf", targetResolvConf, "", syscall.MS_BIND, "")
			if err != nil {
				log.Warnf("failed to bind-mount /etc/resolv.conf to chroot: %v", err)
				resolvConfErr = err
				goto resolvConfDone
			}
		} else {
			log.Warnf("/etc/resolv.conf does not exist, skipping mounting: %v", err)
		}
	}

resolvConfDone:
	if resolvConfErr != nil {
		log.Warnf("Internet access may not be available", err)
	}

	systemClosure := opts.System
	if systemClosure == "" {
		systemClosure = filepath.Join(constants.NixProfileDirectory, "system")
	}

	s := system.NewLocalSystem(log)

	log.Step("Activating system...")

	err = activate(s, opts.RootLocation, systemClosure, opts.Verbose, opts.Silent)
	if err != nil {
		log.Errorf("failed to activate system: %v", err)
		return err
	}

	log.Step("Starting chroot...")

	if len(opts.CommandArray) > 0 && len(opts.Command) > 1 {
		log.Warn("preferring --command flag over positional args, both were specified")
	}

	bash := filepath.Join(systemClosure, "sw", "bin", "bash")
	args := opts.CommandArray
	if opts.Command != "" {
		args = []string{bash, "-c", opts.Command}
	}
	if len(args) == 0 {
		args = []string{bash, "--login"}
	}

	err = startChroot(s, opts.RootLocation, args, opts.Verbose)
	if err != nil {
		log.Errorf("failed to start chroot: %v", err)
		return err
	}

	return nil
}

const NIXOS_REEXEC = "_NIXOS_ENTER_REEXEC"

func execSandboxedEnterProcess(log *logger.Logger, verbose bool) error {
	if verbose {
		log.Infof("sandboxing process with unshare")
	}

	argv := []string{"unshare", "--fork", "--mount", "--uts", "--mount-proc", "--pid"}
	argv = append(argv, os.Args...)

	// Map root user if not running as root
	if os.Geteuid() != 0 {
		argv = append(argv, "-r")
	}

	env := os.Environ()
	env = append(env, NIXOS_REEXEC+"=1")

	if verbose {
		log.CmdArray(argv)
	}

	unsharePath, err := exec.LookPath(argv[0])
	if err != nil {
		return err
	}

	err = syscall.Exec(unsharePath, argv, env)
	return err
}

func bindMountDirectory(root string, subdir string) error {
	source := subdir
	target := filepath.Join(root, subdir)

	err := os.MkdirAll(target, 0o755)
	if err != nil && !os.IsExist(err) {
		return err
	}

	err = syscall.Mount(source, target, "", syscall.MS_BIND|syscall.MS_REC, "")
	return err
}

func findResolvConfLocation(root string) (string, error) {
	targetResolvConf := filepath.Join(root, "/etc/resolv.conf")

	resolvConf, err := os.OpenFile(targetResolvConf, os.O_CREATE|os.O_RDONLY, 0o644)
	if err != nil {
		return "", err
	}
	_ = resolvConf.Close()

	resolvedLocation, err := filepath.EvalSymlinks(targetResolvConf)
	if err != nil {
		return "", err
	}

	var finalLocation string
	if !strings.HasPrefix(resolvedLocation, "/") {
		finalLocation = filepath.Join(root, resolvedLocation)
	} else {
		finalLocation = filepath.Join(root, "etc", resolvedLocation)
	}

	return finalLocation, nil
}

func activate(s system.CommandRunner, root string, systemClosure string, verbose bool, silent bool) error {
	localeArchive := filepath.Join(systemClosure, "sw", "lib", "locale", "locale-archive")
	activateScript := filepath.Join(systemClosure, "activate")

	argv := []string{"chroot", root, activateScript}

	if verbose {
		s.Logger().CmdArray(argv)
	}

	// Run the activation script.
	activateCmd := system.NewCommand(argv[0], argv[1:]...)
	activateCmd.SetEnv("LOCALE_ARCHIVE", localeArchive)
	activateCmd.SetEnv("IN_NIXOS_ENTER", "1")

	if silent {
		activateCmd.Stdout = nil
		activateCmd.Stderr = nil
	}

	_, err := s.Run(activateCmd)
	if err != nil {
		return err
	}

	// Create a tmpfs for building/activating the NixOS system.
	systemdTmpfiles := filepath.Join(systemClosure, "sw", "bin", "systemd-tmpfiles")
	argv = []string{"chroot", root, systemdTmpfiles, "--create", "--remove", "-E"}

	if verbose {
		s.Logger().CmdArray(argv)
	}

	tmpfilesCmd := system.NewCommand(argv[0], argv[1:]...)

	// Hide the unhelpful "failed to replace specifiers" errors caused by missing /etc/machine-id.
	tmpfilesCmd.Stdout = nil
	tmpfilesCmd.Stderr = nil

	_, err = s.Run(tmpfilesCmd)
	return err
}

func startChroot(s system.CommandRunner, root string, args []string, verbose bool) error {
	argv := []string{"chroot", root}
	argv = append(argv, args...)

	if verbose {
		s.Logger().CmdArray(argv)
	}

	execPath, err := exec.LookPath(argv[0])
	if err != nil {
		panic(argv[0] + " not found, this should not be reachable")
	}

	err = syscall.Exec(execPath, argv, os.Environ())
	return err
}
</file>

<file path="cmd/enter/unsupported.go">
//go:build !linux

package enter

import (
	"fmt"

	cmdOpts "github.com/nix-community/nixos-cli/internal/cmd/opts"
	"github.com/nix-community/nixos-cli/internal/logger"
	"github.com/spf13/cobra"
)

func enterMain(cmd *cobra.Command, _ *cmdOpts.EnterOpts) error {
	log := logger.FromContext(cmd.Context())
	err := fmt.Errorf("the enter command is unsupported on non-Linux systems")
	log.Error(err)
	return err
}
</file>

<file path="cmd/features/features.go">
package features

import (
	"encoding/json"
	"fmt"
	"os/exec"
	"runtime"
	"strings"

	"github.com/nix-community/nixos-cli/internal/cmd/opts"
	"github.com/nix-community/nixos-cli/internal/cmd/utils"
	"github.com/nix-community/nixos-cli/internal/logger"
	"github.com/spf13/cobra"

	"github.com/nix-community/nixos-cli/internal/build"
)

func FeatureCommand() *cobra.Command {
	opts := cmdOpts.FeaturesOpts{}

	cmd := cobra.Command{
		Use:   "features",
		Short: "Show metadata about this application",
		Long:  "Show metadata about this application and configured options.",
		Run: func(cmd *cobra.Command, args []string) {
			featuresMain(cmd, &opts)
		},
	}

	cmdUtils.SetHelpFlagText(&cmd)

	cmd.Flags().BoolVarP(&opts.DisplayJson, "json", "j", false, "Output information in JSON format")

	return &cmd
}

type features struct {
	Version            string              `json:"version"`
	GitRevision        string              `json:"git_rev"`
	GoVersion          string              `json:"go_version"`
	DetectedNixVersion string              `json:"nix_version"`
	CompilationOptions complilationOptions `json:"options"`
}

type complilationOptions struct {
	NixpkgsVersion string `json:"nixpkgs_version"`
	Flake          bool   `json:"flake"`
}

func featuresMain(cmd *cobra.Command, opts *cmdOpts.FeaturesOpts) {
	log := logger.FromContext(cmd.Context())

	features := features{
		Version:     build.Version(),
		GitRevision: build.GitRevision(),
		GoVersion:   runtime.Version(),
		CompilationOptions: complilationOptions{
			NixpkgsVersion: build.NixpkgsVersion(),
			Flake:          build.Flake(),
		},
	}

	nixVersionCmd := exec.Command("nix", "--version")
	nixVersionOutput, _ := nixVersionCmd.Output()
	if nixVersionCmd.ProcessState.ExitCode() != 0 {
		log.Warn("nix version command failed to run, unable to detect nix version")
		features.DetectedNixVersion = "unknown"
	} else {
		features.DetectedNixVersion = strings.Trim(string(nixVersionOutput), "\n ")
	}

	if opts.DisplayJson {
		bytes, _ := json.MarshalIndent(features, "", "  ")
		fmt.Printf("%v\n", string(bytes))

		return
	}

	fmt.Printf("nixos %v\n", features.Version)
	fmt.Printf("git rev: %v\n", features.GitRevision)
	fmt.Printf("go version: %v\n", features.GoVersion)
	fmt.Printf("nix version: %v\n\n", features.DetectedNixVersion)

	fmt.Println("Compilation Options")
	fmt.Println("-------------------")

	fmt.Printf("flake           :: %v\n", features.CompilationOptions.Flake)
	fmt.Printf("nixpkgs_version :: %v\n", features.CompilationOptions.NixpkgsVersion)
}
</file>

<file path="cmd/generation/delete/delete.go">
package delete

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"slices"
	"strconv"
	"time"

	"github.com/olekukonko/tablewriter"
	"github.com/spf13/cobra"

	genUtils "github.com/nix-community/nixos-cli/cmd/generation/shared"
	"github.com/nix-community/nixos-cli/internal/build"
	cmdOpts "github.com/nix-community/nixos-cli/internal/cmd/opts"
	cmdUtils "github.com/nix-community/nixos-cli/internal/cmd/utils"
	"github.com/nix-community/nixos-cli/internal/constants"
	"github.com/nix-community/nixos-cli/internal/generation"
	"github.com/nix-community/nixos-cli/internal/logger"
	"github.com/nix-community/nixos-cli/internal/settings"
	"github.com/nix-community/nixos-cli/internal/system"
	"github.com/nix-community/nixos-cli/internal/systemd"
	"github.com/nix-community/nixos-cli/internal/utils"
)

func GenerationDeleteCommand(genOpts *cmdOpts.GenerationOpts) *cobra.Command {
	opts := cmdOpts.GenerationDeleteOpts{}

	cmd := cobra.Command{
		Use:   "delete [flags] [GEN...]",
		Short: "Delete generations from this system",
		Long:  "Delete NixOS generations from this system.",
		Args: func(cmd *cobra.Command, args []string) error {
			for _, v := range args {
				value, err := strconv.ParseInt(v, 10, 32)
				if err != nil {
					return fmt.Errorf("[GEN] must be integer value, got '%v'", v)
				}
				opts.Remove = append(opts.Remove, uint(value))
			}
			if cmd.Flags().Changed("older-than") {
				// Make sure older-than is a valid systemd.time(7) string
				if _, err := systemdUtils.DurationFromTimeSpan(opts.OlderThan); err != nil {
					return fmt.Errorf("invalid value for --older-than: %v", err.Error())
				}
			}

			if _, err := regexp.Compile(opts.Pattern); err != nil {
				return fmt.Errorf("invalid pattern: %v", err)
			}

			for _, remove := range opts.Remove {
				if slices.Contains(opts.Keep, remove) {
					return fmt.Errorf("cannot remove and keep the same generation %v", remove)
				}
			}

			log := logger.FromContext(cmd.Context())

			if opts.All {
				if opts.LowerBound != 0 {
					log.Warn("--all was specified, ignoring --from")
				}
				if opts.OlderThan != "" {
					log.Warn("--all was specified, ignoring --older-than")
				}
				if opts.UpperBound != 0 {
					log.Warn("--all was specified, ignoring --to")
				}
				if len(opts.Remove) != 0 {
					log.Warn("--all was specified, ignoring positional arguments")
				}
			}

			if !opts.All && opts.LowerBound == 0 && opts.UpperBound == 0 && len(opts.Remove) == 0 && opts.OlderThan == "" && len(opts.Keep) == 0 && opts.MinimumToKeep == 0 && opts.Pattern == "" {
				return fmt.Errorf("no generations or deletion parameters were given")
			}

			return nil
		},
		ValidArgsFunction: generation.CompleteGenerationNumber(&genOpts.ProfileName, 0),
		RunE: func(cmd *cobra.Command, args []string) error {
			return cmdUtils.CommandErrorHandler(generationDeleteMain(cmd, genOpts, &opts))
		},
	}

	cmd.Flags().BoolVarP(&opts.All, "all", "a", false, "Delete all generations except the current one")
	cmd.Flags().Uint64VarP(&opts.LowerBound, "from", "f", 0, "Delete all generations after `gen`, inclusive")
	cmd.Flags().Uint64VarP(&opts.UpperBound, "to", "t", 0, "Delete all generations until `gen`, inclusive")
	cmd.Flags().Uint64VarP(&opts.MinimumToKeep, "min", "m", 0, "Keep a minimum of `num` generations")
	cmd.Flags().StringVarP(&opts.OlderThan, "older-than", "o", "", "Delete all generations older than `period`")
	// TODO: add -p shorthand if possible
	cmd.Flags().StringVar(&opts.Pattern, "pattern", "", "Delete all generations matching `regex`")
	cmd.Flags().UintSliceVarP(&opts.Keep, "keep", "k", nil, "Always keep this `gen`, can be specified many times")
	cmd.Flags().BoolVarP(&opts.Verbose, "verbose", "v", false, "Show verbose logging")
	cmd.Flags().BoolVarP(&opts.AlwaysConfirm, "yes", "y", false, "Automatically confirm generation deletion")

	_ = cmd.RegisterFlagCompletionFunc("from", generation.CompleteGenerationNumberFlag(&genOpts.ProfileName))
	_ = cmd.RegisterFlagCompletionFunc("to", generation.CompleteGenerationNumberFlag(&genOpts.ProfileName))
	_ = cmd.RegisterFlagCompletionFunc("keep", generation.CompleteGenerationNumberFlag(&genOpts.ProfileName))

	cmdUtils.SetHelpFlagText(&cmd)
	cmd.SetHelpTemplate(cmd.HelpTemplate() + `
Arguments:
    [GEN]       Generation number

These options and arguments can be combined ad-hoc as constraints.

The 'period' parameter in --older-than is a systemd.time(7) span
(i.e. "30d 2h 1m"). Check the manual page for more information.
`)

	return &cmd
}

func generationDeleteMain(cmd *cobra.Command, genOpts *cmdOpts.GenerationOpts, opts *cmdOpts.GenerationDeleteOpts) error {
	log := logger.FromContext(cmd.Context())
	cfg := settings.FromContext(cmd.Context())
	s := system.NewLocalSystem(log)

	if os.Geteuid() != 0 {
		err := utils.ExecAsRoot(cfg.RootCommand)
		if err != nil {
			log.Errorf("failed to re-exec command as root: %v", err)
			return err
		}
	}

	generations, err := genUtils.LoadGenerations(log, genOpts.ProfileName, false)
	if err != nil {
		return err
	}

	gensToDelete, err := resolveGenerationsToDelete(generations, opts)
	if err != nil {
		log.Errorf("%v", err)

		switch err.(type) {
		case GenerationResolveMinError:
			log.Info("keeping all generations")
		case GenerationResolveNoneFoundError:
			log.Info("there is nothing to do; exiting")
		}
		return err
	}

	remainingGenCount := len(generations) - len(gensToDelete)

	log.Print("The following generations will be deleted:")
	log.Print()
	displayDeleteSummary(gensToDelete)
	log.Printf("\nThere will be %v generations remaining on this machine.", remainingGenCount)
	log.Print()

	if !opts.AlwaysConfirm {
		confirm, err := cmdUtils.ConfirmationInput("Proceed?")
		if err != nil {
			log.Errorf("failed to get confirmation: %v", err)
			return err
		}
		if !confirm {
			log.Info("confirmation was not given, not proceeding")
			return nil
		}
	}

	log.Step("Deleting generations...")

	profileDirectory := generation.GetProfileDirectoryFromName(genOpts.ProfileName)
	if err := deleteGenerations(s, profileDirectory, gensToDelete, opts.Verbose); err != nil {
		log.Errorf("failed to delete generations: %v", err)
		return err
	}

	log.Step("Regenerating boot menu entries...")

	if err := regenerateBootMenu(s, opts.Verbose); err != nil {
		log.Errorf("failed to regenerate boot menu entries: %v", err)
		return err
	}

	log.Step("Collecting garbage...")

	if err := collectGarbage(s, opts.Verbose); err != nil {
		log.Errorf("failed to collect garbage: %v", err)
		return err
	}

	log.Print("Success!")

	return nil
}

func displayDeleteSummary(generations []generation.Generation) {
	data := make([][]string, len(generations))

	for i, v := range generations {
		data[i] = []string{
			fmt.Sprintf("%v", v.Number),
			v.Description,
			fmt.Sprintf("%v", v.CreationDate.Format(time.ANSIC)),
		}
	}

	table := tablewriter.NewWriter(os.Stdout)

	table.SetHeader([]string{"#", "Description", "Creation Date"})
	table.SetHeaderAlignment(tablewriter.ALIGN_CENTER)
	table.SetAlignment(tablewriter.ALIGN_LEFT)
	table.SetAutoFormatHeaders(false)
	table.SetAutoWrapText(false)
	table.SetBorder(false)
	table.SetRowSeparator("-")
	table.SetColumnSeparator("|")
	table.AppendBulk(data)
	table.Render()
}

func deleteGenerations(s system.CommandRunner, profileDirectory string, generations []generation.Generation, verbose bool) error {
	argv := []string{"nix-env", "-p", profileDirectory, "--delete-generations"}
	for _, v := range generations {
		argv = append(argv, fmt.Sprintf("%v", v.Number))
	}

	if verbose {
		s.Logger().CmdArray(argv)
	}

	cmd := system.NewCommand(argv[0], argv[1:]...)
	_, err := s.Run(cmd)
	return err
}

func regenerateBootMenu(s system.CommandRunner, verbose bool) error {
	switchToConfiguration := filepath.Join(constants.CurrentSystem, "bin", "switch-to-configuration")

	argv := []string{switchToConfiguration, "boot"}

	if verbose {
		s.Logger().CmdArray(argv)
	}

	cmd := system.NewCommand(argv[0], argv[1:]...)
	_, err := s.Run(cmd)
	return err
}

func collectGarbage(s system.CommandRunner, verbose bool) error {
	var argv []string
	if build.Flake() {
		argv = []string{"nix", "store", "gc"}
	} else {
		argv = []string{"nix-collect-garbage"}
	}

	if verbose {
		argv = append(argv, "-v")
		s.Logger().CmdArray(argv)
	}

	var cmd *system.Command
	if len(argv) == 1 {
		cmd = system.NewCommand(argv[0])
	} else {
		cmd = system.NewCommand(argv[0], argv[1:]...)
	}

	_, err := s.Run(cmd)
	return err
}
</file>

<file path="cmd/generation/delete/resolver_test.go">
package delete

import (
	"errors"
	"reflect"
	"testing"
	"time"

	"github.com/nix-community/nixos-cli/internal/cmd/opts"
	"github.com/nix-community/nixos-cli/internal/generation"
)

func TestResolveGenerationsToDelete(t *testing.T) {
	timeNow := time.Now()
	generations := []generation.Generation{
		{Number: 1, CreationDate: timeNow.Add(-48 * time.Hour), IsCurrent: false},
		{Number: 2, CreationDate: timeNow.Add(-24 * time.Hour), IsCurrent: false},
		{Number: 3, CreationDate: timeNow, IsCurrent: true},
	}

	tests := []struct {
		name      string
		opts      *cmdOpts.GenerationDeleteOpts
		expect    []uint64
		expectErr error
	}{
		{
			name: "Delete all generations",
			opts: &cmdOpts.GenerationDeleteOpts{
				All: true,
			},
			expect: []uint64{1, 2},
		},
		{
			name: "Keep specific generations",
			opts: &cmdOpts.GenerationDeleteOpts{
				Keep: []uint{1},
				All:  true,
			},
			expect: []uint64{2},
		},
		{
			name: "Minimum to keep",
			opts: &cmdOpts.GenerationDeleteOpts{
				MinimumToKeep: 3,
			},
			expect: []uint64{},
			expectErr: GenerationResolveMinError{
				ExpectedMinimum:      3,
				AvailableGenerations: 3,
			},
		},
		{
			name: "Lower and upper bounds",
			opts: &cmdOpts.GenerationDeleteOpts{
				LowerBound: 1,
				UpperBound: 2,
			},
			expect: []uint64{1, 2},
		},
		{
			name: "Older than specified duration",
			opts: &cmdOpts.GenerationDeleteOpts{
				OlderThan: "24h",
			},
			expect: []uint64{1, 2},
		},
		{
			name: "Remove specific generations",
			opts: &cmdOpts.GenerationDeleteOpts{
				Remove: []uint{1},
			},
			expect: []uint64{1},
		},
		{
			name: "Invalid lower and upper bounds",
			opts: &cmdOpts.GenerationDeleteOpts{
				LowerBound: 3,
				UpperBound: 1,
			},
			expectErr: GenerationResolveBoundsError{LowerBound: 3, UpperBound: 1},
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			result, err := resolveGenerationsToDelete(generations, test.opts)

			if test.expectErr != nil {
				if !errors.Is(err, test.expectErr) {
					t.Errorf("expected error %v, got %v", test.expectErr, err)
				}
			} else {
				if err != nil {
					t.Errorf("unexpected error: %v", err)
				}

				resultNumbers := make([]uint64, len(result))
				for i, g := range result {
					resultNumbers[i] = g.Number
				}

				if !reflect.DeepEqual(test.expect, resultNumbers) {
					t.Errorf("expected %v, got %v", test.expect, resultNumbers)
				}
			}
		})
	}
}
</file>

<file path="cmd/generation/delete/resolver.go">
package delete

import (
	"fmt"
	"regexp"
	"slices"
	"sort"
	"time"

	"github.com/nix-community/nixos-cli/internal/cmd/opts"
	"github.com/nix-community/nixos-cli/internal/generation"
	"github.com/nix-community/nixos-cli/internal/systemd"
)

type generationSet map[uint64]present

// evil type system hack to avoid typing struct{} all the time
type present struct{}

func resolveGenerationsToDelete(generations []generation.Generation, opts *cmdOpts.GenerationDeleteOpts) ([]generation.Generation, error) {
	currentGenIdx := slices.IndexFunc(generations, func(g generation.Generation) bool {
		return g.IsCurrent
	})
	if currentGenIdx == -1 {
		panic("current generation not found, this is a bug")
	}
	currentGen := generations[currentGenIdx]

	totalGenerations := uint64(len(generations))

	if totalGenerations == 0 {
		return nil, fmt.Errorf("no generations exist in profile")
	}
	if totalGenerations == 1 {
		return nil, fmt.Errorf("only one generations exists in profile, cannot delete the current generation")
	}

	if opts.MinimumToKeep > 0 && opts.MinimumToKeep >= totalGenerations {
		return nil, GenerationResolveMinError{ExpectedMinimum: opts.MinimumToKeep, AvailableGenerations: totalGenerations}
	}

	gensToKeep := make(generationSet, len(opts.Keep))
	for _, v := range opts.Keep {
		gensToKeep[uint64(v)] = present{}
	}
	gensToKeep[currentGen.Number] = present{}

	gensToRemove := make(generationSet, len(opts.Remove))
	for _, v := range opts.Remove {
		gensToRemove[uint64(v)] = present{}
	}

	if opts.All {
		for _, v := range generations {
			gensToRemove[v.Number] = present{}
		}
	} else {
		if opts.Pattern != "" {
			pattern := regexp.MustCompile(opts.Pattern)
			for _, g := range generations {
				if pattern.MatchString(g.Description) {
					gensToRemove[g.Number] = present{}
				}
			}
		}

		if opts.LowerBound != 0 || opts.UpperBound != 0 {
			upperBound := opts.UpperBound
			if upperBound == 0 {
				upperBound = generations[len(generations)-1].Number
			}
			lowerBound := opts.LowerBound
			if lowerBound == 0 {
				lowerBound = generations[0].Number
			}

			if lowerBound > upperBound {
				return nil, GenerationResolveBoundsError{LowerBound: lowerBound, UpperBound: upperBound}
			}
			if upperBound > generations[len(generations)-1].Number || upperBound < generations[0].Number {
				return nil, GenerationResolveRangeError{InvalidBound: upperBound}
			}
			if lowerBound < generations[0].Number || lowerBound > generations[len(generations)-1].Number {
				return nil, GenerationResolveRangeError{InvalidBound: lowerBound}
			}

			for _, v := range generations {
				if v.Number >= lowerBound && v.Number <= upperBound {
					gensToRemove[v.Number] = present{}
				}
			}
		}

		if opts.OlderThan != "" {
			// This is validated during argument parsing, so no need to check for errors.
			olderThanTimeSpan, _ := systemdUtils.DurationFromTimeSpan(opts.OlderThan)
			upperDateBound := time.Now().Add(-olderThanTimeSpan)

			for _, v := range generations {
				if v.CreationDate.Before(upperDateBound) {
					gensToRemove[v.Number] = present{}
				}
			}
		}
	}

	for g := range gensToKeep {
		delete(gensToRemove, g)
	}

	remainingGenCount := uint64(len(generations) - len(gensToRemove))
	if opts.MinimumToKeep > 0 && remainingGenCount < opts.MinimumToKeep {
		for j := range generations {
			i := len(generations) - 1 - j
			g := generations[i]

			delete(gensToRemove, g.Number)

			remainingGenCount = uint64(len(generations) - len(gensToRemove))
			if remainingGenCount == opts.MinimumToKeep {
				break
			}
		}
	}

	if len(gensToRemove) == 0 {
		return nil, GenerationResolveNoneFoundError{}
	}

	result := make([]generation.Generation, 0, len(gensToRemove))
	for num := range gensToRemove {
		for _, g := range generations {
			if g.Number == num {
				result = append(result, g)
			}
		}
	}

	sort.Slice(result, func(i, j int) bool {
		return result[i].Number < result[j].Number
	})
	return result, nil
}

type GenerationResolveMinError struct {
	ExpectedMinimum      uint64
	AvailableGenerations uint64
}

func (e GenerationResolveMinError) Error() string {
	return fmt.Sprintf("cannot keep %v generations, there are only %v available", e.ExpectedMinimum, e.AvailableGenerations)
}

type GenerationResolveBoundsError struct {
	LowerBound uint64
	UpperBound uint64
}

func (e GenerationResolveBoundsError) Error() string {
	return fmt.Sprintf("lower bound '%v' must be less than upper bound '%v'", e.LowerBound, e.UpperBound)
}

type GenerationResolveRangeError struct {
	InvalidBound uint64
}

func (e GenerationResolveRangeError) Error() string {
	return fmt.Sprintf("bound '%v' is not within the range of available generations", e.InvalidBound)
}

type GenerationResolveNoneFoundError struct{}

func (e GenerationResolveNoneFoundError) Error() string {
	return "no generations were resolved for deletion from the given parameters"
}
</file>

<file path="cmd/generation/diff/diff.go">
package diff

import (
	"fmt"
	"path/filepath"
	"strconv"

	"github.com/spf13/cobra"

	"github.com/nix-community/nixos-cli/internal/cmd/opts"
	"github.com/nix-community/nixos-cli/internal/cmd/utils"
	"github.com/nix-community/nixos-cli/internal/constants"
	"github.com/nix-community/nixos-cli/internal/generation"
	"github.com/nix-community/nixos-cli/internal/logger"
	"github.com/nix-community/nixos-cli/internal/settings"
	"github.com/nix-community/nixos-cli/internal/system"
)

func GenerationDiffCommand(genOpts *cmdOpts.GenerationOpts) *cobra.Command {
	opts := cmdOpts.GenerationDiffOpts{}

	cmd := cobra.Command{
		Use:   "diff {BEFORE} {AFTER}",
		Short: "Show what changed between two generations",
		Long:  "Display what paths differ between two generations.",
		Args: func(cmd *cobra.Command, args []string) error {
			if err := cobra.ExactArgs(2)(cmd, args); err != nil {
				return err
			}

			before, err := strconv.ParseInt(args[0], 10, 32)
			if err != nil {
				return fmt.Errorf("{BEFORE} must be an integer, got '%v'", before)
			}
			opts.Before = uint(before)

			after, err := strconv.ParseInt(args[1], 10, 32)
			if err != nil {
				return fmt.Errorf("{AFTER} must be an integer, got '%v'", after)
			}
			opts.After = uint(after)

			return nil
		},
		ValidArgsFunction: generation.CompleteGenerationNumber(&genOpts.ProfileName, 2),
		RunE: func(cmd *cobra.Command, args []string) error {
			return cmdUtils.CommandErrorHandler(generationDiffMain(cmd, genOpts, &opts))
		},
	}

	cmd.Flags().BoolVarP(&opts.Verbose, "verbose", "v", false, "Show verbose logging")

	cmd.SetHelpTemplate(cmd.HelpTemplate() + `
Arguments:
  [BEFORE]  Number of first generation to compare with
  [AFTER]   Number of second generation to compare with
`)
	cmdUtils.SetHelpFlagText(&cmd)

	return &cmd
}

func generationDiffMain(cmd *cobra.Command, genOpts *cmdOpts.GenerationOpts, opts *cmdOpts.GenerationDiffOpts) error {
	log := logger.FromContext(cmd.Context())
	cfg := settings.FromContext(cmd.Context())
	s := system.NewLocalSystem(log)

	profileDirectory := constants.NixProfileDirectory
	if genOpts.ProfileName != "system" {
		profileDirectory = constants.NixSystemProfileDirectory
	}

	beforeDirectory := filepath.Join(profileDirectory, fmt.Sprintf("%v-%v-link", genOpts.ProfileName, opts.Before))
	afterDirectory := filepath.Join(profileDirectory, fmt.Sprintf("%v-%v-link", genOpts.ProfileName, opts.After))

	err := generation.RunDiffCommand(log, s, beforeDirectory, afterDirectory, &generation.DiffCommandOptions{
		UseNvd:  cfg.UseNvd,
		Verbose: opts.Verbose,
	})
	if err != nil {
		log.Errorf("failed to run diff command: %v", err)
		return err
	}

	return nil
}
</file>

<file path="cmd/generation/list/list.go">
package list

import (
	"encoding/json"
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/spf13/cobra"

	"github.com/nix-community/nixos-cli/cmd/generation/shared"
	"github.com/nix-community/nixos-cli/internal/cmd/opts"
	"github.com/nix-community/nixos-cli/internal/cmd/utils"
	"github.com/nix-community/nixos-cli/internal/generation"
	"github.com/nix-community/nixos-cli/internal/logger"
	"github.com/olekukonko/tablewriter"
)

func GenerationListCommand(genOpts *cmdOpts.GenerationOpts) *cobra.Command {
	opts := cmdOpts.GenerationListOpts{}

	cmd := cobra.Command{
		Use:   "list",
		Short: "List all NixOS generations in a profile",
		Long:  "List all generations in a NixOS profile and their details.",
		RunE: func(cmd *cobra.Command, args []string) error {
			return cmdUtils.CommandErrorHandler(generationListMain(cmd, genOpts, &opts))
		},
	}

	cmd.Flags().BoolVarP(&opts.DisplayJson, "json", "j", false, "Display in JSON format")
	cmd.Flags().BoolVarP(&opts.DisplayTable, "table", "t", false, "Display in table format")

	cmdUtils.SetHelpFlagText(&cmd)

	return &cmd
}

func generationListMain(cmd *cobra.Command, genOpts *cmdOpts.GenerationOpts, opts *cmdOpts.GenerationListOpts) error {
	log := logger.FromContext(cmd.Context())

	generations, err := genUtils.LoadGenerations(log, genOpts.ProfileName, true)
	if err != nil {
		return err
	}

	if opts.DisplayTable {
		displayTable(generations)
		return nil
	}

	if opts.DisplayJson {
		bytes, _ := json.MarshalIndent(generations, "", "  ")
		fmt.Printf("%v\n", string(bytes))

		return nil
	}

	err = generationUI(log, genOpts.ProfileName, generations)
	if err != nil {
		log.Errorf("error running generation TUI: %v", err)
		return err
	}

	return nil
}

func displayTable(generations []generation.Generation) {
	data := make([][]string, len(generations))

	for i, v := range generations {
		data[i] = []string{
			fmt.Sprintf("%v", v.Number),
			fmt.Sprintf("%v", v.IsCurrent),
			fmt.Sprintf("%v", v.CreationDate.Format(time.ANSIC)),
			v.NixosVersion,
			v.NixpkgsRevision,
			v.ConfigurationRevision,
			v.KernelVersion,
			strings.Join(v.Specialisations, ","),
		}
	}

	table := tablewriter.NewWriter(os.Stdout)
	table.SetHeader([]string{"Number", "Current", "Date", "NixOS Version", "Nixpkgs Version", "Config Version", "Kernel Version", "Specialisations"})
	table.SetAutoWrapText(false)
	table.SetAutoFormatHeaders(true)
	table.SetHeaderAlignment(tablewriter.ALIGN_LEFT)
	table.SetAlignment(tablewriter.ALIGN_LEFT)
	table.SetCenterSeparator("")
	table.SetColumnSeparator("")
	table.SetRowSeparator("")
	table.SetHeaderLine(false)
	table.SetBorder(false)
	table.SetTablePadding("\t")
	table.SetNoWhiteSpace(true)
	table.AppendBulk(data)
	table.Render()
}
</file>

<file path="cmd/generation/list/tui.go">
package list

import (
	"fmt"
	"io"
	"os"
	"os/exec"
	"strings"
	"time"

	"github.com/charmbracelet/bubbles/key"
	"github.com/charmbracelet/bubbles/list"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/muesli/termenv"
	"github.com/nix-community/nixos-cli/cmd/generation/shared"
	"github.com/nix-community/nixos-cli/internal/cmd/utils"
	"github.com/nix-community/nixos-cli/internal/generation"
	"github.com/nix-community/nixos-cli/internal/logger"
)

var (
	// Colors
	ansiRed     = lipgloss.ANSIColor(termenv.ANSIRed)
	ansiYellow  = lipgloss.ANSIColor(termenv.ANSIYellow)
	ansiGreen   = lipgloss.ANSIColor(termenv.ANSIGreen)
	ansiWhite   = lipgloss.ANSIColor(termenv.ANSIBrightWhite)
	ansiBlue    = lipgloss.ANSIColor(termenv.ANSIBlue)
	ansiCyan    = lipgloss.ANSIColor(termenv.ANSICyan)
	ansiMagenta = lipgloss.ANSIColor(termenv.ANSIMagenta)

	// Styles
	itemStyle         = lipgloss.NewStyle().MarginLeft(4).PaddingLeft(1).Border(lipgloss.NormalBorder(), false, false, false, true)
	currentItemStyle  = lipgloss.NewStyle().MarginLeft(4).PaddingLeft(1).Foreground(ansiGreen).Border(lipgloss.NormalBorder(), false, false, false, true).BorderForeground(ansiGreen)
	selectedItemStyle = lipgloss.NewStyle().MarginLeft(4).PaddingLeft(1).Foreground(ansiYellow).Border(lipgloss.NormalBorder(), false, false, false, true).BorderForeground(ansiYellow)
	attrStyle         = lipgloss.NewStyle().Foreground(ansiCyan)
	boldStyle         = lipgloss.NewStyle().Bold(true)
	italicStyle       = lipgloss.NewStyle().Italic(true)
)

type generationItem struct {
	Generation generation.Generation
	Selected   bool
}

func (i generationItem) FilterValue() string {
	g := i.Generation
	return fmt.Sprintf("%v %v", g.Number, g.Description)
}

type generationItemDelegate struct{}

func (d generationItemDelegate) Height() int { return 7 }

func (d generationItemDelegate) Spacing() int { return 1 }

func (d generationItemDelegate) Update(_ tea.Msg, _ *list.Model) tea.Cmd { return nil }

func (d generationItemDelegate) Render(w io.Writer, m list.Model, index int, listItem list.Item) {
	i, ok := listItem.(generationItem)
	if !ok {
		return
	}

	g := i.Generation

	current := ""
	if g.IsCurrent {
		current = " (active)"
	}

	str := boldStyle.Render(fmt.Sprintf("%v%v", g.Number, current))
	if len(g.Description) > 0 {
		trimmedDesc, _, _ := strings.Cut(g.Description, "\n")
		str += italicStyle.Render(fmt.Sprintf(" - %v", trimmedDesc))
	}

	cfgRev := g.ConfigurationRevision
	if cfgRev == "" {
		cfgRev = italicStyle.Render("(unknown)")
	}

	nixpkgsRev := g.NixpkgsRevision
	if nixpkgsRev == "" {
		nixpkgsRev = italicStyle.Render("(unknown)")
	}

	kernelVersion := g.KernelVersion
	if kernelVersion == "" {
		kernelVersion = italicStyle.Render("(unknown)")
	}

	var specialisations string
	if len(g.Specialisations) > 0 {
		specialisations = strings.Join(g.Specialisations, ", ")
	} else {
		specialisations = italicStyle.Render("(none)")
	}

	str += fmt.Sprintf("\n%s    :: %s", attrStyle.Render("NixOS Version"), g.NixosVersion)
	str += fmt.Sprintf("\n%s    :: %s", attrStyle.Render("Creation Date"), g.CreationDate.Format(time.ANSIC))
	str += fmt.Sprintf("\n%s :: %s", attrStyle.Render("Nixpkgs Revision"), nixpkgsRev)
	str += fmt.Sprintf("\n%s  :: %s", attrStyle.Render("Config Revision"), cfgRev)
	str += fmt.Sprintf("\n%s   :: %s", attrStyle.Render("Kernel Version"), kernelVersion)
	str += fmt.Sprintf("\n%s  :: %s", attrStyle.Render("Specialisations"), specialisations)

	fn := itemStyle.Render

	if index == m.Index() {
		fn = func(s ...string) string {
			return currentItemStyle.Render(strings.Join(s, " "))
		}
	} else if i.Selected {
		fn = func(s ...string) string {
			return selectedItemStyle.Render(strings.Join(s, " "))
		}
	}

	_, _ = fmt.Fprint(w, fn(str))
}

type endAction interface {
	Type() string
}

type quitAction struct{}

func (a quitAction) Type() string { return "quit" }

type switchAction struct {
	Generation uint64
}

func (a switchAction) Type() string { return "switch" }

type deleteAction struct {
	Generations []uint64
}

func (a deleteAction) Type() string { return "delete" }

type model struct {
	list    list.Model
	profile string
	action  endAction
}

func (m model) Init() tea.Cmd {
	return nil
}

func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		m.list.SetWidth(msg.Width)
		m.list.SetHeight(msg.Height - 1)
		return m, nil

	case tea.KeyMsg:
		if m.list.FilterState() == list.Filtering {
			break
		}

		switch keypress := msg.String(); keypress {
		case "q", "ctrl+c":
			m.action = quitAction{}
			return m, tea.Quit

		case "enter":
			g := m.list.SelectedItem().(generationItem).Generation
			m.action = switchAction{Generation: g.Number}
			return m, tea.Quit

		case "d":
			items := m.list.Items()
			gens := make([]uint64, 0, len(items))
			for _, v := range items {
				i := v.(generationItem)
				if i.Selected {
					gens = append(gens, i.Generation.Number)
				}
			}

			if len(gens) > 0 {
				m.action = deleteAction{Generations: gens}
				return m, tea.Quit
			}

		case tea.KeySpace.String():
			i := m.list.SelectedItem().(generationItem)
			if !i.Generation.IsCurrent {
				i.Selected = !i.Selected
				m.list.SetItem(m.list.Index(), i)
			}
		}
	}

	var cmd tea.Cmd
	m.list, cmd = m.list.Update(msg)
	return m, cmd
}

const (
	CLEAR       = "\x1B[2J"
	MV_TOP_LEFT = "\x1B[H"
)

func clearScreen() {
	fmt.Print(CLEAR + MV_TOP_LEFT)
}

func runGenerationSwitchCmd(log *logger.Logger, generation uint64, profile string) error {
	argv := []string{os.Args[0], "generation", "-p", profile, "switch", fmt.Sprintf("%v", generation)}

	cmd := exec.Command(argv[0], argv[1:]...)

	log.CmdArray(argv)

	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	cmd.Stdin = os.Stdin

	return cmd.Run()
}

func runGenerationDeleteCmd(log *logger.Logger, generations []uint64, profile string) error {
	argv := []string{os.Args[0], "generation", "-p", profile, "delete"}
	for _, v := range generations {
		argv = append(argv, fmt.Sprintf("%v", v))
	}

	cmd := exec.Command(argv[0], argv[1:]...)

	log.CmdArray(argv)

	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	cmd.Stdin = os.Stdin

	return cmd.Run()
}

func (m model) View() string {
	// Clear the view before exiting.
	if m.action != nil {
		return ""
	}

	return "\n" + m.list.View()
}

func newGenerationList(generations []generation.Generation) list.Model {
	items := make([]list.Item, len(generations))
	for i, v := range generations {
		items[i] = generationItem{
			Generation: v,
			Selected:   false,
		}
	}

	l := list.New(items, generationItemDelegate{}, 0, 0)

	l.Title = "NixOS Generations"

	l.Styles.Title = lipgloss.NewStyle().MarginLeft(2).Background(ansiRed).Foreground(ansiWhite)
	l.Styles.PaginationStyle = list.DefaultStyles().PaginationStyle.PaddingLeft(4)
	l.Styles.HelpStyle = list.DefaultStyles().HelpStyle.PaddingLeft(4).PaddingBottom(1)
	l.Styles.StatusBar = lipgloss.NewStyle().PaddingLeft(4).PaddingBottom(1).Foreground(ansiMagenta)

	l.FilterInput.PromptStyle = lipgloss.NewStyle().Foreground(ansiBlue).Bold(true).PaddingLeft(2)
	l.FilterInput.TextStyle = lipgloss.NewStyle().Foreground(ansiBlue)
	l.FilterInput.Cursor.Style = lipgloss.NewStyle().Foreground(ansiBlue)
	l.Styles.StatusBarActiveFilter = lipgloss.NewStyle().Foreground(ansiBlue)
	l.Styles.StatusBarFilterCount = lipgloss.NewStyle().Foreground(ansiBlue)

	l.AdditionalFullHelpKeys = func() []key.Binding {
		return []key.Binding{
			key.NewBinding(
				key.WithKeys("space"),
				key.WithHelp("space", "select for deletion"),
			),
			key.NewBinding(
				key.WithKeys("enter"),
				key.WithHelp("enter", "switch to generation"),
			),
			key.NewBinding(
				key.WithKeys("d"),
				key.WithHelp("d", "delete selected generations"),
			),
		}
	}

	return l
}

func generationUI(log *logger.Logger, profile string, generations []generation.Generation) error {
	closeLogFile, _ := cmdUtils.ConfigureBubbleTeaLogger("genlist")
	defer closeLogFile()

	l := newGenerationList(generations)

	m := model{
		list:    l,
		profile: profile,
	}

	for {
		finalM, err := tea.NewProgram(&m).Run()
		if err != nil {
			return err
		}

		action := finalM.(model).action

		switch a := action.(type) {
		case quitAction:
			return nil
		case switchAction:
			err = runGenerationSwitchCmd(log, a.Generation, profile)
		case deleteAction:
			err = runGenerationDeleteCmd(log, a.Generations, profile)
		}

		if err != nil {
			log.Errorf("%v", err)
		}

		log.Info("returning to main window")
		if err != nil {
			time.Sleep(time.Second * 3)
		} else {
			time.Sleep(time.Second)
		}

		reloadedGenerations, err := genUtils.LoadGenerations(log, profile, true)
		if err != nil {
			return err
		}
		m.list = newGenerationList(reloadedGenerations)
		m.action = nil
		clearScreen()
	}
}
</file>

<file path="cmd/generation/rollback/rollback.go">
package rollback

import (
	"fmt"
	"os"
	"path/filepath"
	"slices"

	"github.com/spf13/cobra"

	"github.com/nix-community/nixos-cli/cmd/generation/shared"
	"github.com/nix-community/nixos-cli/internal/activation"
	"github.com/nix-community/nixos-cli/internal/cmd/opts"
	"github.com/nix-community/nixos-cli/internal/cmd/utils"
	"github.com/nix-community/nixos-cli/internal/constants"
	"github.com/nix-community/nixos-cli/internal/generation"
	"github.com/nix-community/nixos-cli/internal/logger"
	"github.com/nix-community/nixos-cli/internal/settings"
	"github.com/nix-community/nixos-cli/internal/system"
	"github.com/nix-community/nixos-cli/internal/utils"
)

func GenerationRollbackCommand(genOpts *cmdOpts.GenerationOpts) *cobra.Command {
	opts := cmdOpts.GenerationRollbackOpts{}

	cmd := cobra.Command{
		Use:   "rollback [flags] {GEN}",
		Short: "Activate the previous generation",
		Long:  "Rollback to the previous NixOS generation.",
		RunE: func(cmd *cobra.Command, args []string) error {
			return cmdUtils.CommandErrorHandler(generationRollbackMain(cmd, genOpts, &opts))
		},
	}

	cmd.Flags().BoolVarP(&opts.Dry, "dry", "d", false, "Show what would be activated, but do not activate")
	cmd.Flags().StringVarP(&opts.Specialisation, "specialisation", "s", "", "Activate the specialisation with `name`")
	cmd.Flags().BoolVarP(&opts.Verbose, "verbose", "v", false, "Show verbose logging")
	cmd.Flags().BoolVarP(&opts.AlwaysConfirm, "yes", "y", false, "Automatically confirm activation")

	_ = cmd.RegisterFlagCompletionFunc("specialisation", completeSpecialisationFlag(genOpts.ProfileName))

	cmdUtils.SetHelpFlagText(&cmd)

	return &cmd
}

func generationRollbackMain(cmd *cobra.Command, genOpts *cmdOpts.GenerationOpts, opts *cmdOpts.GenerationRollbackOpts) error {
	log := logger.FromContext(cmd.Context())
	cfg := settings.FromContext(cmd.Context())
	s := system.NewLocalSystem(log)

	if os.Geteuid() != 0 {
		err := utils.ExecAsRoot(cfg.RootCommand)
		if err != nil {
			log.Errorf("failed to re-exec command as root: %v", err)
			return err
		}
	}

	// While it is possible to use the `rollback` command, we still need
	// to find the previous generation number ourselves in order to run
	// `nvd` or `nix store diff-closures` properly.
	previousGen, err := findPreviousGeneration(log, genOpts.ProfileName)
	if err != nil {
		return err
	}

	profileDirectory := constants.NixProfileDirectory
	if genOpts.ProfileName != "system" {
		profileDirectory = constants.NixSystemProfileDirectory
	}
	generationLink := filepath.Join(profileDirectory, fmt.Sprintf("%v-%v-link", genOpts.ProfileName, previousGen.Number))

	log.Step("Comparing changes...")

	err = generation.RunDiffCommand(log, s, constants.CurrentSystem, generationLink, &generation.DiffCommandOptions{
		UseNvd:  cfg.UseNvd,
		Verbose: opts.Verbose,
	})
	if err != nil {
		log.Errorf("failed to run diff command: %v", err)
	}

	if !opts.AlwaysConfirm {
		log.Printf("\n")
		confirm, err := cmdUtils.ConfirmationInput("Activate the previous generation?")
		if err != nil {
			log.Errorf("failed to get confirmation: %v", err)
			return err
		}
		if !confirm {
			msg := "confirmation was not given, skipping activation"
			log.Warn(msg)
			return fmt.Errorf("%v", msg)
		}
	}

	specialisation := opts.Specialisation
	if specialisation == "" {
		defaultSpecialisation, err := activation.FindDefaultSpecialisationFromConfig(generationLink)
		if err != nil {
			log.Warnf("unable to find default specialisation from config: %v", err)
		} else {
			specialisation = defaultSpecialisation
		}
	}

	if !activation.VerifySpecialisationExists(generationLink, specialisation) {
		log.Warnf("specialisation '%v' does not exist", specialisation)
		log.Warn("using base configuration without specialisations")
		specialisation = ""
	}

	previousGenNumber, err := activation.GetCurrentGenerationNumber(genOpts.ProfileName)
	if err != nil {
		log.Errorf("%v", err)
		return err
	}

	if !opts.Dry {
		log.Step("Setting system profile...")

		if err := activation.SetNixProfileGeneration(s, genOpts.ProfileName, uint64(previousGen.Number), opts.Verbose); err != nil {
			log.Errorf("failed to set system profile: %v", err)
			return err
		}
	}

	// In case switch-to-configuration fails, rollback the profile.
	// This is to prevent accidental deletion of all working
	// generations in case the switch-to-configuration script
	// fails, since the active profile will not be rolled back
	// automatically.
	rollbackProfile := false
	if !opts.Dry {
		defer func(rollback *bool) {
			if !*rollback {
				return
			}

			if !cfg.AutoRollback {
				log.Warnf("automatic rollback is disabled, the currently active profile may have unresolved problems")
				log.Warnf("you are on your own!")
				return
			}

			log.Step("Rolling back system profile...")
			if err := activation.SetNixProfileGeneration(s, "system", previousGenNumber, opts.Verbose); err != nil {
				log.Errorf("failed to rollback system profile: %v", err)
				log.Info("make sure to rollback the system manually before deleting anything!")
			}
		}(&rollbackProfile)
	}

	log.Step("Activating...")

	var stcAction activation.SwitchToConfigurationAction = activation.SwitchToConfigurationActionSwitch
	if opts.Dry {
		stcAction = activation.SwitchToConfigurationActionDryActivate
	}

	err = activation.SwitchToConfiguration(s, generationLink, stcAction, &activation.SwitchToConfigurationOptions{
		Verbose:        opts.Verbose,
		Specialisation: specialisation,
	})
	if err != nil {
		rollbackProfile = true
		log.Errorf("failed to switch to configuration: %v", err)
		return err
	}

	return nil
}

func findPreviousGeneration(log *logger.Logger, profileName string) (*generation.Generation, error) {
	generations, err := genUtils.LoadGenerations(log, profileName, false)
	if err != nil {
		return nil, err
	}

	currentGenIdx := slices.IndexFunc(generations, func(g generation.Generation) bool {
		return g.IsCurrent
	})
	if currentGenIdx == -1 {
		panic("current generation not found, this is a bug")
	}
	currentGen := generations[currentGenIdx]

	if currentGenIdx == 0 {
		msg := fmt.Sprintf("no generation older than the current one (%v) exists", currentGen.Number)
		log.Error(msg)
		return nil, fmt.Errorf("%v", msg)
	}

	return &generations[currentGenIdx-1], nil
}

func completeSpecialisationFlag(profileName string) cobra.CompletionFunc {
	profileDirectory := constants.NixProfileDirectory
	if profileName != "system" {
		profileDirectory = constants.NixSystemProfileDirectory
	}

	return func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
		// I was too lazy to not
		log := logger.FromContext(cmd.Context())

		previousGen, err := findPreviousGeneration(log, profileName)
		if err != nil {
			return []string{}, cobra.ShellCompDirectiveNoFileComp
		}

		generationLink := filepath.Join(profileDirectory, fmt.Sprintf("%v-%v-link", profileName, previousGen.Number))

		return generation.CompleteSpecialisationFlag(generationLink)(cmd, args, toComplete)
	}
}
</file>

<file path="cmd/generation/shared/utils.go">
package genUtils

import (
	"github.com/nix-community/nixos-cli/internal/generation"
	"github.com/nix-community/nixos-cli/internal/logger"
)

func LoadGenerations(log *logger.Logger, profileName string, reverse bool) ([]generation.Generation, error) {
	generations, err := generation.CollectGenerationsInProfile(log, profileName)
	if err != nil {
		switch v := err.(type) {
		case *generation.GenerationReadError:
			for _, err := range v.Errors {
				log.Warnf("%v", err)
			}

		default:
			log.Errorf("error collecting generation information: %v", v)
			return nil, v
		}
	}

	if reverse {
		for i, j := 0, len(generations)-1; i < j; i, j = i+1, j-1 {
			generations[i], generations[j] = generations[j], generations[i]
		}
	}

	return generations, nil
}
</file>

<file path="cmd/generation/switch/switch.go">
package switch_cmd

import (
	"fmt"
	"os"
	"path/filepath"
	"strconv"

	"github.com/spf13/cobra"

	"github.com/nix-community/nixos-cli/internal/activation"
	"github.com/nix-community/nixos-cli/internal/cmd/opts"
	"github.com/nix-community/nixos-cli/internal/cmd/utils"
	"github.com/nix-community/nixos-cli/internal/constants"
	"github.com/nix-community/nixos-cli/internal/generation"
	"github.com/nix-community/nixos-cli/internal/logger"
	"github.com/nix-community/nixos-cli/internal/settings"
	"github.com/nix-community/nixos-cli/internal/system"
	"github.com/nix-community/nixos-cli/internal/utils"
)

func GenerationSwitchCommand(genOpts *cmdOpts.GenerationOpts) *cobra.Command {
	opts := cmdOpts.GenerationSwitchOpts{}

	cmd := cobra.Command{
		Use:   "switch [flags] {GEN}",
		Short: "Activate an existing generation",
		Long:  "Activate an arbitrary existing NixOS generation",
		Args: func(cmd *cobra.Command, args []string) error {
			if err := cobra.ExactArgs(1)(cmd, args); err != nil {
				return err
			}

			arg := args[0]
			gen, err := strconv.ParseInt(arg, 10, 32)
			if err != nil {
				return fmt.Errorf("{GEN} must be integer value, got '%v'", arg)
			}

			opts.Generation = uint(gen)

			return nil
		},
		ValidArgsFunction: generation.CompleteGenerationNumber(&genOpts.ProfileName, 1),
		RunE: func(cmd *cobra.Command, args []string) error {
			return cmdUtils.CommandErrorHandler(generationSwitchMain(cmd, genOpts, &opts))
		},
	}

	cmd.Flags().BoolVarP(&opts.Dry, "dry", "d", false, "Show what would be activated, but do not activate")
	cmd.Flags().StringVarP(&opts.Specialisation, "specialisation", "s", "", "Activate the specialisation with `name`")
	cmd.Flags().BoolVarP(&opts.Verbose, "verbose", "v", false, "Show verbose logging")
	cmd.Flags().BoolVarP(&opts.AlwaysConfirm, "yes", "y", false, "Automatically confirm activation")

	_ = cmd.RegisterFlagCompletionFunc("specialisation", completeSpecialisationFlag(genOpts.ProfileName))

	cmdUtils.SetHelpFlagText(&cmd)
	cmd.SetHelpTemplate(cmd.HelpTemplate() + `
Arguments:
    [GEN]       Generation number
`)

	return &cmd
}

func completeSpecialisationFlag(profileName string) cobra.CompletionFunc {
	profileDirectory := constants.NixProfileDirectory
	if profileName != "system" {
		profileDirectory = constants.NixSystemProfileDirectory
	}

	return func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
		// Cobra does not parse out the generation number, because it has not
		// validated them yet.
		// Let's pull it out ourselves based on the first provided
		// command-line positional argument
		if len(args) < 1 {
			return []string{}, cobra.ShellCompDirectiveNoFileComp
		}
		arg := args[0]

		genNumber, err := strconv.ParseInt(arg, 10, 32)
		if err != nil {
			return []string{}, cobra.ShellCompDirectiveNoFileComp
		}

		generationLink := filepath.Join(profileDirectory, fmt.Sprintf("%v-%v-link", profileName, genNumber))

		return generation.CompleteSpecialisationFlag(generationLink)(cmd, args, toComplete)
	}
}

func generationSwitchMain(cmd *cobra.Command, genOpts *cmdOpts.GenerationOpts, opts *cmdOpts.GenerationSwitchOpts) error {
	log := logger.FromContext(cmd.Context())
	cfg := settings.FromContext(cmd.Context())
	s := system.NewLocalSystem(log)

	if os.Geteuid() != 0 {
		err := utils.ExecAsRoot(cfg.RootCommand)
		if err != nil {
			log.Errorf("failed to re-exec command as root: %v", err)
			return err
		}
	}

	profileDirectory := constants.NixProfileDirectory
	if genOpts.ProfileName != "system" {
		profileDirectory = constants.NixSystemProfileDirectory
	}
	generationLink := filepath.Join(profileDirectory, fmt.Sprintf("%v-%v-link", genOpts.ProfileName, opts.Generation))

	// Check if generation exists. There are rare cases in which a Nix profile can
	// point to a nonexistent store path, such as in the case that someone manually
	// deletes stuff, but this shouldn't really happen much, if at all.
	if _, err := os.Stat(generationLink); err != nil {
		if os.IsNotExist(err) {
			msg := fmt.Sprintf("generation %v not found", opts.Generation)
			log.Error(msg)
			return fmt.Errorf("%v", msg)
		}

		log.Errorf("failed to access generation link: %v", err)
		return err
	}

	log.Step("Comparing changes...")

	err := generation.RunDiffCommand(log, s, constants.CurrentSystem, generationLink, &generation.DiffCommandOptions{
		UseNvd:  cfg.UseNvd,
		Verbose: opts.Verbose,
	})
	if err != nil {
		log.Errorf("failed to run diff command: %v", err)
	}

	if !opts.AlwaysConfirm {
		log.Printf("\n")
		confirm, err := cmdUtils.ConfirmationInput("Activate this generation?")
		if err != nil {
			log.Errorf("failed to get confirmation: %v", err)
			return err
		}
		if !confirm {
			msg := "confirmation was not given, skipping activation"
			log.Warn(msg)
			return fmt.Errorf("%v", msg)
		}
	}

	specialisation := opts.Specialisation
	if specialisation == "" {
		defaultSpecialisation, err := activation.FindDefaultSpecialisationFromConfig(generationLink)
		if err != nil {
			log.Warnf("unable to find default specialisation from config: %v", err)
		} else {
			specialisation = defaultSpecialisation
		}
	}

	if !activation.VerifySpecialisationExists(generationLink, specialisation) {
		log.Warnf("specialisation '%v' does not exist", specialisation)
		log.Warn("using base configuration without specialisations")
		specialisation = ""
	}

	previousGenNumber, err := activation.GetCurrentGenerationNumber(genOpts.ProfileName)
	if err != nil {
		log.Errorf("%v", err)
		return err
	}

	if !opts.Dry {
		log.Step("Setting system profile...")

		if err := activation.SetNixProfileGeneration(s, genOpts.ProfileName, uint64(opts.Generation), opts.Verbose); err != nil {
			log.Errorf("failed to set system profile: %v", err)
			return err
		}
	}

	// In case switch-to-configuration fails, rollback the profile.
	// This is to prevent accidental deletion of all working
	// generations in case the switch-to-configuration script
	// fails, since the active profile will not be rolled back
	// automatically.
	rollbackProfile := false
	if !opts.Dry {
		defer func(rollback *bool) {
			if !*rollback {
				return
			}

			if !cfg.AutoRollback {
				log.Warnf("automatic rollback is disabled, the currently active profile may have unresolved problems")
				log.Warnf("you are on your own!")
				return
			}

			log.Step("Rolling back system profile...")
			if err := activation.SetNixProfileGeneration(s, "system", previousGenNumber, opts.Verbose); err != nil {
				log.Errorf("failed to rollback system profile: %v", err)
				log.Info("make sure to rollback the system manually before deleting anything!")
			}
		}(&rollbackProfile)
	}

	log.Step("Activating...")

	var stcAction activation.SwitchToConfigurationAction = activation.SwitchToConfigurationActionSwitch
	if opts.Dry {
		stcAction = activation.SwitchToConfigurationActionDryActivate
	}

	err = activation.SwitchToConfiguration(s, generationLink, stcAction, &activation.SwitchToConfigurationOptions{
		Verbose:        opts.Verbose,
		Specialisation: specialisation,
	})
	if err != nil {
		rollbackProfile = true
		log.Errorf("failed to switch to configuration: %v", err)
		return err
	}

	return nil
}
</file>

<file path="cmd/generation/generation.go">
package generation

import (
	"fmt"

	"github.com/spf13/cobra"

	cmdOpts "github.com/nix-community/nixos-cli/internal/cmd/opts"
	cmdUtils "github.com/nix-community/nixos-cli/internal/cmd/utils"
	"github.com/nix-community/nixos-cli/internal/generation"
	"github.com/nix-community/nixos-cli/internal/logger"
	"github.com/nix-community/nixos-cli/internal/system"

	genDeleteCmd "github.com/nix-community/nixos-cli/cmd/generation/delete"
	genDiffCmd "github.com/nix-community/nixos-cli/cmd/generation/diff"
	genListCmd "github.com/nix-community/nixos-cli/cmd/generation/list"
	genRollbackCmd "github.com/nix-community/nixos-cli/cmd/generation/rollback"
	genSwitchCmd "github.com/nix-community/nixos-cli/cmd/generation/switch"
)

func GenerationCommand() *cobra.Command {
	opts := cmdOpts.GenerationOpts{}

	cmd := cobra.Command{
		Use:   "generation {command}",
		Short: "Manage NixOS generations",
		Long:  "Manage NixOS generations on this machine.",
		PersistentPreRunE: func(cmd *cobra.Command, args []string) error {
			log := logger.FromContext(cmd.Context())
			s := system.NewLocalSystem(log)

			if !s.IsNixOS() {
				return fmt.Errorf("generation commands can only be run on NixOS systems")
			}

			return nil
		},
	}

	cmd.PersistentFlags().StringVarP(&opts.ProfileName, "profile", "p", "system", "System profile to use")

	cmd.AddCommand(genDeleteCmd.GenerationDeleteCommand(&opts))
	cmd.AddCommand(genDiffCmd.GenerationDiffCommand(&opts))
	cmd.AddCommand(genListCmd.GenerationListCommand(&opts))
	cmd.AddCommand(genSwitchCmd.GenerationSwitchCommand(&opts))
	cmd.AddCommand(genRollbackCmd.GenerationRollbackCommand(&opts))

	cmdUtils.SetHelpFlagText(&cmd)

	_ = cmd.RegisterFlagCompletionFunc("profile", generation.CompleteProfileFlag)

	return &cmd
}
</file>

<file path="cmd/info/info.go">
package info

import (
	"encoding/json"
	"fmt"
	"strings"

	"github.com/fatih/color"
	"github.com/nix-community/nixos-cli/internal/activation"
	"github.com/nix-community/nixos-cli/internal/cmd/opts"
	"github.com/nix-community/nixos-cli/internal/cmd/utils"
	"github.com/nix-community/nixos-cli/internal/constants"
	"github.com/nix-community/nixos-cli/internal/generation"
	"github.com/nix-community/nixos-cli/internal/logger"
	"github.com/nix-community/nixos-cli/internal/system"
	"github.com/spf13/cobra"
)

func InfoCommand() *cobra.Command {
	opts := cmdOpts.InfoOpts{}

	cmd := cobra.Command{
		Use:   "info",
		Short: "Show info about the currently running generation",
		Long:  "Show information about the currently running NixOS generation.",
		RunE: func(cmd *cobra.Command, args []string) error {
			return cmdUtils.CommandErrorHandler(infoMain(cmd, &opts))
		},
	}

	cmdUtils.SetHelpFlagText(&cmd)

	cmd.Flags().BoolVarP(&opts.DisplayJson, "json", "j", false, "Format output as JSON")
	cmd.Flags().BoolVarP(&opts.DisplayMarkdown, "markdown", "m", false, "Format output as Markdown for reporting")

	return &cmd
}

const (
	markdownTemplate = `- nixos version: %v
- nixpkgs revision: %v
- kernel version: %v
`
)

func infoMain(cmd *cobra.Command, opts *cmdOpts.InfoOpts) error {
	log := logger.FromContext(cmd.Context())
	s := system.NewLocalSystem(log)

	if !s.IsNixOS() {
		msg := "the info command is only supported on NixOS systems"
		log.Errorf(msg)
		return fmt.Errorf("%v", msg)
	}

	// Only support the `system` profile for now.
	currentGenNumber, err := activation.GetCurrentGenerationNumber("system")
	if err != nil {
		log.Warnf("failed to determine current generation number: %v", err)
		return err
	}

	currentGen, err := generation.GenerationFromDirectory(constants.CurrentSystem, currentGenNumber)
	if err != nil {
		log.Warnf("failed to collect generations: %v", err)
		return err
	}
	currentGen.Number = currentGenNumber
	currentGen.IsCurrent = true

	if opts.DisplayJson {
		bytes, _ := json.MarshalIndent(currentGen, "", "  ")
		fmt.Printf("%v\n", string(bytes))
		return nil
	}

	if opts.DisplayMarkdown {
		fmt.Printf(markdownTemplate, currentGen.NixosVersion, currentGen.NixpkgsRevision, currentGen.KernelVersion)
		return nil
	}

	prettyPrintGenInfo(currentGen)

	return nil
}

var titleColor = color.New(color.Bold, color.Italic)

func prettyPrintGenInfo(g *generation.Generation) {
	version := g.NixosVersion
	if version == "" {
		version = "NixOS (unknown version)"
	}

	_, _ = titleColor.Printf("%v\n", version)
	_, _ = titleColor.Println(strings.Repeat("-", len(version)))

	printKey("Generation")
	fmt.Println(g.Number)

	printKey("Description")
	desc := g.Description
	if desc == "" {
		desc = color.New(color.Italic).Sprint("(none)")
	}
	fmt.Println(desc)

	printKey("Nixpkgs Version")
	nixpkgsVersion := g.NixpkgsRevision
	if nixpkgsVersion == "" {
		nixpkgsVersion = color.New(color.Italic).Sprint("(unknown)")
	}
	fmt.Println(nixpkgsVersion)

	printKey("Config Version")
	configVersion := g.ConfigurationRevision
	if configVersion == "" {
		configVersion = color.New(color.Italic).Sprint("(unknown)")
	}
	fmt.Println(configVersion)

	printKey("Kernel Version")
	kernelVersion := g.KernelVersion
	if kernelVersion == "" {
		kernelVersion = color.New(color.Italic).Sprint("(unknown)")
	}
	fmt.Println(kernelVersion)

	printKey("Specialisations")
	specialisations := strings.Join(g.Specialisations, ", ")
	if specialisations == "" {
		specialisations = color.New(color.Italic).Sprint("(none)")
	}
	fmt.Println(specialisations)
}

func getKeyMaxLength() int {
	strings := []string{
		"Generation", "Description", "NixOS Version", "Nixpkgs Version",
		"Config Version", "Kernel Version", "Specialisations",
	}

	maxLength := 0

	for _, v := range strings {
		l := len(color.CyanString(v))
		if l > maxLength {
			maxLength = l
		}
	}

	return maxLength
}

func printKey(key string) {
	fmt.Printf("%-"+fmt.Sprintf("%v", keyMaxLength)+"v :: ", color.CyanString(key))
}

var keyMaxLength = getKeyMaxLength()
</file>

<file path="cmd/init/configuration.nix.txt">
# Edit this configuration file to define what should be installed on
# your system. Help is available in the configuration.nix(5) man page, on
# https://search.nixos.org/options and in the NixOS manual (`nixos-help`).

{
  config,
  lib,
  pkgs,
  ...
}: {
  imports = [
    # Include the results of the hardware scan.
    ./hardware-configuration.nix
  ];

  # Bootloader config
%s
  # networking.hostName = "nixos"; # Define your hostname.
  # Pick only one of the below networking options.
  # networking.wireless.enable = true;  # Enables wireless support via wpa_supplicant.
  # networking.networkmanager.enable = true;  # Easiest to use and most distros use this by default.

  # Set your time zone.
  # time.timeZone = "Europe/Amsterdam";

  # Configure network proxy if necessary
  # networking.proxy.default = "http://user:password\@proxy:port/";
  # networking.proxy.noProxy = "127.0.0.1,localhost,internal.domain";

  # Select internationalisation properties.
  # i18n.defaultLocale = "en_US.UTF-8";
  # console = {
  #   font = "Lat2-Terminus16";
  #   keyMap = "us";
  #   useXkbConfig = true; # use xkb.options in tty.
  # };

%s
  # Configure keymap in X11
  # services.xserver.xkb.layout = "us";
  # services.xserver.xkb.options = "eurosign:e,caps:escape";

  # Desktop configuration
%s
  # Enable CUPS to print documents.
  # services.printing.enable = true;

  # Enable sound.
  # sound.enable = true;
  # hardware.pulseaudio.enable = true;

  # Enable touchpad support (enabled default in most desktop managers).
  # services.xserver.libinput.enable = true;

  # Define a user account. Don't forget to set a password with `passwd`.
  # Or, if you don't want users to set a password imperatively, set
  # `users.mutableUsers` to false and specify password using the
  # `users.passwordFile` or `users.hashedPassword` options.
  # users.users.alice = {
  #   isNormalUser = true;
  #   extraGroups = ["wheel"]; # Enable ‘sudo’ for the user.
  #   packages = with pkgs; [
  #     firefox
  #     tree
  #   ];
  # };

  # List packages installed in system profile. To search, run:
  # $ nix search wget
  # environment.systemPackages = with pkgs; [
  #   vim # Do not forget to add an editor to edit configuration.nix! The Nano editor is also installed by default.
  #   wget
  # ];

  # Some programs need SUID wrappers, can be configured further or are
  # started in user sessions.
  # programs.mtr.enable = true;
  # programs.gnupg.agent = {
  #   enable = true;
  #   enableSSHSupport = true;
  # };

  # List services that you want to enable:

  # Enable the OpenSSH daemon.
  # services.openssh.enable = true;

  # Open ports in the firewall.
  # networking.firewall.allowedTCPPorts = [ ... ];
  # networking.firewall.allowedUDPPorts = [ ... ];
  # Or disable the firewall altogether.
  # networking.firewall.enable = false;
%s
  # Copy the NixOS configuration file and link it from the resulting system
  # (/run/current-system/configuration.nix). This is useful in case you
  # accidentally delete configuration.nix.
  # system.copySystemConfiguration = true;

  # This option defines the first version of NixOS you have installed on this particular machine,
  # and is used to maintain compatibility with application data (e.g. databases) created on older NixOS versions.
  #
  # Most users should NEVER change this value after the initial install, for any reason,
  # even if you've upgraded your system to a new NixOS release.
  #
  # This value does NOT affect the Nixpkgs version your packages and OS are pulled from,
  # so changing it will NOT upgrade your system.
  #
  # This value being lower than the current NixOS release does NOT mean your system is
  # out of date, out of support, or vulnerable.
  #
  # Do NOT change this value unless you have manually inspected all the changes it would make to your configuration,
  # and migrated your data accordingly.
  #
  # For more information, see `man configuration.nix` or https://nixos.org/manual/nixos/stable/options#opt-system.stateVersion .
  system.stateVersion = "%s"; # Did you read the comment?
}
</file>

<file path="cmd/init/cpuinfo.go">
//go:build linux

package init

import (
	"bufio"
	"bytes"
	"os"
	"strings"

	"github.com/nix-community/nixos-cli/internal/logger"
	"github.com/nix-community/nixos-cli/internal/system"
)

type CPUInfo struct {
	VirtualisationEnabled bool
	Manufacturer          CPUManufacturer
}

type CPUManufacturer int

const (
	manufacturerIntel CPUManufacturer = iota
	manufacturerAMD
	manufacturerUnknown
)

func (c CPUManufacturer) CPUType() string {
	switch c {
	case manufacturerIntel:
		return "Intel"
	case manufacturerAMD:
		return "AMD"
	default:
		return "unknown"
	}
}

func getCPUInfo(log *logger.Logger) *CPUInfo {
	result := &CPUInfo{
		VirtualisationEnabled: false,
		Manufacturer:          manufacturerUnknown,
	}

	cpuinfoFile, err := os.Open("/proc/cpuinfo")
	if err != nil {
		log.Warnf("failed to open /proc/cpuinfo: %v", err)
		return result
	}

	defer func() { _ = cpuinfoFile.Close() }()

	s := bufio.NewScanner(cpuinfoFile)
	s.Split(bufio.ScanLines)

	for s.Scan() {
		line := s.Text()
		if strings.HasPrefix(line, "flags") {
			if strings.Contains(line, "vmx") || strings.Contains(line, "svm") {
				result.VirtualisationEnabled = true
			}
		} else if strings.HasPrefix(line, "vendor_id") {
			if strings.Contains(line, "GenuineIntel") {
				result.Manufacturer = manufacturerIntel
			} else if strings.Contains(line, "AuthenticAMD") {
				result.Manufacturer = manufacturerAMD
			}
		}
	}

	return result
}

type VirtualisationType int

const (
	VirtualisationTypeNone VirtualisationType = iota
	VirtualisationTypeOracle
	VirtualisationTypeParallels
	VirtualisationTypeQemu
	VirtualisationTypeKVM
	VirtualisationTypeBochs
	VirtualisationTypeHyperV
	VirtualisationTypeSystemdNspawn
	VirtualisationTypeUnknown
)

func (v VirtualisationType) String() string {
	switch v {
	case VirtualisationTypeOracle:
		return "Oracle"
	case VirtualisationTypeParallels:
		return "Parallels"
	case VirtualisationTypeQemu:
		return "QEMU"
	case VirtualisationTypeKVM:
		return "KVM"
	case VirtualisationTypeBochs:
		return "Bochs"
	case VirtualisationTypeHyperV:
		return "Hyper-V"
	case VirtualisationTypeSystemdNspawn:
		return "systemd-nspawn"
	case VirtualisationTypeNone:
		return "none"
	default:
		return "unknown"
	}
}

func determineVirtualisationType(s system.CommandRunner, log *logger.Logger) VirtualisationType {
	cmd := system.NewCommand("systemd-detect-virt")

	var stdout bytes.Buffer
	cmd.Stdout = &stdout

	_, err := s.Run(cmd)
	virtType := strings.TrimSpace(stdout.String())

	if err != nil {
		// Because yes, this fails with exit status 1. Stupid.
		if virtType == "none" {
			return VirtualisationTypeNone
		}

		log.Warnf("failed to run systemd-detect-virt: %v", err)
		return VirtualisationTypeUnknown
	}

	switch virtType {
	case "oracle":
		return VirtualisationTypeOracle
	case "parallels":
		return VirtualisationTypeParallels
	case "qemu":
		return VirtualisationTypeQemu
	case "kvm":
		return VirtualisationTypeKVM
	case "bochs":
		return VirtualisationTypeBochs
	case "microsoft":
		return VirtualisationTypeHyperV
	case "systemd-nspawn":
		return VirtualisationTypeSystemdNspawn
	default:
		log.Warnf("unknown virtualisation type: %v", virtType)
		return VirtualisationTypeUnknown
	}
}
</file>

<file path="cmd/init/devices.go">
//go:build linux

package init

import (
	"net"
	"os"
	"path/filepath"
	"strings"

	"github.com/nix-community/nixos-cli/internal/logger"
)

const (
	pciDeviceDirname     = "/sys/bus/pci/devices"
	usbDeviceDirname     = "/sys/bus/usb/devices"
	blockDeviceDirname   = "/sys/class/block"
	mmcDeviceDirname     = "/sys/class/mmc_host"
	networkDeviceDirname = "/sys/class/net"
)

var (
	// Device numbers that use the Broadcom STA driver (wl.ko)
	broadcomStaDevices = []string{
		"0x4311", "0x4312", "0x4313", "0x4315",
		"0x4327", "0x4328", "0x4329", "0x432a",
		"0x432b", "0x432c", "0x432d", "0x4353",
		"0x4357", "0x4358", "0x4359", "0x4331",
		"0x43a0", "0x43b1",
	}
	//
	broadcomFullmacDevices = []string{
		"0x43a3", "0x43df", "0x43ec", "0x43d3",
		"0x43d9", "0x43e9", "0x43ba", "0x43bb",
		"0x43bc", "0xaa52", "0x43ca", "0x43cb",
		"0x43cc", "0x43c3", "0x43c4", "0x43c5",
	}
	virtioScsiDevices  = []string{"0x1004", "0x1048"}
	intel2200bgDevices = []string{
		"0x1043", "0x104f", "0x4220",
		"0x4221", "0x4223", "0x4224",
	}
	intel3945abgDevices = []string{
		"0x4229", "0x4230", "0x4222", "0x4227",
	}
)

func findPCIDevices(h *hardwareConfigSettings, log *logger.Logger) {
	entries, err := os.ReadDir(pciDeviceDirname)
	if err != nil {
		log.Warnf("failed to read %v: %v", pciDeviceDirname, err)
		return
	}

findDevices:
	for _, entry := range entries {
		devicePath := filepath.Join(pciDeviceDirname, entry.Name())

		vendorFilename := filepath.Join(devicePath, "vendor")
		deviceFilename := filepath.Join(devicePath, "device")
		classFilename := filepath.Join(devicePath, "class")

		vendorContents, _ := os.ReadFile(vendorFilename)
		deviceContents, _ := os.ReadFile(deviceFilename)
		classContents, _ := os.ReadFile(classFilename)

		vendor := strings.TrimSpace(string(vendorContents))
		device := strings.TrimSpace(string(deviceContents))
		class := strings.TrimSpace(string(classContents))

		requiredModuleName := findModuleName(devicePath)
		if requiredModuleName != "" {
			// Add mass storage controllers, Firewire controllers, or USB controllers
			// (respectively) to the initrd modules list.
			if strings.HasPrefix(class, "0x01") || strings.HasPrefix(class, "0x02") || strings.HasPrefix(class, "0x0c03") {
				*h.InitrdAvailableModules = append(*h.InitrdAvailableModules, requiredModuleName)
			}
		}

		if vendor == "0x14e4" {
			// Broadcom devices
			for _, d := range broadcomStaDevices {
				if d == device {
					*h.ModulePackages = append(*h.ModulePackages, "config.boot.kernelPackages.broadcom_sta")
					*h.KernelModules = append(*h.KernelModules, "wl")
					continue findDevices
				}
			}

			for _, d := range broadcomFullmacDevices {
				if d == device {
					*h.ModulePackages = append(*h.ModulePackages, `(modulesPath + "/hardware/network/broadcom-43xx.nix")`)
					continue findDevices
				}
			}
		} else if vendor == "0x1af4" {
			// VirtIO SCSI devices
			for _, d := range virtioScsiDevices {
				if d == device {
					*h.InitrdAvailableModules = append(*h.InitrdAvailableModules, "virtio_scsi")
					continue findDevices
				}
			}
		} else if vendor == "0x8086" {
			// Intel devices
			for _, d := range intel2200bgDevices {
				if d == device {
					*h.Attrs = append(*h.Attrs, KVPair{Key: "networking.enableIntel2200BGFirmware", Value: "true"})
					continue findDevices
				}
			}

			for _, d := range intel3945abgDevices {
				if d == device {
					*h.Attrs = append(*h.Attrs, KVPair{Key: "networking.enableIntel3945ABGFirmware", Value: "true"})
					continue findDevices
				}
			}
		}
	}
}

func findUSBDevices(h *hardwareConfigSettings, log *logger.Logger) {
	entries, err := os.ReadDir(usbDeviceDirname)
	if err != nil {
		log.Warnf("failed to read %s: %v", usbDeviceDirname, err)
		return
	}

	for _, entry := range entries {
		devicePath := filepath.Join(usbDeviceDirname, entry.Name())

		classFilename := filepath.Join(devicePath, "bInterfaceClass")
		protocolFilename := filepath.Join(devicePath, "bInterfaceProtocol")

		classContents, _ := os.ReadFile(classFilename)
		protocolContents, _ := os.ReadFile(protocolFilename)

		class := strings.TrimSpace(string(classContents))
		protocol := strings.TrimSpace(string(protocolContents))

		moduleName := findModuleName(devicePath)

		// Add modules for USB mass storage controllers (first condition) or keyboards (second condition)
		if strings.HasPrefix(class, "08") || (strings.HasPrefix(class, "03") && strings.HasPrefix(protocol, "01")) {
			*h.InitrdAvailableModules = append(*h.InitrdAvailableModules, moduleName)
		}
	}
}

func findGenericDevicesInDir(h *hardwareConfigSettings, log *logger.Logger, deviceDirname string) {
	entries, err := os.ReadDir(deviceDirname)
	if err != nil {
		log.Warnf("failed to read %v: %v", deviceDirname, err)
		return
	}

	for _, entry := range entries {
		devicePath := filepath.Join(blockDeviceDirname, entry.Name(), "device")

		moduleName := findModuleName(devicePath)
		if moduleName != "" {
			*h.InitrdAvailableModules = append(*h.InitrdAvailableModules, moduleName)
		}
	}
}

func detectNetworkInterfaces() []string {
	detectedInterfaces := []string{}

	interfaces, _ := net.Interfaces()
	for _, i := range interfaces {
		// Skip loopback interfaces
		if !strings.HasPrefix(i.Name, "lo") {
			detectedInterfaces = append(detectedInterfaces, i.Name)
		}
	}

	return detectedInterfaces
}

func findModuleName(devicePath string) string {
	moduleFilename := filepath.Join(devicePath, "driver", "module")
	if _, err := os.Stat(moduleFilename); err != nil {
		return ""
	}

	realFilename, err := os.Readlink(moduleFilename)
	if err != nil {
		return ""
	}

	return filepath.Base(realFilename)
}
</file>

<file path="cmd/init/filesystems.go">
//go:build linux

package init

import (
	"bufio"
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"slices"
	"strings"
	"syscall"

	"github.com/nix-community/nixos-cli/internal/logger"
	"github.com/nix-community/nixos-cli/internal/system"
)

const (
	swapDeviceListFilename        = "/proc/swaps"
	mountedFilesystemListFilename = "/proc/self/mountinfo"
)

type Filesystem struct {
	Mountpoint      string
	DevicePath      string
	FSType          string
	Options         []string
	LUKSInformation *LUKSInformation
}

type LUKSInformation struct {
	Name       string
	DevicePath string
}

func findSwapDevices(log *logger.Logger) []string {
	swapDevices := []string{}

	swapDeviceList, err := os.Open(swapDeviceListFilename)
	if err != nil {
		log.Warnf("failed to open swap device list %v: %v", swapDeviceListFilename, err)
		return swapDevices
	}
	defer func() { _ = swapDeviceList.Close() }()

	s := bufio.NewScanner(swapDeviceList)
	s.Split(bufio.ScanLines)

	_ = s.Scan() // Skip header line

	for s.Scan() {
		fields := strings.Fields(s.Text())
		swapFilename := fields[0]
		swapType := fields[1]

		switch swapType {
		case "partition":
			swapDevices = append(swapDevices, findStableDevPath(swapFilename))
		case "file":
			log.Infof("skipping swap file %v, specify in configuration manually if needed", swapFilename)
		default:
			log.Warnf("unsupported swap type %v for %v; do not specify in configuration", swapType, swapFilename)
		}
	}

	return swapDevices
}

func findFilesystems(log *logger.Logger, rootDir string) []Filesystem {
	filesystems := []Filesystem{}

	foundFileystems := make(map[string]string, 0)
	foundLuksDevices := make(map[string]struct{}, 0)

	mountList, err := os.Open(mountedFilesystemListFilename)
	if err != nil {
		log.Warnf("failed to open swap device list %v: %v", mountedFilesystemListFilename, err)
		return filesystems
	}
	defer func() { _ = mountList.Close() }()

	s := bufio.NewScanner(mountList)
	s.Split(bufio.ScanLines)

	for s.Scan() {
		fields := strings.Fields(s.Text())

		mountID := fields[2]
		path := fields[3]
		if path == "/" {
			path = ""
		}

		absoluteMountpoint := strings.ReplaceAll(fields[4], "\\040", "")

		if stat, err := os.Stat(absoluteMountpoint); err != nil || !stat.IsDir() {
			continue
		}

		if !isSubdir(absoluteMountpoint, rootDir) {
			continue
		}

		var mountpoint string
		if absoluteMountpoint == rootDir {
			mountpoint = "/"
		} else {
			mountpoint = absoluteMountpoint[len(rootDir):]
		}

		mountOptions := strings.Split(fields[5], ",")

		if isSubdir(mountpoint, "/proc") || isSubdir(mountpoint, "/sys") || isSubdir(mountpoint, "/dev") || isSubdir(mountpoint, "/run") {
			continue
		} else if mountpoint == "/var/lib/nfs/rpc_pipefs" {
			continue
		}

		// Skip irrelevant fields
		n := 6
		for ; n < len(fields); n++ {
			if fields[n] == "-" {
				n++
				break
			}
		}

		// Sanity check. If the mount entry is malformed, we should not attempt
		// to access the rest of the fields, lest we risk an OOB.
		if n > len(fields)-3 {
			log.Warnf("malformed mount entry: %v", s.Text())
			continue
		}

		fsType := fields[n]

		devicePath := fields[n+1]
		devicePath = strings.ReplaceAll(devicePath, "\\040", "")
		devicePath = strings.ReplaceAll(devicePath, "\\011", "\t")

		superblockOptions := strings.Split(fields[n+2], ",")

		// Skip read-only Nix store bind mount
		if mountpoint == "/nix/store" && slices.Contains(superblockOptions, "rw") && slices.Contains(mountOptions, "ro") {
			continue
		}

		if fsType == "fuse" || fsType == "fuseblk" {
			log.Warnf("don't know how to emit `fileSystem` option for FUSE filesystem '%v'", mountpoint)
			continue
		}

		if mountpoint == "/tmp" && fsType == "tmpfs" {
			continue
		}

		if existingFsPath, ok := foundFileystems[mountID]; ok {
			// TODO: check if filesystem is a btrfs subvolume

			filesystems = append(filesystems, Filesystem{
				Mountpoint: mountpoint,
				DevicePath: filepath.Join(existingFsPath, path),
				FSType:     fsType,
				Options:    []string{"bind"},
			})

			continue
		}

		foundFileystems[mountID] = path

		extraOptions := []string{}

		if strings.HasPrefix(devicePath, "/dev/loop") {
			startIndex := len("/dev/loop")
			endIndex := strings.Index(devicePath[startIndex:], "/")
			if endIndex == -1 {
				endIndex = len(devicePath)
			}
			loopNumber := devicePath[startIndex:endIndex]

			backerFilename := fmt.Sprintf("/sys/block/loop%s/loop/backing_file", loopNumber)

			if backer, err := os.ReadFile(backerFilename); err == nil {
				devicePath = string(backer)
				extraOptions = append(extraOptions, "loop")
			}
		}

		// Preserve umask for FAT filesystems in order to preserve
		// EFI system partition security.
		if fsType == "vfat" {
			for _, o := range superblockOptions {
				if o == "fmask" || o == "dmask" {
					extraOptions = append(extraOptions, o)
				}
			}
		}

		// TODO: check if filesystem is a btrfs subvolume

		// TODO: check if Stratis pool

		filesystemToAdd := Filesystem{
			Mountpoint: mountpoint,
			DevicePath: findStableDevPath(devicePath),
			FSType:     fsType,
			Options:    extraOptions,
		}

		deviceName := filepath.Base(devicePath)
		filesystemToAdd.LUKSInformation = queryLUKSInformation(deviceName, foundLuksDevices)

		filesystems = append(filesystems, filesystemToAdd)

	}

	return filesystems
}

func lvmDevicesExist(s system.CommandRunner, log *logger.Logger) bool {
	cmd := system.NewCommand("lsblk", "-o", "TYPE")

	var stdout bytes.Buffer
	cmd.Stdout = &stdout

	_, err := s.Run(cmd)
	if err != nil {
		log.Warnf("failed to run lsblk: %v", err)
		return false
	}

	// There should probably be a better metric than just checking if the
	// string "lvm" exists inside `lsblk` output, but meh. This is a rough
	// heuristic that somewhat works unless device labels end up having "lvm"
	// in them.
	return strings.Contains(stdout.String(), "lvm")
}

func bcachefsFilesystemsExist(log *logger.Logger) bool {
	entries, err := os.ReadDir("/dev")
	if err != nil {
		log.Warnf("failed to read /dev: %v", err)
		return false
	}

	for _, entry := range entries {
		if strings.HasPrefix(entry.Name(), "bcache") {
			return true
		}
	}

	return false
}

func findStableDevPath(devicePath string) string {
	if !filepath.IsAbs(devicePath) {
		return devicePath
	}

	rdev, err := getRdev(devicePath)
	if err != nil {
		return devicePath
	}

	directoriesToCheck := []string{
		"/dev/disk/by-uuid",
		"/dev/mapper",
		"/dev/disk/by-label",
	}

	for _, directory := range directoriesToCheck {
		if stablePath, ok := checkDirForEqualDevice(rdev, directory); ok {
			return stablePath
		}
	}

	return devicePath
}

func getRdev(devicePath string) (uint64, error) {
	stat, err := os.Stat(devicePath)
	if err != nil {
		return 0, err
	}
	sysStat := stat.Sys()
	if sysStat == nil {
		return 0, err
	}
	devStat, ok := sysStat.(*syscall.Stat_t)
	if !ok {
		return 0, err
	}

	return devStat.Rdev, nil
}

func checkDirForEqualDevice(deviceRdev uint64, dirname string) (string, bool) {
	entries, err := os.ReadDir(dirname)
	if err != nil {
		return "", false
	}

	for _, entry := range entries {
		devicePath := filepath.Join(dirname, entry.Name())
		rdev, err := getRdev(devicePath)
		if err != nil {
			continue
		}

		if rdev == deviceRdev {
			return devicePath, true
		}
	}

	return "", false
}

func isSubdir(subdir string, dir string) bool {
	if len(dir) == 0 || dir == "/" {
		return true
	}

	if dir == subdir {
		return true
	}

	if len(subdir) <= len(dir)+1 {
		return false
	}

	return strings.Index(subdir, dir) == 0 && subdir[len(dir)] == '/'
}

func queryLUKSInformation(deviceName string, foundLuksDevices map[string]struct{}) *LUKSInformation {
	// Check if the device in question is a LUKS device.
	uuidFilename := fmt.Sprintf("/sys/class/block/%s/dm/uuid", deviceName)
	uuidFileContents, err := os.ReadFile(uuidFilename)
	if err != nil {
		return nil
	}
	if !strings.HasPrefix(string(uuidFileContents), "CRYPT_LUKS") {
		return nil
	}

	// Then, make sure it has a single slave device. These are the only types of
	// supported LUKS devices for filesystem generation.
	slaveDeviceDirname := fmt.Sprintf("/sys/class/block/%s/slaves", deviceName)
	slaveDeviceEntries, err := os.ReadDir(slaveDeviceDirname)
	if err != nil {
		return nil
	}

	if len(slaveDeviceEntries) != 1 {
		return nil
	}

	// Get the real name of the device that LUKS is using, and attempt to find
	// a stable device path for it.
	slaveName := slaveDeviceEntries[0].Name()
	slaveDeviceName := filepath.Join("/dev", slaveName)
	dmNameFilename := fmt.Sprintf("/sys/class/block/%s/dm/name", slaveDeviceName)

	dmNameFileContents, err := os.ReadFile(dmNameFilename)
	if err != nil {
		return nil
	}
	dmName := strings.TrimSpace(string(dmNameFileContents))

	realDevicePath := findStableDevPath(dmName)

	// Check if the device has already been found.
	if _, ok := foundLuksDevices[dmName]; ok {
		return nil
	}
	foundLuksDevices[dmName] = struct{}{}

	return &LUKSInformation{
		Name:       dmName,
		DevicePath: realDevicePath,
	}
}
</file>

<file path="cmd/init/flake.nix.txt">
{
  description = "A basic NixOS configuration";

  inputs = {
    %s
  };

  outputs = {nixpkgs, ...}: {
    # Change `my-nixos` to your desired hostname or machine name.
    nixosConfigurations.my-nixos = nixpkgs.lib.nixosSystem {
      modules = [
        ./configuration.nix
      ];
    };
  };
}
</file>

<file path="cmd/init/generate.go">
//go:build linux

package init

import (
	"bytes"
	_ "embed"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/nix-community/nixos-cli/internal/build"
	"github.com/nix-community/nixos-cli/internal/cmd/opts"
	"github.com/nix-community/nixos-cli/internal/logger"
	"github.com/nix-community/nixos-cli/internal/settings"
	"github.com/nix-community/nixos-cli/internal/system"
)

//go:embed hardware_configuration.nix.txt
var hardwareConfigurationNixTemplate string

//go:embed configuration.nix.txt
var configurationNixTemplate string

//go:embed flake.nix.txt
var flakeNixTemplate string

func generateHwConfigNix(s system.CommandRunner, log *logger.Logger, cfg *settings.Settings, virtType VirtualisationType, opts *cmdOpts.InitOpts) (string, error) {
	imports := []string{}
	initrdAvailableModules := []string{}
	initrdModules := []string{}
	kernelModules := []string{}
	modulePackages := []string{}
	extraAttrs := []KVPair{}

	for k, v := range cfg.Init.ExtraAttrs {
		extraAttrs = append(extraAttrs, KVPair{Key: k, Value: v})
	}

	hwConfigSettings := hardwareConfigSettings{
		Imports:                &imports,
		InitrdAvailableModules: &initrdAvailableModules,
		InitrdModules:          &initrdModules,
		KernelModules:          &kernelModules,
		ModulePackages:         &modulePackages,
		Attrs:                  &extraAttrs,
	}

	if cfg.Init.ExtraAttrs != nil {
		for k, v := range cfg.Init.ExtraAttrs {
			extraAttrs = append(extraAttrs, KVPair{Key: k, Value: v})
		}
	}

	log.Infof("determining host platform")
	hostPlatform, err := determineHostPlatform(s)
	if err != nil {
		log.Warnf("failed to determine host platform: %v", err)
		log.Info("fill in the `nixpkgs.hostPlatform` attribute in your hardware-configuration.nix before continuing installation")
	} else {
		log.Infof("host platform: %v", hostPlatform)
		extraAttrs = append(extraAttrs, KVPair{Key: "nixpkgs.hostPlatform", Value: hostPlatform})
	}

	cpuInfo := getCPUInfo(log)

	log.Infof("detected CPU type: %v", cpuInfo.Manufacturer.CPUType())
	log.Infof("KVM virtualisation enabled: %v", cpuInfo.VirtualisationEnabled)
	log.Infof("virtualisation type of current host: %v", virtType)

	// Add KVM modules if need be.
	if cpuInfo.VirtualisationEnabled {
		switch cpuInfo.Manufacturer {
		case manufacturerIntel:
			kernelModules = append(kernelModules, "kvm-intel")
		case manufacturerAMD:
			kernelModules = append(kernelModules, "kvm-amd")
		}
	}

	switch virtType {
	case VirtualisationTypeOracle:
		extraAttrs = append(extraAttrs, KVPair{Key: "virtualisation.virtualbox.guest.enable", Value: "true"})
	case VirtualisationTypeParallels:
		extraAttrs = append(extraAttrs, KVPair{Key: "hardware.parallels.enable", Value: "true"})
		extraAttrs = append(extraAttrs, KVPair{Key: "nixpkgs.config.allowUnfreePredicate", Value: `pkg: builtins.elem (lib.getName pkg [ "prl-tools" ])`})
	case VirtualisationTypeQemu, VirtualisationTypeKVM, VirtualisationTypeBochs:
		imports = append(imports, `(modulesPath + "/profiles/qemu-guest.nix")`)
	case VirtualisationTypeHyperV:
		extraAttrs = append(extraAttrs, KVPair{Key: "virtualisation.hypervGuest.enable", Value: "true"})
	case VirtualisationTypeSystemdNspawn:
		extraAttrs = append(extraAttrs, KVPair{Key: "boot.isContainer", Value: "true"})
	case VirtualisationTypeNone:
		imports = append(imports, `(modulesPath + "/installer/scan/not-detected.nix")`)
		switch cpuInfo.Manufacturer {
		case manufacturerIntel:
			extraAttrs = append(extraAttrs, KVPair{Key: "hardware.cpu.intel.updateMicrocode", Value: "lib.mkDefault config.hardware.enableRedistributableFirmware"})
		case manufacturerAMD:
			extraAttrs = append(extraAttrs, KVPair{Key: "hardware.cpu.amd.updateMicrocode", Value: "lib.mkDefault config.hardware.enableRedistributableFirmware"})
		}
	}

	findPCIDevices(&hwConfigSettings, log)
	findUSBDevices(&hwConfigSettings, log)

	findGenericDevicesInDir(&hwConfigSettings, log, blockDeviceDirname)
	findGenericDevicesInDir(&hwConfigSettings, log, mmcDeviceDirname)

	networkInterfaces := detectNetworkInterfaces()
	networkInterfaceLines := []string{}
	for _, i := range networkInterfaces {
		networkInterfaceLines = append(networkInterfaceLines, fmt.Sprintf("  # networking.interfaces.%v.useDHCP = lib.mkDefault true;", i))
	}

	if lvmDevicesExist(s, log) {
		initrdModules = append(initrdModules, "dm-snapshot")
	}

	if bcachefsFilesystemsExist(log) {
		initrdAvailableModules = append(initrdAvailableModules, "bcache")
	}

	swapDevices := findSwapDevices(log)
	swapDeviceStrings := make([]string, len(swapDevices))
	for i, d := range swapDevices {
		swapDeviceStrings[i] = fmt.Sprintf(`{device = "%s";}`, d)
	}
	swapDevicesStr := fmt.Sprintf(`  swapDevices = [
    %v
  ];`, strings.Join(swapDeviceStrings, "\n    "))

	extraAttrLines := make([]string, len(extraAttrs))
	for i, attr := range extraAttrs {
		extraAttrLines[i] = fmt.Sprintf("  %v = %v;", attr.Key, attr.Value)
	}

	rootDirectory, err := filepath.EvalSymlinks(opts.Root)
	if err != nil {
		log.Errorf("failed to resolve root directory: %v", err)
		return "", err
	}
	if rootDirectory == "/" {
		rootDirectory = ""
	}

	var filesystems []Filesystem
	if opts.NoFSGeneration {
		filesystems = []Filesystem{}
	} else {
		filesystems = findFilesystems(log, rootDirectory)
	}

	fsStrB := strings.Builder{}
	for _, fs := range filesystems {
		_, _ = fsStrB.WriteString(generateFilesystemAttrset(&fs))
		_, _ = fsStrB.WriteString("\n")
	}

	return fmt.Sprintf(
		hardwareConfigurationNixTemplate,
		strings.Join(imports, "\n    "),
		nixStringList(initrdAvailableModules),
		nixStringList(initrdModules),
		nixStringList(kernelModules),
		strings.Join(modulePackages, " "),
		fsStrB.String(),
		swapDevicesStr,
		strings.Join(networkInterfaceLines, "\n")+"\n",
		strings.Join(extraAttrLines, "\n"),
	), nil
}

func generateConfigNix(log *logger.Logger, cfg *settings.Settings, virtType VirtualisationType) (string, error) {
	var bootloaderConfig string

	if _, err := os.Stat("/sys/firmware/efi/efivars"); err == nil {
		log.Info("EFI system detected, using systemd-boot for bootloader")

		bootloaderConfig = `  # Use the systemd-boot EFI bootloader.
  boot.loader.systemd-boot.enable = true;
  boot.loader.efi.canTouchEfiVariables = true;
`
	} else if _, err := os.Stat("/boot/extlinux"); err == nil {
		log.Info("extlinux bootloader detected, using generic-extlinux-compatible bootloader")

		bootloaderConfig = `  # Use the extlinux bootloader.
  boot.loader.generic-extlinux-compatible.enable = true;
  # Disable GRUB, because NixOS enables it by default.
  boot.loader.grub.enable = false
`
	} else if virtType != VirtualisationTypeSystemdNspawn {
		log.Info("using GRUB2 for bootloader")

		bootloaderConfig = `  # Use the GRUB 2 bootloader.
  boot.loader.grub.enable = true;
  # boot.loader.grub.efiSupport = true;
  # boot.loader.grub.efiInstallAsRemovable = true;
  # boot.loader.efi.efiSysMountPoint = "/boot/efi";
  # Define on which hard drive you want to install GRUB2.
  # boot.loader.grub.device = "/dev/sda"; # or "nodev" for EFI systems
`
	} else {
		log.Info("container system (systemd-nspawn) detected, no bootloader is required")
	}

	var xserverConfig string
	if cfg.Init.EnableXserver {
		xserverConfig = `  # Enable the X11 windowing system.
  services.xserver.enable = true;
`
	} else {
		xserverConfig = `  # Enable the X11 windowing system.
  # services.xserver.enable = true;
`
	}

	stateVersion, _ := getNixpkgsVersion()

	return fmt.Sprintf(
		configurationNixTemplate,
		bootloaderConfig,
		xserverConfig,
		cfg.Init.DesktopConfig,
		cfg.Init.ExtraConfig,
		stateVersion,
	), nil
}

// A heuristic for determining if the version actually exists, or
// if a future `nixpkgs` version like nixos-unstable is being used.
// If this is the case, bail.
func getNixpkgsVersion() (string, error) {
	version := build.NixpkgsVersion()

	timeOfRelease, err := time.Parse("06.01", version)
	if err != nil {
		return "", err
	}

	if timeOfRelease.After(time.Now()) {
		return "", fmt.Errorf("release %v does not exist yet", version)
	}

	return version, nil
}

func generateFlakeNix() string {
	var branchName string

	if version, err := getNixpkgsVersion(); err == nil {
		branchName = fmt.Sprintf("release-%v", version)
	} else {
		branchName = "nixos-unstable"
	}

	nixpkgsInputLine := fmt.Sprintf(`nixpkgs.url = "github:NixOS/nixpkgs/%s";`, branchName)
	return fmt.Sprintf(flakeNixTemplate, nixpkgsInputLine)
}

type KVPair struct {
	Key   string
	Value string
}

type hardwareConfigSettings struct {
	Imports                *[]string
	InitrdAvailableModules *[]string
	InitrdModules          *[]string
	KernelModules          *[]string
	ModulePackages         *[]string
	Attrs                  *[]KVPair
}

func determineHostPlatform(s system.CommandRunner) (string, error) {
	cmd := system.NewCommand("nix-instantiate", "--eval", "--expr", "builtins.currentSystem")

	var stdout bytes.Buffer
	cmd.Stdout = &stdout

	_, err := s.Run(cmd)
	if err != nil {
		return "", err
	}

	return strings.TrimSpace(stdout.String()), nil
}

func nixString(s string) string {
	return fmt.Sprintf(`"%v"`, strings.ReplaceAll(strings.ReplaceAll(s, "\\", "\\\\"), `"`, `\"`))
}

// Serialize a slice of strings to a Nix string list, without duplicates.
// Caller must add the opening and closing brackets, or ensure they exist
// in the format string.
func nixStringList(s []string) string {
	itemSet := make(map[string]bool)
	quotedItems := make([]string, len(s))

	for i, item := range s {
		if itemSet[item] {
			continue
		}

		itemSet[item] = true
		quotedItems[i] = nixString(item)
	}

	return strings.Join(quotedItems, " ")
}

const (
	fileSystemEntryKeyTemplate = `  fileSystems."%s" = {` + "\n"
	fileSystemDeviceTemplate   = `    device = "%s";` + "\n"
	fileSystemTypeTemplate     = `    type = "%s";` + "\n"
	fileSystemOptionTemplate   = `    options = [%s];` + "\n"

	fileSystemLuksTemplate = `  boot.initrd.luks.devices."%s".device = "%s";` + "\n\n"
)

func generateFilesystemAttrset(filesystem *Filesystem) string {
	fsStr := strings.Builder{}

	_, _ = fsStr.WriteString(fmt.Sprintf(fileSystemEntryKeyTemplate, filesystem.Mountpoint))
	_, _ = fsStr.WriteString(fmt.Sprintf(fileSystemDeviceTemplate, filesystem.DevicePath))
	_, _ = fsStr.WriteString(fmt.Sprintf(fileSystemTypeTemplate, filesystem.FSType))

	if len(filesystem.Options) > 0 {
		optionStr := fmt.Sprintf(fileSystemOptionTemplate, nixStringList(uniqueStringsInSlice(filesystem.Options)))
		_, _ = fsStr.WriteString(optionStr)
	}

	fsStr.WriteString("  }\n")

	luks := filesystem.LUKSInformation
	if luks != nil {
		_, _ = fsStr.WriteString(fmt.Sprintf(fileSystemLuksTemplate, luks.Name, luks.DevicePath))
	}

	return fsStr.String()
}

func uniqueStringsInSlice(s []string) []string {
	visited := make(map[string]bool, len(s))

	result := make([]string, 0, len(s))

	for _, v := range s {
		_, ok := visited[v]
		if !ok {
			visited[v] = true
			result = append(result, v)
		}
	}

	return result
}
</file>

<file path="cmd/init/hardware_configuration.nix.txt">
# Do not modify this file! It was generated by `nixos init`
# and may be overwritten by future invocations. Please make
# changes to your configuration.nix instead.

{
  config,
  lib,
  pkgs,
  modulesPath,
  ...
}: {
  imports = [
    %s
  ];

  boot.initrd.availableKernelModules = [%s];
  boot.initrd.kernelModules = [%s];
  boot.kernelModules = [%s];
  boot.extraModulePackages = [%s];

  # Filesystems
%s
  # Swap devices
%s

  # Enable DHCP on each ethernet and wireless interface. In case of scripted networking
  # (the default) this is the recommended approach. When using systemd-networkd it's
  # still possible to use this option, but it's recommended to use it in conjunction
  # with explicit per-interface declarations with `networking.interfaces.<interface>.useDHCP`.
  networking.useDHCP = lib.mkDefault true;
%s
  # Other config
%s
}
</file>

<file path="cmd/init/init.go">
package init

import (
	"fmt"
	"path/filepath"

	cmdOpts "github.com/nix-community/nixos-cli/internal/cmd/opts"
	cmdUtils "github.com/nix-community/nixos-cli/internal/cmd/utils"
	"github.com/spf13/cobra"
)

func InitCommand() *cobra.Command {
	opts := cmdOpts.InitOpts{}

	cmd := cobra.Command{
		Use:   "init",
		Short: "Initialize a NixOS configuration",
		Long:  "Initialize a NixOS configuration template and/or hardware options.",
		Args: func(cmd *cobra.Command, args []string) error {
			if !filepath.IsAbs(opts.Root) {
				return fmt.Errorf("--root must be an absolute path")
			}
			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return cmdUtils.CommandErrorHandler(initMain(cmd, &opts))
		},
	}

	cmdUtils.SetHelpFlagText(&cmd)

	cmd.Flags().StringVarP(&opts.Directory, "dir", "d", "/etc/nixos", "Directory `path` in root to write to")
	cmd.Flags().BoolVarP(&opts.ForceWrite, "force", "f", false, "Force generation of all configuration files")
	cmd.Flags().BoolVarP(&opts.NoFSGeneration, "no-fs", "n", false, "Do not generate 'fileSystem' options configuration")
	cmd.Flags().StringVarP(&opts.Root, "root", "r", "/", "Treat `path` as the root directory")
	cmd.Flags().BoolVarP(&opts.ShowHardwareConfig, "show-hardware-config", "s", false, "Print hardware config to stdout and exit")

	return &cmd
}
</file>

<file path="cmd/init/run.go">
//go:build linux

package init

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/nix-community/nixos-cli/internal/build"
	cmdOpts "github.com/nix-community/nixos-cli/internal/cmd/opts"
	"github.com/nix-community/nixos-cli/internal/logger"
	"github.com/nix-community/nixos-cli/internal/settings"
	"github.com/nix-community/nixos-cli/internal/system"
	"github.com/spf13/cobra"
)

func initMain(cmd *cobra.Command, opts *cmdOpts.InitOpts) error {
	log := logger.FromContext(cmd.Context())
	cfg := settings.FromContext(cmd.Context())
	s := system.NewLocalSystem(log)

	virtType := determineVirtualisationType(s, log)

	log.Step("Generating hardware-configuration.nix...")

	hwConfigNixText, err := generateHwConfigNix(s, log, cfg, virtType, opts)
	if err != nil {
		log.Errorf("failed to generate hardware-configuration.nix: %v", err)
		return err
	}

	if opts.ShowHardwareConfig {
		fmt.Println(hwConfigNixText)
		return nil
	}

	log.Step("Generating configuration.nix...")

	configNixText, err := generateConfigNix(log, cfg, virtType)
	if err != nil {
		log.Errorf("failed to generate configuration.nix: %v", err)
	}

	log.Step("Writing configuration...")

	configDir := filepath.Join(opts.Root, opts.Directory)
	err = os.MkdirAll(configDir, 0o755)
	if err != nil {
		log.Errorf("failed to create %v: %v", configDir, err)
		return err
	}

	if build.Flake() {
		flakeNixText := generateFlakeNix()
		flakeNixFilename := filepath.Join(configDir, "flake.nix")
		log.Infof("writing %v", flakeNixFilename)

		if _, err := os.Stat(flakeNixFilename); err == nil {
			if opts.ForceWrite {
				log.Warn("overwriting existing flake.nix")
			} else {
				log.Error("not overwriting existing flake.nix since --force was not specified, exiting")
				return nil
			}
		}

		err = os.WriteFile(flakeNixFilename, []byte(flakeNixText), 0o644)
		if err != nil {
			log.Errorf("failed to write %v: %v", flakeNixFilename, err)
			return err
		}
	}

	configNixFilename := filepath.Join(configDir, "configuration.nix")
	log.Infof("writing %v", configNixFilename)
	if _, err := os.Stat(configNixFilename); err == nil {
		if opts.ForceWrite {
			log.Warn("overwriting existing configuration.nix")
		} else {
			log.Error("not overwriting existing configuration.nix since --force was not specified, exiting")
			return nil
		}
	}
	err = os.WriteFile(configNixFilename, []byte(configNixText), 0o644)
	if err != nil {
		log.Errorf("failed to write %v: %v", configNixFilename, err)
		return err
	}

	hwConfigNixFilename := filepath.Join(configDir, "hardware-configuration.nix")
	log.Infof("writing %v", hwConfigNixFilename)
	if _, err := os.Stat(hwConfigNixFilename); err == nil {
		log.Warn("overwriting existing hardware-configuration.nix")
	}
	err = os.WriteFile(hwConfigNixFilename, []byte(hwConfigNixText), 0o644)
	if err != nil {
		log.Errorf("failed to write %v: %v", hwConfigNixFilename, err)
		return err
	}

	return nil
}
</file>

<file path="cmd/init/unsupported.go">
//go:build !linux

package init

import (
	"fmt"

	cmdOpts "github.com/nix-community/nixos-cli/internal/cmd/opts"
	"github.com/nix-community/nixos-cli/internal/logger"
	"github.com/spf13/cobra"
)

func initMain(cmd *cobra.Command, _ *cmdOpts.InitOpts) error {
	log := logger.FromContext(cmd.Context())
	err := fmt.Errorf("the init command is unsupported on non-Linux systems")
	log.Error(err)
	return err
}
</file>

<file path="cmd/install/install.go">
package install

import (
	"bytes"
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/nix-community/nixos-cli/internal/build"
	"github.com/nix-community/nixos-cli/internal/cmd/nixopts"
	"github.com/nix-community/nixos-cli/internal/cmd/opts"
	"github.com/nix-community/nixos-cli/internal/cmd/utils"
	"github.com/nix-community/nixos-cli/internal/configuration"
	"github.com/nix-community/nixos-cli/internal/constants"
	"github.com/nix-community/nixos-cli/internal/logger"
	"github.com/nix-community/nixos-cli/internal/system"
	"github.com/spf13/cobra"
	"golang.org/x/term"
)

func InstallCommand() *cobra.Command {
	opts := cmdOpts.InstallOpts{}

	usage := "install"
	if build.Flake() {
		usage += " {FLAKE-URI}#{SYSTEM-NAME}"
	}

	cmd := cobra.Command{
		Use:   usage,
		Short: "Install a NixOS system",
		Long:  "Install a NixOS system from a given configuration.",
		Args: func(cmd *cobra.Command, args []string) error {
			if build.Flake() {
				if err := cobra.ExactArgs(1)(cmd, args); err != nil {
					return err
				}

				ref := configuration.FlakeRefFromString(args[0])
				if ref.System == "" {
					return fmt.Errorf("missing required argument {SYSTEM-NAME}")
				}
				opts.FlakeRef = ref
			} else {
				if err := cobra.NoArgs(cmd, args); err != nil {
					return err
				}
			}
			return nil
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if len(opts.Root) > 0 && !filepath.IsAbs(opts.Root) {
				return fmt.Errorf("--root must be an absolute path")
			}
			if len(opts.SystemClosure) > 0 && !filepath.IsAbs(opts.SystemClosure) {
				return fmt.Errorf("--system must be an absolute path")
			}
			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return cmdUtils.CommandErrorHandler(installMain(cmd, &opts))
		},
	}

	cmd.Flags().StringVarP(&opts.Channel, "channel", "c", "", "Use derivation at `path` as the 'nixos' channel to copy")
	cmd.Flags().BoolVar(&opts.NoBootloader, "no-bootloader", false, "Do not install bootloader on device")
	cmd.Flags().BoolVar(&opts.NoChannelCopy, "no-channel-copy", false, "Do not copy over a NixOS channel")
	cmd.Flags().BoolVar(&opts.NoRootPassword, "no-root-passwd", false, "Do not prompt for setting root password")
	cmd.Flags().StringVarP(&opts.Root, "root", "r", "/mnt", "Treat `dir` as the root for installation")
	cmd.Flags().StringVarP(&opts.SystemClosure, "system", "s", "", "Install system from system closure at `path`")
	cmd.Flags().BoolVarP(&opts.Verbose, "verbose", "v", false, "Show verbose logging")

	nixopts.AddQuietNixOption(&cmd, &opts.NixOptions.Quiet)
	nixopts.AddPrintBuildLogsNixOption(&cmd, &opts.NixOptions.PrintBuildLogs)
	nixopts.AddNoBuildOutputNixOption(&cmd, &opts.NixOptions.NoBuildOutput)
	nixopts.AddShowTraceNixOption(&cmd, &opts.NixOptions.ShowTrace)
	nixopts.AddKeepGoingNixOption(&cmd, &opts.NixOptions.KeepGoing)
	nixopts.AddKeepFailedNixOption(&cmd, &opts.NixOptions.KeepFailed)
	nixopts.AddFallbackNixOption(&cmd, &opts.NixOptions.Fallback)
	nixopts.AddRefreshNixOption(&cmd, &opts.NixOptions.Refresh)
	nixopts.AddRepairNixOption(&cmd, &opts.NixOptions.Repair)
	nixopts.AddImpureNixOption(&cmd, &opts.NixOptions.Impure)
	nixopts.AddOfflineNixOption(&cmd, &opts.NixOptions.Offline)
	nixopts.AddNoNetNixOption(&cmd, &opts.NixOptions.NoNet)
	nixopts.AddMaxJobsNixOption(&cmd, &opts.NixOptions.MaxJobs)
	nixopts.AddCoresNixOption(&cmd, &opts.NixOptions.Cores)
	nixopts.AddLogFormatNixOption(&cmd, &opts.NixOptions.LogFormat)
	nixopts.AddOptionNixOption(&cmd, &opts.NixOptions.Options)
	nixopts.AddIncludesNixOption(&cmd, &opts.NixOptions.Includes)

	if build.Flake() {
		nixopts.AddRecreateLockFileNixOption(&cmd, &opts.NixOptions.RecreateLockFile)
		nixopts.AddNoUpdateLockFileNixOption(&cmd, &opts.NixOptions.NoUpdateLockFile)
		nixopts.AddNoWriteLockFileNixOption(&cmd, &opts.NixOptions.NoWriteLockFile)
		nixopts.AddNoUseRegistriesNixOption(&cmd, &opts.NixOptions.NoUseRegistries)
		nixopts.AddCommitLockFileNixOption(&cmd, &opts.NixOptions.CommitLockFile)
		nixopts.AddUpdateInputNixOption(&cmd, &opts.NixOptions.UpdateInputs)
		nixopts.AddOverrideInputNixOption(&cmd, &opts.NixOptions.OverrideInputs)
	}

	cmd.MarkFlagsMutuallyExclusive("channel", "no-channel-copy")

	helpTemplate := cmd.HelpTemplate()
	if build.Flake() {
		helpTemplate += `
Arguments:
  [FLAKE-URI]    Flake URI that contains NixOS system to build
  [SYSTEM-NAME]  Name of NixOS system attribute to build
`
	}
	helpTemplate += `
This command also forwards Nix options passed here to all relevant Nix invocations.
Check the Nix manual page for more details on what options are available.
`

	cmd.SetHelpTemplate(helpTemplate)
	cmdUtils.SetHelpFlagText(&cmd)

	return &cmd
}

func validateMountpoint(log *logger.Logger, mountpoint string) error {
	stat, err := os.Stat(mountpoint)
	if err != nil {
		log.Errorf("failed to stat %v: %v", mountpoint, err)
		return err
	}

	if !stat.IsDir() {
		msg := fmt.Sprintf("mountpoint %v is not a directory", mountpoint)
		log.Error(msg)
		return fmt.Errorf("%v", msg)
	}

	// Check permissions for the mountpoint. All components in the
	// mountpoint directory must have an "other users" bit set to at
	// least 5 (read+execute).

	currentPath := "/"
	for _, component := range filepath.SplitList(mountpoint) {
		if component == "" {
			continue
		}

		currentPath = filepath.Join(currentPath, component)

		info, err := os.Stat(currentPath)
		if err != nil {
			return fmt.Errorf("failed to stat %s: %w", currentPath, err)
		}

		mode := info.Mode()
		hasCorrectPermission := mode.Perm()&0o005 >= 0o005

		if !hasCorrectPermission {
			msg := fmt.Sprintf("path %s should have permissions 755, but had permissions %s", currentPath, mode.Perm())
			log.Errorf(msg)
			log.Printf("hint: consider running `chmod o+rx %s", currentPath)

			return fmt.Errorf("%v", msg)
		}
	}

	return nil
}

const (
	defaultExtraSubstituters = "auto?trusted=1"
)

func copyChannel(cobraCmd *cobra.Command, s system.CommandRunner, log *logger.Logger, mountpoint string, channelDirectory string, buildOptions any, verbose bool) error {
	mountpointChannelDir := filepath.Join(mountpoint, constants.NixChannelDirectory)

	channelPath := channelDirectory
	if channelPath == "" {
		argv := []string{"nix-env", "-p", constants.NixChannelDirectory, "-q", "nixos", "--no-name", "--out-path"}

		var stdout bytes.Buffer

		cmd := system.NewCommand(argv[0], argv[1:]...)
		cmd.Stdout = &stdout

		_, err := s.Run(cmd)
		if err != nil {
			log.Errorf("failed to obtain default nixos channel location: %v", err)
			return err
		}

		channelPath = strings.TrimSpace(stdout.String())
	}

	argv := []string{"nix-env", "--store", mountpoint}
	argv = append(argv, nixopts.NixOptionsToArgsList(cobraCmd.Flags(), buildOptions)...)
	argv = append(argv, "--extra-substituters", defaultExtraSubstituters)
	argv = append(argv, "-p", mountpointChannelDir, "--set", channelPath)

	cmd := system.NewCommand(argv[0], argv[1:]...)
	if verbose {
		log.CmdArray(argv)
	}

	_, err := s.Run(cmd)
	if err != nil {
		log.Errorf("failed to copy channel: %v", err)
		return err
	}

	defexprDirname := filepath.Join(mountpoint, "root", ".nix-defexpr")
	err = os.MkdirAll(defexprDirname, 0o700)
	if err != nil {
		log.Errorf("failed to create .nix-defexpr directory when copying channel: %v", err)
		return err
	}

	defexprChannelsDirname := filepath.Join(defexprDirname, "channels")
	err = os.RemoveAll(defexprChannelsDirname)
	if err != nil {
		log.Errorf("failed to remove .nix-defexpr/channels directory: %v", err)
		return err
	}

	err = os.Symlink(mountpointChannelDir, defexprChannelsDirname)
	if err != nil {
		log.Errorf("failed to create .nix-defexpr/channels symlink: %v", err)
		return err
	}

	return nil
}

func createInitialGeneration(s system.CommandRunner, mountpoint string, closure string, verbose bool) error {
	systemProfileDir := filepath.Join(mountpoint, constants.NixProfileDirectory, "system")

	log := s.Logger()

	if err := os.MkdirAll(filepath.Dir(systemProfileDir), 0o755); err != nil {
		log.Errorf("failed to create nix system profile directory for new system: %v", err)
		return err
	}

	argv := []string{
		"nix-env", "--store", mountpoint, "-p", systemProfileDir,
		"--set", closure, "--extra-substituters", defaultExtraSubstituters,
	}

	if verbose {
		log.CmdArray(argv)
	}

	cmd := system.NewCommand(argv[0], argv[1:]...)
	_, err := s.Run(cmd)
	if err != nil {
		log.Errorf("failed to create initial profile for new system: %v", err)
		return err
	}

	return nil
}

const (
	bootloaderTemplate = `
mount --rbind --mkdir / '%s'
mount --make-rslave '%s'
/run/current-system/bin/switch-to-configuration boot
umount -R '%s' && rmdir '%s'
`
)

func installBootloader(s system.CommandRunner, root string, verbose bool) error {
	bootloaderScript := fmt.Sprintf(bootloaderTemplate, root, root, root, root)
	mtabLocation := filepath.Join(root, "etc", "mtab")

	log := s.Logger()

	err := os.Symlink("/proc/mounts", mtabLocation)
	if err != nil {
		if !errors.Is(err, os.ErrExist) {
			log.Errorf("unable to symlink /proc/mounts to '%v': %v; this is required for bootloader installation", mtabLocation, err)
			return err
		}
	}

	argv := []string{os.Args[0], "enter", "--root", root, "-c", bootloaderScript}
	if verbose {
		argv = append(argv, "-v")
	} else {
		argv = append(argv, "-s")
	}

	if verbose {
		log.CmdArray(argv)
	}

	cmd := system.NewCommand(argv[0], argv[1:]...)
	cmd.SetEnv("NIXOS_INSTALL_BOOTLOADER", "1")
	cmd.SetEnv("NIXOS_CLI_DISABLE_STEPS", "1")

	_, err = s.Run(cmd)
	if err != nil {
		log.Errorf("failed to install bootloader: %v", err)
		return err
	}

	return nil
}

func setRootPassword(s system.CommandRunner, mountpoint string, verbose bool) error {
	argv := []string{os.Args[0], "enter", "--root", mountpoint, "-c", "/nix/var/nix/profiles/system/sw/bin/passwd"}

	if verbose {
		argv = append(argv, "-v")
	} else {
		argv = append(argv, "-s")
	}

	if verbose {
		s.Logger().CmdArray(argv)
	}

	cmd := system.NewCommand(argv[0], argv[1:]...)
	cmd.SetEnv("NIXOS_CLI_DISABLE_STEPS", "1")

	_, err := s.Run(cmd)
	return err
}

func installMain(cmd *cobra.Command, opts *cmdOpts.InstallOpts) error {
	log := logger.FromContext(cmd.Context())
	s := system.NewLocalSystem(log)

	if !s.IsNixOS() {
		msg := "this command can only be run on NixOS systems"
		log.Error(msg)
		return fmt.Errorf("%v", msg)
	}

	mountpoint, err := filepath.EvalSymlinks(opts.Root)
	if err != nil {
		log.Errorf("failed to resolve root directory: %v", err)
		return err
	}

	if err := validateMountpoint(log, mountpoint); err != nil {
		return err
	}
	tmpDirname, err := os.MkdirTemp(mountpoint, "system")
	if err != nil {
		log.Errorf("failed to create temporary directory: %v", err)
		return err
	}
	defer func() {
		err = os.RemoveAll(tmpDirname)
		if err != nil {
			log.Warnf("unable to remove temporary directory %s, please remove manually", tmpDirname)
		}
	}()

	// Find config location. Do not use the config utils to find the configuration,
	// since the configuration must be specified explicitly. We must avoid
	// the assumptions about `NIX_PATH` containing `nixos-config`, since it
	// refers to the installer's configuration, not the target one to install.

	if opts.Verbose {
		log.Step("Finding configuration...")
	}

	var nixConfig configuration.Configuration
	if build.Flake() {
		nixConfig = opts.FlakeRef
	} else {
		var configLocation string

		if nixosCfg, set := os.LookupEnv("NIXOS_CONFIG"); set {
			if opts.Verbose {
				log.Info("$NIXOS_CONFIG is set, using automatically")
			}
			configLocation = nixosCfg
		} else {
			configLocation = filepath.Join(mountpoint, "etc", "nixos", "configuration.nix")
		}

		if _, err := os.Stat(configLocation); err != nil {
			log.Errorf("failed to stat %s: %v", configLocation, err)
			return err
		}

		nixConfig = &configuration.LegacyConfiguration{
			Includes:      opts.NixOptions.Includes,
			ConfigDirname: configLocation,
		}
	}
	nixConfig.SetBuilder(s)

	log.Step("Copying channel...")

	err = copyChannel(cmd, s, log, mountpoint, opts.Channel, opts.NixOptions, opts.Verbose)
	if err != nil {
		return err
	}

	envMap := map[string]string{}
	if os.Getenv("TMPDIR") == "" {
		envMap["TMPDIR"] = tmpDirname
	}

	if c, ok := nixConfig.(*configuration.LegacyConfiguration); ok {
		// This value gets appended to the list of includes,
		// and does not replace existing values already provided
		// for -I on the command line.
		if err := cmd.Flags().Set("include", fmt.Sprintf("nixos-config=%s", c.ConfigDirname)); err != nil {
			panic("failed to set --include flag for nixos install command for legacy systems")
		}
	}

	systemBuildOptions := configuration.SystemBuildOptions{
		Verbose:   opts.Verbose,
		CmdFlags:  cmd.Flags(),
		NixOpts:   opts.NixOptions,
		Env:       envMap,
		ExtraArgs: []string{"--extra-substituters", defaultExtraSubstituters},
	}

	log.Step("Building system...")

	resultLocation, err := nixConfig.BuildSystem(configuration.SystemBuildTypeSystem, &systemBuildOptions)
	if err != nil {
		log.Errorf("failed to build system: %v", err)
		return err
	}

	log.Step("Creating initial generation...")

	if err := createInitialGeneration(s, mountpoint, resultLocation, opts.Verbose); err != nil {
		return err
	}

	// Create /etc/NIXOS file to mark this system as a NixOS system to
	// NixOS tooling such as `switch-to-configuration.pl`.
	log.Step("Creating NixOS indicator")

	etcDirname := filepath.Join(mountpoint, "etc")
	err = os.MkdirAll(etcDirname, 0o755)
	if err != nil {
		log.Errorf("failed to create %v directory: %v", etcDirname, err)
		return err
	}

	etcNixosFilename := filepath.Join(mountpoint, constants.NixOSMarker)
	etcNixos, err := os.Create(etcNixosFilename)
	if err != nil {
		log.Errorf("failed to create %v marker: %v", etcNixosFilename, err)
		return err
	}
	_ = etcNixos.Close()

	log.Step("Installing bootloader...")

	if err := installBootloader(s, mountpoint, opts.Verbose); err != nil {
		return err
	}

	log.Step("Setting root password...")

	if !opts.NoRootPassword {
		manualHint := "you can set the root password manually by executing `nixos enter --root {s}` and then running `passwd` in the shell of them new system"

		if !term.IsTerminal(int(os.Stdin.Fd())) {
			log.Warn("stdin is not a terminal; skipping setting root password")
			log.Info(manualHint)
		} else {
			err := setRootPassword(s, mountpoint, opts.Verbose)
			if err != nil {
				log.Warnf("failed to set root password: %v", err)
				log.Info(manualHint)
			}
		}
	}

	log.Print("Installation successful! You may now reboot.")

	return nil
}
</file>

<file path="cmd/manual/manual.go">
package manual

import (
	"fmt"
	"os"
	"os/exec"
	"strings"

	"github.com/nix-community/nixos-cli/internal/cmd/utils"
	"github.com/nix-community/nixos-cli/internal/constants"
	"github.com/nix-community/nixos-cli/internal/logger"
	"github.com/nix-community/nixos-cli/internal/system"
	"github.com/spf13/cobra"
)

func ManualCommand() *cobra.Command {
	cmd := cobra.Command{
		Use:   "manual",
		Short: "Open the NixOS manual",
		Long:  "Open the NixOS manual in a browser.",
		Args:  cobra.NoArgs,
		RunE: func(cmd *cobra.Command, _ []string) error {
			return cmdUtils.CommandErrorHandler(manualMain(cmd))
		},
	}

	cmdUtils.SetHelpFlagText(&cmd)

	return &cmd
}

const (
	localManualFile = constants.CurrentSystem + "/sw/share/doc/nixos/index.html"
	manualURL       = "https://nixos.org/manual/nixos/stable"
)

func manualMain(cmd *cobra.Command) error {
	log := logger.FromContext(cmd.Context())
	s := system.NewLocalSystem(log)

	if !s.IsNixOS() {
		log.Error("this command is only supported on NixOS systems")
		return nil
	}

	url := localManualFile
	if _, err := os.Stat(url); err != nil {
		log.Error("local documentation is not available, opening manual for current NixOS stable version")
		url = manualURL
	}

	var openCommand string

	browsers := strings.Split(os.Getenv("BROWSERS"), ":")
	for _, browser := range browsers {
		if p, err := exec.LookPath(browser); err == nil && p != "" {
			openCommand = p
			break
		}
	}

	defaultCommands := []string{"xdg-open", "w3m", "open"}
	if openCommand == "" {
		for _, cmd := range defaultCommands {
			if p, err := exec.LookPath(cmd); err == nil && p != "" {
				openCommand = p
				break
			}
		}

		if openCommand == "" {
			msg := "unable to locate suitable browser to open manual, exiting"
			log.Error(msg)
			return fmt.Errorf("%v", msg)
		}
	}

	log.Infof("opening manual using %v", openCommand)
	err := exec.Command(openCommand, url).Run()
	if err != nil {
		log.Errorf("failed to open manual: %v", err)
		return err
	}

	return nil
}
</file>

<file path="cmd/option/cache.go">
package option

import (
	"bytes"
	"fmt"
	"path/filepath"
	"strings"

	"github.com/nix-community/nixos-cli/internal/configuration"
	"github.com/nix-community/nixos-cli/internal/constants"
	"github.com/nix-community/nixos-cli/internal/system"
)

const (
	flakeOptionsCacheExpr = `let
  flake = builtins.getFlake "%s";
  system = flake.nixosConfigurations."%s";
  inherit (system) pkgs;
  inherit (pkgs) lib;

  optionsList' = lib.optionAttrSetToDocList system.options;
  optionsList = builtins.filter (v: v.visible && !v.internal) optionsList';

  jsonFormat = pkgs.formats.json {};
in
  jsonFormat.generate "options-cache.json" optionsList
`
	legacyOptionsCacheExpr = `let
  system = import <nixpkgs/nixos> {};
  inherit (system) pkgs;
  inherit (pkgs) lib;

  optionsList' = lib.optionAttrSetToDocList system.options;
  optionsList = builtins.filter (v: v.visible && !v.internal) optionsList';

  jsonFormat = pkgs.formats.json {};
in
  jsonFormat.generate "options-cache.json" optionsList
`
)

var prebuiltOptionCachePath = filepath.Join(constants.CurrentSystem, "etc", "nixos-cli", "options-cache.json")

func buildOptionCache(s system.CommandRunner, cfg configuration.Configuration) (string, error) {
	argv := []string{"nix-build", "--no-out-link", "--expr"}

	switch v := cfg.(type) {
	case *configuration.FlakeRef:
		argv = append(argv, fmt.Sprintf(flakeOptionsCacheExpr, v.URI, v.System))
	case *configuration.LegacyConfiguration:
		argv = append(argv, legacyOptionsCacheExpr)
		for _, v := range v.Includes {
			argv = append(argv, "-I", v)
		}
	}

	cmd := system.NewCommand(argv[0], argv[1:]...)

	var stdout bytes.Buffer
	var stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	_, err := s.Run(cmd)
	if err != nil {
		return "", err
	}

	return strings.TrimSpace(stdout.String()), nil
}
</file>

<file path="cmd/option/completion.go">
package option

import (
	"os"
	"strings"

	"github.com/nix-community/nixos-cli/internal/cmd/opts"
	"github.com/nix-community/nixos-cli/internal/configuration"
	"github.com/nix-community/nixos-cli/internal/logger"
	"github.com/nix-community/nixos-cli/internal/settings"
	"github.com/nix-community/nixos-cli/internal/system"
	"github.com/spf13/cobra"
	"github.com/water-sucks/optnix/option"
)

func loadOptions(log *logger.Logger, cfg *settings.Settings, includes []string) (option.NixosOptionSource, error) {
	s := system.NewLocalSystem(log)

	nixosConfig, err := configuration.FindConfiguration(log, cfg, includes, false)
	if err != nil {
		log.Errorf("failed to find configuration: %v", err)
		return nil, err
	}

	// Always use cache for completion if available.
	useCache := true
	_, err = os.Stat(prebuiltOptionCachePath)
	if err != nil {
		log.Warnf("error accessing prebuilt option cache: %v", err)
		useCache = false
	}

	optionsFileName := prebuiltOptionCachePath
	if !useCache {
		log.Info("building options list")
		f, err := buildOptionCache(s, nixosConfig)
		if err != nil {
			log.Errorf("failed to build option list: %v", err)
			return nil, err
		}
		optionsFileName = f
	}

	optionsFile, err := os.Open(optionsFileName)
	if err != nil {
		log.Errorf("failed to open options file %v: %v", optionsFileName, err)
		return nil, err
	}
	defer func() { _ = optionsFile.Close() }()

	options, err := option.LoadOptions(optionsFile)
	if err != nil {
		log.Errorf("failed to load options: %v", err)
		return nil, err
	}

	return options, nil
}

func OptionsCompletionFunc(opts *cmdOpts.OptionOpts) cobra.CompletionFunc {
	return func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
		log := logger.FromContext(cmd.Context())
		cfg := settings.FromContext(cmd.Context())

		if len(args) != 0 {
			return []string{}, cobra.ShellCompDirectiveNoFileComp
		}

		options, err := loadOptions(log, cfg, opts.NixPathIncludes)
		if err != nil {
			return []string{}, cobra.ShellCompDirectiveNoFileComp
		}

		completions := []string{}
		for _, v := range options {
			if toComplete == v.Name {
				return []string{v.Name}, cobra.ShellCompDirectiveNoFileComp
			}

			if strings.HasPrefix(v.Name, toComplete) {
				completions = append(completions, v.Name)
			}
		}

		return completions, cobra.ShellCompDirectiveNoSpace | cobra.ShellCompDirectiveNoFileComp
	}
}
</file>

<file path="cmd/option/option.go">
package option

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"slices"

	"github.com/nix-community/nixos-cli/internal/build"
	"github.com/nix-community/nixos-cli/internal/cmd/nixopts"
	"github.com/nix-community/nixos-cli/internal/cmd/opts"
	"github.com/nix-community/nixos-cli/internal/cmd/utils"
	"github.com/nix-community/nixos-cli/internal/configuration"
	"github.com/nix-community/nixos-cli/internal/logger"
	"github.com/nix-community/nixos-cli/internal/settings"
	"github.com/nix-community/nixos-cli/internal/system"
	"github.com/sahilm/fuzzy"
	"github.com/spf13/cobra"
	"github.com/water-sucks/optnix/option"
	optionTUI "github.com/water-sucks/optnix/tui"
	"github.com/yarlson/pin"
)

func OptionCommand() *cobra.Command {
	opts := cmdOpts.OptionOpts{}

	cmd := cobra.Command{
		Use:   "option [flags] [OPTION-NAME]",
		Short: "Query NixOS options and their details",
		Long:  "Query available NixOS module options for this system.",
		Args: func(cmd *cobra.Command, args []string) error {
			if err := cobra.MaximumNArgs(1)(cmd, args); err != nil {
				return err
			}

			if len(args) > 0 {
				opts.OptionInput = args[0]
			}

			// Imply `--non-interactive` for scripting output if not specified
			if opts.DisplayJson || opts.DisplayValueOnly {
				if cmd.Flags().Changed("non-interactive") && !opts.NonInteractive {
					return fmt.Errorf("--non-interactive is required when using output format flags")
				}

				opts.NonInteractive = true
			}

			if opts.DisplayJson && opts.DisplayValueOnly {
				return fmt.Errorf("--json and --value-only flags conflict")
			}

			if opts.NonInteractive && len(args) < 1 {
				return fmt.Errorf("argument [OPTION-NAME] is required for non-interactive mode")
			}

			return nil
		},
		ValidArgsFunction: OptionsCompletionFunc(&opts),
		RunE: func(cmd *cobra.Command, args []string) error {
			return cmdUtils.CommandErrorHandler(optionMain(cmd, &opts))
		},
	}

	cmd.Flags().BoolVarP(&opts.DisplayJson, "json", "j", false, "Output information in JSON format")
	cmd.Flags().BoolVarP(&opts.NonInteractive, "non-interactive", "n", false, "Do not show search TUI for options")
	cmd.Flags().BoolVar(&opts.NoUseCache, "no-cache", false, "Do not attempt to use prebuilt option cache")
	cmd.Flags().Int64VarP(&opts.MinScore, "min-score", "s", 0, "Minimum `score` threshold for matching queries")
	cmd.Flags().BoolVarP(&opts.DisplayValueOnly, "value-only", "v", false, "Show only the selected option's value")

	if build.Flake() {
		cmd.Flags().StringVarP(&opts.FlakeRef, "flake", "f", "", "Flake `ref` to explicitly load options from")
	}

	nixopts.AddIncludesNixOption(&cmd, &opts.NixPathIncludes)

	cmdUtils.SetHelpFlagText(&cmd)
	cmd.SetHelpTemplate(cmd.HelpTemplate() + `
Arguments:
  [NAME]  Name of option to use. Not required in interactive mode.
`)

	return &cmd
}

func optionMain(cmd *cobra.Command, opts *cmdOpts.OptionOpts) error {
	log := logger.FromContext(cmd.Context())
	cfg := settings.FromContext(cmd.Context())
	s := system.NewLocalSystem(log)

	minScore := cfg.Option.MinScore
	if cmd.Flags().Changed("min-score") {
		minScore = opts.MinScore
	}

	if !s.IsNixOS() {
		msg := "this command is only supported on NixOS systems"
		log.Error(msg)
		return fmt.Errorf("%v", msg)
	}

	var nixosConfig configuration.Configuration
	if opts.FlakeRef != "" {
		nixosConfig = configuration.FlakeRefFromString(opts.FlakeRef)
		if err := nixosConfig.(*configuration.FlakeRef).InferSystemFromHostnameIfNeeded(); err != nil {
			log.Errorf("failed to infer hostname: %v", err)
			return err
		}
	} else {
		c, err := configuration.FindConfiguration(log, cfg, opts.NixPathIncludes, false)
		if err != nil {
			log.Errorf("failed to find configuration: %v", err)
			return err
		}
		nixosConfig = c
	}

	spinner := pin.New("Loading...",
		pin.WithSpinnerColor(pin.ColorCyan),
		pin.WithTextColor(pin.ColorRed),
		pin.WithPosition(pin.PositionRight),
		pin.WithSpinnerFrames([]rune{'-', '\\', '|', '/'}),
		pin.WithWriter(os.Stderr),
	)
	cancelSpinner := spinner.Start(context.Background())
	defer cancelSpinner()

	spinner.UpdateMessage("Loading options...")

	useCache := !opts.NoUseCache
	if useCache {
		_, err := os.Stat(prebuiltOptionCachePath)
		if err != nil {
			log.Warnf("error accessing prebuilt option cache: %v", err)
			useCache = false
		}
	}

	optionsFileName := prebuiltOptionCachePath
	if !useCache {
		f, err := buildOptionCache(s, nixosConfig)
		if err != nil {
			spinner.Stop()
			log.Errorf("failed to build option list: %v", err)
			log.Errorf("evaluation trace:", f)
			return err
		}
		optionsFileName = f
	}

	optionsFile, err := os.Open(optionsFileName)
	if err != nil {
		log.Errorf("failed to open options file %v: %v", optionsFileName, err)
		return err
	}

	options, err := option.LoadOptions(optionsFile)
	if err != nil {
		spinner.Stop()
		log.Errorf("failed to load options: %v", err)
		return err
	}

	var evaluator option.EvaluatorFunc = func(optionName string) (string, error) {
		value, err := nixosConfig.EvalAttribute(optionName)
		realValue := ""
		if value != nil {
			realValue = *value
		}
		return realValue, err
	}

	if !opts.NonInteractive {
		spinner.Stop()
		return optionTUI.OptionTUI(optionTUI.OptionTUIArgs{
			Options:      options,
			ScopeName:    "nixos",
			MinScore:     minScore,
			DebounceTime: cfg.Option.DebounceTime,
			Evaluator:    evaluator,
			InitialInput: opts.OptionInput,
		})
	}

	spinner.UpdateMessage(fmt.Sprintf("Finding option %v...", opts.OptionInput))

	exactOptionMatchIdx := slices.IndexFunc(options, func(o option.NixosOption) bool {
		return o.Name == opts.OptionInput
	})
	if exactOptionMatchIdx != -1 {
		o := options[exactOptionMatchIdx]

		spinner.UpdateMessage("Evaluating option value...")

		evaluatedValue, err := evaluator(o.Name)

		spinner.Stop()

		if opts.DisplayJson {
			displayOptionJson(&o, evaluatedValue)
		} else if opts.DisplayValueOnly {
			fmt.Printf("%v\n", evaluatedValue)
		} else {
			fmt.Print(o.PrettyPrint(&option.ValuePrinterInput{
				Value: evaluatedValue,
				Err:   err,
			}))
		}

		return nil
	}

	spinner.Stop()

	msg := fmt.Sprintf("no exact match for query '%s' found", opts.OptionInput)
	err = fmt.Errorf("%v", msg)

	fuzzySearchResults := fuzzy.FindFrom(opts.OptionInput, options)
	if len(fuzzySearchResults) > 10 {
		fuzzySearchResults = fuzzySearchResults[:10]
	}

	fuzzySearchResults = filterMinimumScoreMatches(fuzzySearchResults, int(minScore))

	if opts.DisplayJson {
		displayErrorJson(msg, fuzzySearchResults)
		return err
	}

	log.Error(msg)
	if len(fuzzySearchResults) > 0 {
		log.Print("\nSome similar options were found:\n")
		for _, v := range fuzzySearchResults {
			log.Printf(" - %s\n", v.Str)
		}
	} else {
		log.Print("\nTry refining your search query.\n")
	}

	return err
}

func displayOptionJson(o *option.NixosOption, evaluatedValue string) {
	type optionJson struct {
		Name         string   `json:"name"`
		Description  string   `json:"description"`
		Type         string   `json:"type"`
		Value        string   `json:"value"`
		Default      string   `json:"default"`
		Example      string   `json:"example"`
		Location     []string `json:"loc"`
		ReadOnly     bool     `json:"readOnly"`
		Declarations []string `json:"declarations"`
	}

	defaultText := ""
	if o.Default != nil {
		defaultText = o.Default.Text
	}

	exampleText := ""
	if o.Example != nil {
		exampleText = o.Example.Text
	}

	bytes, _ := json.MarshalIndent(optionJson{
		Name:         o.Name,
		Description:  o.Description,
		Type:         o.Type,
		Value:        evaluatedValue,
		Default:      defaultText,
		Example:      exampleText,
		Location:     o.Location,
		ReadOnly:     o.ReadOnly,
		Declarations: o.Declarations,
	}, "", "  ")
	fmt.Printf("%v\n", string(bytes))
}

func displayErrorJson(msg string, matches fuzzy.Matches) {
	type errorJson struct {
		Message        string   `json:"message"`
		SimilarOptions []string `json:"similar_options"`
	}

	matchedStrings := make([]string, len(matches))
	for i, match := range matches {
		matchedStrings[i] = match.Str
	}

	bytes, _ := json.MarshalIndent(errorJson{
		Message:        msg,
		SimilarOptions: matchedStrings,
	}, "", "  ")
	fmt.Printf("%v\n", string(bytes))
}

// Filter a sorted (descending) match list until a minimum score is reached.
// Return a slice of the original matches.
func filterMinimumScoreMatches(matches []fuzzy.Match, minScore int) []fuzzy.Match {
	for i, v := range matches {
		if v.Score < minScore {
			return matches[:i]
		}
	}

	return matches
}
</file>

<file path="cmd/repl/repl.go">
package repl

import (
	"fmt"
	"os"
	"os/exec"
	"syscall"

	"github.com/fatih/color"
	"github.com/nix-community/nixos-cli/internal/cmd/nixopts"
	"github.com/nix-community/nixos-cli/internal/cmd/opts"
	"github.com/nix-community/nixos-cli/internal/cmd/utils"
	"github.com/nix-community/nixos-cli/internal/configuration"
	"github.com/nix-community/nixos-cli/internal/logger"
	"github.com/nix-community/nixos-cli/internal/settings"
	"github.com/spf13/cobra"

	"github.com/nix-community/nixos-cli/internal/build"
)

func ReplCommand() *cobra.Command {
	opts := cmdOpts.ReplOpts{}

	usage := "repl [flags]"
	if build.Flake() {
		usage += " [FLAKE-REF]"
	}

	cmd := cobra.Command{
		Use:   usage,
		Short: "Start a Nix REPL with system configuration loaded",
		Long:  "Start a Nix REPL with current system's configuration loaded.",
		Args: func(cmd *cobra.Command, args []string) error {
			if build.Flake() {
				if err := cobra.MaximumNArgs(1)(cmd, args); err != nil {
					return err
				}
				if len(args) > 0 {
					opts.FlakeRef = args[0]
				}
				return nil
			}
			return cobra.NoArgs(cmd, args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return cmdUtils.CommandErrorHandler(replMain(cmd, &opts))
		},
	}

	cmdUtils.SetHelpFlagText(&cmd)

	nixopts.AddIncludesNixOption(&cmd, &opts.NixPathIncludes)

	if build.Flake() {
		cmd.SetHelpTemplate(cmd.HelpTemplate() + `
Arguments:
    [FLAKE-REF]  Flake ref to load attributes from (default: $NIXOS_CONFIG)
`)
	}

	return &cmd
}

const (
	flakeReplExpr = `let
  flake = builtins.getFlake "%s";
  system = flake.nixosConfigurations."%s";
  motd = ''
%s'';
  scope =
    assert system._type or null == "configuration";
    assert system.class or "nixos" == "nixos";
      system._module.args
      // system._module.specialArgs
      // {
        inherit (system) config options;
        inherit flake;
      };
in
  builtins.seq scope builtins.trace motd scope
`

	legacyReplExpr = `let
  system = import <nixpkgs/nixos> {};
  motd = ''
%s'';
in
 builtins.seq system builtins.trace motd system
`

	flakeMotdTemplate = `This Nix REPL has been automatically loaded with a NixOS configuration.

Configuration :: %s

The following values have been added to the toplevel scope:
  - %s :: Flake inputs, outputs, and source information
  - %s :: Configured option values
  - %s :: Option data and associated metadata
  - %s :: %s package set
  - Any additional arguments in %s and %s

Tab completion can be used to browse around all of these attributes.

Use the %s command to reload the configuration after it has
been changed, assuming it is a mutable configuration.

Use %s to see all available repl commands.

%s: %s does not enforce pure evaluation.
`

	legacyMotdTemplate = `This Nix REPL has been automatically loaded with this system's NixOS configuration.

The following values have been added to the toplevel scope:
  - %s :: Configured option values
  - %s :: Option data and associated metadata
  - %s :: %s package set
  - Any additional arguments in %s and %s

Tab completion can be used to browse around all of these attributes.

Use the %s command to reload the configuration after it has
been changed.

Use %s to see all available repl commands.
`
)

func replMain(cmd *cobra.Command, opts *cmdOpts.ReplOpts) error {
	log := logger.FromContext(cmd.Context())
	cfg := settings.FromContext(cmd.Context())

	var nixConfig configuration.Configuration
	if opts.FlakeRef != "" {
		nixConfig = configuration.FlakeRefFromString(opts.FlakeRef)
	} else {
		c, err := configuration.FindConfiguration(log, cfg, opts.NixPathIncludes, false)
		if err != nil {
			log.Errorf("failed to find configuration: %v", err)
			return err
		}
		nixConfig = c
	}

	switch c := nixConfig.(type) {
	case *configuration.FlakeRef:
		err := execFlakeRepl(c)
		if err != nil {
			log.Errorf("failed to exec nix flake repl: %v", err)
			return err
		}
	case *configuration.LegacyConfiguration:
		err := execLegacyRepl(c.Includes, os.Getenv("NIXOS_CONFIG") != "")
		if err != nil {
			log.Errorf("failed to exec nix repl: %v", err)
			return err
		}
	}

	return nil
}

func execLegacyRepl(includes []string, impure bool) error {
	motd := formatLegacyMotd()
	expr := fmt.Sprintf(legacyReplExpr, motd)

	argv := []string{"nix", "repl", "--expr", expr}
	for _, v := range includes {
		argv = append(argv, "-I", v)
	}
	if impure {
		argv = append(argv, "--impure")
	}

	nixCommandPath, err := exec.LookPath("nix")
	if err != nil {
		return err
	}

	err = syscall.Exec(nixCommandPath, argv, os.Environ())
	return err
}

func execFlakeRepl(flakeRef *configuration.FlakeRef) error {
	motd := formatFlakeMotd(flakeRef)
	expr := fmt.Sprintf(flakeReplExpr, flakeRef.URI, flakeRef.System, motd)

	argv := []string{"nix", "repl", "--expr", expr}

	nixCommandPath, err := exec.LookPath("nix")
	if err != nil {
		return err
	}

	err = syscall.Exec(nixCommandPath, argv, os.Environ())
	return err
}

func formatFlakeMotd(ref *configuration.FlakeRef) string {
	flakeRef := fmt.Sprintf("%s#%s", ref.URI, ref.System)

	return fmt.Sprintf(flakeMotdTemplate,
		color.CyanString(flakeRef),
		color.MagentaString("flake"),
		color.MagentaString("config"),
		color.MagentaString("options"),
		color.MagentaString("pkgs"), color.CyanString("nixpkgs"),
		color.MagentaString("_module.args"), color.MagentaString("_module.specialArgs"),
		color.MagentaString(":r"),
		color.MagentaString(":?"),
		color.YellowString("warning"), color.CyanString("nixos repl"),
	)
}

func formatLegacyMotd() string {
	return fmt.Sprintf(legacyMotdTemplate,
		color.MagentaString("config"),
		color.MagentaString("options"),
		color.MagentaString("pkgs"), color.CyanString("nixpkgs"),
		color.MagentaString("_module.args"), color.MagentaString("_module.specialArgs"),
		color.MagentaString(":r"),
		color.MagentaString(":?"),
	)
}
</file>

<file path="cmd/root/aliases.go">
package root

import (
	"fmt"
	"os"
	"os/exec"

	"github.com/nix-community/nixos-cli/internal/utils"
	"github.com/spf13/cobra"
)

func addAliasCmd(parent *cobra.Command, alias string, args []string) error {
	displayedArgs := utils.EscapeAndJoinArgs(args)
	description := fmt.Sprintf("Alias for `%v`.", displayedArgs)

	existingCommands := parent.Commands()
	for _, v := range existingCommands {
		if v.Name() == alias {
			return fmt.Errorf("alias conflicts with existing builtin command")
		}
	}

	if !parent.ContainsGroup("aliases") {
		parent.AddGroup(&cobra.Group{
			ID:    "aliases",
			Title: "Aliases",
		})
	}

	cmd := &cobra.Command{
		Use:                alias,
		Short:              description,
		Long:               description,
		GroupID:            "aliases",
		DisableFlagParsing: true,
		RunE: func(cmd *cobra.Command, passedArgs []string) error {
			fullArgsList := append(args, passedArgs...)

			root := cmd.Root()
			root.SetArgs(fullArgsList)
			return root.Execute()
		},
		ValidArgsFunction: func(cmd *cobra.Command, passedArgs []string, toComplete string) ([]string, cobra.ShellCompDirective) {
			// HACK: So this is a rather lazy way of implementing completion for aliases.
			// I couldn't figure out how to get completions from the flag, so I decided
			// to just run the hidden completion command with the resolved arguments
			// and anything else that was passed. This should be negligible from a
			// performance perspective, but it's definitely a piece of shit.
			// Also, if you know, you know.

			// evil completion command hacking
			completionArgv := []string{os.Args[0], "__complete"} // what the fuck?
			completionArgv = append(completionArgv, args...)
			completionArgv = append(completionArgv, passedArgs...)
			completionArgv = append(completionArgv, toComplete)

			completionCmd := exec.Command(completionArgv[0], completionArgv[1:]...)
			completionCmd.Stdout = os.Stdout
			completionCmd.Stderr = os.Stderr

			// The completion command should always run.
			if err := completionCmd.Run(); err != nil {
				cobra.CompDebugln("failed to run completion command: "+err.Error(), true)
				os.Exit(1)
			}

			os.Exit(0)

			return []string{}, cobra.ShellCompDirectiveNoFileComp
		},
	}

	parent.AddCommand(cmd)

	return nil
}
</file>

<file path="cmd/root/root.go">
package root

import (
	"context"
	"fmt"
	"os"

	"github.com/carapace-sh/carapace"
	"github.com/fatih/color"
	"github.com/nix-community/nixos-cli/internal/build"
	"github.com/nix-community/nixos-cli/internal/constants"
	"github.com/nix-community/nixos-cli/internal/logger"
	"github.com/nix-community/nixos-cli/internal/settings"
	"github.com/spf13/cobra"

	"github.com/nix-community/nixos-cli/internal/cmd/opts"

	activateCmd "github.com/nix-community/nixos-cli/cmd/activate"
	applyCmd "github.com/nix-community/nixos-cli/cmd/apply"
	completionCmd "github.com/nix-community/nixos-cli/cmd/completion"
	enterCmd "github.com/nix-community/nixos-cli/cmd/enter"
	featuresCmd "github.com/nix-community/nixos-cli/cmd/features"
	generationCmd "github.com/nix-community/nixos-cli/cmd/generation"
	infoCmd "github.com/nix-community/nixos-cli/cmd/info"
	initCmd "github.com/nix-community/nixos-cli/cmd/init"
	installCmd "github.com/nix-community/nixos-cli/cmd/install"
	manualCmd "github.com/nix-community/nixos-cli/cmd/manual"
	optionCmd "github.com/nix-community/nixos-cli/cmd/option"
	replCmd "github.com/nix-community/nixos-cli/cmd/repl"
)

const helpTemplate = `Usage:{{if .Runnable}}
  {{.UseLine}}{{end}}{{if .HasAvailableSubCommands}}
  {{.CommandPath}} [command]{{end}}{{if gt (len .Aliases) 0}}

Aliases:
  {{.NameAndAliases}}{{end}}{{if .HasExample}}

Examples:
{{.Example}}{{end}}{{if .HasAvailableSubCommands}}{{$cmds := .Commands}}{{if eq (len .Groups) 0}}

Commands:{{range $cmds}}{{if (or .IsAvailableCommand (eq .Name "help"))}}
  {{rpad .Name .NamePadding }} {{.Short}}{{end}}{{end}}{{else}}{{if not .AllChildCommandsHaveGroup}}

Commands:{{range $cmds}}{{if (and (eq .GroupID "") (or .IsAvailableCommand (eq .Name "help")))}}
  {{rpad .Name .NamePadding }} {{.Short}}{{end}}{{end}}{{end}}{{range $group := .Groups}}

{{.Title}}:{{range $cmds}}{{if (and (eq .GroupID $group.ID) (or .IsAvailableCommand (eq .Name "help")))}}
  {{rpad .Name .NamePadding }} {{.Short}}{{end}}{{end}}{{end}}{{end}}{{end}}{{if .HasAvailableLocalFlags}}

Flags:
{{.LocalFlags.FlagUsages | trimTrailingWhitespaces}}{{end}}
`

func mainCommand() (*cobra.Command, error) {
	opts := cmdOpts.MainOpts{}

	log := logger.NewLogger()
	cmdCtx := logger.WithLogger(context.Background(), log)

	configLocation := os.Getenv("NIXOS_CLI_CONFIG")
	if configLocation == "" {
		configLocation = constants.DefaultConfigLocation
	}

	cfg, err := settings.ParseSettings(configLocation)
	if err != nil {
		if os.Getenv("NIXOS_CLI_SUPPRESS_NO_SETTINGS_WARNING") == "" {
			log.Error(err)
			log.Warn("proceeding with defaults only, you have been warned")
		}

		cfg = settings.NewSettings()
	}

	errs := cfg.Validate()
	for _, err := range errs {
		log.Warn(err.Error())
	}

	cmdCtx = settings.WithConfig(cmdCtx, cfg)

	cmd := cobra.Command{
		Use:                        "nixos {command} [flags]",
		Short:                      "nixos-cli",
		Long:                       "A tool for managing NixOS installations",
		Version:                    build.Version(),
		SilenceUsage:               true,
		SuggestionsMinimumDistance: 1,
		CompletionOptions: cobra.CompletionOptions{
			DisableDefaultCmd: true,
		},
		PersistentPreRunE: func(cmd *cobra.Command, args []string) error {
			for key, value := range opts.ConfigValues {
				err := cfg.SetValue(key, value)
				if err != nil {
					return fmt.Errorf("failed to set %v: %w", key, err)
				}
			}

			errs := cfg.Validate()
			for _, err := range errs {
				log.Warn(err.Error())
			}

			// Now that we have the real color settings from parsing
			// the configuration and command-line arguments, set it.
			//
			// Precedence of color settings:
			// 1. -C flag -> true
			// 2. NO_COLOR=1 -> false, fatih/color already takes this into account
			// 3. `color` setting from config (default: true)
			if opts.ColorAlways {
				color.NoColor = false
				log.RefreshColorPrefixes()
			} else if os.Getenv("NO_COLOR") == "" {
				color.NoColor = !cfg.UseColor
				log.RefreshColorPrefixes()
			}

			return nil
		},
	}

	cmd.SetContext(cmdCtx)

	cmd.SetHelpCommand(&cobra.Command{Hidden: true})
	cmd.SetUsageTemplate(helpTemplate)

	boldRed := color.New(color.FgRed).Add(color.Bold)
	cmd.SetErrPrefix(boldRed.Sprint("error:"))

	cmd.Flags().BoolP("help", "h", false, "Show this help menu")
	cmd.Flags().BoolP("version", "v", false, "Display version information")

	cmd.PersistentFlags().BoolVar(&opts.ColorAlways, "color-always", false, "Always color output when possible")
	cmd.PersistentFlags().StringToStringVar(&opts.ConfigValues, "config", map[string]string{}, "Set a configuration `key=value`")

	_ = cmd.RegisterFlagCompletionFunc("config", settings.CompleteConfigFlag)

	cmd.AddCommand(activateCmd.ActivateCommand())
	cmd.AddCommand(applyCmd.ApplyCommand(cfg))
	cmd.AddCommand(completionCmd.CompletionCommand())
	cmd.AddCommand(enterCmd.EnterCommand())
	cmd.AddCommand(featuresCmd.FeatureCommand())
	cmd.AddCommand(generationCmd.GenerationCommand())
	cmd.AddCommand(infoCmd.InfoCommand())
	cmd.AddCommand(initCmd.InitCommand())
	cmd.AddCommand(installCmd.InstallCommand())
	cmd.AddCommand(manualCmd.ManualCommand())
	cmd.AddCommand(optionCmd.OptionCommand())
	cmd.AddCommand(replCmd.ReplCommand())

	for alias, resolved := range cfg.Aliases {
		err := addAliasCmd(&cmd, alias, resolved)
		if err != nil {
			log.Warnf("failed to add alias '%v': %v", alias, err.Error())
		}
	}

	carapace.Gen(cmd.Root())

	return &cmd, nil
}

func Execute() {
	cmd, err := mainCommand()
	if err != nil {
		os.Exit(1)
	}

	if err = cmd.Execute(); err != nil {
		os.Exit(1)
	}
}
</file>

<file path="doc/man/nixos-cli-activate.1.scd">
NIXOS-CLI-ACTIVATE(1)

# NAME

nixos activate - run activation routines for a NixOS system

# SYNOPSIS

*nixos activate* <ACTION> [options]

# DESCRIPTION

Run activation routines for a given NixOS system.

This command handles migrating (switching) between built NixOS configurations,
built from a NixOS configuration's _config.system.build.toplevel_ build output.

If ran directly by a user, the switch script, located at
_/run/current-system/bin/switch-to-configuration_, will be executed. If using
the activation interface NixOS module, this calls back out to _nixos activate_
with the correct parameters for the given generation.

This activation script is mostly backwards-compatible with the existing
_switch-to-configuration-ng_ script that is provided in upstream _nixpkgs_.

This is a low-level command, and should be regarded accordingly.

# ARGUMENTS

*ACTION*
	The activation routine to run.

	Can be exactly one of the following values:

	- *boot* - Generate boot entries and make this the default configuration
	- *check* - Run pre-activation checks and exit
	- *dry-activate* - Show what would be activated but do not perform it
	- *switch* - Activate this configuration, generate entries, and make this
	  the default configuration
	- *test* - Activate this configuration, but do not generate boot entries

# OPTIONS

*-s*, *--specialisation* <NAME>
	Activate a specialisation *NAME* from the available specialisations.

	If none are provided, then the base configuration without specialisations
	is assumed. Check *nixos-cli-settings(5)* for more information.

	This is only available in user-direct invocation mode, to figure out which
	specialisation to use, and does not exist during actual activation mode.

*-h*, *--help*
	Show the help message for this command.

# SEE ALSO

*nixos-cli-apply(1)*

*nixos-cli-env*(5)

# AUTHORS

Maintained by the *nixos-cli* team. See the main man page *nixos-cli(1)* for
details.
</file>

<file path="doc/man/nixos-cli-apply.1.scd">
NIXOS-CLI-APPLY(1)

# NAME

nixos apply - build and/or activate a NixOS configuration

# SYNOPSIS

*nixos apply* [FLAKE-REF] [options]

# DESCRIPTION

Build and activate a NixOS system configuration.

This command performs the equivalent of evaluating the NixOS module system,
building the system configuration, and activating the resulting derivation.
It may also install the bootloader and manage boot entries, depending on
provided options.

This command behaves slightly differently based on if it is flake-enabled
or not, and this requirement will be specified for the relevant options
and sections.

# EXAMPLES

Many behaviors are similar to the _nixos-rebuild_ command of old. Here are some
common commands, alongside their _nixos-rebuild_ equivalents.

_`nixos-rebuild switch`_

	*nixos apply*

_`nixos-rebuild switch`_, without interactive confirmation

	*nixos apply -y*

_nixos-rebuild switch_, on an arbitrary flake ref (for flake-enabled CLIs only)

	*nixos apply "github:water-sucks/nixed#CharlesWoodson"*

_nixos-rebuild test_

	*nixos apply --no-boot*

_`nixos-rebuild vm[-with-bootloader]`_

	*nixos apply --vm[-with-bootloader] --output ./vm*

_nixos-rebuild boot_

	*nixos apply --no-activate*

_nixos-rebuild dry-activate_

	*nixos apply --dry*

_nixos-rebuild dry-build_

	*nixos apply --dry --no-activate --no-boot --output ./result*

Many other behaviors for _nixos-rebuild_ are in the *nixos generation*
command tree. See *nixos-cli-generation(1)* for details.

## Rollback

In rare cases, automatic rollback is performed on the system profile when
activation fails.

In order to disable this behavior for known working configurations (such as when
reboot is required for a successful activation or daemon restart), use the
global *--config* flag as such:

	*nixos --config auto_rollback=false apply [options]*

# ARGUMENTS

*FLAKE-REF*
	Specify an explicit flake ref with a NixOS configuration. Only available
	on flake-enabled CLIs.

	See *nixos-config-env(5)* for the proper flake ref format.

	Default: *$NIXOS_CONFIG*

# OPTIONS

*-d*, *--dry*
	Perform a dry run. Show what would be built or executed without making
	changes.

	Cannot be specified alongside **--output**.
	
	There are two modes of dry-ness: dry activation and dry builds.

	Dry builds are Nix builds that show what will be built. On the other hand,
	dry activations show what will be ran in the activation script, and require
	a real configuration to be built beforehand.

	Dry builds of the configuration can be achieved by passing *--no-activate*
	and *--no-build*, as well as *--output*. If any of these options are not
	passed, then dry activation is assumed.

	The list of changes is not guaranteed to be complete for dry activations.

*--install-bootloader*
	(Re)install the bootloader to the configured target device(s). The
	bootloader configuration is managed by their NixOS modules, so this behavior
	will vary depending on the relevant NixOS configuration options.

*--no-activate*
	Do not run activation scripts. Useful for setting up a system to boot later,
	or for build-only runs.

*--no-boot*
	Skip registering the generation as a boot entry. Useful for testing a NixOS
	system configuration, or for build-only runs.

*-o*, *--output* <PATH>
	Symlink the result of the build to the given *PATH*.

*-p*, *--profile-name* <NAME>
	Specify the Nix profile *NAME* used for tracking generations.

	Default: *system*

*-s*, *--specialisation* <NAME>
	Activate a specialisation *NAME* from the available specialisations.

	If none are provided, then the base configuration without specialisations
	is assumed unless there is a default one specified in
	*apply.specialisation*. Check *nixos-cli-settings(5)* for more information.

	This requires activation, and as such, conflicts with the *--no-activate*
	option.

*-t*, *--tag* <DESCRIPTION>
	Tag this generation with the given *DESCRIPTION*.

	Useful for identifying its purpose later.

	This option may require *--impure* to be passed for flake configurations,
	unless *apply.imply_impure_with_tag* is set to _true_ in the settings. This
	is due to the internal implementation that uses an environment variable to
	pass it to the Nix configuration.

	Additionally, a tag may be inferred from Git commit messages if the
	option *apply.use_git_commit_msg* is enabled. This only works for local
	paths, and will not work with remote flake refs.

*--upgrade*
	Upgrade the root user's _nixos_ Nix channel before building the
	configuration, as well as any Nix channels with a file named
	_.update-on-nixos-rebuild_ in it.

	This option only exists for legacy CLIs, rather than flake-enabled ones.

*--upgrade-all*
	Like *--upgrade*, but for all of the root user's Nix channels.

	This option only exists for legacy CLIs, rather than flake-enabled ones.

*--use-nom*
	Use *nix-output-monitor* (_nom_) to display build progress.

	Requires that _nom_ is installed and available in the *$PATH*.

*-v*, *--verbose*
	Enable verbose logging during the operation.

*--vm*
	Instead of activating the configuration, build a NixOS VM boot script.

*--vm-with-bootloader*
	Like *--vm*, but includes the bootloader setup in the generated VM script.

	Only set one or the other, not both.

*-y*, *--yes*
	Automatically confirm activation steps, skipping interactive prompts.

*-h*, *--help*
	Show the help message for this command.

# NIX OPTIONS

*nixos apply* accepts some Nix options and passes them through to their relevant
Nix invocations.

The following options are supported:

- *--quiet*
- *--print-build-logs*, *-L*
- *--no-build-output*, *-Q*
- *--show-trace*
- *--keep-going*, *-k*
- *--keep-failed*, *-K*
- *--fallback*
- *--refresh*
- *--repair*
- *--impure*
- *--offline*
- *--no-net*
- *--max-jobs*, *-j*
- *--cores*
- *--builders*
- *--log-format*
- *--include*, *-I*
- *--option* <KEY=VALUE> (single argument, separated by an = sign)

*--option* is specified slightly differently; for *nixos-cli* to pass it through
properly, pass the option key and value as a single argument, rather than as two
separate arguments in the actual Nix CLI.

The following options are supported on flake-enabled CLIs:

- *--recreate-lock-file*
- *--no-update-lock-file*
- *--no-registries*, *--no-use-registries*
- *--commit-lock-file*
- *--update-input*
- *--override-input* <INPUT=VALUE>

*--override-input* is specified slightly differently; for *nixos-cli* to pass it
through properly, pass the input name and value as a single argument, rather
than as two arguments in the actual Nix CLI.

# SEE ALSO

*nixos-cli-generation(1)*

*nixos-cli-option(1)*

*nix3-build*(1), *nix-build(1)*

*nix-env(1)*

*nixos-cli-env*(5)

# AUTHORS

Maintained by the *nixos-cli* team. See the main man page *nixos-cli(1)* for
details.
</file>

<file path="doc/man/nixos-cli-enter.1.scd">
NIXOS-CLI-ENTER(1)

# NAME

nixos-enter - enter a NixOS chroot environment

# SYNOPSIS

*nixos enter* [options] [-- ARGS...]

# DESCRIPTION

Enter a chroot environment rooted at the specified NixOS installation directory.
This is primarily used for post-installation repair, debugging, or activating a
configuration in an isolated environment.

By default, the command enters _/mnt_ unless another root is specified with
*--root*.

You can execute commands within the chrooted shell using *--command* or by
passing positional arguments after a double dash (`--`).

# EXAMPLES

Enter a chroot in _/path_ and get a login root shell:

	*nixos enter --root /path*

Enter a chroot rooted at _/mnt_ by default, and run a single command (no shell):

	*nixos enter -- ls /etc/nixos*

Enter a different system root with a custom system derivation closure path:

	*nixos enter --system /nix/store/NIX_STORE_HASH/nixos-system...*

Run a command in a chrooted Bash shell and exit:

	*nixos enter --command "nixos-rebuild switch"*

# OPTIONS

*-c*, *--command* <STRING>
	Execute the provided *STRING* in a Bash login shell after entering the
	chroot environment.

	Takes precedence over positional arguments for the command to execute.

*-r*, *--root* <PATH>
	Specify the root *PATH* of the NixOS system to enter.

	Default: */mnt*

*--system* <PATH>
	Manually specify the NixOS system configuration closure *PATH* to activate
	inside the chroot.

*-s*, *--silent*
	Suppress output from the activation scripts and other spurious logging.

*-v*, *--verbose*
	Show verbose logging and diagnostic output during entry and activation.

*-h*, *--help*
	Show the help message for this command.

# ARGUMENTS

*[ARGS...]*
	If provided, arguments are interpreted as the command to execute in the
	environment. Must be preceded by a double dash (`--`) to separate invoked
	command options from *nixos enter* options.

	If *--command* is specified, these arguments will be ignored.

# SEE ALSO

*nixos-apply*(1)

*nixos-install*(1)

*chroot*(1)

# AUTHORS

Maintained by the *nixos-cli* team. See the main man page *nixos-cli(1)* for
details.
</file>

<file path="doc/man/nixos-cli-env.5.scd">
NIXOS-CLI-ENV(5)

# NAME

nixos-cli-env - environment variables used by *nixos-cli*

# DESCRIPTION

The *nixos-cli* tool is influenced by a number of environment variables. These
allow the user to configure the CLI's behavior at runtime, such as:

- Default inputs
- Formatting preferences

Among other things.

# ENVIRONMENT VARIABLES

*NO_COLOR*
	Disable colored output in *nixos-cli*.

	Does not apply to terminal user interfaces (TUIs), which manage their own
	display logic.

*NIXOS_CLI_CONFIG*
	Specify a custom path for the *nixos-cli* settings file. 

	Default: */etc/nixos-cli/config.toml*

*NIXOS_CONFIG*
	Defines the configuration that *nixos-cli* will operate on.
	Its meaning depends on whether the CLI is built with flake support.

	This environment variable takes precedence over the *config_location*
	setting if it is set.

	*Flake-enabled CLIs:*
		This must be a valid flake ref (e.g., */home/user/config* or
		*github:myorg/nixos-config#attr*).

		Flake refs without a local path may have slightly different behavior,
		such as not supporting implicit Git operations. Check relevant man pages
		for more information.

		If a flake ref is a path, it _MUST_ be absolute. Use *realpath(1)* if
		you must.

		Additionally, flake refs will usually be expanded when necessary.
		For example, the following flake ref:

			_github:water-sucks/nixed#CharlesWoodson_

		will get expanded to the following flake ref and attribute:

			_github:water-sucks/nixed#nixosConfigurations.CharlesWoodson_

		If the ref does not have text after the "#", then the NixOS system
		attribute name will be inferred to be the current system's hostname.

	*Legacy CLIs:*
		This can be a path to a configuration file directly
		(*configuration.nix*), or a directory containing a *default.nix*.

		Legacy configurations can also be sourced from the *$NIX_PATH*
		environment variable, if the _nixos-config=<PATH>_ attribute is
		specified there.

*NIXOS_GENERATION_TAG*
	A description for the generation. Usually set by default through the *-t*
	flag in *nixos apply* for child commands.

*NIXOS_CLI_DISABLE_STEPS*
	Disable showing visual steps with the logger. These "steps" get converted to
	information logs internally if this is set.

	Mostly useful for internal implementation, rather than for end-users.

*NIXOS_CLI_SUPPRESS_NO_SETTINGS_WARNING*
	Suppress the settings warning. Useful for non-NixOS systems where there is
	no settings file configured by default and the warnings get noisy/clutter
	logs.

*NIXOS_NO_CHECK*
	_nixos activate_ skips running its pre-switch checks if this is set to 1.

*NIXOS_NO_SYNC*
	_nixos activate_ skips syncing the Nix store to disk before activating. Can
	speed up activations at the cost of risking data loss if interrupted.

*STC_DISPLAY_ALL_UNITS*
	Show all actual units that are being modified by _nixos activate_.

## DEVELOPMENT MODE VARIABLES

These variables are useful to know about for developers working on this CLI only.

Do not set directly unless running this in development.

*NIXOS_CLI_ATTEMPTING_ACTIVATION*
	Used to control _nixos activate_'s execution, and prevent it from infinitely
	recursing when a user invokes it directly.

*NIXOS_CLI_DEBUG_MODE*
	Show log messages for when developing TUIs. Only useful for during
	development.

*\_\_NIXOS_SWITCH_TO_CONFIGURATION_PARENT_EXE*
	Set to prevent user activation invocations from infinitely recursing.

	If this is not set correctly to the running executable during user
	switching, then it is not being executed correctly and must immediately
	exit.

# SEE ALSO

*nixos-cli-config(5)*

# AUTHORS

Maintained by the *nixos-cli* team. See the main man page *nixos-cli(1)* for
details.
</file>

<file path="doc/man/nixos-cli-features.1.scd">
NIXOS-CLI-FEATURES(1)

# NAME

nixos features - show metadata about the application and configured options

# SYNOPSIS

*nixos features* [options]

# DESCRIPTION

The *nixos features* command displays metadata about the current build of the
*nixos-cli* application. This includes version information, enabled features,
environment details such as the detected Nix version, and relevant build-time
configuration.

This command is particularly useful for:

- Understanding capabilities of the current *nixos-cli* binary
- Diagnostics for reporting issues
- Debugging issues with the current installation

# OPTIONS

*-j*, *--json*
	Output all metadata in machine-readable JSON format.

*-h*, *--help*
	Show the help message for this command.

# AUTHORS

Maintained by the *nixos-cli* team. See the main man page *nixos-cli(1)* for
details.
</file>

<file path="doc/man/nixos-cli-generation-delete.1.scd">
NIXOS-CLI-GENERATION-DELETE(1)

# NAME

nixos generation delete - delete NixOS generations from this system

# SYNOPSIS

*nixos generation delete* [options] [GEN...]

# DESCRIPTION

Delete NixOS generations from this system based on a flexible set of
constraints.

You can specify individual generation numbers or combine options to tailor which
generations are deleted; the order of operations for these options is defined
below the options and arguments.

# EXAMPLES

Delete all generations older than 30 days but keep generation #42:

	*nixos generation delete --older-than '30d' --keep 42*

Delete generations from 42-69 (inclusive) and ensure that 5 generations remain:

	*nixos generation delete --from 42 --to 69 --min 5*

Delete all generations starting from 25 and ensure that 32 is always kept; also
delete 22 explicitly at the same time:

	*nixos generation delete 22 --from 25 --keep 25*

# OPTIONS

*-a*, *--all*
	Delete all generations except the current one.

*-f*, *--from* <GEN>
	Delete all generations after generation number *GEN*, inclusive.

	This will go all the way up to the latest generation number if not
	accompanied by the *--to* parameter, which sets an upper bound.

*-h*, *--help*
	Show the help message for this command.

*-k*, *--keep* <GEN>
	Always keep the specified generation number *GEN*. This option can be
	specified multiple times.

*-m*, *--min* <NUM>
	Ensure that a minimum of *NUM* generations _always_ exists.

*-o*, *--older-than* <DURATION>
	Delete all generations older than *DURATION*. The *DURATION* value is a
	*systemd.time(7)*-formatted time span, such as *"30d 2h 1m"*.

	For more information, see the *systemd.time(7)* man page.

*-p*, *--pattern* <REGEX>
	Delete all generations that have a tag/description match *REGEX*.

	The *REGEX* value is a Go-formatted regular expression using RE2
	syntax, which is roughly a subset of PCRE regular expression syntax.

	For more information, see https://github.com/google/re2/wiki/Syntax.

*-t*, *--to* <GEN>
	Delete all generations until generation number *GEN*, inclusive.

	This will go all the way down to the earliest generation number if not
	accompanied by the *--from* parameter, which sets a lower bound.

*-v*, *--verbose*
	Enable verbose logging.

*-y*, *--yes*
	Automatically confirm generation deletion without any interactive prompt.

# ARGUMENTS

*[GEN]...*
	One or more specific generation numbers to delete. These can be used
	alongside the options for more fine-grained control, but are optional.


Options and arguments can be combined ad-hoc to create complex filtering
constraints.

# ORDER OF OPERATIONS

The order of evaluating generations to delete vs. which ones to keep is this,
from most prioritized to least prioritized:

	- *--min*
	- *--keep*
	- *[GEN...]* positional args
	- *--all*
	- *--pattern*
	- *--from* + *--to*
	- *--older-than*

And for any range where the generation numbers to keep can be ambiguous, the
most recent generations will be kept.

# SEE ALSO

*nixos-cli-generation(1)*

*systemd.time(7)*

# AUTHORS

Maintained by the *nixos-cli* team. See the main man page *nixos-cli(1)* for
details.
</file>

<file path="doc/man/nixos-cli-generation-diff.1.scd">
NIXOS-CLI-GENERATION-DIFF(1)

# NAME

nixos generation diff - display differences between two generations

# SYNOPSIS

*nixos generation diff* [BEFORE] [AFTER] [options]

# DESCRIPTION

Compare two NixOS system generations and show which paths differ between them.
This can help users understand what changed between deployments.

Both generation numbers must exist and belong to the same profile.

The output highlights differing store paths or system configuration files
between the two specified generations.

The diff command that is ran can be one of two options:

	- *nix store diff-closures* (default)
	- *nvd*, which has prettier output (if the setting _use_nvd_ is set and
	if it is installed)

# OPTIONS

*-h*, *--help*
	Show the help message for this command.

*-v*, *--verbose*
	Enable verbose logging, including more detailed output of differing paths.

# ARGUMENTS

*BEFORE*
	Generation number to compare from.

*AFTER*
	Generation number to compare against.

# SEE ALSO

*nixos-generation(1)*

*nixos-cli-generation-list(1)*

*nix3-store-diff-closures(1)*

# AUTHORS

Maintained by the *nixos-cli* team. See the main man page *nixos-cli(1)* for
details.
</file>

<file path="doc/man/nixos-cli-generation-list.1.scd">
NIXOS-CLI-GENERATION-LIST(1)

# NAME

nixos generation list - list available generations on a NixOS machine

# SYNOPSIS

*nixos generation list* [options]

# DESCRIPTION

List all generations in the current NixOS profile, along with relevant metadata
such as generation number, timestamp, and description.

This command provides both programmatic output formats and an interactive
TUI that can be used to view generations with ease.

By default, this command launches the TUI.

- Use the arrow keys or _hjkl_ to navigate through generations.
- Type _/_ to search by generation number or description.
- Press _<Enter>_ to switch to a given generation.
- Press _<Space>_ to mark generations for deletion (except the current one).
- Press _d_ to delete all marked generations.
- Press _<Ctrl+C>_ or _q_ to exit.

This interface is designed to make reviewing and managing system generations
faster and more user-friendly.

# EXAMPLES

Extract just the generation numbers using *jq*:

	*nixos generation list -j | jq '.[].number'*

List generations in table format without the interactive UI:

	*nixos generation list -t*

Extract just the generation numbers using *cut* from table output:

	*nixos generation list -t | cut -d ' ' -f 1*

# OPTIONS

*-h*, *--help*
	Show the help message for this command.

*-j*, *--json*
	Display the generation list in JSON format. Suitable for scripts or machine
	parsing.

*-t*, *--table*
	Display the generation list in a *grep*-pable table format. Also suitable
	for scripts where JSON parsing is not available.

# SEE ALSO

*nixos-cli-generation-diff(1)*

*nixos-cli-generation-delete(1)*

*nixos-cli-generation-rollback(1)*

*nixos-cli-generation-switch(1)*

# AUTHORS

Maintained by the *nixos-cli* team. See the main man page *nixos-cli(1)* for
details.
</file>

<file path="doc/man/nixos-cli-generation-rollback.1.scd">
NIXOS-CLI-GENERATION-ROLLBACK(1)

# NAME

nixos generation rollback - rollback to the previous NixOS generation

# SYNOPSIS

*nixos generation rollback* [options]

# DESCRIPTION

Rollback to the previous NixOS generation number, if it exists. Similar to
*nixos generation switch*, except the generation number is not required, and
as such, is a little more ergonomic to use in most situations where a rollback
is required.

*NOTE*: This only relies on the number to determine the last generation that was
activated; as such, it does not actually rollback to the last generation
number that was switched to, since there is no record of this.

Useful for rolling back to a known good state or testing previous
configurations.

# OPTIONS

*-d*, *--dry*
	Show what would be activated, but do not perform any actual activation.

	Equivalent to running *switch-to-configuration* manually with the
	*dry-activate* command.

*-h*, *--help*
	Show the help message for this command.

*-s*, *--specialisation* <NAME>
	Activate a specific specialisation *NAME* within the selected generation.

	If the default specialisation is specified in the *nixos-cli* configuration
	for this generation number, and this option is not specified, it will switch
	to that specialisation automatically, rather than using the base one.

*-v*, *--verbose*
	Show verbose logging during activation.

*-y*, *--yes*
	Automatically confirm the generation switch, without prompting.

# SEE ALSO

*nixos-cli-generation-list*(1)

*nixos-cli-generation-switch*(1)

*nixos-cli-apply(1)*

# AUTHORS

Maintained by the *nixos-cli* team. See the main man page *nixos-cli(1)* for
details.
</file>

<file path="doc/man/nixos-cli-generation-switch.1.scd">
NIXOS-CLI-GENERATION-SWITCH(1)

# NAME

nixos generation switch - activate an arbitrary existing NixOS generation

# SYNOPSIS

*nixos generation switch* [GEN] [options]

# DESCRIPTION

Activate a specific, already-existing NixOS generation by its generation number.

Useful for rolling back to a known good state or testing previous
configurations.

# EXAMPLES

Switch to generation 42 with confirmation prompt:

	*nixos generation switch 42*

Dry-run switch to generation 35:

	*nixos generation switch 35 -d*

Switch to generation 18 and automatically confirm:

	*nixos generation switch 18 -y*

Switch to a given specialisation within generation 25:

	*nixos generation switch 25 -s "minimal"*

# OPTIONS

*-d*, *--dry*
	Show what would be activated, but do not perform any actual activation.

	Equivalent to running *switch-to-configuration* manually with the
	*dry-activate* command.

*-h*, *--help*
	Show the help message for this command.

*-s*, *--specialisation* <NAME>
	Activate a specific specialisation *NAME* within the selected generation.

	If the default specialisation is specified in the *nixos-cli* configuration
	for this generation number, and this option is not specified, it will switch
	to that specialisation automatically, rather than using the base one.

*-v*, *--verbose*
	Show verbose logging during activation.

*-y*, *--yes*
	Automatically confirm the generation switch, without prompting.

# ARGUMENTS

*[GEN]*
	The number of the generation to activate.

	This must be an existing generation in the selected NixOS profile.

# SEE ALSO

*nixos-cli-generation-list*(1)

*nixos-cli-generation-rollback*(1)

*nixos-cli-apply(1)*

# AUTHORS

Maintained by the *nixos-cli* team. See the main man page *nixos-cli(1)* for
details.
</file>

<file path="doc/man/nixos-cli-generation.1.scd">
NIXOS-CLI-GENERATION(1)

# NAME

nixos generation - manage NixOS generations on this machine

# SYNOPSIS

*nixos generation* [command] [options]

# DESCRIPTION

The *nixos generation* command provides subcommands for managing NixOS system
generations.

This is the other component to *nixos apply* that replaces the existing
*nixos-rebuild(1)* command's functionality.

Generations are snapshots of system configurations that can be listed,
activated, compared, or deleted in the same way as any other Nix closure.

As such, this command allows you to explore previous system states, switch
between them, or inspect changes across generations.

# EXAMPLES

Examples are provided in each subcommand's respective man page.

# COMMANDS

*delete*
	Delete one or more generations from the specified profile based on a range
	of constraints.

*diff*
	Show differences between two generations, such as package changes or option
	modifications.

*list*
	List all generations available in the system profile.

*rollback*
	Activate the generation prior to the current one.

*switch*
	Activate a specified existing generation.

# OPTIONS

*-p*, *--profile* <NAME>
	Specify the system profile *NAME* to operate on; this should contain all
	the generations that will be worked with.

	Default: *system*

*-h*, *--help*  
	Show the help message for this command.

# SEE ALSO

*nixos-cli-generation-delete*(1)

*nixos-cli-generation-diff*(1)

*nixos-cli-generation-list*(1)

*nixos-cli-generation-rollback*(1)

*nixos-cli-generation-switch*(1)

*nixos-cli-apply(1)*

# AUTHORS

Maintained by the *nixos-cli* team. See the main man page *nixos-cli(1)* for
details.
</file>

<file path="doc/man/nixos-cli-info.1.scd">
NIXOS-CLI-INFO(1)

# NAME

nixos info - show information about the currently running NixOS generation

# SYNOPSIS

*nixos info* [options]

# DESCRIPTION

The *nixos info* command displays metadata about the currently active NixOS
generation.

This includes generation number, activation time, system profile, and
configuration details.

It can be useful for diagnostics, system reporting, or to confirming that a
deployment has succeeded.

Currently, this command only shows the generation number when using the
_system_ profile, due to the fact that there is no reliable way to tell
what profile is being used.

# OPTIONS

*-h*, *--help*
	Show the help message for this command.

*-j*, *--json*
	Output the information as a structured JSON object.

*-m*, *--markdown*
	Format the output as Markdown, useful for pasting into issue reports or
	documentation.

# SEE ALSO

*nixos-cli-generation-list(1)*

# AUTHORS

Maintained by the *nixos-cli* team. See the main man page *nixos-cli(1)* for
details.
</file>

<file path="doc/man/nixos-cli-init.1.scd">
NIXOS-CLI-INIT(1)

# NAME

nixos init - initialize a NixOS configuration template and/or hardware options

# SYNOPSIS

*nixos init* [options]

# DESCRIPTION

The *nixos init* command scaffolds a basic NixOS configuration in the specified
root directory and/or updates hardware configurations depending on what is
detected on the system.

It is primarily used before a system installation to create an initial
_configuration.nix_ and hardware settings, or after installation to
automatically update a given hardware configuration.

Two files are generated for all systems:

_/path/to/configuration.nix_
	A main NixOS system configuration module. Only generated when it does not
	exist, unless *--force* is passed.

_/path/to/hardware_configuration.nix_
	A module that sets NixOS configuration options based on the current
	hardware and filesystems that are detected. Examples of these types of
	configurations include
		- Kernel modules required for the hardware
		- Detected filesystems
		- Detected swap partitions
		- _initrd_ options for booting the system

	This gets regenerated, and shouldn't be touched much, since changes are
	overwritten each time this command is ran.

Depending on if the CLI is flake-enabled, a _flake.nix_ file may also be
generated for new configurations.

# EXAMPLES

Create a new NixOS configuration in /mnt for installation:

	*nixos init --root /mnt*

Print a NixOS hardware configuration module to stdout and redirect to a file:

	*nixos init --show-hardware-config > path/to/hwconfig.nix*

# OPTIONS

*-d*, *--dir* _path_
	Directory inside the root where configuration files will be written.

	This gets concatenated to the *--root* option, so paths will take the form
	of _/mnt/etc/nixos_ if *--root* is _/mnt_

	Default: */etc/nixos*

*-f*, *--force*
	Forcefully generate all configuration files, overwriting any existing ones
	for _configuration.nix_ (and _flake.nix_, if applicable).

*-h*, *--help*
	Show the help message for this command.

*-n*, *--no-fs*
	Skip generation of _fileSystems_ and _swapDevices_ configuration options.

	Useful if disk options are to be managed separately/manually, such as
	through external modules.

*-r*, *--root* <PATH>
	Treat *PATH* as the root directory of the system.

	Default: */*

*-s*, *--show-hardware-config*
	Print the generated hardware configuration to stdout and exit.

	No files will be written when this option is used.

# SEE ALSO

*nixos-cli-install(1)*

# AUTHORS

Maintained by the *nixos-cli* team. See the main man page *nixos-cli(1)* for
details.
</file>

<file path="doc/man/nixos-cli-install.1.scd">
NIXOS-CLI-INSTALL(1)

# NAME

nixos install - install a NixOS system from a provided configuration

# SYNOPSIS

*nixos install* [FLAKE-REF] [options]

# DESCRIPTION

*nixos install* installs a NixOS system by:

	- Initialize the Nix store and copy an initial _nixos_ channel
	- Building and creating an initial generation on the target mountpoint
	- Installing a bootloader if configured
	- Setting a root password

The installed configuration will depend on if the CLI is flake-enabled or not.

If the CLI is flake-enabled:
	- The *[FLAKE-REF]* argument is _required_, and must point to a valid
	  flake reference with a NixOS configuration.
Otherwise:
	- The *$NIXOS_CONFIG* variable must point to a valid NixOS configuration
	  module or a directory containing a _default.nix_ with the same.
	- OR the target root must have a file at _/etc/nixos/configuration.nix_

The installation will take place relative to a specified root directory
(defaults to `/mnt`). Mountpoints and all other filesystems must be mounted
in the correct place prior to installation, or they will not exist on the
target system.

*nixos install* is idempotent, and as such, can be used to re-install broken
NixOS systems without needing to wipe filesystems first, in most cases. That
means this command can be re-run if problems arise during installation, and
can also be ran on already-existing NixOS installations.

In the future, remote installations will be supported. Look to the release page
on GitHub for when this feature comes out.

# EXMAPLES

In order to create a fresh NixOS installation, mountpoints need to be set up
beforehand.

This block of commands will show a typical installation procedure, assuming the
following simple partition layout on a UEFI system:

	/dev/sda1 :: EFI System Partition (512M, FAT32)
	/dev/sda2 :: NixOS root partition (ext4)

Typically, a user will also need to obtain *nixos-cli* in a Nix shell, as it is
not available on traditional NixOS install ISOs or Linux distributions, as of
yet.

Refer to the installation steps in the online manual to obtain the *nixos-cli*
binary in a development shell.

Installation steps:

	_$ mkfs.fat -F 32 /dev/sda1_

	_$ mkfs.ext4 /dev/sda2_

	_$ mount /dev/sda2 /mnt_

	_$ mkdir -p /mnt/boot_

	_$ mount /dev/sda1 /mnt/boot_

	_$ nixos init --root /mnt_

	# Change whatever you will need to in the configuration.

	# For flake-enabled CLIs, use the following invocation:

	_$ nixos install --root /mnt --flake /mnt/etc/nixos#<SYSTEM>_

	# For non-flake CLIs, use the following invocation:

	_$ nixos install --root /mnt_

	# Reboot

Running *nixos enter --root /mnt* in order to inspect the new installation
is also possible, assuming a successful installation.

# ARGUMENTS

*FLAKE-REF*
	Specify an explicit flake ref to evaluate options from. Only available
	on flake-enabled CLIs.

	See *nixos-config-env(5)* for the proper flake ref format.

	The system name is NOT inferred from the hostname, and must be provided
	explicitly after the #.

	There is no fallback, so if this argument is not provided on a flake-enabled
	CLI, the program will fail.

# OPTIONS

*-c*, *--channel* <PATH>
	Use the derivation at *PATH* as the _nixos_ channel to copy to the target
	system.

	If not provided, then the existing _nixos_ channel for the root user on the
	running system will be copied instead. This is usually the case on live
	NixOS USBs or external media used for fresh installations.

*-h*, *--help*
	Show the help message for this command.

*--no-bootloader*
	Do not install the bootloader on the target device.

	For fresh installations, it is recommended not to enable this option.
	Proceed at your own risk.

*--no-channel-copy*
	Do not copy a NixOS channel to the target system.

	This is useful for speeding up installations if the target NixOS channel
	already exists, or if using flake configurations that do not require
	Nix channels configured at all.

	Conflicts with *--channel*.

*--no-root-passwd*
	Skip prompting to set the root password.

	Useful for non-interactive installation, such as in scripts.

*-r*, *--root* <DIR>
	Treat *DIR* as the root directory for installation.

	Default: */mnt*

*-s*, *--system* <PATH>
	Install the system from an already built system closure at *PATH*.

	This is useful for installing multiple systems from the same system closure,
	to avoid repeated _nix build_ calls.

*-v*, *--verbose*
	Enable verbose logging.

# NIX OPTIONS

*nixos apply* accepts some Nix options and passes them through to their relevant
Nix invocations.

The following options are supported:

- *--quiet*
- *--print-build-logs*, *-L*
- *--no-build-output*, *-Q*
- *--show-trace*
- *--keep-going*, *-k*
- *--keep-failed*, *-K*
- *--fallback*
- *--refresh*
- *--repair*
- *--impure*
- *--offline*
- *--no-net*
- *--max-jobs*, *-j*
- *--cores*
- *--log-format*
- *--include*, *-I*
- *--option* <KEY=VALUE> (single argument, separated by an = sign)

*--option* is specified slightly differently; for *nixos-cli* to pass it through
properly, pass the option key and value as a single argument, rather than as two
separate arguments in the actual Nix CLI.

The following options are supported on flake-enabled CLIs:

- *--recreate-lock-file*
- *--no-update-lock-file*
- *--no-registries*, *--no-use-registries*
- *--commit-lock-file*
- *--update-input*
- *--override-input* <INPUT=VALUE>

*--override-input* is specified slightly differently; for *nixos-cli* to pass it
through properly, pass the input name and value as a single argument, rather
than as two arguments in the actual Nix CLI.

# SEE ALSO

*nixos-cli-enter(1)*

*nixos-cli-init(1)*

*nix3-build*(1), *nix-build(1)*

*nix-env(1)*

*nixos-cli-env*(5)

# AUTHORS

Maintained by the *nixos-cli* team. See the main man page *nixos-cli(1)* for
details.
</file>

<file path="doc/man/nixos-cli-manual.1.scd">
NIXOS-CLI-MANUAL(1)

# NAME

nixos manual - open the NixOS manual in a browser

# SYNOPSIS

*nixos manual*

# DESCRIPTION

Opens the NixOS manual in your default web browser.

This command is a convenience wrapper that launches the appropriate URL for the
NixOS manual associated with your configuration. It is especially helpful for
quickly referencing system configuration options and NixOS concepts.

The manual opened is based on the version of Nixpkgs currently in use by your
system, unless the manual is not present on the local system in question.

# ENVIRONMENT

The behavior of this command can be influenced by the *$BROWSERS* environment
variable, which determines which browser is used to open the manual.

If *$BROWSERS* is not set, the command attempts to fall back on a sensible
system default (*xdg-open*).

Examples of `BROWSER` usage:

	*BROWSER=firefox nixos manual*

	*BROWSER=brave nixos manual*

	*BROWSER=w3m nixos manual*

# OPTIONS

*-h*, *--help*
	Show the help message for this command.

# SEE ALSO

*xdg-open(1)*

# AUTHORS

Maintained by the *nixos-cli* team. See the main man page *nixos-cli(1)* for
details.
</file>

<file path="doc/man/nixos-cli-option-tui.1.scd">
NIXOS-CLI-OPTION-TUI(1)

# NAME

nixos option (interactive) - query available NixOS options interactively

# SYNOPSIS

*nixos option* [QUERY]

# DESCRIPTION

*nixos option*, by default, spawns interactive TUI search mode for NixOS
options, unless *-n* is specified.

Refer to *nixos-cli-option(1)* for non-interactive mode usage.

# WINDOW LAYOUT

A purple border means that a given window is active. If a window is active, then
its keybinds will work.

The main windows are the:

- Input/Result List Window
- Preview Window
- Help Window (this one)
- Option Value Window

## Help Window

Use the arrow keys or _h_, _j_, _k_, and _l_ to scroll around.

_<Esc>_ or _q_ will close this help window.

## Option Input Window

Type anything into the input box and all available options that match will be
filtered into a list. Scroll this list with the up or down cursor keys, and the
information for that option will show in the option preview window.

_<Tab>_ moves to the option preview window.

_<Enter>_ previews that option's current value, if it is able to be evaluated.
This will toggle the option value window.

## Option Preview Window

Use the cursor keys or _h_, _j_, _k_, and _l_ to scroll around.

The input box is not updated when this window is active.

_<Tab>_ will move back to the input window for searching.

_<Enter>_ will also evaluate the value, if possible. This will toggle the option
value window.

## Option Value Window

Use the cursor keys or _h_, _j_, _k_, and _l_ to scroll around.

_<Esc>_ or _q_ will close this window.

# SEE ALSO

*nixos-cli-option(1)*

# AUTHORS

Maintained by the *nixos-cli* team. See the main man page *nixos-cli(1)* for
details.
</file>

<file path="doc/man/nixos-cli-option.1.scd">
NIXOS-CLI-OPTION(1)

# NAME

nixos option - query available NixOS module options for this system

# SYNOPSIS

*nixos option* [options] [NAME]

# DESCRIPTION

Display documentation and values for available NixOS configuration options.
This command can be used to inspect how modules influence the system and what
values are currently set for individual options.

By default, *nixos option* will enter an interactive TUI with a search bar.
Non-interactive mode can be specified explicitly using *--non-interactive*/*-n*
or by using the alternative display options *--json* or *--value-only*. When in
non-interactive mode, a specific option name to display details for is required.

See *nixos-cli-option-ui(1)* for information on how the option TUI works.

If the option is found in non-interactive mode, then its details are displayed.
Otherwise, similar options are searched for, and printed if they roughly
match the search query.

# EXAMPLES

Find an option using the UI (starting with an initial search):

	*nixos option "search.for.option.with.this.name"*

Find an option and display its details, non-interactively:

	*nixos option -n \_module.args*

Find an option and obtain the type using structured JSON output and _jq_:

	*nixos option \_module.args -j | jq .type*

Find an option in a different flake ref (assume a flake-enabled CLI):

	*nixos option -n -f "github:MattRStoffel/mixed#nixos-machine" "option.name"*

# OPTIONS

*-h*, *--help*
	Show the help message for this command.

*-f*, *--flake* <REF>
	Specify an explicit flake *REF* to evaluate options from. Only available
	on flake-enabled CLIs.

	If the cache is used to retrieve available options, some options that show
	up may actually not be available on the target configuration.

	Use the *--no-cache* flag to fully evaluate the option set for this
	configuration to avoid this issue.

	See *nixos-config-env(5)* for the proper flake ref format.

	Default: *$NIXOS_CONFIG*

*-j*, *--json*
	Output option data as a JSON object.

	Errors will have an "error" key along with "similar_options" with the
	list of at max 10 items that have been matched.

*-s*, *--min-score* <SCORE>
	Minimum fuzzy match *SCORE* for filtering results. The bigger the number,
	the less search results will appear. However, the results will be more
	relevant as they appear if the score is higher.

	Default: *1*

*--no-cache*
	Disable usage of the prebuilt options cache.

	Disabling the cache means that the index will need to be built, which takes
	time due to Nix evaluation being slow. Use only when the normal option cache
	is not working.

*-n*, *--non-interactive*
	Do not start the interactive search environment. This option is implied
	when *--json* or *--value-only* modes are in use.

*-v*, *--value-only*
	Print only the current value of the selected option.

	Useful for scripts where the option name is needed.

# ARGUMENTS

*NAME*
	The name of the option to look up. If not provided, interactive mode
	is required to explore available options.

# SEE ALSO

*nixos-cli-option-ui(1)*

*nix-instantiate(1)*

*nix3-eval(1)*

# AUTHORS

Maintained by the *nixos-cli* team. See the main man page *nixos-cli(1)* for
details.
</file>

<file path="doc/man/nixos-cli-repl.1.scd">
NIXOS-CLI-REPL(1)

# NAME

nixos repl - start a Nix REPL with the current system's configuration loaded

# SYNOPSIS

nixos repl [FLAKE-REF] [options]

# DESCRIPTION

Launches an interactive Nix expression evaluator (REPL) preloaded with the
NixOS system configuration.

This command is useful for inspecting the configuration programmatically,
querying attributes, or testing expressions in the context of the active system.

If a flake-enabled CLI is in use, a flake ref may be supplied to specify the
configuration to load; otherwise, *$NIXOS_CONFIG* will be used and _must_
contain a valid flake ref.

If not, the environment variable *$NIXOS_CONFIG* will be
used, or the configuration can be passed through setting the *$NIX_PATH*'s
_nixos-config_ attribute properly through *-I* or elsewhere.

# OPTIONS

*-h*, *--help*
	Show the help message for this command.

*-I*, *--include*
	Specify an additional location to search for Nix expressions. This behaves
	like passing *-I* to *nix repl* directly.

	It can be used to add custom search paths, such as
	*-I nixpkgs=/path/to/nixpkgs*.

# ARGUMENTS

*FLAKE-REF*  
	Optional flake reference to load attributes from. If the CLI is not
	flake-enabled, this argument is ignored.

	Default: *$NIXOS_CONFIG*

# SEE ALSO

*nix repl(1)*

*nixos-cli-env(5)*

# AUTHORS

Maintained by the *nixos-cli* team. See the main man page *nixos-cli(1)* for
details.
</file>

<file path="doc/man/nixos-cli-settings.5.scd.template">
NIXOS-CLI-SETTINGS(5)

# NAME

nixos-cli-settings - configuration options for nixos-cli

# DESCRIPTION

This man page documents available configuration keys for the *nixos-cli* tool.

Each setting may be configured through a config file, environment variable, or
command-line flag.

Defaults are noted alongside each option.

For more information about particular commands, run *nixos --help* or refer to
individual command man pages.

# FORMAT

Settings are stored in a configuration file using the TOML format.

The default location for this file is /etc/nixos-cli/config.toml by default,
but this can be overridden by the *$NIXOS_CLI_CONFIG* environment variable.

They can also be defined in a NixOS module that will automatically create
this file, if configured through the 

# OPTIONS

All available settings and their descriptions + default values are located here.

%s

# SEE ALSO

*nixos-cli-env(5)*

# AUTHORS

Maintained by the *nixos-cli* team. See the main man page *nixos-cli(1)* for
details.
</file>

<file path="doc/man/nixos-cli.1.scd">
NIXOS-CLI(1)

# NAME

nixos-cli - a tool for managing NixOS installations

# SYNOPSIS

*nixos* [command] [options]

# COMMANDS

*apply*
	Build and/or activate a NixOS configuration. This includes evaluating the
	NixOS module system, building the system derivation, and switching to the
	new generation.

*enter*
	Enter a chroot environment using a provided NixOS installation root. Useful
	for debugging, performing repairs, or running commands in the target system
	context.

*features*
	Show metadata and features supported by this build of the CLI. This is
	mostly useful for diagnosing issues.

*generation*
	List, remove, or inspect generations of the system. Works similarly to
	_nix-env --list-generations_ but scoped to the NixOS CLI context.

*info*
	Display information about the currently running generation on the local
	system.

*init*
	Initialize a new NixOS configuration in the current directory. This sets up
	a default configuration, likely including hardware discovery and system
	flake scaffolding.

*install*
	Perform a full system install of NixOS, including setting up the target
	drive, copying a configuration, and activating the system.

*manual*
	Open the official NixOS manual in the default browser. This is equivalent to
	navigating to <https://nixos.org/manual> but integrated into the CLI.

*option*
	Query the NixOS option system. This allows searching for options, reading
	their documentation, defaults, types, and current values.

*repl*
	Start a Nix REPL preloaded with the system configuration and modules. Useful
	for experimentation and debugging.

# OPTIONS

*--color-always*
	Always produce colored output when possible. By default, output may be
	auto-detected for TTYs.

*--config <KEY>=<VALUE>*
	Override configuration settings directly on the command line. Multiple
	values can be passed.

	Example: *--config use_nvd=true --config option.prettify=false*

	This only works for simple values such as true/false, string, and number
	values. Settings such as *aliases* or *init.extra_attrs* are not settable
	through this option due to implementation complexity.

*-h, --help*
	Show the help message for this command.

*--version*
	Display the version of the *nixos-cli* tool.

# AUTHORS

Maintained by Varun Narravula <varun@snare.dev>. Up-to-date sources can be
found at https://github.com/nix-community/nixos-cli, and bugs reports or patches
can be submitted to GitHub's issue tracker.

# SEE ALSO

*nixos-cli-apply(1)*

*nixos-cli-enter(1)*

*nixos-cli-features(1)*

*nixos-cli-generation(1)*

*nixos-cli-info(1)*

*nixos-cli-init(1)*

*nixos-cli-install(1)*

*nixos-cli-manual(1)*

*nixos-cli-option(1)*

*nixos-cli-repl(1)*

*nixos-cli-settings(5)*

*nixos-cli-env(5)*
</file>

<file path="doc/src/comparisons.md">
# Comparisons to Existing NixOS Tools

## [`nh`](https://github.com/nix-community/nh)

`nh` is a more popular application in this realm, perhaps because it looked
prettier due to the earlier `nix-output-monitor` and `nvd` integration, and is
significantly older than `nixos-cli`.

However, I prefer to keep the focus on NixOS here, while `nh` tries to be a
unified `rebuild` + `switch` manager for multiple OSes. That's the biggest
difference.

`nixos-cli` also has more features than `nh` for NixOS-based machines, so that's
a plus.

In the future, I may want to write similar CLIs to `nixos-cli` as replacements
for the current `darwin-rebuild` and `home-manager` scripts, but this is purely
imaginative for the time being. My personal belief is that these are
fundamentally separate projects with vaguely similar, but disparate concerns,
and in my opinion, should be kept that way.

## [`nixos-rebuild-ng`](https://github.com/NixOS/nixpkgs/tree/master/pkgs/by-name/ni/nixos-rebuild-ng) + [`switch-to-configuration-ng`](https://github.com/NixOS/nixpkgs/tree/master/pkgs/by-name/sw/switch-to-configuration-ng)

The big differences:

- They mimic the existing `nixos-rebuild.sh` project 1:1 when it comes to
  features
- They're two separate projects still written in two separate languages
- They are developed in the `nixpkgs` tree, so it's harder to track progress

`nixos-cli` intends to go much further than these. The interface is much more
approachable, and the development is done out-of-tree, which makes it easier to
separate concerns.

Also, the plan in the future is to have a `nixos activate` command that is a
self-contained drop-in replacement for `switch-to-configuration` functionality,
rather than being two separate projects. The progress for this is tracked in
[this GitHub issue](https://github.com/nix-community/nixos-cli/issues/55).

Also, the `nixos-rebuild-ng` project is written in Python, which would require a
Python runtime as a builtin dependency for base NixOS systems with it, while
`nixos-cli` only requires the Go compiler.
</file>

<file path="doc/src/contributing.md">
# Contributing

Contributions of all kinds are appreciated! The following are especially
welcome.

## Code Contribution

This is _by far_ the best way to help!

`nixos-cli` is quite a large tool with a very large scope and many moving parts,
so any efforts to ease the burden around implementation and maintenance is
greatly appreciated. Even so-called "drive-by" contributions or features are
also appreciated, as long as they do not result in excessive maintenance burden
later on.

Submit contributions through pull requests, or by emailing them personally to
`varun@snare.dev`, if you do not want to use GitHub. Credit will be preserved.

Please make sure your code is up to standard by running:

- `gofmt` to format Go code
- `golangci-lint` to catch common issues
- `prettier` to format Markdown files

All available dependencies are provided in a Nix development shell.

If your changes modify the CLI or any core behavior, please also update the
relevant `man` pages or documentation in `doc/`. This includes changes to the
following things:

- CLI commands/options
- Settings
- NixOS module options

## Bug Reports

Testing every feature edge-case is hard—especially before full releases.

If you're a brave soul, use the main branch instead of a release version, and
file bug reports by
[opening a new issue](https://github.com/nix-community/nixos-cli/issues) with
the **Bug Report** template. In the bug report, provide:

- A clear description of the problem
  - **IMPORTANT**: What was _expected_ vs. what actually _happened_
- Steps to reproduce the issue
- Your environment (run `nixos features`)
- Any relevant logs, error messages, or images

Clear reports will assist in faster bug fixes!

## Improving Documentation

Nix documentation is notoriously patchy — so help here is _especially_ welcome.

As such, documentation quality is of utmost importance. `nixos-cli` should be a
tool that is both easy to use and powerful in functionality; however, as
powerful as it can be, who cares if that power isn't discoverable?

Documentation lives in two places:

- Markdown files for this website, generated using
  [`mdbook`](https://rust-lang.github.io/mdBook/)
- Manual pages (`man` pages), generated using
  [`scdoc`](https://sr.ht/~sircmpwn/scdoc/)

Refer to the code contribution guidelines when submitting documentation
improvements, or file an issue if the documentation issues are substantial.

## Feature Suggestions

Have an idea for improving NixOS tooling here? Start a discussion or open an
issue!

Discourse around how this can be done is always productive.

The vision is to make this a standard NixOS tool, so all ideas that align with
that scope are welcome. If there’s a new command or sub-tool you’d like to see,
open a GitHub issue or reach out on Matrix. However, try to keep it within scope
of the NixOS project, though.

❌ Features like `home-manager` or `nix-darwin` integration will not be
considered as first-class features. Sorry in advance.

## Community Conduct

All contributors must follow a friendly, respectful code of conduct.

The TL;DR? **Don't be a dick.**

Disagreement is fine, but harassment, rudeness, or discrimination are not
tolerated in any spaces.
</file>

<file path="doc/src/faq.md">
# FAQ

## Do you intend on making this an official NixOS application?

Yes! I will be writing an RFC to see if people are interested in this.

That's my ultimate goal, anyway.

## Aren't there other people doing what you're doing?

Yes! Check the [comparisons](./comparisons.md) page for a listing of there tools
as well as some pros/cons to each one.

## What about `home-manager` and `nix-darwin`? Will you support those systems?

They are fundamentally separate projects with roughly similar surfaces, so no. I
am a heavy user of both projects, though, so I may write my own `darwin` and
`hm` CLIs that roughly mirror this.

Think about this:

- `home-manager` has to work in the user context, while NixOS works in the
  system one.
- `nix-darwin` doesn't interact with boot scripts, while NixOS does.

Among a slew of other differences. The `rebuild` + `switch` workflow may be the
same, but the options are different, and I'm lazy. So no.

## Can the option search work with other sources?

Yes! However, this has been moved to a separate tool called
[`optnix`](https://github.com/water-sucks/optnix).

`nixos option` actually uses `optnix` as a library within its code, so it is
exactly the same UX.

## More questions?

File an issue! Perhaps it's important enough to add to this FAQ as well.
</file>

<file path="doc/src/installation.md">
# Installation

`nixos-cli` is split into two separate executables. This is very intentional for
a number of reasons.

1. The majority of NixOS users use either flakes or legacy-style Nix, without
   mixing the two.
2. While the majority of logic is shared between the two styles of
   configuration, the command-line interface should not be forced to deal with
   the differences, for the sake of clarity.
3. If users want to mix styles, they should do so intentionally. This
   distinction is reflected in the CLI binaries themselves—not hidden in command
   behavior.

The flake-style configuration is the default. Nix flakes have been available for
several years; although still technically experimental, they are widely adopted
and considered stable in practice, particularly in forks like
[Lix](https://lix.systems). Legacy configurations are actively supported
regardless of this status, though.

NixOS has quite a large ecosystem of tools, and can be quite the moving target
in terms of features, so `nixos-unstable` and the current stable release are the
only actively supported releases.

## Adding To Configuration

Use the following sections depending on whether or not your systems are
configured with flakes or legacy-style configurations.

Available configuration settings for `nixos-cli` are defined in the more
detailed [settings](./usage/settings.md) section, and are specified in Nix
attribute set format here. Internally, they are converted to TOML.

### Flakes

`nixos-cli` is provided as a flake input. Add this and the exported NixOS module
to the system configuration.

```nix
{
  inputs.nixos-cli.url = "github:nix-community/nixos-cli";

  outputs = { nixpkgs, nixos-cli, ... }: {
    nixosConfigurations.system-name = nixpkgs.lib.nixosSystem {
      modules = [
        nixos-cli.nixosModules.nixos-cli
        # ...
      ];
    };
  };
}
```

Then, enable the module.

```nix
{ config, pkgs, ... }:

{
  services.nixos-cli = {
    enable = true;
    config = {
      # Whatever settings desired.
    }
  };
}
```

The default package is flake-enabled in this setup, so the
`services.nixos-cli.package` option does not need to be specified.

### Legacy

To use the NixOS module in legacy mode, import the `default.nix` provided in
this repository. An example is provided below with `builtins.fetchTarball`:

```nix
{ config, system, pkgs, ...}:

let
  # In pure evaluation mode, always use a full Git commit hash instead of a branch name.
  nixos-cli-url = "github:nix-community/nixos-cli/archive/GITREVORBRANCHDEADBEEFDEADBEEF0000.tar.gz";
  nixos-cli = import "${builtins.fetchTarball nixos-cli-url}" {inherit pkgs;};
in {
  imports = [
    nixos-cli.module
  ];

  services.nixos-cli = {
    enable = true;
    config = {
      # Other configuration for nixos-cli
    };
  };

  # ... rest of config
}
```

NOTE: By default, importing like this will use the `nixosLegacy` package by
default, so there is no need to specify the `services.nixos-cli.package`
attribute manually in this setup unless overriding something.

## Cache

There is a Cachix cache available. Add the following to your NixOS configuration
to avoid lengthy rebuilds and fetching extra build-time dependencies:

```nix
{
  nix.settings = {
    substituters = [ "https://watersucks.cachix.org" ];
    trusted-public-keys = [
      "watersucks.cachix.org-1:6gadPC5R8iLWQ3EUtfu3GFrVY7X6I4Fwz/ihW25Jbv8="
    ];
  };
}
```

Or if using the Cachix CLI outside a NixOS environment:

```sh
$ cachix use watersucks
```

There are rare cases in which you want to automatically configure a cache when
using flakes, such as when installing NixOS configurations using this tool. The
following configuration in the `flake.nix` can help with this:

```nix
{
  nixConfig = {
    extra-substituters = [ "https://watersucks.cachix.org" ];
    extra-trusted-public-keys = [
      "watersucks.cachix.org-1:6gadPC5R8iLWQ3EUtfu3GFrVY7X6I4Fwz/ihW25Jbv8="
    ];
  };

  inputs = {}; # Whatever you normally have here
  outputs = inputs: {}; # Whatever you normally have here
}
```

⚠️ Beware, though: this is a relatively undocumented feature—use with caution.

## Running Using Nix Shells

Sometimes, you may not want to add it to your configuration, and instead run
`nixos-cli` on an ad-hoc basis.

This is the preferred way to use `nixos-cli` when running `nixos init` or
`nixos install` on a live NixOS USB for installation.

Use `nix develop` (flake-enabled package by default):

```
$ nix shell github:nix-community/nixos-cli
```

Alternative using legacy-style `nix-shell` and the `nixosLegacy` package:

```sh
$ nix-shell -E 'with import (fetchTarball "https://github.com/nix-community/nixos-cli/archive/refs/heads/main.tar.gz") {}; nixosLegacy'
```

## Rebuild

After adding the next sections to your configuration, rebuild your configuration
once, and then the `nixos` command should be available. Verify by running
`nixos features`:

```sh
# Example output of `nixos features`
$ nixos features
nixos 0.13.0-dev
git rev: 53beba5f09042ab8361708a5e0196098d642ba5b
go version: go1.24.1
nix version: nix (Nix) 2.28.2

Compilation Options
-------------------
flake           :: true
nixpkgs_version :: 24.11
```

Nice! `nixos-cli` is now ready for usage.
</file>

<file path="doc/src/introduction.md">
# Introduction - `nixos-cli`

`nixos-cli` is a robust, cohesive, drop-in replacement for NixOS tooling such as
`nixos-rebuild`, among many other tools.

## Why?

NixOS tooling today is fragmented across large, aging shell and other assorted
scripts/projects that are difficult to maintain or extend. Prolific examples
include:

- [`nixos-rebuild.sh`](https://github.com/NixOS/nixpkgs/blob/master/pkgs/os-specific/linux/nixos-rebuild/nixos-rebuild.sh)
  (a mess of convoluted Bash)
- [`switch-to-configuration-ng`](https://github.com/NixOS/nixpkgs/tree/master/pkgs/by-name/sw/switch-to-configuration-ng),
  (a Rust project), as well as the old implementation in Perl

These tools contain deep functionality, but much of it is hidden, hard to
modify, or locked behind poor ergonomics.

`nixos-cli` aims to modernize this experience by:

- Replacing and improving existing tooling
- Providing a consistent interface across all commands
- Making functionality more accessible and extensible
- Offering a clean, discoverable CLI experience for both users and developers

In summary, this tool has one goal: to create a modular NixOS CLI that mirrors
or enhances the functionality of all current NixOS tooling in `nixpkgs`, adds on
to it if needed, and eventually **come to replace it entirely**.

Yes, this is already being done somewhat by `switch-to-configuration-ng` and
`nixos-rebuild-ng`. However, `nixos-cli` strives to achieve further goals,
including (but not limited to the following)

- Enhanced usability (and looking nice! Who doesn't love eye candy?)
- Deeper integration with NixOS internals
- Creating a self-contained NixOS manager binary that includes routine scripts
  such as `switch-to-configuration` activation functionality
- Plugins for further NixOS tooling to be developed out-of-tree

Check the [comparisons](./comparisons.md) page for an overview of how this tool
differs from existing ecosystem tools.

## Key Features

- Drop-in replacements for common NixOS tools (with better names!)
- An integrated NixOS option search UI
- An improved generation manager, with an additional UI (more fine-tuned than
  `nix-collect-garbage -d`)

Check out the [overview](./overview.md) page for more information about key
features.

More features are planned; see the [roadmap](roadmap.md) for more information.

## Status

This tool is under **active development**, but is **not yet stable**.  
Until a 1.0 release, the CLI interface and configuration may change without
notice.

Watch the [Releases](https://github.com/nix-community/nixos-cli/releases) page
for:

- Breaking changes
- Feature updates
- Bug fixes

Core contributors:

- [`@water-sucks`](https://github.com/water-sucks)

Contributions, testing, and bug reports/general feedback are highly encouraged,
since there are few people working on this project actively.

## Talk!

Join the Matrix room at
[#nixos-cli:matrix.org](https://matrix.to/#/#nixos-cli:matrix.org)! It's open
for chatting about NixOS in general, and for making it a better experience for
all that involved.
</file>

<file path="doc/src/module.md">
# Module

These are the available NixOS module options for `nixos-cli`. This is the
preferred way to configure things like settings, and to add the CLI itself to
the `$PATH`.

{{ #include generated-module.md }}
</file>

<file path="doc/src/overview.md">
# Overview

## NixOS Tooling Replacements

`nixos-cli` has drop-in replacements for the following tools:

- `nixos-rebuild` → `nixos apply` + `nixos generation`
- `nixos-enter` → `nixos enter`
- `nixos-generate-config` → `nixos init`
- `nixos-version` → `nixos info`
- `nixos-install` → `nixos install`
- `nixos-info` → `nixos manual`

### `nixos apply` + `nixos generation`

`nixos-rebuild` is primarily used to manage NixOS configurations, but has become
bloated and has some non-obvious behavior.

`nixos-rebuild` commands are replaced entirely by a combination of the
`nixos apply` and `nixos generation` commands, with some better-looking logging,
showing diffs between generations, and interactive confirmation before applying
configurations.

Alternatives to builtin Nix tools are provided that can be switched through the
settings if available; for example:

- [`nix-output-monitor`](https://github.com/maralorn/nix-output-monitor) for
  building configurations
- [`nvd`](https://khumba.net/projects/nvd/) for showing generation diffs

A list of analogues to `nixos-rebuild` behavior:

```sh
# `nixos-rebuild switch`
$ nixos apply

# `nixos-rebuild switch`, without interactive confirmation
$ nixos apply -y

# `nixos-rebuild switch` on an arbitrary flake ref
$ nixos apply "github:water-sucks/nixed#CharlesWoodson"

# `nixos-rebuild test`
$ nixos apply --no-boot

# `nixos-rebuild vm[-with-bootloader]`
$ nixos apply --vm[-with-bootloader] --output ./vm

# `nixos-rebuild boot`
$ nixos apply --no-activate

# `nixos-rebuild list-generations`
$ nixos generation list

# Show diffs between two generation numbers on the local system
$ nixos generation diff 59 60

# Switch to an arbitrary generation number (and specialisation)
$ nixos generation switch 420 [--specialisation "wayland"]

# `nixos-rebuild switch --rollback`
$ nixos generation rollback

# Fine-tuned generation deletion; keep at least five generations, delete the rest
$ nixos generation delete --min 5 --all
```

Check the manual for more important information.

Setting the `$NIXOS_CONFIG` variable allows for not specifying the `--flake`
flag at _all_, which is a huge improvement over `nixos-rebuild`.

`nixos generation list` by default is a TUI list with Vim-like bindings. To get
tabular, `grep`-able output like the old behavior of `nixos-rebuild` uses, use
`-t`.

Default specialisations are managed through the `nixos-cli` configuration.

In the future, setting build and target hosts for remote building/activation
using SSH will be supported.

### `nixos-enter`

`nixos enter` behaves mostly the same as `nixos-enter`, minus some extra logging
controls.

### `nixos-generate-config` -> `nixos init`

`nixos init` can be used in the same way as `nixos-generate-config`. Usually,
this is done through a NixOS live USB before installation. As such, refer to the
[installation](./installation.md) section for instructions on how to do that.

**NOTE**: The current configuration that is generated does not include
`nixos-cli` setup, due to implementation complexity. If you believe this is
important enough, please file a feature request.

### `nixos-install` -> `nixos install`

`nixos install` can also be used in the same way as the current `nixos-install`
script. Similar to `nixos init` usage, this is likely to be done off a live USB,
rather than on a live system.

In the future, remote NixOS installations will be supported.

### `nixos features`

This command describes the features that `nixos-cli` was compiled with.

Use this when filing issues, in order to provide information about the
environment for proper problem diagnosis.

## Option UI

The option UI is a nice search for NixOS options that are available on a given
system. These are computed on demand for the system, so _all_ available options
on that exact system are present.

This is a significant advantage over alternatives; since options are computed
from the modules present in a given system, modules that don't have module
documentation exposed can _still_ have documentation through the option UI!

Cool, right?

By default, `nixos option` uses this TUI.

To use normal, non-interactive output for a specific option, add the `-n`
switch.

However, there is one caveat: generating the option index is an intensive
operation; this can be precomputed on every configuration change using the
`services.nixos-cli.prebuildOptionCache` if desired.

## Environment Variables

The following environment variables influence `nixos-cli` behavior:

- `NO_COLOR` :: disable output color (does not apply for TUIs)
- `NIXOS_CLI_CONFIG` :: change the `nixos-cli` settings location (default:
  `/etc/nixos-cli/config.toml`)
- `NIXOS_CONFIG` :: where the configuration to work with is stored

  This can vary depending on if the CLI is flake-enabled. If the CLI is
  flake-enabled, then `$NIXOS_CONFIG` _must_ point to a valid flake ref.
  Otherwise, it can point to a local Nix configuration file (i.e.
  `configuration.nix`) or directory containing a `default.nix`.

## Aliases

Aliases can be used to make shortcuts for `nixos-cli` commands. Check the
[settings](./settings.md) section for an example.

A list of common aliases that people can configure:

- `nixos genlist` :: `nixos generation list`
- `nixos switch` :: `nixos generation switch`
- `nixos testcfg` :: `nixos apply --no-boot --no-activate`
- `nixos build` :: `nixos apply --no-boot --no-activate --output ./result`

**NOTE**: Currently, aliases to compose multiple CLI commands or to invoke shell
commands are not supported. If this is important to you, please file a feature
request.

## Completion

Shell completion is provided through the default package. Descriptions for
completion candidates are provided (requires newer Bash versions if applicable).

If desired, completion scripts can be obtained manually using
`nixos completion <SHELL>`.

Supported shells:

- `bash`
- `zsh`
- `fish`
- `nushell`
- `elvish`
- `xonsh`

If you want support for another shell, file an issue. However, this support is
provided by [Carapace](https://github.com/carapace-sh/carapace), and as such,
support will probably need to be implemented upstream before this is possible.
</file>

<file path="doc/src/roadmap.md">
# Roadmap

- ❌ Remote application of configurations
- ❌ Remote installation of NixOS configurations (a la
  [`nixos-anywhere`](https;//github.com/numtide/nixos-anywhere))
- ❌ Ability to remotely manage generations
- ❌ Smart container management (a la `nixos-container`)
- ❌ Explicit ability to deploy systems from non-NixOS operating systems
- ❌ **Drafting an RFC** to make `nixos-cli` the default NixOS management tool

See the [Issues](https://github.com/nix-community/nixos-cli/issues) section in
the GitHub repository for a list of other issues and/or features to be
implemented or make your own requests! All requests are welcome.
</file>

<file path="doc/src/settings.md">
# Settings

Settings are stored in `/etc/nixos-cli/config.toml`, and are stored in
[`TOML`](https://toml.io) format.

If preferred, this can be overridden by an environment variable
`NIXOS_CLI_CONFIG` at runtime. This is useful for testing configuration files.

Additionally, some configuration values can be overridden on the command-line
with the `--config` flag.

Example invocation:

```sh
$ nixos --config apply.imply_impure_with_tag=false apply
```

The preferred way to create this settings file is through the provided Nix
module that generates the TOML using the `services.nixos-cli.config` option.
Refer to the [module documentation](./module.md) for other available options.

## Available Settings

These are the available settings for `nixos-cli` and their default values.

{{ #include generated-settings.md }}
</file>

<file path="doc/src/SUMMARY.md">
[Introduction](introduction.md)

# Usage

- [Installation](installation.md)
- [Overview](overview.md)
- [Settings](settings.md)
- [Module](module.md)

# Community

- [FAQ](faq.md)
- [Comparisons](comparisons.md)
- [Contributing](contributing.md)
- [Roadmap](roadmap.md)
</file>

<file path="doc/.gitignore">
book
</file>

<file path="doc/book.toml">
[book]
authors = ["Varun Narravula"]
language = "en"
multilingual = false
src = "src"
title = "nixos-cli"
</file>

<file path="doc/build.go">
package main

import (
	"bytes"
	_ "embed"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"reflect"
	"regexp"
	"sort"
	"strings"

	"github.com/nix-community/nixos-cli/internal/settings"
	"github.com/spf13/cobra"
)

func main() {
	rootCmd := &cobra.Command{
		Use: "build",
		CompletionOptions: cobra.CompletionOptions{
			DisableDefaultCmd: true,
			HiddenDefaultCmd:  true,
		},
	}

	var gitRev string

	siteCmd := &cobra.Command{
		Use:   "site",
		Short: "Generate Markdown documentation for settings and modules",
		RunE: func(cmd *cobra.Command, args []string) error {
			fmt.Println("generating settings documentation")

			generatedSettingsPath := filepath.Join("doc", "src", "generated-settings.md")
			if err := generateSettingsDocMarkdown(generatedSettingsPath); err != nil {
				return err
			}

			fmt.Println("generating module documentation")

			generatedModulePath := filepath.Join("doc", "src", "generated-module.md")
			if err := generateModuleDoc(generatedModulePath, gitRev); err != nil {
				return err
			}

			fmt.Println("generated settings and modules for mdbook site")

			return nil
		},
	}
	siteCmd.Flags().StringVarP(&gitRev, "revision", "r", "main", "Git rev to use when generating module doc links")

	var outputManDir string

	manCmd := &cobra.Command{
		Use:   "man",
		Short: "Generate man pages using scdoc",
		RunE: func(cmd *cobra.Command, args []string) error {
			return generateManPages(filepath.Join("doc", "man"), outputManDir)
		},
	}
	manCmd.Flags().StringVarP(&outputManDir, "output", "o", "man", "Where to place generated man pages")

	rootCmd.AddCommand(siteCmd, manCmd)

	if err := rootCmd.Execute(); err != nil {
		os.Exit(1)
	}
}

func generateSettingsDocMarkdown(filename string) error {
	var sb strings.Builder

	defaults := *settings.NewSettings()

	writeSettingsDoc(reflect.TypeOf(defaults), reflect.ValueOf(defaults), "", &sb, 2, MarkdownSettingsFormatter{})

	return os.WriteFile(filename, []byte(sb.String()), 0o644)
}

//go:embed man/nixos-cli-settings.5.scd.template
var settingsTemplate string

func generateSettingsDocManpage(filename string) error {
	var sb strings.Builder

	defaults := *settings.NewSettings()

	writeSettingsDoc(reflect.TypeOf(defaults), reflect.ValueOf(defaults), "", &sb, 2, ManpageSettingsFormatter{})

	contents := fmt.Sprintf(settingsTemplate, sb.String())

	return os.WriteFile(filename, []byte(contents), 0o644)
}

func generateModuleDoc(filename string, rev string) error {
	var sb strings.Builder

	cmd := exec.Command("nix-options-doc", "--strip-prefix")
	cmd.Stdout = &sb

	if err := cmd.Run(); err != nil {
		fmt.Printf("error: couldn't generate docs for module with nix-options-doc: %v\n", err)
		return err
	}

	// Strip the first line and some whitespace (assumed to be the title)
	lines := strings.Split(sb.String(), "\n")
	if len(lines) == 0 {
		return fmt.Errorf("no output from nix-options-doc")
	}
	lines = lines[3:]

	repoBaseURL := fmt.Sprintf("https://github.com/nix-community/nixos-cli/blob/%s", rev)

	re := regexp.MustCompile(`(?m)^## \[` +
		`(?P<name>.*?)` +
		`\]\(` +
		`(?P<file>[^)]+)` +
		`\)`)

	for i, line := range lines {
		lines[i] = re.ReplaceAllString(line, fmt.Sprintf("## [`${name}`](%s/${file})", repoBaseURL))
	}

	final := strings.Join(lines, "\n")
	return os.WriteFile(filename, []byte(final), 0o644)
}

type SettingsFormatter interface {
	WriteHeader(sb *strings.Builder, title string, level int)
	WriteSectionDescription(sb *strings.Builder, desc string)
	WriteItem(sb *strings.Builder, key string, desc string, defaultValue string)
}

type MarkdownSettingsFormatter struct{}

func (f MarkdownSettingsFormatter) WriteHeader(sb *strings.Builder, title string, level int) {
	fmt.Fprintf(sb, "%s %s\n\n", strings.Repeat("#", level), title)
}

func (MarkdownSettingsFormatter) WriteSectionDescription(sb *strings.Builder, desc string) {
	sb.WriteString(desc + "\n\n")
}

func (f MarkdownSettingsFormatter) WriteItem(sb *strings.Builder, key, desc, defaultValue string) {
	fmt.Fprintf(sb, "- **%s**\n\n  %s\n\n  **Default**: `%s`\n\n", key, desc, defaultValue)
}

type ManpageSettingsFormatter struct{}

func (f ManpageSettingsFormatter) WriteHeader(sb *strings.Builder, title string, level int) {
	fmt.Fprintf(sb, "\n%s %s\n", strings.Repeat("#", level), strings.ToUpper(title))
}

func (ManpageSettingsFormatter) WriteSectionDescription(sb *strings.Builder, desc string) {
	sb.WriteString(desc + "\n\n")
}

func (f ManpageSettingsFormatter) WriteItem(sb *strings.Builder, key, desc, defaultValue string) {
	fmt.Fprintf(sb, "\n*%s*\n\n%s\n\nDefault: _%s_\n", key, desc, defaultValue)
}

func writeSettingsDoc(
	t reflect.Type,
	v reflect.Value,
	path string,
	sb *strings.Builder,
	depth int,
	formatter SettingsFormatter,
) {
	type nestedField struct {
		field    reflect.StructField
		fieldVal reflect.Value
		fullKey  string
	}

	type configKey struct {
		key          string
		desc         string
		defaultValue string
	}

	var generalItems []configKey
	var nestedFields []nestedField

	for i := range t.NumField() {
		field := t.Field(i)
		tag := field.Tag
		koanfKey := tag.Get("koanf")
		if koanfKey == "" {
			continue
		}

		fullKey := path + koanfKey
		fieldVal := v.Field(i)

		if field.Type.Kind() == reflect.Struct {
			nestedFields = append(nestedFields, nestedField{field, fieldVal, fullKey})
		} else {
			defaultVal := formatValue(fieldVal)
			descriptions := settings.SettingsDocs[fullKey]
			desc := descriptions.Long
			if desc == "" {
				desc = descriptions.Short
			}
			generalItems = append(generalItems, configKey{fullKey, desc, defaultVal})
		}
	}

	if len(generalItems) > 0 {
		if path == "" {
			formatter.WriteHeader(sb, "General", 2)
		}

		sort.Slice(generalItems, func(i, j int) bool {
			return generalItems[i].key < generalItems[j].key
		})

		for _, item := range generalItems {
			formatter.WriteItem(sb, item.key, item.desc, item.defaultValue)
		}
	}

	for _, entry := range nestedFields {
		descriptions := settings.SettingsDocs[entry.fullKey]
		desc := descriptions.Long
		if desc == "" {
			desc = descriptions.Short
		}

		formatter.WriteHeader(sb, entry.fullKey, depth)
		formatter.WriteSectionDescription(sb, desc)
		writeSettingsDoc(entry.field.Type, entry.fieldVal, entry.fullKey+".", sb, depth+1, formatter)
	}
}

func formatValue(v reflect.Value) string {
	if !v.IsValid() {
		return "n/a"
	}
	switch v.Kind() {
	case reflect.String:
		if v.String() == "" {
			return `""`
		}
		return fmt.Sprintf(`"%s"`, v.String())
	case reflect.Bool:
		return fmt.Sprintf("%t", v.Bool())
	case reflect.Int, reflect.Int64:
		return fmt.Sprintf("%d", v.Int())
	case reflect.Map, reflect.Slice:
		if v.Len() == 0 {
			return "[]"
		}
		return "(multiple entries)"
	default:
		return fmt.Sprintf("%v", v.Interface())
	}
}

func generateManPages(inputDir string, outputDir string) error {
	generatedSettingsManPagePath := filepath.Join("doc", "man", "nixos-cli-settings.5.scd")

	if err := generateSettingsDocManpage(generatedSettingsManPagePath); err != nil {
		return err
	}

	return filepath.WalkDir(inputDir, func(path string, d os.DirEntry, err error) error {
		if err != nil || d.IsDir() {
			return err
		}

		if filepath.Ext(path) != ".scd" {
			return nil
		}

		content, readErr := os.ReadFile(path)
		if readErr != nil {
			return fmt.Errorf("failed to read %s: %w", path, readErr)
		}

		cmd := exec.Command("scdoc")
		cmd.Stdin = bytes.NewReader(content)

		var outBuf bytes.Buffer
		cmd.Stdout = &outBuf
		cmd.Stderr = os.Stderr

		if err := cmd.Run(); err != nil {
			return fmt.Errorf("scdoc failed for %s: %w", path, err)
		}

		base := filepath.Base(path)
		manFile := base[:len(base)-len(".scd")]
		outPath := filepath.Join(outputDir, manFile)

		if err := os.MkdirAll(outputDir, 0o755); err != nil {
			return err
		}

		if writeErr := os.WriteFile(outPath, outBuf.Bytes(), 0o644); writeErr != nil {
			return fmt.Errorf("failed to write %s: %w", outPath, writeErr)
		}

		fmt.Printf("generated %s\n", outPath)
		return nil
	})
}
</file>

<file path="internal/activation/activation.go">
package activation

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strconv"

	"github.com/nix-community/nixos-cli/internal/constants"
	"github.com/nix-community/nixos-cli/internal/generation"
	"github.com/nix-community/nixos-cli/internal/settings"
	"github.com/nix-community/nixos-cli/internal/system"
)

// Parse the generation's `nixos-cli` configuration to find the default specialisation
// for that generation.
func FindDefaultSpecialisationFromConfig(generationDirname string) (string, error) {
	generationCfgFilename := filepath.Join(generationDirname, constants.DefaultConfigLocation)
	generationCfg, err := settings.ParseSettings(generationCfgFilename)
	if err != nil {
		return "", err
	}

	return generationCfg.Apply.DefaultSpecialisation, nil
}

// Make sure a specialisation exists in a given generation and can be activated by
// checking for the presence of the switch-to-configuration script.
func VerifySpecialisationExists(generationDirname string, specialisation string) bool {
	if specialisation == "" {
		// The base config always exists.
		return true
	}

	specialisationStcFilename := filepath.Join(generationDirname, "specialisation", specialisation, "bin", "switch-to-configuration")
	if _, err := os.Stat(specialisationStcFilename); err != nil {
		return false
	}

	return true
}

func EnsureSystemProfileDirectoryExists() error {
	// The system profile directory sometimes doesn't exist,
	// and does need to be manually created if this is the case.
	// This kinda sucks, since it requires root execution, but
	// there's not really a better way to ensure that this
	// profile's directory exists.

	err := os.MkdirAll(constants.NixSystemProfileDirectory, 0o755)
	if err != nil {
		if err != os.ErrExist {
			return fmt.Errorf("failed to create nix system profile directory: %w", err)
		}
	}

	return nil
}

func AddNewNixProfile(s system.CommandRunner, profile string, closure string, verbose bool) error {
	if profile != "system" {
		err := EnsureSystemProfileDirectoryExists()
		if err != nil {
			return err
		}
	}

	profileDirectory := generation.GetProfileDirectoryFromName(profile)

	argv := []string{"nix-env", "--profile", profileDirectory, "--set", closure}

	if verbose {
		s.Logger().CmdArray(argv)
	}

	cmd := system.NewCommand(argv[0], argv[1:]...)

	_, err := s.Run(cmd)

	return err
}

func SetNixProfileGeneration(s system.CommandRunner, profile string, genNumber uint64, verbose bool) error {
	if profile != "system" {
		err := EnsureSystemProfileDirectoryExists()
		if err != nil {
			return err
		}
	}

	profileDirectory := generation.GetProfileDirectoryFromName(profile)

	argv := []string{"nix-env", "--profile", profileDirectory, "--switch-generation", fmt.Sprintf("%d", genNumber)}

	if verbose {
		s.Logger().CmdArray(argv)
	}

	cmd := system.NewCommand(argv[0], argv[1:]...)

	_, err := s.Run(cmd)

	return err
}

func GetCurrentGenerationNumber(profile string) (uint64, error) {
	genLinkRegex, err := regexp.Compile(fmt.Sprintf(generation.GenerationLinkTemplateRegex, profile))
	if err != nil {
		return 0, fmt.Errorf("failed to compile generation regex: %w", err)
	}

	profileDirectory := generation.GetProfileDirectoryFromName(profile)
	currentGenerationLink, err := os.Readlink(profileDirectory)
	if err != nil {
		return 0, fmt.Errorf("unable to determine current generation: %v", err)
	}

	if matches := genLinkRegex.FindStringSubmatch(currentGenerationLink); len(matches) > 0 {
		genNumber, err := strconv.ParseInt(matches[1], 10, 64)
		if err != nil {
			return 0, fmt.Errorf("failed to parse generation number %v for %v", matches[1], currentGenerationLink)
		}

		return uint64(genNumber), nil
	} else {
		panic("current link format does not match 'profile-generation-link' format")
	}
}

type SwitchToConfigurationAction int

const (
	SwitchToConfigurationActionUnknown = iota
	SwitchToConfigurationActionChecksOnly
	SwitchToConfigurationActionSwitch
	SwitchToConfigurationActionBoot
	SwitchToConfigurationActionTest
	SwitchToConfigurationActionDryActivate
)

func ParseSwitchToConfigurationAction(arg string) (SwitchToConfigurationAction, error) {
	switch arg {
	case "check":
		return SwitchToConfigurationActionChecksOnly, nil
	case "switch":
		return SwitchToConfigurationActionSwitch, nil
	case "boot":
		return SwitchToConfigurationActionBoot, nil
	case "test":
		return SwitchToConfigurationActionTest, nil
	case "dry-activate":
		return SwitchToConfigurationActionDryActivate, nil
	default:
		return SwitchToConfigurationActionUnknown, fmt.Errorf("invalid switch action: %q", arg)
	}
}

func (c SwitchToConfigurationAction) String() string {
	switch c {
	case SwitchToConfigurationActionChecksOnly:
		return "check"
	case SwitchToConfigurationActionSwitch:
		return "switch"
	case SwitchToConfigurationActionBoot:
		return "boot"
	case SwitchToConfigurationActionTest:
		return "test"
	case SwitchToConfigurationActionDryActivate:
		return "dry-activate"
	default:
		panic("unknown switch to configuration action type")
	}
}

type SwitchToConfigurationOptions struct {
	InstallBootloader bool
	Verbose           bool
	Specialisation    string
}

func SwitchToConfiguration(s system.CommandRunner, generationLocation string, action SwitchToConfigurationAction, opts *SwitchToConfigurationOptions) error {
	var commandPath string
	if opts.Specialisation != "" {
		commandPath = filepath.Join(generationLocation, "specialisation", opts.Specialisation, "bin", "switch-to-configuration")
	} else {
		commandPath = filepath.Join(generationLocation, "bin", "switch-to-configuration")
	}

	argv := []string{commandPath, action.String()}

	if opts.Verbose {
		s.Logger().CmdArray(argv)
	}

	cmd := system.NewCommand(argv[0], argv[1:]...)
	if opts.InstallBootloader {
		cmd.SetEnv("NIXOS_INSTALL_BOOTLOADER", "1")
	}

	cmd.SetEnv("NIXOS_CLI_ATTEMPTING_ACTIVATION", "1")

	_, err := s.Run(cmd)

	return err
}
</file>

<file path="internal/build/vars/vars.go">
package vars

// Do not change these. These are always going to be set
// at compile-time.

var (
	Version        string = "unknown"
	GitRevision    string = "unknown"
	Flake          string = "true"
	NixpkgsVersion string = ""
)
</file>

<file path="internal/build/build.go">
package build

import (
	"github.com/nix-community/nixos-cli/internal/build/vars"
)

func boolCheck(varName string, value string) {
	if value != "true" && value != "false" {
		panic("Compile-time variable internal.build." + varName + " is not a value of either 'true' or 'false'; this application was compiled incorrectly")
	}
}

func boolCast(value string) bool {
	switch value {
	case "true":
		return true
	case "false":
		return false
	default:
		panic("unreachable, this variable has not been bool-checked properly")
	}
}

func Version() string {
	return vars.Version
}

func GitRevision() string {
	return vars.GitRevision
}

func Flake() bool {
	return boolCast(vars.Flake)
}

func NixpkgsVersion() string {
	return vars.NixpkgsVersion
}

func init() {
	boolCheck("Flake", vars.Flake)
}
</file>

<file path="internal/cmd/errors/errors.go">
package errors

type ArgError struct {
	Message string
	Hint    string
}

func (e ArgError) Error() string {
	return e.Message
}
</file>

<file path="internal/cmd/nixopts/convert_test.go">
package nixopts_test

import (
	"reflect"
	"testing"

	"github.com/nix-community/nixos-cli/internal/cmd/nixopts"
	"github.com/spf13/cobra"
)

type nixOptions struct {
	Quiet          bool
	PrintBuildLogs bool
	MaxJobs        int
	LogFormat      string
	Builders       []string
	Options        map[string]string
}

func createTestCmd() (*cobra.Command, *nixOptions) {
	opts := nixOptions{}

	cmd := &cobra.Command{}

	nixopts.AddQuietNixOption(cmd, &opts.Quiet)
	nixopts.AddPrintBuildLogsNixOption(cmd, &opts.PrintBuildLogs)
	nixopts.AddMaxJobsNixOption(cmd, &opts.MaxJobs)
	nixopts.AddLogFormatNixOption(cmd, &opts.LogFormat)
	nixopts.AddBuildersNixOption(cmd, &opts.Builders)
	nixopts.AddOptionNixOption(cmd, &opts.Options)

	return cmd, &opts
}

func TestNixOptionsToArgsList(t *testing.T) {
	tests := []struct {
		name string
		// The command-line arguments passed to Cobra
		passedArgs []string
		// The expected arguments to be passed to Nix
		expected []string
	}{
		{
			name:       "All fields zero-valued",
			passedArgs: []string{},
			expected:   []string{},
		},
		{
			name:       "Single boolean field",
			passedArgs: []string{"--quiet"},
			expected:   []string{"--quiet"},
		},
		{
			name:       "Integer field set",
			passedArgs: []string{"--max-jobs", "4"},
			expected:   []string{"--max-jobs", "4"},
		},
		{
			name:       "Integer field set to zero value",
			passedArgs: []string{"--max-jobs", "0"},
			expected:   []string{"--max-jobs", "0"},
		},
		{
			name:       "String field set",
			passedArgs: []string{"--log-format", "json"},
			expected:   []string{"--log-format", "json"},
		},
		{
			name:       "Slice field set",
			passedArgs: []string{"--builders", "builder1", "--builders", "builder2"},
			expected:   []string{"--builders", "builder1", "--builders", "builder2"},
		},
		{
			name:       "Map field set",
			passedArgs: []string{"--option", "option1=value1", "--option", "option2=value2"},
			expected:   []string{"--option", "option1", "value1", "--option", "option2", "value2"},
		},
		{
			name:       "Mixed fields set",
			passedArgs: []string{"--quiet", "--max-jobs", "2", "--log-format", "xml", "--builders", "builder1", "--option", "option1=value1", "--option", "option2=value2"},
			expected:   []string{"--quiet", "--max-jobs", "2", "--log-format", "xml", "--builders", "builder1", "--option", "option1", "value1", "--option", "option2", "value2"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			cmd, opts := createTestCmd()

			// Dummy execution of "command" for Cobra to parse flags
			cmd.SetArgs(tt.passedArgs)
			_ = cmd.Execute()

			args := nixopts.NixOptionsToArgsList(cmd.Flags(), opts)

			if !reflect.DeepEqual(args, tt.expected) {
				t.Errorf("NixOptionsToArgsList() = %v, want %v", args, tt.expected)
			}
		})
	}
}
</file>

<file path="internal/cmd/nixopts/convert.go">
package nixopts

import (
	"fmt"
	"reflect"
	"sort"

	"github.com/spf13/pflag"
)

var availableOptions = map[string]string{
	"Quiet":            "quiet",
	"PrintBuildLogs":   "print-build-logs",
	"NoBuildOutput":    "fallback",
	"ShowTrace":        "show-trace",
	"KeepGoing":        "keep-going",
	"KeepFailed":       "keep-failed",
	"Fallback":         "fallback",
	"Refresh":          "refresh",
	"Repair":           "repair",
	"Impure":           "impure",
	"Offline":          "offline",
	"NoNet":            "no-net",
	"MaxJobs":          "max-jobs",
	"Cores":            "cores",
	"LogFormat":        "log-format",
	"Options":          "option",
	"Builders":         "builders",
	"RecreateLockFile": "recreate-lock-file",
	"NoUpdateLockFile": "no-update-lock-file",
	"NoWriteLockFile":  "no-write-lock-file",
	"NoUseRegistries":  "no-use-registries",
	"CommitLockFile":   "commit-lock-file",
	"UpdateInputs":     "update-inputs",
	"OverrideInputs":   "override-input",
	"Includes":         "include",
}

func getNixFlag(name string) string {
	if option, ok := availableOptions[name]; ok {
		return option
	}

	panic("unknown option '" + name + "' when trying to convert to nix options struct")
}

func NixOptionsToArgsList(flags *pflag.FlagSet, options any) []string {
	val := reflect.ValueOf(options)
	typ := reflect.TypeOf(options)

	if val.Kind() == reflect.Ptr {
		val = val.Elem()
		typ = typ.Elem()
	}

	args := make([]string, 0)

	for i := 0; i < val.NumField(); i++ {
		field := val.Field(i)
		fieldType := typ.Field(i)
		fieldName := getNixFlag(fieldType.Name)

		if !flags.Changed(fieldName) {
			continue
		}

		optionArg := fmt.Sprintf("--%s", fieldName)

		switch field.Kind() {
		case reflect.Bool:
			if field.Bool() {
				args = append(args, optionArg)
			}
		case reflect.Int:
			args = append(args, optionArg, fmt.Sprintf("%d", field.Int()))
		case reflect.String:
			if field.String() != "" {
				args = append(args, optionArg, field.String())
			}
		case reflect.Slice:
			if field.Len() > 0 {
				for j := 0; j < field.Len(); j++ {
					args = append(args, optionArg, field.Index(j).String())
				}
			}
		case reflect.Map:
			keys := field.MapKeys()

			sort.Slice(keys, func(i, j int) bool {
				return keys[i].String() < keys[j].String()
			})

			for _, key := range keys {
				value := field.MapIndex(key)
				args = append(args, optionArg, key.String(), value.String())
			}
		default:
			panic("unsupported field type " + field.Kind().String() + " for field '" + fieldName + "'")
		}
	}

	return args
}
</file>

<file path="internal/cmd/nixopts/nixopts.go">
package nixopts

import (
	"github.com/spf13/cobra"
)

func addNixOptionBool(cmd *cobra.Command, dest *bool, name string, shorthand string, desc string) {
	if shorthand != "" {
		cmd.Flags().BoolVarP(dest, name, shorthand, false, desc)
	} else {
		cmd.Flags().BoolVar(dest, name, false, desc)
	}
	cmd.Flags().Lookup(name).Hidden = true
}

func addNixOptionInt(cmd *cobra.Command, dest *int, name string, shorthand string, desc string) {
	if shorthand != "" {
		cmd.Flags().IntVarP(dest, name, shorthand, 0, desc)
	} else {
		cmd.Flags().IntVar(dest, name, 0, desc)
	}
	cmd.Flags().Lookup(name).Hidden = true
}

func addNixOptionString(cmd *cobra.Command, dest *string, name string, shorthand string, desc string) {
	if shorthand != "" {
		cmd.Flags().StringVarP(dest, name, shorthand, "", desc)
	} else {
		cmd.Flags().StringVar(dest, name, "", desc)
	}
	cmd.Flags().Lookup(name).Hidden = true
}

func addNixOptionStringArray(cmd *cobra.Command, dest *[]string, name string, shorthand string, desc string) {
	if shorthand != "" {
		cmd.Flags().StringSliceVarP(dest, name, shorthand, nil, desc)
	} else {
		cmd.Flags().StringSliceVar(dest, name, nil, desc)
	}
	cmd.Flags().Lookup(name).Hidden = true
}

func addNixOptionStringMap(cmd *cobra.Command, dest *map[string]string, name string, shorthand string, desc string) {
	if shorthand != "" {
		cmd.Flags().StringToStringVarP(dest, name, shorthand, nil, desc)
	} else {
		cmd.Flags().StringToStringVar(dest, name, nil, desc)
	}
	cmd.Flags().Lookup(name).Hidden = true
}

func AddQuietNixOption(cmd *cobra.Command, dest *bool) {
	addNixOptionBool(cmd, dest, "quiet", "", "Decrease logging verbosity level")
}

func AddPrintBuildLogsNixOption(cmd *cobra.Command, dest *bool) {
	addNixOptionBool(cmd, dest, "print-build-logs", "L", "Decrease logging verbosity level")
}

func AddNoBuildOutputNixOption(cmd *cobra.Command, dest *bool) {
	addNixOptionBool(cmd, dest, "no-build-output", "Q", "Silence build output on stdout and stderr")
}

func AddShowTraceNixOption(cmd *cobra.Command, dest *bool) {
	addNixOptionBool(cmd, dest, "show-trace", "", "Print stack trace of evaluation errors")
}

func AddKeepGoingNixOption(cmd *cobra.Command, dest *bool) {
	addNixOptionBool(cmd, dest, "keep-going", "k", "Keep going until all builds are finished despite failures")
}

func AddKeepFailedNixOption(cmd *cobra.Command, dest *bool) {
	addNixOptionBool(cmd, dest, "keep-failed", "K", "Keep failed builds (usually in /tmp)")
}

func AddFallbackNixOption(cmd *cobra.Command, dest *bool) {
	addNixOptionBool(cmd, dest, "fallback", "", "If binary download fails, fall back on building from source")
}

func AddRefreshNixOption(cmd *cobra.Command, dest *bool) {
	addNixOptionBool(cmd, dest, "refresh", "", "Consider all previously downloaded files out-of-date")
}

func AddRepairNixOption(cmd *cobra.Command, dest *bool) {
	addNixOptionBool(cmd, dest, "repair", "", "Fix corrupted or missing store paths")
}

func AddImpureNixOption(cmd *cobra.Command, dest *bool) {
	addNixOptionBool(cmd, dest, "impure", "", "Allow access to mutable paths and repositories")
}

func AddOfflineNixOption(cmd *cobra.Command, dest *bool) {
	addNixOptionBool(cmd, dest, "offline", "", "Disable substituters and consider all previously downloaded files up-to-date.")
}

func AddNoNetNixOption(cmd *cobra.Command, dest *bool) {
	addNixOptionBool(cmd, dest, "no-net", "", "Disable substituters and set all network timeout settings to minimum")
}

func AddIncludesNixOption(cmd *cobra.Command, dest *[]string) {
	addNixOptionStringArray(cmd, dest, "include", "I", "Add path to list of locations to look up <...> file names")
}

func AddMaxJobsNixOption(cmd *cobra.Command, dest *int) {
	addNixOptionInt(cmd, dest, "max-jobs", "j", "Max number of build jobs in parallel")
}

func AddCoresNixOption(cmd *cobra.Command, dest *int) {
	addNixOptionInt(cmd, dest, "cores", "", "Max number of CPU cores used (sets NIX_BUILD_CORES env variable)")
}

func AddBuildersNixOption(cmd *cobra.Command, dest *[]string) {
	addNixOptionStringArray(cmd, dest, "builders", "", "List of Nix remote builder addresses")
}

func AddLogFormatNixOption(cmd *cobra.Command, dest *string) {
	addNixOptionString(cmd, dest, "log-format", "", "Configure how output is formatted")
}

func AddOptionNixOption(cmd *cobra.Command, dest *map[string]string) {
	addNixOptionStringMap(cmd, dest, "option", "", "Set Nix config option (passed as 1 arg, requires = separator)")
}

func AddRecreateLockFileNixOption(cmd *cobra.Command, dest *bool) {
	addNixOptionBool(cmd, dest, "recreate-lock-file", "", "Recreate the flake's lock file from scratch")
}

func AddNoUpdateLockFileNixOption(cmd *cobra.Command, dest *bool) {
	addNixOptionBool(cmd, dest, "no-update-lock-file", "", "Do not allow any updates to the flake's lock file")
}

func AddNoWriteLockFileNixOption(cmd *cobra.Command, dest *bool) {
	addNixOptionBool(cmd, dest, "no-write-lock-file", "", "Do not write the flake's newly generated lock file")
}

func AddNoUseRegistriesNixOption(cmd *cobra.Command, dest *bool) {
	addNixOptionBool(cmd, dest, "no-use-registries", "", "Don't allow lookups in the flake registries")
	addNixOptionBool(cmd, dest, "no-registries", "", "Don't allow lookups in the flake registries")
	// TODO: add deprecation notice for --no-registries?
}

func AddCommitLockFileNixOption(cmd *cobra.Command, dest *bool) {
	addNixOptionBool(cmd, dest, "commit-lock-file", "", "Commit changes to the flake's lock file")
}

func AddUpdateInputNixOption(cmd *cobra.Command, dest *[]string) {
	addNixOptionStringArray(cmd, dest, "update-input", "", "Update a specific flake input")
}

func AddOverrideInputNixOption(cmd *cobra.Command, dest *map[string]string) {
	addNixOptionStringMap(cmd, dest, "override-input", "", "Override a specific flake input (passed as 1 arg, requires = separator)")
}
</file>

<file path="internal/cmd/opts/opts.go">
package cmdOpts

import (
	"github.com/nix-community/nixos-cli/internal/configuration"
	"github.com/nix-community/nixos-cli/internal/activation"
)

type MainOpts struct {
	ColorAlways  bool
	ConfigValues map[string]string
}

type ActivateOpts struct {
	Action         activation.SwitchToConfigurationAction
	Specialisation string
}

type AliasesOpts struct {
	DisplayJson bool
}

type ApplyOpts struct {
	Dry                   bool
	InstallBootloader     bool
	NoActivate            bool
	NoBoot                bool
	OutputPath            string
	ProfileName           string
	Specialisation        string
	GenerationTag         string
	UpgradeChannels       bool
	UpgradeAllChannels    bool
	UseNom                bool
	Verbose               bool
	BuildVM               bool
	BuildVMWithBootloader bool
	AlwaysConfirm         bool
	FlakeRef              string

	NixOptions ApplyNixOptions
}

type ApplyNixOptions struct {
	Quiet          bool
	PrintBuildLogs bool
	NoBuildOutput  bool
	ShowTrace      bool
	KeepGoing      bool
	KeepFailed     bool
	Fallback       bool
	Refresh        bool
	Repair         bool
	Impure         bool
	Offline        bool
	NoNet          bool
	MaxJobs        int
	Cores          int
	Builders       []string
	LogFormat      string
	Includes       []string
	Options        map[string]string

	RecreateLockFile bool
	NoUpdateLockFile bool
	NoWriteLockFile  bool
	NoUseRegistries  bool
	CommitLockFile   bool
	UpdateInputs     []string
	OverrideInputs   map[string]string
}

type EnterOpts struct {
	Command      string
	CommandArray []string
	RootLocation string
	System       string
	Silent       bool
	Verbose      bool
}

type FeaturesOpts struct {
	DisplayJson bool
}

type GenerationOpts struct {
	ProfileName string
}

type GenerationDiffOpts struct {
	Before  uint
	After   uint
	Verbose bool
}

type GenerationDeleteOpts struct {
	All        bool
	LowerBound uint64
	// This ideally should be a uint64 to match types,
	// but Cobra's pflags does not support this type yet.
	Keep          []uint
	MinimumToKeep uint64
	OlderThan     string
	UpperBound    uint64
	AlwaysConfirm bool
	Pattern       string
	// This ideally should be a uint64 to match types,
	// but Cobra's pflags does not support this type yet.
	Remove  []uint
	Verbose bool
}

type GenerationListOpts struct {
	DisplayJson  bool
	DisplayTable bool
}

type GenerationSwitchOpts struct {
	Dry            bool
	Specialisation string
	Verbose        bool
	AlwaysConfirm  bool
	Generation     uint
}

type GenerationRollbackOpts struct {
	Dry            bool
	Specialisation string
	Verbose        bool
	AlwaysConfirm  bool
}

type InfoOpts struct {
	DisplayJson     bool
	DisplayMarkdown bool
}

type InitOpts struct {
	Directory          string
	ForceWrite         bool
	NoFSGeneration     bool
	Root               string
	ShowHardwareConfig bool
}

type InstallOpts struct {
	Channel        string
	NoBootloader   bool
	NoChannelCopy  bool
	NoRootPassword bool
	Root           string
	SystemClosure  string
	Verbose        bool
	FlakeRef       *configuration.FlakeRef

	NixOptions struct {
		Quiet          bool
		PrintBuildLogs bool
		NoBuildOutput  bool
		ShowTrace      bool
		KeepGoing      bool
		KeepFailed     bool
		Fallback       bool
		Refresh        bool
		Repair         bool
		Impure         bool
		Offline        bool
		NoNet          bool
		MaxJobs        int
		Cores          int
		LogFormat      string
		Includes       []string
		Options        map[string]string

		RecreateLockFile bool
		NoUpdateLockFile bool
		NoWriteLockFile  bool
		NoUseRegistries  bool
		CommitLockFile   bool
		UpdateInputs     []string
		OverrideInputs   map[string]string
	}
}

type OptionOpts struct {
	NonInteractive   bool
	NixPathIncludes  []string
	DisplayJson      bool
	NoUseCache       bool
	DisplayValueOnly bool
	MinScore         int64
	OptionInput      string
	FlakeRef         string
}

type ReplOpts struct {
	NixPathIncludes []string
	FlakeRef        string
}
</file>

<file path="internal/cmd/utils/confirmation.go">
package cmdUtils

import (
	"fmt"
	"os"
	"strings"

	"github.com/fatih/color"
)

func ConfirmationInput(msg string) (bool, error) {
	var input string

	fmt.Fprintf(os.Stderr, "%s\n[y/n]: ", color.GreenString("|> %s", msg))

	_, err := fmt.Scanln(&input)
	if err != nil {
		return false, err
	}

	if len(input) == 0 {
		return false, err
	}

	input = strings.ToLower(strings.TrimSpace(input))

	return input[0] == 'y', nil
}
</file>

<file path="internal/cmd/utils/utils.go">
package cmdUtils

import (
	"errors"
	"fmt"
	"maps"
	"os"
	"slices"
	"sort"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/spf13/cobra"
)

func SetHelpFlagText(cmd *cobra.Command) {
	cmd.Flags().BoolP("help", "h", false, "Show this help menu")
}

var ErrCommand = errors.New("command error")

// Replace a returned error with the generic `ErrCommand`, and.
// exit with a non-zero exit code. This is to avoid extra error
// messages being printed when a command function defined with
// RunE returns a non-nil error.
func CommandErrorHandler(err error) error {
	if err != nil {
		os.Exit(1)
		return ErrCommand
	}
	return nil
}

func ConfigureBubbleTeaLogger(prefix string) (func(), error) {
	if os.Getenv("NIXOS_CLI_DEBUG_MODE") == "" {
		return func() {}, nil
	}

	file, err := tea.LogToFile("debug.log", prefix)

	return func() {
		if err != nil || file == nil {
			return
		}
		_ = file.Close()
	}, err
}

func AlignedOptions(options map[string]string) string {
	maxLen := 0
	for cmd := range options {
		if len(cmd) > maxLen {
			maxLen = len(cmd)
		}
	}

	result := ""
	format := fmt.Sprintf("  %%-%ds  %%s\n", maxLen)

	keys := slices.Collect(maps.Keys(options))
	sort.Strings(keys)

	for _, cmd := range keys {
		desc := options[cmd]
		result += fmt.Sprintf(format, cmd, desc)
	}

	return result
}
</file>

<file path="internal/configuration/configuration_test.go">
package configuration_test

import (
	"reflect"
	"testing"

	"github.com/nix-community/nixos-cli/internal/configuration"
)

func TestFlakeRefFromString(t *testing.T) {
	tests := []struct {
		input    string
		expected *configuration.FlakeRef
	}{
		{
			input: "github:owner/repo#linux",
			expected: &configuration.FlakeRef{
				URI:    "github:owner/repo",
				System: "linux",
			},
		},
		{
			input: "github:owner/repo",
			expected: &configuration.FlakeRef{
				URI:    "github:owner/repo",
				System: "",
			},
		},
		{
			input: "github:owner/repo#",
			expected: &configuration.FlakeRef{
				URI:    "github:owner/repo",
				System: "",
			},
		},
		{
			input: "#linux",
			expected: &configuration.FlakeRef{
				URI:    "",
				System: "linux",
			},
		},
		{
			input: "",
			expected: &configuration.FlakeRef{
				URI:    "",
				System: "",
			},
		},
		{
			input: "github:owner/repo#linux#extra",
			expected: &configuration.FlakeRef{
				URI:    "github:owner/repo",
				System: "linux#extra",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.input, func(t *testing.T) {
			result := configuration.FlakeRefFromString(tt.input)

			if !reflect.DeepEqual(result, tt.expected) {
				t.Errorf("FlakeRefFromString(%q) = %+v, want %+v", tt.input, result, tt.expected)
			}
		})
	}
}
</file>

<file path="internal/configuration/configuration.go">
package configuration

import (
	"fmt"

	"github.com/nix-community/nixos-cli/internal/build"
	"github.com/nix-community/nixos-cli/internal/logger"
	"github.com/nix-community/nixos-cli/internal/settings"
	"github.com/nix-community/nixos-cli/internal/system"
	"github.com/spf13/pflag"
)

type SystemBuildOptions struct {
	ResultLocation string
	DryBuild       bool
	UseNom         bool
	GenerationTag  string
	Verbose        bool

	// Command-line flags that were passed for the command context.
	// This is needed to determine the proper Nix options to pass
	// when building, if any were passed through.
	CmdFlags  *pflag.FlagSet
	NixOpts   any
	Env       map[string]string
	ExtraArgs []string
}

type Configuration interface {
	SetBuilder(builder system.CommandRunner)
	EvalAttribute(attr string) (*string, error)
	BuildSystem(buildType SystemBuildType, opts *SystemBuildOptions) (string, error)
}

type AttributeEvaluationError struct {
	Attribute        string
	EvaluationOutput string
}

func (e *AttributeEvaluationError) Error() string {
	return fmt.Sprintf("failed to evaluate attribute %s", e.Attribute)
}

func FindConfiguration(log *logger.Logger, cfg *settings.Settings, includes []string, verbose bool) (Configuration, error) {
	if build.Flake() {
		if verbose {
			log.Info("looking for flake configuration")
		}

		f, err := FlakeRefFromEnv(cfg.ConfigLocation)
		if err != nil {
			return nil, err
		}

		if err := f.InferSystemFromHostnameIfNeeded(); err != nil {
			return nil, err
		}

		if verbose {
			log.Infof("found flake configuration: %s#%s", f.URI, f.System)
		}

		return f, nil
	} else {
		c, err := FindLegacyConfiguration(log, includes, verbose)
		if err != nil {
			return nil, err
		}

		if verbose {
			log.Infof("found legacy configuration at %s", c)
		}

		return c, nil
	}
}

type SystemBuildType int

const (
	SystemBuildTypeSystem SystemBuildType = iota
	SystemBuildTypeSystemActivation
	SystemBuildTypeVM
	SystemBuildTypeVMWithBootloader
)

func (b SystemBuildType) BuildAttr() string {
	switch b {
	case SystemBuildTypeSystem, SystemBuildTypeSystemActivation:
		if build.Flake() {
			return "toplevel"
		} else {
			return "system"
		}
	case SystemBuildTypeVM:
		return "vm"
	case SystemBuildTypeVMWithBootloader:
		return "vmWithBootLoader"
	default:
		panic("unknown build type")
	}
}

func (b SystemBuildType) IsVM() bool {
	return b == SystemBuildTypeVM || b == SystemBuildTypeVMWithBootloader
}

func (b SystemBuildType) IsSystem() bool {
	return b == SystemBuildTypeSystem || b == SystemBuildTypeSystemActivation
}
</file>

<file path="internal/configuration/flake.go">
package configuration

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/nix-community/nixos-cli/internal/cmd/nixopts"
	"github.com/nix-community/nixos-cli/internal/system"
)

type FlakeRef struct {
	URI    string
	System string

	// Builder is used to build the flake ref. They must have Nix installed.
	Builder system.CommandRunner
}

func FlakeRefFromString(s string) *FlakeRef {
	split := strings.Index(s, "#")

	var uri string
	if split > -1 {
		uri = s[:split]
	} else {
		uri = s
	}

	if _, err := os.Stat(uri); err == nil {
		if resolved, err := filepath.EvalSymlinks(uri); err == nil {
			uri = resolved
		}
    }

	if split > -1 {
		return &FlakeRef{
			URI:    uri,
			System: s[split+1:],
		}
	}

	return &FlakeRef{
		URI:    uri,
		System: "",
	}
}

func FlakeRefFromEnv(defaultLocation string) (*FlakeRef, error) {
	nixosConfig, set := os.LookupEnv("NIXOS_CONFIG")
	if !set {
		nixosConfig = defaultLocation
	}

	if nixosConfig == "" {
		return nil, fmt.Errorf("NIXOS_CONFIG is not set")
	}

	return FlakeRefFromString(nixosConfig), nil
}

func (f *FlakeRef) InferSystemFromHostnameIfNeeded() error {
	if f.System == "" {
		hostname, err := os.Hostname()
		if err != nil {
			return err
		}

		f.System = hostname
	}

	return nil
}

func (f *FlakeRef) SetBuilder(builder system.CommandRunner) {
	f.Builder = builder
}

func (f *FlakeRef) EvalAttribute(attr string) (*string, error) {
	evalArg := fmt.Sprintf(`%s#nixosConfigurations.%s.config.%s`, f.URI, f.System, attr)
	argv := []string{"nix", "eval", evalArg}

	var stdout bytes.Buffer
	var stderr bytes.Buffer

	cmd := exec.Command(argv[0], argv[1:]...)
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	err := cmd.Run()
	if err != nil {
		return nil, &AttributeEvaluationError{
			Attribute:        attr,
			EvaluationOutput: strings.TrimSpace(stderr.String()),
		}
	}

	value := strings.TrimSpace(stdout.String())

	return &value, nil
}

func (f *FlakeRef) BuildSystem(buildType SystemBuildType, opts *SystemBuildOptions) (string, error) {
	nixCommand := "nix"
	if opts.UseNom {
		nixCommand = "nom"
	}

	systemAttribute := fmt.Sprintf("%s#nixosConfigurations.%s.config.system.build.%s", f.URI, f.System, buildType.BuildAttr())

	argv := []string{nixCommand, "build", systemAttribute, "--print-out-paths"}

	if opts.ResultLocation != "" {
		argv = append(argv, "--out-link", opts.ResultLocation)
	} else {
		argv = append(argv, "--no-link")
	}

	if opts.DryBuild {
		argv = append(argv, "--dry-run")
	}

	if opts.NixOpts != nil {
		argv = append(argv, nixopts.NixOptionsToArgsList(opts.CmdFlags, opts.NixOpts)...)
	}

	if opts.ExtraArgs != nil {
		argv = append(argv, opts.ExtraArgs...)
	}

	if opts.Verbose {
		argv = append(argv, "-v")
		f.Builder.Logger().CmdArray(argv)
	}

	var stdout bytes.Buffer
	cmd := system.NewCommand(nixCommand, argv[1:]...)
	cmd.Stdout = &stdout

	if opts.GenerationTag != "" {
		cmd.SetEnv("NIXOS_GENERATION_TAG", opts.GenerationTag)
	}

	for k, v := range opts.Env {
		cmd.SetEnv(k, v)
	}

	if f.Builder == nil {
		panic("FlakeRef.Builder is nil")
	}

	_, err := f.Builder.Run(cmd)

	return strings.Trim(stdout.String(), "\n "), err
}
</file>

<file path="internal/configuration/legacy.go">
package configuration

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/nix-community/nixos-cli/internal/cmd/nixopts"
	"github.com/nix-community/nixos-cli/internal/logger"
	"github.com/nix-community/nixos-cli/internal/system"
)

type LegacyConfiguration struct {
	Includes      []string
	ConfigDirname string

	// Builder is used to build the legacy system. They must have Nix installed.
	Builder system.CommandRunner
}

func FindLegacyConfiguration(log *logger.Logger, includes []string, verbose bool) (*LegacyConfiguration, error) {
	if verbose {
		log.Infof("looking for legacy configuration")
	}

	var configuration string
	if nixosCfg, set := os.LookupEnv("NIXOS_CONFIG"); set {
		if verbose {
			log.Info("$NIXOS_CONFIG is set, using automatically")
		}
		configuration = nixosCfg
	}

	if configuration == "" && includes != nil {
		for _, include := range includes {
			if strings.HasPrefix(include, "nixos-config=") {
				configuration = strings.TrimPrefix(include, "nixos-config=")
				break
			}
		}
	}

	if configuration == "" {
		if verbose {
			log.Infof("$NIXOS_CONFIG not set, using $NIX_PATH to find configuration")
		}

		nixPath := strings.Split(os.Getenv("NIX_PATH"), ":")
		for _, entry := range nixPath {
			if strings.HasPrefix(entry, "nixos-config=") {
				configuration = strings.TrimPrefix(entry, "nixos-config=")
				break
			}
		}

		if configuration == "" {
			return nil, fmt.Errorf("expected 'nixos-config' attribute to exist in NIX_PATH")
		}
	}

	configFileStat, err := os.Stat(configuration)
	if err != nil {
		return nil, err
	}

	if configFileStat.IsDir() {
		defaultNix := filepath.Join(configuration, "default.nix")

		info, err := os.Stat(defaultNix)
		if err != nil {
			return nil, err
		}

		if info.IsDir() {
			return nil, fmt.Errorf("%v is a directory, not a file", defaultNix)
		}
	} else {
		configuration = filepath.Dir(configuration)
	}

	return &LegacyConfiguration{
		Includes:      includes,
		ConfigDirname: configuration,
	}, nil
}

func (l *LegacyConfiguration) SetBuilder(builder system.CommandRunner) {
	l.Builder = builder
}

func (l *LegacyConfiguration) EvalAttribute(attr string) (*string, error) {
	configAttr := fmt.Sprintf("config.%s", attr)
	argv := []string{"nix-instantiate", "--eval", "<nixpkgs/nixos>", "-A", configAttr}

	for _, v := range l.Includes {
		argv = append(argv, "-I", v)
	}

	var stdout bytes.Buffer
	var stderr bytes.Buffer

	cmd := exec.Command(argv[0], argv[1:]...)
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	err := cmd.Run()
	if err != nil {
		return nil, &AttributeEvaluationError{
			Attribute:        attr,
			EvaluationOutput: strings.TrimSpace(stderr.String()),
		}
	}

	value := strings.TrimSpace(stdout.String())

	return &value, nil
}

func (l *LegacyConfiguration) BuildSystem(buildType SystemBuildType, opts *SystemBuildOptions) (string, error) {
	nixCommand := "nix-build"
	if opts.UseNom {
		nixCommand = "nom-build"
	}

	argv := []string{nixCommand, "<nixpkgs/nixos>", "-A", buildType.BuildAttr()}

	// Mimic `nixos-rebuild` behavior of using -k option
	// for all commands except for switch and boot
	if buildType != SystemBuildTypeSystemActivation {
		argv = append(argv, "-k")
	}

	if opts.NixOpts != nil {
		argv = append(argv, nixopts.NixOptionsToArgsList(opts.CmdFlags, opts.NixOpts)...)
	}

	if opts.ResultLocation != "" {
		argv = append(argv, "--out-link", opts.ResultLocation)
	} else {
		argv = append(argv, "--no-out-link")
	}

	if opts.ExtraArgs != nil {
		argv = append(argv, opts.ExtraArgs...)
	}

	if opts.Verbose {
		argv = append(argv, "-v")
		l.Builder.Logger().CmdArray(argv)
	}

	var stdout bytes.Buffer
	cmd := system.NewCommand(nixCommand, argv[1:]...)
	cmd.Stdout = &stdout

	if opts.GenerationTag != "" {
		cmd.SetEnv("NIXOS_GENERATION_TAG", opts.GenerationTag)
	}

	if l.Builder == nil {
		panic("LegacyConfiguration.Builder is nil")
	}

	for k, v := range opts.Env {
		cmd.SetEnv(k, v)
	}

	_, err := l.Builder.Run(cmd)

	return strings.Trim(stdout.String(), "\n "), err
}
</file>

<file path="internal/constants/constants.go">
package constants

const (
	NixProfileDirectory       = "/nix/var/nix/profiles"
	NixSystemProfileDirectory = NixProfileDirectory + "/system-profiles"
	DefaultConfigLocation     = "/etc/nixos-cli/config.toml"
	CurrentSystem             = "/run/current-system"
	NixOSMarker               = "/etc/NIXOS"
	NixChannelDirectory       = NixProfileDirectory + "/per-user/root/channels"
)
</file>

<file path="internal/generation/completion.go">
package generation

import (
	"fmt"
	"os"
	"regexp"
	"slices"
	"sort"
	"strconv"

	"github.com/nix-community/nixos-cli/internal/constants"
	"github.com/nix-community/nixos-cli/internal/logger"
	"github.com/spf13/cobra"
)

var genLinkRegex = regexp.MustCompile(`-(\d+)-link$`)

func CompleteProfileFlag(_ *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
	profiles := []string{"system"}

	entries, err := os.ReadDir(constants.NixSystemProfileDirectory)
	if err != nil {
		return []string{}, cobra.ShellCompDirectiveNoFileComp
	}

	for _, v := range entries {
		name := v.Name()

		if matches := genLinkRegex.FindStringSubmatch(name); len(matches) > 0 {
			continue
		}

		profiles = append(profiles, name)
	}

	sort.Strings(profiles)

	return profiles, cobra.ShellCompDirectiveNoFileComp
}

func CompleteGenerationNumber(profile *string, limit int) cobra.CompletionFunc {
	return func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
		log := logger.FromContext(cmd.Context())

		if limit != 0 && len(args) >= limit {
			return []string{}, cobra.ShellCompDirectiveNoFileComp
		}

		generations, err := CollectGenerationsInProfile(log, *profile)
		if err != nil {
			return []string{}, cobra.ShellCompDirectiveNoFileComp
		}

		exclude := []uint64{}
		for _, v := range args {
			parsed, err := strconv.ParseUint(v, 10, 64)
			if err != nil {
				continue
			}
			exclude = append(exclude, parsed)
		}

		genNumbers := []string{}
		for _, v := range generations {
			if slices.Contains(exclude, v.Number) {
				continue
			}
			genNumber := fmt.Sprint(v.Number)
			if v.Description != "" {
				genNumber += "\t" + v.Description
			}
			genNumbers = append(genNumbers, genNumber)
		}

		sort.Strings(genNumbers)

		return genNumbers, cobra.ShellCompDirectiveNoFileComp
	}
}

func CompleteGenerationNumberFlag(profile *string) cobra.CompletionFunc {
	return func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
		log := logger.FromContext(cmd.Context())

		generations, err := CollectGenerationsInProfile(log, *profile)
		if err != nil {
			return []string{}, cobra.ShellCompDirectiveNoFileComp
		}

		genNumbers := []string{}
		for _, v := range generations {
			genNumber := fmt.Sprint(v.Number)
			if v.Description != "" {
				genNumber += "\t" + v.Description
			}
			genNumbers = append(genNumbers, genNumber)
		}

		sort.Strings(genNumbers)

		return genNumbers, cobra.ShellCompDirectiveNoFileComp
	}
}
</file>

<file path="internal/generation/diff.go">
package generation

import (
	"os/exec"

	"github.com/nix-community/nixos-cli/internal/logger"
	"github.com/nix-community/nixos-cli/internal/system"
)

type DiffCommandOptions struct {
	UseNvd  bool
	Verbose bool
}

func RunDiffCommand(log *logger.Logger, s system.CommandRunner, before string, after string, opts *DiffCommandOptions) error {
	useNvd := opts.UseNvd

	if opts.UseNvd {
		nvdPath, _ := exec.LookPath("nvd")
		nvdFound := nvdPath != ""
		if !nvdFound {
			log.Warn("use_nvd is specified in config, but `nvd` is not executable")
			log.Warn("falling back to `nix store diff-closures`")
			useNvd = false
		}
	}

	argv := []string{"nix", "store", "diff-closures", before, after}
	if useNvd {
		argv = []string{"nvd", "diff", before, after}
	}

	if opts.Verbose {
		s.Logger().CmdArray(argv)
	}

	cmd := system.NewCommand(argv[0], argv[1:]...)

	_, err := s.Run(cmd)

	return err
}
</file>

<file path="internal/generation/generation.go">
package generation

import (
	"encoding/json"
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strconv"
	"time"

	"github.com/djherbis/times"
	"github.com/nix-community/nixos-cli/internal/constants"
	"github.com/nix-community/nixos-cli/internal/logger"
)

func GetProfileDirectoryFromName(profile string) string {
	if profile != "system" {
		return filepath.Join(constants.NixSystemProfileDirectory, profile)
	} else {
		return filepath.Join(constants.NixProfileDirectory, "system")
	}
}

type Generation struct {
	Number          uint64    `json:"number"`
	CreationDate    time.Time `json:"creation_date"`
	IsCurrent       bool      `json:"is_current"`
	KernelVersion   string    `json:"kernel_version"`
	Specialisations []string  `json:"specialisations"`

	NixosVersion          string `json:"nixos_version"`
	NixpkgsRevision       string `json:"nixpkgs_revision"`
	ConfigurationRevision string `json:"configuration_revision"`
	Description           string `json:"description"`
}

type GenerationManifest struct {
	NixosVersion          string `json:"nixosVersion"`
	NixpkgsRevision       string `json:"nixpkgsRevision"`
	ConfigurationRevision string `json:"configurationRevision"`
	Description           string `json:"description"`
}

type GenerationReadError struct {
	Directory string
	Number    uint64
	Errors    []error
}

func (e *GenerationReadError) Error() string {
	return fmt.Sprintf("failed to read generation %d from directory %s", e.Number, e.Directory)
}

func GenerationFromDirectory(generationDirname string, number uint64) (*Generation, error) {
	info := &Generation{
		Number:          number,
		CreationDate:    time.Time{},
		IsCurrent:       false,
		KernelVersion:   "",
		Specialisations: []string{},
	}

	nixosVersionManifestFile := filepath.Join(generationDirname, "nixos-version.json")

	encounteredErrors := []error{}

	manifestBytes, err := os.ReadFile(nixosVersionManifestFile)
	if err != nil {
		// The `nixos-version.json` file does not exist in generations that
		// are created without the corresponding NixOS module enabled or
		// created with `nixos-rebuild`/other application tools, and should
		// be ignored.
		if !errors.Is(err, os.ErrNotExist) {
			encounteredErrors = append(encounteredErrors, err)
		}
	} else {
		var manifest GenerationManifest
		err := json.Unmarshal(manifestBytes, &manifest)

		if err != nil {
			encounteredErrors = append(encounteredErrors, err)
		} else {
			info.NixosVersion = manifest.NixosVersion
			info.NixpkgsRevision = manifest.NixpkgsRevision
			info.ConfigurationRevision = manifest.ConfigurationRevision
			info.Description = manifest.Description
		}
	}

	// Fall back to reading the nixos-version file that should always
	// exist if the `nixos-version.json` file doesn't exist.
	if info.NixosVersion == "" {
		nixosVersionFile := filepath.Join(generationDirname, "nixos-version")
		nixosVersionContents, err := os.ReadFile(nixosVersionFile)
		if err != nil {
			encounteredErrors = append(encounteredErrors, err)
		} else {
			info.NixosVersion = string(nixosVersionContents)
		}
	}

	// Get time of creation for the generation
	creationTimeStat, err := times.Stat(generationDirname)
	if err != nil {
		encounteredErrors = append(encounteredErrors, err)
	} else {
		if creationTimeStat.HasBirthTime() {
			info.CreationDate = creationTimeStat.BirthTime()
		} else {
			info.CreationDate = creationTimeStat.ModTime()
		}
	}

	kernelVersionDirGlob := filepath.Join(generationDirname, "kernel-modules", "lib", "modules", "*")
	kernelVersionMatches, err := filepath.Glob(kernelVersionDirGlob)
	if err != nil {
		encounteredErrors = append(encounteredErrors, err)
	} else if len(kernelVersionMatches) == 0 {
		encounteredErrors = append(encounteredErrors, fmt.Errorf("no kernel modules version directory found"))
	} else {
		info.KernelVersion = filepath.Base(kernelVersionMatches[0])
	}

	specialisations, err := CollectSpecialisations(generationDirname)
	if err != nil {
		encounteredErrors = append(encounteredErrors, err)
	}

	info.Specialisations = specialisations

	if len(encounteredErrors) > 0 {
		return info, &GenerationReadError{
			Directory: generationDirname,
			Number:    number,
			Errors:    encounteredErrors,
		}
	}

	return info, nil
}

const (
	GenerationLinkTemplateRegex = `^%s-(\d+)-link$`
)

func CollectGenerationsInProfile(log *logger.Logger, profile string) ([]Generation, error) {
	profileDirectory := constants.NixProfileDirectory
	if profile != "system" {
		profileDirectory = constants.NixSystemProfileDirectory
	}

	generationDirEntries, err := os.ReadDir(profileDirectory)
	if err != nil {
		return nil, err
	}

	genLinkRegex, err := regexp.Compile(fmt.Sprintf(GenerationLinkTemplateRegex, profile))
	if err != nil {
		return nil, fmt.Errorf("failed to compile generation regex: %w", err)
	}

	currentGenerationDirname := GetProfileDirectoryFromName(profile)
	currentGenerationLink, err := os.Readlink(currentGenerationDirname)
	if err != nil {
		log.Warnf("unable to determine current generation: %v", err)
	}

	generations := []Generation{}
	for _, v := range generationDirEntries {
		name := v.Name()

		if matches := genLinkRegex.FindStringSubmatch(name); len(matches) > 0 {
			genNumber, err := strconv.ParseInt(matches[1], 10, 64)
			if err != nil {
				log.Warnf("failed to parse generation number %v for %v, skipping", matches[1], filepath.Join(profileDirectory, name))
				continue
			}

			profileDirectory := constants.NixProfileDirectory
			if profile != "system" {
				profileDirectory = constants.NixSystemProfileDirectory
			}

			generationDirectoryName := filepath.Join(profileDirectory, fmt.Sprintf("%s-%d-link", profile, genNumber))

			info, err := GenerationFromDirectory(generationDirectoryName, uint64(genNumber))
			if err != nil {
				return nil, err
			}

			if name == currentGenerationLink {
				info.IsCurrent = true
			}

			generations = append(generations, *info)
		}
	}

	sort.Slice(generations, func(i, j int) bool {
		return generations[i].Number < generations[j].Number
	})

	return generations, nil
}
</file>

<file path="internal/generation/specialisations.go">
package generation

import (
	"encoding/json"
	"fmt"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"

	"github.com/nix-community/nixos-cli/internal/configuration"
	"github.com/nix-community/nixos-cli/internal/logger"
	"github.com/nix-community/nixos-cli/internal/settings"
	"github.com/spf13/cobra"
)

func CollectSpecialisations(generationDirname string) ([]string, error) {
	var specialisations []string

	specialisationsGlob := filepath.Join(generationDirname, "specialisation", "*")

	specialisationsMatches, err := filepath.Glob(specialisationsGlob)
	if err != nil {
		return nil, err
	} else {
		for _, match := range specialisationsMatches {
			specialisations = append(specialisations, filepath.Base(match))
		}
	}

	sort.Strings(specialisations)

	return specialisations, nil
}

func CollectSpecialisationsFromConfig(cfg configuration.Configuration) []string {
	var argv []string

	switch c := cfg.(type) {
	case *configuration.FlakeRef:
		attr := fmt.Sprintf("%s#nixosConfigurations.%s.config.specialisation", c.URI, c.System)
		argv = []string{"nix", "eval", attr, "--apply", "builtins.attrNames", "--json"}
	case *configuration.LegacyConfiguration:
		argv = []string{
			"nix-instantiate", "--eval", "--json", "--expr", "builtins.attrNames",
			"builtins.attrNames (import <nixpkgs/nixos> {}).config.specialisation",
		}
	}

	cmd := exec.Command(argv[0], argv[1:]...)

	stdout, err := cmd.Output()
	if err != nil {
		return []string{}
	}

	specialisations := []string{}

	err = json.Unmarshal(stdout, &specialisations)
	if err != nil {
		return []string{}
	}

	return specialisations
}

func CompleteSpecialisationFlag(generationDirname string) cobra.CompletionFunc {
	return func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
		specialisations, err := CollectSpecialisations(generationDirname)
		if err != nil {
			return []string{}, cobra.ShellCompDirectiveNoFileComp
		}

		candidates := []string{}

		for _, specialisation := range specialisations {
			if specialisation == toComplete {
				return specialisations, cobra.ShellCompDirectiveNoFileComp
			}

			if strings.HasPrefix(specialisation, toComplete) {
				candidates = append(candidates, specialisation)
			}
		}

		return candidates, cobra.ShellCompDirectiveNoFileComp
	}
}

func CompleteSpecialisationFlagFromConfig(flakeRefStr string, includes []string) cobra.CompletionFunc {
	return func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
		log := logger.FromContext(cmd.Context())
		cfg := settings.FromContext(cmd.Context())

		var nixConfig configuration.Configuration
		if flakeRefStr != "" {
			nixConfig = configuration.FlakeRefFromString(flakeRefStr)
		} else {
			c, err := configuration.FindConfiguration(log, cfg, includes, false)
			if err != nil {
				log.Errorf("failed to find configuration: %v", err)
				return []string{}, cobra.ShellCompDirectiveNoFileComp
			}
			nixConfig = c
		}

		if nixConfig == nil {
			log.Error("config is nil")
			return []string{}, cobra.ShellCompDirectiveNoFileComp
		}

		specialisations := CollectSpecialisationsFromConfig(nixConfig)

		candidates := []string{}

		for _, specialisation := range specialisations {
			if specialisation == toComplete {
				return []string{specialisation}, cobra.ShellCompDirectiveNoFileComp
			}

			if strings.HasPrefix(specialisation, toComplete) {
				candidates = append(candidates, specialisation)
			}
		}

		return candidates, cobra.ShellCompDirectiveNoFileComp
	}
}
</file>

<file path="internal/logger/context.go">
package logger

import "context"

type loggerCtxKeyType string

const loggerCtxKey loggerCtxKeyType = "logger"

func WithLogger(ctx context.Context, logger *Logger) context.Context {
	return context.WithValue(ctx, loggerCtxKey, logger)
}

func FromContext(ctx context.Context) *Logger {
	logger, ok := ctx.Value(loggerCtxKey).(*Logger)
	if !ok {
		panic("logger not present in context")
	}
	return logger
}
</file>

<file path="internal/logger/logger.go">
package logger

import (
	"log"
	"os"

	"github.com/fatih/color"
	"github.com/nix-community/nixos-cli/internal/utils"
)

type Logger struct {
	print *log.Logger
	info  *log.Logger
	warn  *log.Logger
	error *log.Logger

	level        LogLevel
	stepNumber   uint
	stepsEnabled bool
}

type LogLevel int

const (
	LogLevelInfo   LogLevel = 0
	LogLevelWarn   LogLevel = 1
	LogLevelError  LogLevel = 2
	LogLevelSilent LogLevel = 3
)

func NewLogger() *Logger {
	green := color.New(color.FgGreen)
	boldYellow := color.New(color.FgYellow).Add(color.Bold)
	boldRed := color.New(color.FgRed).Add(color.Bold)

	return &Logger{
		print:      log.New(os.Stderr, "", 0),
		info:       log.New(os.Stderr, green.Sprint("info: "), 0),
		warn:       log.New(os.Stderr, boldYellow.Sprint("warning: "), 0),
		error:      log.New(os.Stderr, boldRed.Sprint("error: "), 0),
		stepNumber: 0,
		// Some commands call other subcommands through forks, such.
		// as `install` calling `enter`. For those, step numbers can
		// be confusing.
		stepsEnabled: os.Getenv("NIXOS_CLI_DISABLE_STEPS") == "",
	}
}

func (l *Logger) Print(v ...any) {
	l.print.Print(v...)
}

func (l *Logger) Printf(format string, v ...any) {
	l.print.Printf(format, v...)
}

func (l *Logger) Info(v ...any) {
	if l.level > LogLevelInfo {
		return
	}
	l.info.Println(v...)
}

func (l *Logger) Infof(format string, v ...any) {
	if l.level > LogLevelInfo {
		return
	}
	l.info.Printf(format+"\n", v...)
}

func (l *Logger) Warn(v ...any) {
	if l.level > LogLevelWarn {
		return
	}
	l.warn.Println(v...)
}

func (l *Logger) Warnf(format string, v ...any) {
	if l.level > LogLevelWarn {
		return
	}
	l.warn.Printf(format+"\n", v...)
}

func (l *Logger) Error(v ...any) {
	if l.level > LogLevelError {
		return
	}
	l.error.Println(v...)
}

func (l *Logger) Errorf(format string, v ...any) {
	if l.level > LogLevelError {
		return
	}
	l.error.Printf(format+"\n", v...)
}

func (l *Logger) CmdArray(argv []string) {
	if l.level > LogLevelInfo {
		return
	}

	msg := color.New(color.FgBlue).Sprintf("$ %v", utils.EscapeAndJoinArgs(argv))
	l.print.Printf("%v\n", msg)
}

func (l *Logger) Step(message string) {
	// Replace step numbers with generic l.Info() calls if
	// steps are disabled, to increase clarity in steps.
	if !l.stepsEnabled {
		l.Info(message)
		return
	}

	if l.level > LogLevelInfo {
		return
	}

	l.stepNumber++
	if l.stepNumber > 1 {
		l.print.Println()
	}
	msg := color.New(color.FgMagenta).Add(color.Bold).Sprintf("%v. %v", l.stepNumber, message)
	l.print.Println(msg)
}

func (l *Logger) SetLogLevel(level LogLevel) {
	l.level = level
}

// Call this when the colors have been enabled or disabled.
func (l *Logger) RefreshColorPrefixes() {
	green := color.New(color.FgGreen)
	boldYellow := color.New(color.FgYellow).Add(color.Bold)
	boldRed := color.New(color.FgRed).Add(color.Bold)

	l.info.SetPrefix(green.Sprint("info: "))
	l.warn.SetPrefix(boldYellow.Sprint("warning: "))
	l.error.SetPrefix(boldRed.Sprint("error: "))
}
</file>

<file path="internal/settings/completion_test.go">
package settings_test

import (
	"strings"
	"testing"

	"github.com/nix-community/nixos-cli/internal/settings"
	"github.com/spf13/cobra"
)

type TestCase struct {
	Input    string
	Expected []string
}

func TestCompleteConfigFlag(t *testing.T) {
	testCases := []TestCase{
		// Fields tagged with `noset:"true"` should result in no completions
		{"aliases", []string{}},
		{"ali", []string{}},
		{"init.extra_config", []string{}},

		// Fields with a single match to a settable key should add an = at the end.
		{"apply.imply_impure_with_tag", []string{"apply.imply_impure_with_tag="}},
		{"apply.imp", []string{"apply.imply_impure_with_tag="}},

		// Fields with further nested keys should add a .
		{"app", []string{"apply."}},
		{"ent", []string{"enter."}},

		// Fields after a . should be underneath the nested option
		{"option.", []string{"option.min_score", "option.prettify", "option.debounce_time"}},

		{"apply.use_", []string{"apply.use_nom", "apply.use_git_commit_msg"}},

		// Invalid fields should result in no completions
		{"invalid", []string{}},
		{"bruh.lmao", []string{}},

		// Boolean field value completion
		{"color=", []string{"color=true", "color=false"}},
		{"color=t", []string{"color=true"}},
		{"color=f", []string{"color=false"}},
		{"color=invalid", []string{}},
	}

	for _, testCase := range testCases {
		actual, _ := settings.CompleteConfigFlag(&cobra.Command{}, []string{}, testCase.Input)

		// Discard completion descriptions.
		for i, v := range actual {
			actual[i] = stripAfterTab(v)
		}

		if !slicesEqual(actual, testCase.Expected) {
			t.Errorf("for input '%s': expected %v, got %v", testCase.Input, testCase.Expected, actual)
		}
	}
}

func slicesEqual(a []string, b []string) bool {
	if len(a) != len(b) {
		return false
	}

	for i, v := range a {
		if v != b[i] {
			return false
		}
	}

	return true
}

func stripAfterTab(input string) string {
	if i := strings.Index(input, "\t"); i > -1 {
		return input[:i]
	}
	return input
}
</file>

<file path="internal/settings/completion.go">
package settings

import (
	"fmt"
	"reflect"
	"strings"

	"github.com/spf13/cobra"
)

type fieldCompleteResult struct {
	Name        string
	Description string
}

func findFieldCompletions(value any, prefix string) ([]fieldCompleteResult, bool) {
	var candidates []fieldCompleteResult

	fieldNames := strings.Split(prefix, ".")

	finalFieldComponent := ""
	previousComponents := []string{}

	if len(fieldNames) > 0 {
		finalFieldComponent = fieldNames[len(fieldNames)-1]
		previousComponents = fieldNames[:len(fieldNames)-1]
	}

	current := reflect.ValueOf(value)
	if current.Kind() == reflect.Ptr {
		current = current.Elem()
	}

	// Traverse into the structure following all components except the final one
	for _, fieldName := range previousComponents {
		found := false

		for i := 0; i < current.Type().NumField(); i++ {
			field := current.Type().Field(i)
			if field.Tag.Get("koanf") == fieldName {
				current = current.Field(i)
				if current.Kind() == reflect.Ptr {
					if current.IsNil() {
						current.Set(reflect.New(current.Type().Elem()))
					}

					current = current.Elem()
				}

				found = true
				break
			}
		}

		if !found || current.Kind() != reflect.Struct {
			return nil, false
		}
	}

	if current.Kind() == reflect.Ptr {
		if current.IsNil() {
			current.Set(reflect.New(current.Type().Elem()))
		}
		current = current.Elem()
	}

	if current.Kind() != reflect.Struct {
		return nil, false
	}

	for i := 0; i < current.Type().NumField(); i++ {
		structField := current.Type().Field(i)

		if structField.Tag.Get("noset") == "true" {
			continue
		}

		name := structField.Tag.Get("koanf")
		if name == "" {
			continue
		}

		fullName := strings.Join(append(previousComponents, name), ".")
		description := bestDescriptionFor(fullName)

		if name == finalFieldComponent {
			field := current.Field(i)
			isComplete := isSettable(&field)
			return []fieldCompleteResult{
				{
					Name:        fullName,
					Description: description,
				},
			}, isComplete
		}

		if strings.HasPrefix(name, finalFieldComponent) {
			candidates = append(candidates, fieldCompleteResult{
				Name:        fullName,
				Description: description,
			})
		}
	}

	isComplete := false

	if len(candidates) == 1 {
		candidate := candidates[0].Name
		lastDot := strings.LastIndex(candidate, ".")
		fieldName := candidate
		if lastDot != -1 {
			fieldName = candidate[lastDot+1:]
		}

		for i := 0; i < current.Type().NumField(); i++ {
			structField := current.Type().Field(i)
			if structField.Tag.Get("koanf") == fieldName {
				field := current.Field(i)
				isComplete = isSettable(&field)
				break
			}
		}
	}

	return candidates, isComplete
}

func bestDescriptionFor(name string) string {
	best := ""
	shortestLen := -1

	for k, v := range SettingsDocs {
		if strings.HasSuffix(k, name) {
			if shortestLen == -1 || len(k) < shortestLen {
				best = v.Short
				shortestLen = len(k)
			}
		}
	}

	return best
}

func CompleteConfigFlag(_ *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
	splitIndex := strings.Index(toComplete, "=")
	if splitIndex == -1 {
		return completeKeys(toComplete)
	}

	key := toComplete[0:splitIndex]
	candidate := toComplete[splitIndex+1:]

	return completeValues(key, candidate)
}

func completeKeys(candidate string) ([]string, cobra.ShellCompDirective) {
	completionCandidates, complete := findFieldCompletions(NewSettings(), candidate)

	// There are three cases of completions where extra actions need to be taken:
	// 1. Multiple candidates remaining
	//    - Do nothing
	// 2. Single candidate, but does not represent a settable key (aka a struct)
	//    - Add a '.', more input is needed
	// 3. Single candidate, and complete key is found
	//    - Add a '=' to signify start of value completions, if they exist
	if len(completionCandidates) == 1 {
		if complete {
			completionCandidates[0].Name = completionCandidates[0].Name + "="
		} else {
			completionCandidates[0].Name = completionCandidates[0].Name + "."
		}
	}

	candidates := make([]string, len(completionCandidates))
	for i, v := range completionCandidates {
		if v.Description != "" {
			candidates[i] = fmt.Sprintf("%v\t%v", v.Name, v.Description)
		} else {
			candidates[i] = v.Name
		}
	}

	// Completion of keys should never end with a space, since the value
	// is required.
	return candidates, cobra.ShellCompDirectiveNoSpace
}

type CompletionValueFunc func(key string, candidate string) ([]string, cobra.ShellCompDirective)

func boolCompletionFunc(key string, candidate string) ([]string, cobra.ShellCompDirective) {
	options := []string{"true\tTurn this setting on", "false\tTurn this setting off"}
	var matches []string

	for _, option := range options {
		if strings.HasPrefix(option, candidate) {
			// Yeah, this kind of sucks. It would be preferable to not have to include
			// the prefix in the arguments, since this becomes rather verbose,
			// but this works alright, for now.

			match := fmt.Sprintf("%v=%v", key, option)
			matches = append(matches, match)
		}
	}

	return matches, cobra.ShellCompDirectiveNoFileComp
}

// For custom completion functions, use this.
var completionValueFuncs = map[string]CompletionValueFunc{}

func completeValues(key string, value string) ([]string, cobra.ShellCompDirective) {
	cfg := NewSettings()

	if completeFunc, ok := completionValueFuncs[key]; ok {
		return completeFunc(key, value)
	}

	if isBoolField(cfg, key) {
		return boolCompletionFunc(key, value)
	}

	return []string{}, cobra.ShellCompDirectiveNoFileComp
}

func isBoolField(root any, key string) bool {
	field := findField(root, key)
	kind := field.Kind()
	return kind == reflect.Bool
}

func findField(root any, key string) *reflect.Value {
	parts := strings.Split(key, ".")
	current := reflect.ValueOf(root)

	if current.Kind() == reflect.Ptr {
		current = current.Elem()
	}

	for _, part := range parts {
		if current.Kind() != reflect.Struct {
			return nil
		}

		found := false
		for i := 0; i < current.Type().NumField(); i++ {
			field := current.Type().Field(i)
			if field.Tag.Get("koanf") == part {
				current = current.Field(i)
				if current.Kind() == reflect.Ptr {
					if current.IsNil() {
						return nil
					}
					current = current.Elem()
				}
				found = true
				break
			}
		}
		if !found {
			return nil
		}
	}

	return &current
}
</file>

<file path="internal/settings/context.go">
package settings

import "context"

type settincsCtxKeyType string

const settingsCtxKey settincsCtxKeyType = "settings"

func WithConfig(ctx context.Context, cfg *Settings) context.Context {
	return context.WithValue(ctx, settingsCtxKey, cfg)
}

func FromContext(ctx context.Context) *Settings {
	logger, ok := ctx.Value(settingsCtxKey).(*Settings)
	if !ok {
		panic("settings not present in context")
	}
	return logger
}
</file>

<file path="internal/settings/errors.go">
package settings

import "fmt"

type SettingsErrors []SettingsError

type SettingsError struct {
	Field   string
	Message string
}

func (e SettingsError) Error() string {
	return fmt.Sprintf("%s: %s", e.Field, e.Message)
}
</file>

<file path="internal/settings/settings_test.go">
package settings_test

import (
	"testing"

	"github.com/nix-community/nixos-cli/internal/settings"
)

func TestValidateConfig(t *testing.T) {
	t.Run("incorrect config fails", func(t *testing.T) {
		cfg := &settings.Settings{
			Aliases: map[string][]string{
				"":                     {"value1"},
				"-bad":                 {"value2"},
				"has space":            {"value3"},
				"validalias":           {"value4"},
				"validalias-noentries": {},
			},
			Option: settings.OptionSettings{
				MinScore: 1,
			},
		}

		errs := cfg.Validate()
		if len(errs) != 4 {
			t.Errorf("expected 4 errors, got %d", len(errs))
		}

		if len(cfg.Aliases) != 1 {
			t.Errorf("expected Aliases to have one valid entry, got %v", cfg.Aliases)
		}
	})

	t.Run("valid config passes", func(t *testing.T) {
		cfg := &settings.Settings{
			Aliases: map[string][]string{
				"validalias": {"value1", "value2"},
			},
			Option: settings.OptionSettings{
				MinScore: 2,
			},
		}

		errs := cfg.Validate()
		if errs != nil {
			t.Errorf("expected error slice to be nil, got %d errors", len(errs))
		}
	})
}

func TestSetConfigValue(t *testing.T) {
	t.Run("Set int field successfully", func(t *testing.T) {
		cfg := &settings.Settings{
			Option: settings.OptionSettings{
				MinScore: 1,
			},
		}

		err := cfg.SetValue("option.min_score", "4")
		if err != nil {
			t.Fatalf("expected option.min_score to be set, err = %v", err)
		}

		expected := int64(4)
		actual := cfg.Option.MinScore

		if expected != actual {
			t.Fatalf("expected option.min_score = %v, actual = %v", expected, actual)
		}
	})

	t.Run("Set string field successfully", func(t *testing.T) {
		cfg := &settings.Settings{
			ConfigLocation: "/etc/nixos",
		}

		err := cfg.SetValue("config_location", "/home/user")
		if err != nil {
			t.Fatalf("expected config_location to be set, err = %v", err)
		}

		expected := "/home/user"
		actual := cfg.ConfigLocation

		if expected != actual {
			t.Fatalf("expected config_location = %v, actual = %v", expected, actual)
		}
	})

	t.Run("Set boolean field successfully", func(t *testing.T) {
		cfg := &settings.Settings{
			Apply: settings.ApplySettings{
				ImplyImpureWithTag: true,
			},
		}

		err := cfg.SetValue("apply.imply_impure_with_tag", "true")
		if err != nil {
			t.Fatalf("expected apply.imply_impure_with_tag to be set, err = %v", err)
		}

		expected := true
		actual := cfg.Apply.ImplyImpureWithTag

		if expected != actual {
			t.Fatalf("expected apply.imply_impure_with_tag = %v, actual = %v", expected, actual)
		}
	})

	t.Run("Invalid key", func(t *testing.T) {
		cfg := &settings.Settings{}

		err := cfg.SetValue("invalid_key", "")
		if err == nil {
			t.Fatalf("expected invalid_key to error out, no errors detected")
		}
	})

	t.Run("Invalid nested key", func(t *testing.T) {
		cfg := &settings.Settings{}

		err := cfg.SetValue("apply.invalid.nested", "")
		if err == nil {
			t.Fatalf("expected apply.invalid.nested to error out, no errors detected")
		}
	})

	t.Run("Invalid boolean value", func(t *testing.T) {
		cfg := &settings.Settings{
			Apply: settings.ApplySettings{
				ImplyImpureWithTag: true,
			},
		}

		err := cfg.SetValue("apply.imply_impure_with_tag", "invalid")
		if err == nil {
			t.Fatalf("expected apply.imply_impure_with_tag to error out, no errors detected")
		}
	})

	t.Run("Invalid int value", func(t *testing.T) {
		cfg := &settings.Settings{
			Option: settings.OptionSettings{
				MinScore: 1,
			},
		}

		err := cfg.SetValue("option.min_score", "invalid")
		if err == nil {
			t.Fatalf("expected option.min_score to error out, no errors detected")
		}

		expected := int64(1)
		actual := cfg.Option.MinScore

		if expected != actual {
			t.Fatalf("expected option.min_score to remain unchanged, expected = %v actual = %v", expected, actual)
		}
	})
}
</file>

<file path="internal/settings/settings.go">
package settings

import (
	"fmt"
	"reflect"
	"regexp"
	"strconv"
	"strings"

	"github.com/knadh/koanf/parsers/toml/v2"
	"github.com/knadh/koanf/providers/file"
	"github.com/knadh/koanf/v2"
)

type Settings struct {
	Aliases        map[string][]string `koanf:"aliases" noset:"true"`
	Apply          ApplySettings       `koanf:"apply"`
	AutoRollback   bool                `koanf:"auto_rollback"`
	UseColor       bool                `koanf:"color"`
	ConfigLocation string              `koanf:"config_location"`
	Enter          EnterSettings       `koanf:"enter"`
	Init           InitSettings        `koanf:"init"`
	NoConfirm      bool                `koanf:"no_confirm"`
	Option         OptionSettings      `koanf:"option"`
	RootCommand    string              `koanf:"root_command"`
	UseNvd         bool                `koanf:"use_nvd"`
}

type ApplySettings struct {
	ImplyImpureWithTag    bool   `koanf:"imply_impure_with_tag"`
	DefaultSpecialisation string `koanf:"specialisation"`
	UseNom                bool   `koanf:"use_nom"`
	UseGitCommitMsg       bool   `koanf:"use_git_commit_msg"`
	IgnoreDirtyTree       bool   `koanf:"ignore_dirty_tree"`
}

type EnterSettings struct {
	MountResolvConf bool `koanf:"mount_resolv_conf"`
}

type InitSettings struct {
	EnableXserver bool              `koanf:"xserver_enabled"`
	DesktopConfig string            `koanf:"desktop_config"`
	ExtraAttrs    map[string]string `koanf:"extra_attrs" noset:"true"`
	ExtraConfig   string            `koanf:"extra_config" noset:"true"`
}

type OptionSettings struct {
	MinScore     int64 `koanf:"min_score"`
	Prettify     bool  `koanf:"prettify"`
	DebounceTime int64 `koanf:"debounce_time"`
}

type DescriptionEntry struct {
	Short string
	Long  string
}

const (
	aliasExample = "```\n" + `[aliases]
genlist = ["generation", "list"]
switch = ["generation", "switch"]
rollback = ["generation", "rollback"]
` + "```\n"
)

var SettingsDocs = map[string]DescriptionEntry{
	"aliases": {
		Short: "Shortcuts for long commands",
		Long:  "Defines alternative aliases for long commands to improve user ergonomics.\nExample:\n" + aliasExample,
	},
	"apply": {
		Short: "Settings for `apply` command",
	},
	"apply.imply_impure_with_tag": {
		Short: "Add --impure automatically when using --tag with flakes",
		Long:  "Automatically appends '--impure' to the 'apply' command when using '--tag' in flake-based workflows.",
	},
	"apply.specialisation": {
		Short: "Name of specialisation to use by default when activating",
		Long:  "Specifies which systemd specialisation to use when activating a configuration with 'apply'.",
	},
	"apply.use_nom": {
		Short: "Use 'nix-output-monitor' as an alternative 'nix build' frontend",
		Long:  "Enables nix-output-monitor to show more user-friendly build progress output for the 'apply' command.",
	},
	"apply.use_git_commit_msg": {
		Short: "Use last git commit message for --tag by default",
		Long:  "When enabled, the last Git commit message will be used as the value for '--tag' automatically.",
	},
	"apply.ignore_dirty_tree": {
		Short: "Ignore dirty working tree when using Git commit message for --tag",
		Long:  "Allows 'apply' to use Git commit messages even when the working directory is dirty.",
	},
	"auto_rollback": {
		Short: "Automatically rollback profile on activation failure",
		Long: "Enables automatic rollback of a NixOS system profile when an activation command fails. This can be " +
			"disabled when a reboot or some other circumstance is needed for successful activation",
	},
	"color": {
		Short: "Enable colored output",
		Long:  "Turns on ANSI color sequences for decorated output in supported terminals.",
	},
	"config_location": {
		Short: "Where to look for configuration by default",
		Long:  "Path to a Nix file or directory to look for user configuration in by default.",
	},
	"enter": {
		Short: "Settings for `enter` command",
	},
	"enter.mount_resolv_conf": {
		Short: "Bind-mount host 'resolv.conf' inside chroot for internet accesss",
		Long:  "Ensures internet access by mounting the host's /etc/resolv.conf into the chroot environment.",
	},
	"init": {
		Short: "Settings for `init` command",
	},
	"init.xserver_enabled": {
		Short: "Generate options to enable X11 display server",
		Long:  "Controls whether X11-related services and packages are configured by default during init.",
	},
	"init.desktop_config": {
		Short: "Config options for desktop environment",
		Long:  "Specifies the desktop environment configuration to inject during initialization.",
	},
	"no_confirm": {
		Short: "Disable interactive confirmation input",
		Long:  "Disables prompts that ask for user confirmation, useful for automation.",
	},
	"option": {
		Short: "Settings for `option` command",
	},
	"option.min_score": {
		Short: "Minimum distance score to consider an option a match",
		Long:  "Sets the cutoff score for showing results in fuzzy-matched option lookups.",
	},
	"option.prettify": {
		Short: "Attempt to render options using Markdown",
		Long:  "If enabled, renders option documentation in a prettier Markdown format where applicable.",
	},
	"option.debounce_time": {
		Short: "Debounce time for searching options using the UI, in milliseconds",
		Long:  "Controls how often search results are recomputed when typing in the options UI, in milliseconds.",
	},
	"root_command": {
		Short: "Command to use to promote process to root",
		Long:  "Specifies which command to use for privilege escalation (e.g., sudo or doas).",
	},
	"use_nvd": {
		Short: "Use 'nvd' instead of `nix store diff-closures`",
		Long:  "Use the better-looking `nvd` diffing tool when comparing configurations instead of `nix store diff-closures`.",
	},
}

func NewSettings() *Settings {
	return &Settings{
		AutoRollback:   true,
		UseColor:       true,
		ConfigLocation: "/etc/nixos",
		Enter: EnterSettings{
			MountResolvConf: true,
		},
		Init:        InitSettings{},
		RootCommand: "sudo",
		Option: OptionSettings{
			MinScore:     1,
			Prettify:     true,
			DebounceTime: 25,
		},
	}
}

func ParseSettings(location string) (*Settings, error) {
	k := koanf.New(".")

	if err := k.Load(file.Provider(location), toml.Parser()); err != nil {
		return nil, err
	}

	cfg := NewSettings()

	err := k.Unmarshal("", cfg)
	if err != nil {
		return nil, err
	}

	return cfg, nil
}

var hasWhitespaceRegex = regexp.MustCompile(`\s`)

// Validate the configuration and remove any erroneous values.
// A list of detected errors is returned, if any exist.
func (cfg *Settings) Validate() SettingsErrors {
	errs := []SettingsError{}

	// First, validate the aliases. Any alias has to adhere to the following rules:
	// 1. Alias names cannot be empty.
	// 2. Alias names cannot have whitespace
	// 3. Alias names cannot start with a -
	// 4. Resolved arguments list must have a len > 1
	for alias, resolved := range cfg.Aliases {
		if len(alias) == 0 {
			errs = append(errs, SettingsError{Field: "aliases", Message: "alias name cannot be empty"})
			delete(cfg.Aliases, alias)
		} else if alias[0] == '-' {
			errs = append(errs, SettingsError{Field: fmt.Sprintf("aliases.%s", alias), Message: "alias cannot start with a '-'"})
			delete(cfg.Aliases, alias)
		} else if hasWhitespaceRegex.MatchString(alias) {
			errs = append(errs, SettingsError{Field: fmt.Sprintf("aliases.%s", alias), Message: "alias cannot have whitespace"})
			delete(cfg.Aliases, alias)
		} else if len(resolved) == 0 {
			errs = append(errs, SettingsError{Field: fmt.Sprintf("aliases.%s", alias), Message: "args list cannot be empty"})
			delete(cfg.Aliases, alias)
		}
	}

	if len(errs) > 0 {
		return errs
	}
	return nil
}

func (cfg *Settings) SetValue(key string, value string) error {
	fields := strings.Split(key, ".")
	current := reflect.ValueOf(cfg).Elem()

	for i, field := range fields {
		// Find the struct field with the matching koanf tag
		found := false
		for j := 0; j < current.Type().NumField(); j++ {
			fieldInfo := current.Type().Field(j)
			if fieldInfo.Tag.Get("koanf") == field {
				current = current.Field(j)
				found = true
				break
			}
		}

		if !found {
			return SettingsError{Field: field, Message: "setting not found"}
		}

		if current.Kind() == reflect.Ptr {
			if current.IsNil() {
				current.Set(reflect.New(current.Type().Elem()))
			}
			current = current.Elem()
		}

		if i == len(fields)-1 {
			if !current.CanSet() {
				return SettingsError{Field: field, Message: "cannot change value of this setting dynamically"}
			}

			switch current.Kind() {
			case reflect.String:
				current.SetString(value)
			case reflect.Bool:
				boolVal, err := strconv.ParseBool(value)
				if err != nil {
					return SettingsError{Field: field, Message: fmt.Sprintf("invalid boolean value '%s' for field", value)}
				}
				current.SetBool(boolVal)
			case reflect.Int, reflect.Int64:
				intVal, err := strconv.ParseInt(value, 10, 64)
				if err != nil {
					return SettingsError{Field: field, Message: fmt.Sprintf("invalid integer value '%s' for field", value)}
				}
				current.SetInt(intVal)
			case reflect.Float64:
				floatVal, err := strconv.ParseFloat(value, 64)
				if err != nil {
					return SettingsError{Field: field, Message: fmt.Sprintf("invalid float value '%s' for field", value)}
				}
				current.SetFloat(floatVal)
			default:
				return SettingsError{Field: field, Message: "unsupported field type"}
			}

			return nil
		}
	}

	return nil
}

func isSettable(value *reflect.Value) bool {
	switch value.Kind() {
	case reflect.String, reflect.Bool, reflect.Int, reflect.Int64, reflect.Float64:
		return true
	}

	return false
}
</file>

<file path="internal/system/local.go">
package system

import (
	"bufio"
	"os"
	"os/exec"
	"regexp"
	"strings"

	"github.com/nix-community/nixos-cli/internal/logger"
)

type LocalSystem struct {
	logger *logger.Logger
}

func NewLocalSystem(logger *logger.Logger) *LocalSystem {
	return &LocalSystem{
		logger: logger,
	}
}

func (l *LocalSystem) Run(cmd *Command) (int, error) {
	command := exec.Command(cmd.Name, cmd.Args...)

	command.Stdout = cmd.Stdout
	command.Stderr = cmd.Stderr
	command.Stdin = cmd.Stdin
	command.Env = os.Environ()

	for key, value := range cmd.Env {
		command.Env = append(command.Env, key+"="+value)
	}

	err := command.Run()

	if exitErr, ok := err.(*exec.ExitError); ok {
		if status, ok := exitErr.Sys().(interface{ ExitStatus() int }); ok {
			return status.ExitStatus(), err
		}
	}

	if err == nil {
		return 0, nil
	}

	return 0, err
}

var nixosDistroIDRegex = regexp.MustCompile("^\"?nixos\"?$")

func (l *LocalSystem) IsNixOS() bool {
	_, err := os.Stat("/etc/NIXOS")
	if err == nil {
		return true
	}

	osRelease, err := parseOSRelease()
	if err != nil {
		return false
	}

	distroID, ok := osRelease["ID"]
	if !ok {
		return false
	}

	return nixosDistroIDRegex.MatchString(distroID)
}

func (l *LocalSystem) Logger() *logger.Logger {
	return l.logger
}

func parseOSRelease() (map[string]string, error) {
	values := make(map[string]string)

	osRelease, err := os.Open("/etc/os-release")
	if err != nil {
		return nil, err
	}
	defer func() { _ = osRelease.Close() }()

	s := bufio.NewScanner(osRelease)
	s.Split(bufio.ScanLines)

	for s.Scan() {
		key, value, found := strings.Cut(s.Text(), "=")
		if !found {
			continue
		}
		values[key] = value
	}

	return values, nil
}
</file>

<file path="internal/system/runner.go">
package system

import (
	"io"
	"os"

	"github.com/nix-community/nixos-cli/internal/logger"
)

type CommandRunner interface {
	Run(cmd *Command) (int, error)
	Logger() *logger.Logger
}

type Command struct {
	Name   string
	Args   []string
	Stdin  io.Reader
	Stdout io.Writer
	Stderr io.Writer
	Env    map[string]string
}

func NewCommand(name string, args ...string) *Command {
	return &Command{
		Name:   name,
		Args:   args,
		Stdin:  os.Stdin,
		Stdout: os.Stdout,
		Stderr: os.Stderr,
		Env:    make(map[string]string),
	}
}

func (c *Command) SetEnv(key string, value string) {
	c.Env[key] = value
}
</file>

<file path="internal/system/system.go">
package system

type System interface {
	IsNixOS() bool
}
</file>

<file path="internal/systemd/time_test.go">
package systemdUtils

import (
	"math"
	"testing"
	"time"
)

func durationsApproxEqual(d1, d2, tolerance time.Duration) bool {
	diff := d1 - d2
	return math.Abs(float64(diff)) <= float64(tolerance)
}

func TestDurationFromTimeSpan(t *testing.T) {
	const tolerance = time.Millisecond

	tests := []struct {
		span      string
		expected  time.Duration
		expectErr bool
	}{
		{"1s", time.Second, false},
		{"1second", time.Second, false},
		{"2m", 2 * time.Minute, false},
		{"2min", 2 * time.Minute, false},
		{"3h", 3 * time.Hour, false},
		{"3hours", 3 * time.Hour, false},
		{"1d", 24 * time.Hour, false},
		{"1day", 24 * time.Hour, false},
		{"1w", 7 * 24 * time.Hour, false},
		{"10weeks", 10 * 7 * 24 * time.Hour, false},
		{"1h30m", 90 * time.Minute, false},
		{"2d3h45m", 2*24*time.Hour + 3*time.Hour + 45*time.Minute, false},
		{"0s", 0, false},

		{"", 0, true},
		{"1x", 0, true},
		{"hour", 0, true},
		{"5 10d", 0, true},
	}

	for _, tt := range tests {
		t.Run(tt.span, func(t *testing.T) {
			actual, err := DurationFromTimeSpan(tt.span)

			if (err != nil) != tt.expectErr {
				t.Errorf("DurationFromTimeSpan(%q) error = %v, expectErr %v", tt.span, err, tt.expectErr)
				return
			}

			if !tt.expectErr && !durationsApproxEqual(actual, tt.expected, tolerance) {
				t.Errorf("DurationFromTimeSpan(%q) = %v, expected ~%v", tt.span, actual, tt.expected)
			}
		})
	}
}
</file>

<file path="internal/systemd/time.go">
package systemdUtils

import (
	"fmt"
	"strconv"
	"time"
	"unicode"
)

// Parse a time.Duration from a systemd.time(7) string.
func DurationFromTimeSpan(span string) (time.Duration, error) {
	if len(span) < 2 {
		return 0, fmt.Errorf("time span too short")
	}

	for _, c := range span {
		if !unicode.IsDigit(c) && !unicode.IsLetter(c) && c != ' ' {
			return 0, fmt.Errorf("invalid character %v", c)
		}
	}

	if !unicode.IsDigit(rune(span[0])) {
		return 0, fmt.Errorf("span must start with number")
	}

	totalDuration := time.Duration(0)

	i := 0
	spanLen := len(span)

	for i < spanLen {
		if span[i] == ' ' {
			i += 1
			continue
		}
		if !unicode.IsDigit(rune(span[i])) {
			return 0, fmt.Errorf("span components must start with numbers")
		}

		numStart := i
		for i < spanLen && unicode.IsDigit(rune(span[i])) {
			i += 1
		}
		num, _ := strconv.ParseInt(span[numStart:i], 10, 64)

		if i >= spanLen {
			return 0, fmt.Errorf("span components must have units")
		}

		for unicode.IsSpace(rune(span[i])) {
			i += 1
		}

		unitStart := i
		for i < spanLen && unicode.IsLetter(rune(span[i])) {
			i += 1
		}
		unit := span[unitStart:i]

		var durationUnit time.Duration
		if containsSlice(unit, []string{"ns", "nsec"}) {
			durationUnit = time.Nanosecond
		} else if containsSlice(unit, []string{"us", "usec"}) {
			durationUnit = time.Microsecond
		} else if containsSlice(unit, []string{"ms", "msec"}) {
			durationUnit = time.Millisecond
		} else if containsSlice(unit, []string{"s", "sec", "second", "seconds"}) {
			durationUnit = time.Second
		} else if containsSlice(unit, []string{"m", "min", "minute", "minutes"}) {
			durationUnit = time.Minute
		} else if containsSlice(unit, []string{"h", "hr", "hour", "hours"}) {
			durationUnit = time.Hour
		} else if containsSlice(unit, []string{"d", "day", "days"}) {
			durationUnit = time.Hour * 24
		} else if containsSlice(unit, []string{"w", "week", "weeks"}) {
			durationUnit = time.Hour * 24 * 7
		} else if containsSlice(unit, []string{"M", "month", "months"}) {
			durationUnit = time.Duration(30.44 * float64(24) * float64(time.Hour))
		} else if containsSlice(unit, []string{"y", "year", "years"}) {
			durationUnit = time.Duration(365.25 * float64(24) * float64(time.Hour))
		} else {
			return 0, fmt.Errorf("invalid unit")
		}

		totalDuration += time.Duration(num) * durationUnit
	}

	return totalDuration, nil
}

func containsSlice(candidate string, candidates []string) bool {
	for _, v := range candidates {
		if v == candidate {
			return true
		}
	}
	return false
}
</file>

<file path="internal/systemd/unit_test.go">
package systemdUtils

import (
	"testing"
)

func TestCompareUnits(t *testing.T) {
	tests := []struct {
		name     string
		current  UnitInfo
		new      UnitInfo
		expected UnitComparison
	}{
		{
			name: "equal units",
			current: UnitInfo{
				"Unit": {
					"Description": {"Test service"},
				},
			},
			new: UnitInfo{
				"Unit": {
					"Description": {"Test service"},
				},
			},
			expected: UnitComparisonEqual,
		},
		{
			name: "changed unit key requires restart",
			current: UnitInfo{
				"Service": {
					"ExecStart": {"/bin/old"},
				},
			},
			new: UnitInfo{
				"Service": {
					"ExecStart": {"/bin/new"},
				},
			},
			expected: UnitComparisonNeedsRestart,
		},
		{
			name: "reload trigger only requires reload",
			current: UnitInfo{
				"Unit": {
					"X-Reload-Triggers": {"foo"},
				},
			},
			new: UnitInfo{
				"Unit": {
					"X-Reload-Triggers": {"bar"},
				},
			},
			expected: UnitComparisonNeedsReload,
		},
		{
			name: "ignored unit key change does not restart",
			current: UnitInfo{
				"Unit": {
					"Description": {"Old"},
				},
			},
			new: UnitInfo{
				"Unit": {
					"Description": {"New"},
				},
			},
			expected: UnitComparisonEqual, // ignored key
		},
		{
			name: "mount options change only reloads",
			current: UnitInfo{
				"Mount": {
					"Options": {"old", "opt"},
				},
			},
			new: UnitInfo{
				"Mount": {
					"Options": {"new", "opt"},
				},
			},
			expected: UnitComparisonNeedsReload,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := CompareUnits(tt.current, tt.new)
			if got != tt.expected {
				t.Errorf("compareUnits() = %v, want %v", got, tt.expected)
			}
		})
	}
}
</file>

<file path="internal/systemd/unit.go">
package systemdUtils

import (
	"fmt"
	"os"
	"path/filepath"
	"slices"

	"github.com/coreos/go-systemd/v22/unit"
)

type UnitInfo map[string]map[string][]string

// Parse a systemd unit file into a UnitInfo type.
//
// If a directory with the same basename ending in .d
// exists next to the unit file, it will be assumed to
// contain override files which will be parsed as well
// and handled properly.
func ParseUnit(unitFilePath string, baseUnitFilePath string) (UnitInfo, error) {
	unitData := make(UnitInfo)

	parseAndMerge := func(path string) error {
		file, err := os.Open(path)
		if err != nil {
			return fmt.Errorf("failed to open %s: %s", path, err)
		}
		defer func() { _ = file.Close() }()

		sections, err := unit.DeserializeSections(file)
		if err != nil {
			return fmt.Errorf("failed to parse unit file %s: %s", path, err)
		}

		unitData.merge(sections)
		return nil
	}

	if err := parseAndMerge(baseUnitFilePath); err != nil {
		return nil, err
	}

	matches, _ := filepath.Glob(fmt.Sprintf("%s.d/*.conf", baseUnitFilePath))
	for _, path := range matches {
		_ = parseAndMerge(path)
	}

	if unitFilePath != baseUnitFilePath {
		if _, err := os.Stat(unitFilePath); err == nil {
			matches, _ := filepath.Glob(fmt.Sprintf("%s.d/*.conf", unitFilePath))
			for _, path := range matches {
				_ = parseAndMerge(path)
			}
		}
	}

	return unitData, nil
}

// Retrieve a single property from a UnitInfo type.
//
// If the property is multi-valued, the last value is returned.
// Consider using
//
// A return value of nil means the property does not exist.
func (i UnitInfo) GetProperty(section string, property string) *string {
	sec, ok := i[section]
	if !ok {
		return nil
	}

	values, ok := sec[property]
	if !ok {
		return nil
	}

	if len(values) == 0 {
		return nil
	}

	return &values[len(values)-1]
}

// Retrieve a multi-value property from a UnitInfo type.
//
// A return value of nil means the property does not exist.
func (i UnitInfo) GetPropertyMulti(section string, property string) []string {
	sec, ok := i[section]
	if !ok {
		return nil
	}

	values, ok := sec[property]
	if !ok {
		return nil
	}

	return values
}

func (i UnitInfo) GetBoolean(section string, property string, defaultValue bool) bool {
	val := i.GetProperty(section, property)
	if val == nil {
		return defaultValue
	}

	return ParseBool(*val)
}

func (i UnitInfo) merge(sections []*unit.UnitSection) {
	for _, sec := range sections {
		if _, ok := i[sec.Section]; !ok {
			i[sec.Section] = make(map[string][]string)
		}

		for _, entry := range sec.Entries {
			i[sec.Section][entry.Name] = append(
				i[sec.Section][entry.Name],
				entry.Value,
			)
		}
	}
}

// Parse a systemd boolean value string into a Go boolean.
func ParseBool(value string) bool {
	switch value {
	case "1", "yes", "true", "on":
		return true
	default:
		return false
	}
}

type UnitComparison int

const (
	UnitComparisonEqual UnitComparison = iota
	UnitComparisonNeedsRestart
	UnitComparisonNeedsReload
)

var unitSectionIgnores = map[string]struct{}{
	"X-Reload-Triggers": {},
	"Description":       {},
	"Documentation":     {},
	"OnFailure":         {},
	"OnSuccess":         {},
	"IgnoreOnIsolate":   {},
	"OnFailureJobMode":  {},
	"StopWhenUnneeded":  {},
	"RefuseManualStart": {},
	"RefuseManualStop":  {},
	"AllowIsolate":      {},
	"CollectMode":       {},
	"SourcePath":        {},
}

func CompareUnits(currentUnit UnitInfo, newUnit UnitInfo) UnitComparison {
	result := UnitComparisonEqual

	sectionsToCompare := make(map[string]struct{}, len(newUnit))
	for key := range newUnit {
		sectionsToCompare[key] = struct{}{}
	}

	for sectionName, section := range currentUnit {
		if _, ok := sectionsToCompare[sectionName]; !ok {
			if sectionName == "Unit" {
				for iniKey := range section {
					if _, ignore := unitSectionIgnores[iniKey]; !ignore {
						return UnitComparisonNeedsRestart
					}
				}

				continue
			} else {
				return UnitComparisonNeedsRestart
			}
		}

		delete(sectionsToCompare, sectionName)

		iniKeysToCompare := make(map[string]struct{}, len(section))
		for key := range section {
			iniKeysToCompare[key] = struct{}{}
		}

		for iniKey, currentValue := range section {
			delete(iniKeysToCompare, iniKey)

			newValue := newUnit.GetPropertyMulti(sectionName, iniKey)
			if newValue == nil {
				if sectionName == "Unit" {
					if _, ignore := unitSectionIgnores[iniKey]; ignore {
						continue
					}
				}

				return UnitComparisonNeedsRestart
			}

			if !slices.Equal(currentValue, newValue) {
				if sectionName == "Unit" {
					if iniKey == "X-Reload-Triggers" {
						result = UnitComparisonNeedsReload
						continue
					} else if _, ignore := unitSectionIgnores[iniKey]; ignore {
						continue
					}
				}

				// If this is a mount unit, changes to `Options` can be ignored.
				if sectionName == "Mount" && iniKey == "Options" {
					result = UnitComparisonNeedsReload
					continue
				}

				return UnitComparisonNeedsRestart
			}
		}

		if len(iniKeysToCompare) > 0 {
			if sectionName == "Unit" {
				for iniKey := range iniKeysToCompare {
					if iniKey == "X-Reload-Triggers" {
						result = UnitComparisonNeedsReload
					} else if _, ignore := unitSectionIgnores[iniKey]; ignore {
						continue
					} else {
						return UnitComparisonNeedsRestart
					}
				}
			} else {
				return UnitComparisonNeedsRestart
			}
		}
	}

	remainingSections := len(sectionsToCompare)

	if remainingSections > 0 {
		if remainingSections == 1 {
			unitSection, exists := newUnit["Unit"]
			if !exists {
				return UnitComparisonNeedsRestart
			}

			for iniKey := range unitSection {
				if _, ignore := unitSectionIgnores[iniKey]; !ignore {
					return UnitComparisonNeedsRestart
				} else if iniKey == "X-Reload-Triggers" {
					result = UnitComparisonNeedsReload
				}
			}
		} else {
			return UnitComparisonNeedsRestart
		}
	}

	return result
}
</file>

<file path="internal/utils/utils.go">
package utils

import (
	"fmt"
	"os"
	"os/exec"
	"strings"
	"syscall"
)

// Re-exec the current process as root with the same arguments.
// This is done with the provided rootCommand parameter, which
// usually is "sudo" or "doas", and comes from the command config.
func ExecAsRoot(rootCommand string) error {
	rootCommandPath, err := exec.LookPath(rootCommand)
	if err != nil {
		return err
	}

	argv := []string{rootCommand}
	argv = append(argv, os.Args...)

	err = syscall.Exec(rootCommandPath, argv, os.Environ())
	return err
}

func EscapeAndJoinArgs(args []string) string {
	var escapedArgs []string

	for _, arg := range args {
		if strings.ContainsAny(arg, " \t\n\"'\\") {
			arg = strings.ReplaceAll(arg, "\\", "\\\\")
			arg = strings.ReplaceAll(arg, "\"", "\\\"")
			escapedArgs = append(escapedArgs, fmt.Sprintf("\"%s\"", arg))
		} else {
			escapedArgs = append(escapedArgs, arg)
		}
	}

	return strings.Join(escapedArgs, " ")
}
</file>

<file path=".envrc">
use flake || use nix
</file>

<file path=".gitignore">
# Nix/direnv
/result*
/.direnv/

# Binary destination from `make`
/nixos

# For bubbletea log files
*.log

# Built documentation site
/site/

# Built man pages
/man/

# Generated documentation artifacts
/doc/src/generated-module.md
/doc/src/generated-settings.md
/doc/man/nixos-cli-settings.5.scd
!/doc/man/nixos-cli-settings.5.scd.template
</file>

<file path=".prettierrc.json">
{
  "printWidth": 80,
  "tabWidth": 2,
  "useTabs": false,
  "singleQuote": true,
  "proseWrap": "always"
}
</file>

<file path="default.nix">
{pkgs ? import <nixpkgs> {}}: let
  flakeSelf = import ./flake-compat.nix;
in {
  inherit (flakeSelf.packages.${pkgs.system}) nixos nixosLegacy;

  # Do not use lib.importApply here for better error tracking, since
  # it causes an infinite recursion for a currently unknown reason.
  module = import ./module.nix {
    self = flakeSelf;
    # If someone is using default.nix for imports, it's likely that
    # they will also be using the legacy package on their system.
    useFlakePkg = false;
  };
}
</file>

<file path="flake-compat.nix">
let
  flakeSelf =
    (
      import
      (
        let
          lock = builtins.fromJSON (builtins.readFile ./flake.lock);
        in
          fetchTarball {
            url = "https://github.com/edolstra/flake-compat/archive/${lock.nodes.flake-compat.locked.rev}.tar.gz";
            sha256 = lock.nodes.flake-compat.locked.narHash;
          }
      )
      {src = ./.;}
    )
    .outputs;
in
  flakeSelf
</file>

<file path="flake.lock">
{
  "nodes": {
    "flake-compat": {
      "flake": false,
      "locked": {
        "lastModified": 1747046372,
        "narHash": "sha256-CIVLLkVgvHYbgI2UpXvIIBJ12HWgX+fjA8Xf8PUmqCY=",
        "owner": "edolstra",
        "repo": "flake-compat",
        "rev": "9100a0f413b0c601e0533d1d94ffd501ce2e7885",
        "type": "github"
      },
      "original": {
        "owner": "edolstra",
        "repo": "flake-compat",
        "type": "github"
      }
    },
    "flake-utils": {
      "inputs": {
        "systems": "systems"
      },
      "locked": {
        "lastModified": 1731533236,
        "narHash": "sha256-l0KFg5HjrsfsO/JpG+r7fRrqm12kzFHyUHqHCVpMMbI=",
        "owner": "numtide",
        "repo": "flake-utils",
        "rev": "11707dc2f618dd54ca8739b309ec4fc024de578b",
        "type": "github"
      },
      "original": {
        "owner": "numtide",
        "repo": "flake-utils",
        "type": "github"
      }
    },
    "nix-options-doc": {
      "inputs": {
        "flake-utils": "flake-utils",
        "nixpkgs": "nixpkgs",
        "rust-overlay": "rust-overlay"
      },
      "locked": {
        "lastModified": 1742115705,
        "narHash": "sha256-RfXwJPWBoWswIU68+y/XZfTWtFHd/fK14bKvOlRmfPo=",
        "owner": "Thunderbottom",
        "repo": "nix-options-doc",
        "rev": "2caa4b5756a8666d65d70122f413e295f56886e7",
        "type": "github"
      },
      "original": {
        "owner": "Thunderbottom",
        "ref": "v0.2.0",
        "repo": "nix-options-doc",
        "type": "github"
      }
    },
    "nixpkgs": {
      "locked": {
        "lastModified": 1740695751,
        "narHash": "sha256-D+R+kFxy1KsheiIzkkx/6L63wEHBYX21OIwlFV8JvDs=",
        "owner": "nixos",
        "repo": "nixpkgs",
        "rev": "6313551cd05425cd5b3e63fe47dbc324eabb15e4",
        "type": "github"
      },
      "original": {
        "owner": "nixos",
        "ref": "nixos-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "nixpkgs_2": {
      "locked": {
        "lastModified": 1759070547,
        "narHash": "sha256-JVZl8NaVRYb0+381nl7LvPE+A774/dRpif01FKLrYFQ=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "647e5c14cbd5067f44ac86b74f014962df460840",
        "type": "github"
      },
      "original": {
        "owner": "NixOS",
        "ref": "nixpkgs-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "flake-compat": "flake-compat",
        "nix-options-doc": "nix-options-doc",
        "nixpkgs": "nixpkgs_2"
      }
    },
    "rust-overlay": {
      "inputs": {
        "nixpkgs": [
          "nix-options-doc",
          "nixpkgs"
        ]
      },
      "locked": {
        "lastModified": 1740796337,
        "narHash": "sha256-FuoXrXZPoJEZQ3PF7t85tEpfBVID9JQIOnVKMNfTAb0=",
        "owner": "oxalica",
        "repo": "rust-overlay",
        "rev": "bbac9527bc6b28b6330b13043d0e76eac11720dc",
        "type": "github"
      },
      "original": {
        "owner": "oxalica",
        "repo": "rust-overlay",
        "type": "github"
      }
    },
    "systems": {
      "locked": {
        "lastModified": 1681028828,
        "narHash": "sha256-Vy1rq5AaRuLzOxct8nz4T6wlgyUR7zLU309k9mBC768=",
        "owner": "nix-systems",
        "repo": "default",
        "rev": "da67096a3b9bf56a91d16901293e51ba5b49a27e",
        "type": "github"
      },
      "original": {
        "owner": "nix-systems",
        "repo": "default",
        "type": "github"
      }
    }
  },
  "root": "root",
  "version": 7
}
</file>

<file path="flake.nix">
{
  description = "A unified NixOS tooling replacement for nixos-* utilities";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";

    flake-compat = {
      url = "github:edolstra/flake-compat";
      flake = false;
    };

    nix-options-doc.url = "github:Thunderbottom/nix-options-doc/v0.2.0";
  };

  outputs = {
    self,
    nixpkgs,
    ...
  } @ inputs: let
    inherit (nixpkgs) lib;
    eachSystem = lib.genAttrs lib.systems.flakeExposed;
    pkgsFor = system: nixpkgs.legacyPackages.${system};
  in {
    packages = eachSystem (system: let
      pkgs = pkgsFor system;
      inherit (pkgs) callPackage;
    in {
      default = self.packages.${pkgs.system}.nixos;

      nixos = callPackage ./package.nix {
        revision = self.rev or self.dirtyRev or "unknown";
      };
      nixosLegacy = self.packages.${pkgs.system}.nixos.override {flake = false;};
    });

    devShells = eachSystem (system: let
      pkgs = pkgsFor system;
      inherit (pkgs) go golangci-lint mkShell mdbook scdoc;
      inherit (pkgs.nodePackages) prettier;

      nix-options-doc = inputs.nix-options-doc.packages.${system}.default;
    in {
      default = mkShell {
        name = "nixos-shell";
        nativeBuildInputs = [
          go
          golangci-lint

          mdbook
          prettier
          scdoc
          nix-options-doc
        ];
      };
    });

    nixosModules.nixos-cli = lib.modules.importApply ./module.nix {inherit self;};
  };
}
</file>

<file path="go.mod">
module github.com/nix-community/nixos-cli

go 1.25

require (
	github.com/carapace-sh/carapace v1.8.6
	github.com/charmbracelet/bubbles v0.21.0
	github.com/charmbracelet/bubbletea v1.3.6
	github.com/coreos/go-systemd/v22 v22.6.0
	github.com/djherbis/times v1.6.0
	github.com/fatih/color v1.18.0
	github.com/go-git/go-git/v5 v5.13.1
	github.com/google/shlex v0.0.0-20191202100458-e7afc7fbc510
	github.com/knadh/koanf/parsers/toml/v2 v2.2.0
	github.com/knadh/koanf/providers/file v1.2.0
	github.com/knadh/koanf/v2 v2.2.2
	github.com/olekukonko/tablewriter v0.0.5
	github.com/sahilm/fuzzy v0.1.1
	github.com/spf13/cobra v1.9.1
	github.com/spf13/pflag v1.0.6
	github.com/water-sucks/optnix v0.2.0
	github.com/yarlson/pin v0.9.1
	golang.org/x/sys v0.34.0
	golang.org/x/term v0.33.0
)

require (
	github.com/aymanbagabas/go-osc52/v2 v2.0.1 // indirect
	github.com/charmbracelet/lipgloss v1.1.1-0.20250404203927-76690c660834
	github.com/charmbracelet/x/ansi v0.9.3 // indirect
	github.com/charmbracelet/x/term v0.2.1 // indirect
	github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f // indirect
	github.com/lucasb-eyer/go-colorful v1.2.0 // indirect
	github.com/mattn/go-localereader v0.0.1 // indirect
	github.com/mattn/go-runewidth v0.0.16 // indirect
	github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 // indirect
	github.com/muesli/cancelreader v0.2.2 // indirect
	github.com/muesli/termenv v0.16.0
	github.com/rivo/uniseg v0.4.7 // indirect
	golang.org/x/text v0.27.0 // indirect
)

require (
	dario.cat/mergo v1.0.1 // indirect
	github.com/Microsoft/go-winio v0.6.2 // indirect
	github.com/ProtonMail/go-crypto v1.1.5 // indirect
	github.com/alecthomas/chroma/v2 v2.19.0 // indirect
	github.com/atotto/clipboard v0.1.4 // indirect
	github.com/aymerick/douceur v0.2.0 // indirect
	github.com/carapace-sh/carapace-shlex v1.0.1 // indirect
	github.com/charmbracelet/colorprofile v0.3.1 // indirect
	github.com/charmbracelet/glamour v0.10.0 // indirect
	github.com/charmbracelet/x/cellbuf v0.0.13 // indirect
	github.com/charmbracelet/x/exp/slice v0.0.0-20250711012602-b1f986320f7e // indirect
	github.com/cloudflare/circl v1.5.0 // indirect
	github.com/cyphar/filepath-securejoin v0.4.0 // indirect
	github.com/dlclark/regexp2 v1.11.5 // indirect
	github.com/emirpasic/gods v1.18.1 // indirect
	github.com/fsnotify/fsnotify v1.9.0 // indirect
	github.com/go-git/gcfg v1.5.1-0.20230307220236-3a3c6141e376 // indirect
	github.com/go-git/go-billy/v5 v5.6.2 // indirect
	github.com/go-viper/mapstructure/v2 v2.3.0 // indirect
	github.com/godbus/dbus/v5 v5.1.0 // indirect
	github.com/golang/groupcache v0.0.0-20241129210726-2c02b8208cf8 // indirect
	github.com/gorilla/css v1.0.1 // indirect
	github.com/inconshreveable/mousetrap v1.1.0 // indirect
	github.com/jbenet/go-context v0.0.0-20150711004518-d14ea06fba99 // indirect
	github.com/kevinburke/ssh_config v1.2.0 // indirect
	github.com/knadh/koanf/maps v0.1.2 // indirect
	github.com/mattn/go-colorable v0.1.14 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/microcosm-cc/bluemonday v1.0.27 // indirect
	github.com/mitchellh/copystructure v1.2.0 // indirect
	github.com/mitchellh/reflectwalk v1.0.2 // indirect
	github.com/mmcloughlin/avo v0.6.0 // indirect
	github.com/muesli/reflow v0.3.0 // indirect
	github.com/pelletier/go-toml/v2 v2.2.4 // indirect
	github.com/pjbgf/sha1cd v0.3.1 // indirect
	github.com/sergi/go-diff v1.3.2-0.20230802210424-5b0b94c5c0d3 // indirect
	github.com/skeema/knownhosts v1.3.0 // indirect
	github.com/xanzy/ssh-agent v0.3.3 // indirect
	github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e // indirect
	github.com/yuin/goldmark v1.7.12 // indirect
	github.com/yuin/goldmark-emoji v1.0.6 // indirect
	golang.org/x/crypto v0.40.0 // indirect
	golang.org/x/mod v0.25.0 // indirect
	golang.org/x/net v0.42.0 // indirect
	golang.org/x/sync v0.16.0 // indirect
	golang.org/x/tools v0.34.0 // indirect
	gopkg.in/warnings.v0 v0.1.2 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)

replace github.com/coreos/go-systemd/v22 v22.6.0 => github.com/water-sucks/go-systemd/v22 v22.0.0-20251014195852-fe9dbfc225a6
</file>

<file path="LICENSE">
GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.
</file>

<file path="main.go">
package main

import "github.com/nix-community/nixos-cli/cmd/root"

func main() {
	root.Execute()
}
</file>

<file path="Makefile">
APP_NAME := nixos
BUILD_VAR_PKG := github.com/nix-community/nixos-cli/internal/build/vars

VERSION ?= $(shell git describe --tags --always)
COMMIT_HASH ?= $(shell git rev-parse HEAD)

# Configurable parameters
FLAKE ?= true
NIXPKGS_REVISION ?= 25.05

LDFLAGS := -X $(BUILD_VAR_PKG).Version=$(VERSION)
LDFLAGS += -X $(BUILD_VAR_PKG).GitRevision=$(COMMIT_HASH)
LDFLAGS += -X $(BUILD_VAR_PKG).Flake=$(FLAKE)
LDFLAGS += -X $(BUILD_VAR_PKG).NixpkgsVersion=$(NIXPKGS_REVISION)

# Disable CGO by default. This should be a static executable.
CGO_ENABLED ?= 0

all: build

.PHONY: build
build:
	@echo "building $(APP_NAME)..."
	CGO_ENABLED=$(CGO_ENABLED) go build -o ./$(APP_NAME) -ldflags="$(LDFLAGS)" .

.PHONY: clean
clean:
	@echo "cleaning up..."
	go clean
	rm -rf site/ man/

.PHONY: check
check:
	golangci-lint run

.PHONY: test
test:
	@echo "running tests..."
	CGO_ENABLED=$(CGO_ENABLED) go test ./...

.PHONY: gen-docs
gen-docs: gen-manpages gen-site

.PHONY: site
site: gen-site
	# -d is interpreted relative to the book directory.
	mdbook build ./doc -d ../site

.PHONY: gen-site
gen-site:
	go run doc/build.go site -r $(COMMIT_HASH)

.PHONY: gen-site
gen-manpages:
	go run doc/build.go man

.PHONY: serve-site
serve-site:
	mdbook serve ./doc --open
</file>

<file path="module.nix">
{
  self,
  useFlakePkg ? true,
}: {
  options,
  config,
  pkgs,
  lib,
  ...
}: let
  cfg = config.services.nixos-cli;
  nixosCfg = config.system.nixos;

  inherit (lib) types;

  tomlFormat = pkgs.formats.toml {};
in {
  options.services.nixos-cli = {
    enable = lib.mkEnableOption "unified NixOS tooling replacement for nixos-* utilities";

    package = lib.mkOption {
      type = types.package;
      default =
        if useFlakePkg
        then self.packages.${pkgs.system}.nixos
        else self.packages.${pkgs.system}.nixosLegacy;
      description = "Package to use for nixos-cli";
    };

    config = lib.mkOption {
      type = tomlFormat.type;
      default = {};
      description = "Configuration for nixos-cli, in TOML format";
      apply = prev: let
        # Inherit this from the old nixos-generate-config attrs. Easy to deal with, for now.
        desktopConfig = lib.concatStringsSep "\n" config.system.nixos-generate-config.desktopConfiguration;
      in
        lib.recursiveUpdate {
          init = {
            xserver_enabled = config.services.xserver.enable;
            desktop_config = desktopConfig;
            extra_config = "";
          };
        }
        prev;
    };

    useActivationInterface = lib.mkOption {
      type = types.bool;
      default = false;
      example = true;
      description = ''
        Use the `nixos activate` interface to switch configurations, instead of the
        `switch-to-configuration-ng` program that is currently used in `nixpkgs`.

        The behavior is mostly the same, but changes can be made that may potentially
        break behavior from the original on a per-case basis.

        If this is disabled, users will still be able to use `nixos activate` on their
        own, but it will serve solely as a shim to run the switch script on a switchable.
        system.

        This activation interface is experimental and subject to change.
      '';
    };

    generationTag = lib.mkOption {
      type = types.nullOr types.str;
      default = lib.maybeEnv "NIXOS_GENERATION_TAG" null;
      description = "A description for this generation";
      example = "Sign Git GPG commits by default";
    };

    prebuildOptionCache = lib.mkOption {
      type = types.bool;
      default = config.documentation.nixos.enable;
      description = "Prebuild JSON cache for `nixos option` command";
    };
  };

  config = lib.mkIf cfg.enable (lib.mkMerge [
    {
      environment.systemPackages = [cfg.package];

      environment.etc."nixos-cli/config.toml".source =
        tomlFormat.generate "nixos-cli-config.toml" cfg.config;

      # Hijack system builder commands to insert a `nixos-version.json` file at the root.
      system.systemBuilderCommands = let
        nixos-version-json = builtins.toJSON {
          nixosVersion = "${nixosCfg.distroName} ${nixosCfg.release} (${nixosCfg.codeName})";
          nixpkgsRevision = nixosCfg.revision;
          configurationRevision = "${builtins.toString config.system.configurationRevision}";
          description = cfg.generationTag;
        };
      in ''
        cat > "$out/nixos-version.json" << EOF
        ${nixos-version-json}
        EOF
      '';

      security.sudo.extraConfig = ''
        # Preserve NIXOS_CONFIG and NIXOS_CLI_CONFIG in sudo invocations of
        # `nixos apply`. This is required in order to keep ownership across
        # automatic re-exec as root.
        Defaults env_keep += "NIXOS_CONFIG"
        Defaults env_keep += "NIXOS_GENERATION_TAG"
        Defaults env_keep += "NIXOS_CLI_CONFIG"
        Defaults env_keep += "NIXOS_CLI_DISABLE_STEPS"
        Defaults env_keep += "NIXOS_CLI_DEBUG_MODE"
        Defaults env_keep += "NIXOS_CLI_SUPPRESS_NO_SETTINGS_WARNING"
      '';
    }
    (lib.mkIf cfg.prebuildOptionCache {
      # While there is already an `options.json` that exists in the
      # `config.system.build.manual.optionsJSON` attribute, this is
      # not as full-featured, because it does not contain NixOS options
      # that are not available in base `nixpkgs`. This does increase
      # eval time, but that's a fine tradeoff in this case since it
      # is able to be disabled.
      environment.etc."nixos-cli/options-cache.json" = {
        text = let
          optionList' = lib.optionAttrSetToDocList options;
          optionList = builtins.filter (v: v.visible && !v.internal) optionList';
        in
          builtins.toJSON optionList;
      };
    })
    (lib.mkIf cfg.useActivationInterface {
      # This looks confusing, but this only stops the switch-to-configuration-ng
      # program from being used. The system will still be switchable.
      system.switch.enable = lib.mkForce false;

      # Use a subshell so we can source makeWrapper's setup hook without
      # affecting the rest of activatableSystemBuilderCommands.
      system.activatableSystemBuilderCommands = ''
        (
          source ${pkgs.buildPackages.makeWrapper}/nix-support/setup-hook

          mkdir $out/bin

          ln -sf ${lib.getExe cfg.package} $out/bin/switch-to-configuration

          wrapProgram $out/bin/switch-to-configuration \
            --add-flags activate \
            --set NIXOS_CLI_ATTEMPTING_ACTIVATION 1 \
            --set OUT $out \
            --set TOPLEVEL ''${!toplevelVar} \
            --set DISTRO_ID ${lib.escapeShellArg config.system.nixos.distroId} \
            --set INSTALL_BOOTLOADER ${lib.escapeShellArg config.system.build.installBootLoader} \
            --set PRE_SWITCH_CHECK ${lib.escapeShellArg config.system.preSwitchChecksScript} \
            --set LOCALE_ARCHIVE ${config.i18n.glibcLocales}/lib/locale/locale-archive \
            --set SYSTEMD ${config.systemd.package}
        )
      '';
    })
  ]);
}
</file>

<file path="package.nix">
{
  lib,
  buildGoModule,
  nix-gitignore,
  installShellFiles,
  stdenv,
  scdoc,
  revision ? "unknown",
  flake ? true,
}:
buildGoModule (finalAttrs: {
  pname = "nixos-cli";
  version = "0.13.0-dev";
  src = nix-gitignore.gitignoreSource [] ./.;

  vendorHash = "sha256-e5EAWmSQ4+gykmPaCplYdEOKZuTXlNWsMU7x8Zhc7m0=";

  nativeBuildInputs = [installShellFiles scdoc];

  env = {
    CGO_ENABLED = 0;
    COMMIT_HASH = revision;
    FLAKE = lib.boolToString flake;
    VERSION = finalAttrs.version;
    NIXPKGS_REVISION = lib.trivial.release;
  };

  buildPhase = ''
    runHook preBuild
    make all gen-manpages
    runHook postBuild
  '';

  installPhase = ''
    runHook preInstall

    install -Dm755 ./nixos -t $out/bin

    mkdir -p $out/share/man/man1
    mkdir -p $out/share/man/man5
    find man -name '*.1' -exec cp {} $out/share/man/man1/ \;
    find man -name '*.5' -exec cp {} $out/share/man/man5/ \;

    runHook postInstall
  '';

  postInstall = lib.optionalString (stdenv.buildPlatform.canExecute stdenv.hostPlatform) ''
    installShellCompletion --cmd nixos \
      --bash <($out/bin/nixos completion bash) \
      --fish <($out/bin/nixos completion fish) \
      --zsh <($out/bin/nixos completion zsh)
  '';

  meta = with lib; {
    homepage = "https://github.com/nix-community/nixos";
    description = "A unified NixOS tooling replacement for nixos-* utilities";
    license = licenses.gpl3Only;
    maintainers = with maintainers; [water-sucks];
    mainProgram = "nixos";
  };
})
</file>

<file path="README.md">
<h1 align="center">nixos-cli</h1>
<h6 align="center">A unified NixOS management tool.</h6>

## Introduction

Tooling for `nixos` has become quite scattered, and as a result, NixOS can be
pretty obtuse to use. There are many community tools available to fix the
problem, but no all-in-one solution.

`nixos-cli` is exactly that - an all-in-one tool to manage any NixOS
installation with ease, that consists of:

- Drop-in replacements for NixOS scripts and tools like `nixos-rebuild`
- Generation manager and option preview TUIs
- Many more

All available through an easy-to-use (and pretty!) interface.

High-level documentation is available as a
[website](https://nix-community.github.io/nixos-cli), while a detailed reference
for each command and settings is available in the form of man pages after
installation.

## Development

This application is written in [Go](https://go.dev).

There are two major directories to keep in mind:

- `cmd/` :: command structure, contains actual main command implementations
- `internal/` :: anything that is shared between commands, categorized by
  functionality

Each command and subcommand **MUST** go in their own package and match the
command tree that it implements.

All dependencies for this project are neatly provided in a Nix shell. Run
`nix develop .#` or use [`direnv`](https://direnv.net) to automatically drop
into this Nix shell on changing to this directory.

In order to build both packages at the same time, run
`nix build .#{nixos,nixosLegacy}`.

### Documentation

Documentation is split into two parts:

- A documentation website, built using
  [`mdbook`](https://rust-lang.github.io/mdBook/)
- Manual pages (`man` pages), generated using
  [`scdoc`](https://sr.ht/~sircmpwn/scdoc/)

They are both managed with a build script at [doc/build.go](./doc/build.go), and
with the following Makefile rules:

- `make gen-manpages` :: generate `roff`-formatted man pages with `scdoc`
- `make gen-site` :: automatically generate settings/module docs for website
- `make serve-site` :: start a preview server for the `mdbook` website.

`make gen-site` generates two files:

- Documentation for all available settings in `config.toml`
- Module documentation for `services.nixos-cli`, built using
  [`nix-options-doc`](https://github.com/Thunderbottom/nix-options-doc)

The rest of the site documentation files are located in [doc/man](./doc/src).

`make gen-manpages` generates man pages using `scdoc`, and generates one
additional man page file from a template: the available settings for
`nixos-cli-config(5)`.

Check the build script source for more information on how to work with this.

### Versioning

Version numbers are handled using [semantic versioning](https://semver.org/).
They are also managed using Git tags; every version has a Git tag named with the
version; the tag name does not have a preceding "v".

Non-released builds have a version number that is suffixed with `"-dev"`. As
such, a tag should always exist on a version number change (which removes the
suffix), and the very next commit will re-introduce the suffix.

Once a tag is created and pushed, create a GitHub release off this tag.

The version number is managed inside the Nix derivation at
[package.nix](./package.nix).

### CI

The application must build successfully upon every push to `main`, and this is a
prerequisite for every patch or pull request to be merged.

Cache artifacts are published in a Cachix cache at https://watersucks.cachix.org
when a release is triggered.

## Talk!

Join the Matrix room at
[#nixos-cli:matrix.org](https://matrix.to/#/#nixos-cli:matrix.org)! It's open
for chatting about NixOS in general, and for making it a better experience for
all that involved.

I would like for this to become a standard NixOS tool, which means that I want
to cater to potentially many interests. If you would like for any commands to be
implemented that you think fit this project, talk to me on Matrix or file a
GitHub issue.
</file>

<file path="shell.nix">
(
  import
  (
    let
      lock = builtins.fromJSON (builtins.readFile ./flake.lock);
    in
      fetchTarball {
        url = "https://github.com/edolstra/flake-compat/archive/${lock.nodes.flake-compat.locked.rev}.tar.gz";
        sha256 = lock.nodes.flake-compat.locked.narHash;
      }
  )
  {src = ./.;}
)
.shellNix
</file>

</files>
