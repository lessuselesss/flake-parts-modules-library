This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    test.yml
    update-website.yml
  FUNDING.yml
doc/
  known-files/
    0235d3c1b6cf21e7043fbc98e239ee4bc648048aafaf6be1a94a576300584ef2
    08ffbf991a9e25839d38b80a0d3bce3b5a6c84b9be53a4b68949df4e7e487bb7
    24797ac05542ff8b52910efc77870faa5f9e3275097227ea4e50c430a5f72916
    27274e44b88a1174787f9a3d437d3387edc4f9aaaf40356054130797f5dc7912
    2af1b563e389d11b76a651b446e858116d7a20370d9120a7e9f78991f3e5f336
    2c28f4fe3b4a958cd86b120e7eb799eee6976daa35b228c885f0630c55ef626c
    3bd68ef979a42070a44f8d82c205cfd8e8cca425d91253ec2c10a88179bb34aa
    40b0d8751adae5b0100a4f863be5b75613a49f62706427e92604f7e04d2e2261
    444c716ac2ccd9e1e3347858cb08a00d2ea38e8c12fdc5798380dc261e32e9ef
    4d1ab5704f9d167a042fecac0d056c8a79a8ebd71e032d3489536c8db9ffe3e0
    53712b4335030e2dbfb46bb235f8cffcac83fea404bd32dc99417ac89e2dd7c5
    5d23e6d7015756c6f300f8cd558ec4d9234ca61deefd4f2478e91a49760b0747
    617b39e36fa69270ddbee19ddc072497dbe7ead840cbd442d9f7c22924f116f4
    6787fade1cf934f82db554e78e1fc788705c2c5257fddf9b59bdd963ca6fec63
    6bb8d6b0dd16b44ee793a9b8382dac76c926e4c16ffb8ddd2bb4884d1ca3f811
    966d22ef5bb9b56d481e8e0d5f7ca2deaf4d24c0f0fc969b2eeaa7ae0aa42907
    97f4135d262ca22d65c9554aad795c10a4491fa61b67d9c2430f4d82bbfec9a2
    9d5aa72f807091b481820d12e693093293ba33c73854909ad7b0fb192c2db193
    b027b5cad320b5b8123d9d0db9f815c3f3921596c26dc3c471457098e4d3cc40
    bf76c5ed8e65e616f4329eccf662ee91be33b8bfd33713ce9946f2fe94fea7fa
    c06b0c6080dd1d62e61a30cfad100c0cfed2d3bcd378e296632dc3b28b31dc69
    c6080216f2a170611e339c3f46e4e1d61aaf0d8b417ad93ade8d647da1382c11
    d07015be6875f134976fce84c6c7a77b512079c1c5f9594dfa65c70b7968b65f
    e4974acb79c56148cb8e92137fa4f2de9b7356e897b332fc4e6769e8c0b83e18
    ef78f401a9b5a42fd15e967c50da384f99ec62f9dbc66ea38f1390b46b63e1ff
    f320016e2cf13573731fbee34f9fe97ba867dd2a31f24893d3120154e9306e92
    f3e03d851c240c1aa7daccd144ee929f0f5971982424c868c434eb6030e961d4
    fb5827cb4712b7e7932d438067ec4852c8955a9ff0f55e282473684623ebdfa1
    ff08c12813680da98c4240328f828647b67a65ba7aa89c022bd8072cba862cf1
  manual/
    default.nix
    manual.md
    redirects.json
  website/
    index.html
modules/
  config/
    system-path.nix
    terminfo.nix
  documentation/
    default.nix
  environment/
    default.nix
  examples/
    flake/
      flake.nix
    hydra.nix
    lnl.nix
    simple.nix
  fonts/
    default.nix
  launchd/
    default.nix
    launchd.nix
    types.nix
  lib/
    write-text.nix
  misc/
    ids.nix
    lib.nix
  networking/
    applicationFirewall.nix
    default.nix
  nix/
    default.nix
    linux-builder.nix
    nix-darwin.nix
    nixpkgs-flake.nix
    nixpkgs.nix
  power/
    default.nix
    sleep.nix
  programs/
    bash/
      default.nix
    info/
      default.nix
    nix-index/
      default.nix
    zsh/
      default.nix
      fzf-completion.zsh
      fzf-git.zsh
      fzf-history.zsh
    _1password-gui.nix
    _1password.nix
    arqbackup.nix
    direnv.nix
    fish.nix
    gnupg.nix
    man.nix
    ssh.nix
    tmux.nix
    vim.nix
  security/
    pki/
      default.nix
    sandbox/
      default.nix
    pam.nix
    sudo.nix
  services/
    activate-system/
      default.nix
    aerospace/
      default.nix
    github-runner/
      default.nix
      options.nix
      service.nix
    hercules-ci-agent/
      common.nix
      default.nix
      settings.nix
    jankyborders/
      default.nix
    karabiner-elements/
      default.nix
    khd/
      default.nix
      i3.nix
    kwm/
      default.nix
    mail/
      offlineimap.nix
    monitoring/
      netdata.nix
      prometheus-node-exporter.nix
      telegraf.nix
    nextdns/
      default.nix
    nix-gc/
      default.nix
    nix-optimise/
      default.nix
    ofborg/
      default.nix
    postgresql/
      default.nix
    privoxy/
      default.nix
    redis/
      default.nix
    sketchybar/
      default.nix
    skhd/
      default.nix
    spacebar/
      default.nix
    synergy/
      default.nix
    yabai/
      default.nix
    autossh.nix
    buildkite-agents.nix
    cachix-agent.nix
    chunkwm.nix
    dnscrypt-proxy.nix
    dnsmasq.nix
    emacs.nix
    eternal-terminal.nix
    gitlab-runner.nix
    ipfs.nix
    lorri.nix
    mopidy.nix
    netbird.nix
    nix-daemon.nix
    openssh.nix
    spotifyd.nix
    synapse-bt.nix
    tailscale.nix
    trezord.nix
    wg-quick.nix
  system/
    defaults/
      ActivityMonitor.nix
      alf.nix
      clock.nix
      controlcenter.nix
      CustomPreferences.nix
      dock.nix
      finder.nix
      GlobalPreferences.nix
      hitoolbox.nix
      iCal.nix
      LaunchServices.nix
      loginwindow.nix
      magicmouse.nix
      NSGlobalDomain.nix
      screencapture.nix
      screensaver.nix
      smb.nix
      SoftwareUpdate.nix
      spaces.nix
      trackpad.nix
      universalaccess.nix
      WindowManager.nix
    activation-scripts.nix
    applications.nix
    base.nix
    checks.nix
    default.nix
    defaults-write.nix
    etc.nix
    keyboard.nix
    launchd.nix
    nvram.nix
    patches.nix
    primary-user.nix
    shells.nix
    startup.nix
    version.nix
  time/
    default.nix
  users/
    default.nix
    group.nix
    user.nix
  alias.nix
  homebrew.nix
  meta.nix
  module-list.nix
pkgs/
  darwin-uninstaller/
    configuration.nix
    default.nix
  nix-tools/
    darwin-option.sh
    darwin-rebuild.sh
    darwin-rebuild.zsh-completions
    darwin-version.sh
    default.nix
tests/
  fixtures/
    system-defaults-write/
      system.txt
      user.txt
  activation-scripts.nix
  autossh.nix
  environment-path.nix
  environment-terminfo.nix
  fonts.nix
  homebrew.nix
  launchd-daemons.nix
  launchd-setenv.nix
  networking-hostname.nix
  networking-networkservices.nix
  networking-shell-escape.nix
  networking-wakeonlan.nix
  nix-enable.nix
  nixpkgs-overlays.nix
  power-restart.nix
  power-sleep.nix
  programs-ssh-empty-known-hosts.nix
  programs-ssh.nix
  programs-tmux.nix
  programs-zsh.nix
  security-pki.nix
  services-activate-system-changed-label-prefix.nix
  services-activate-system.nix
  services-aerospace.nix
  services-buildkite-agent.nix
  services-dnscrypt-proxy.nix
  services-dnsmasq.nix
  services-eternal-terminal.nix
  services-github-runners.nix
  services-jankyborders.nix
  services-lorri.nix
  services-netdata.nix
  services-nextdns.nix
  services-nix-daemon.nix
  services-nix-gc.nix
  services-nix-optimise.nix
  services-ofborg.nix
  services-offlineimap.nix
  services-openssh.nix
  services-privoxy.nix
  services-redis.nix
  services-skhd.nix
  services-spacebar.nix
  services-spotifyd.nix
  services-synapse-bt.nix
  services-synergy.nix
  services-yabai.nix
  sockets-nix-daemon.nix
  system-defaults-write.nix
  system-environment.nix
  system-keyboard-mapping.nix
  system-packages.nix
  system-path.nix
  system-shells.nix
  users-groups.nix
  users-packages.nix
.git-blame-ignore-revs
.gitignore
CHANGELOG
default.nix
eval-config.nix
flake.lock
flake.nix
LICENSE
README.md
release.nix
version.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/test.yml">
name: "Test"
on:
  pull_request:
  merge_group:
  push:
    branches:
      - master

env:
  NIXPKGS_BRANCH: nixpkgs-unstable
  NIX_VERSION: 2.24.11

jobs:
  # The `test-stable` and `install-against-stable` job names are
  # load‚Äêbearing, despite their inaccuracy on the unstable branch, as
  # they are set as required checks in the repository configuration,
  # which only repository admins can change.
  #
  # TODO: Change them once the repository configuration is updated.

  test-stable:
    runs-on: macos-14
    steps:
    - uses: actions/checkout@v4
    - name: Install Nix
      uses: cachix/install-nix-action@v30
      with:
        install_url: https://releases.nixos.org/nix/nix-${{ env.NIX_VERSION }}/install
    - run: nix flake check --override-input nixpkgs nixpkgs/${{ env.NIXPKGS_BRANCH }}

  install-against-stable:
    runs-on: macos-14
    timeout-minutes: 30
    steps:
    - uses: actions/checkout@v4
    - name: Install Nix
      uses: cachix/install-nix-action@v30
      with:
        install_url: https://releases.nixos.org/nix/nix-${{ env.NIX_VERSION }}/install
        nix_path: nixpkgs=channel:${{ env.NIXPKGS_BRANCH }}
    - name: Install channels
      run: |
        sudo nix-channel --add https://nixos.org/channels/${{ env.NIXPKGS_BRANCH }} nixpkgs
        sudo nix-channel --update
    - name: Install nix-darwin
      run: |
        sudo mkdir -p /etc/nix-darwin
        sudo cp modules/examples/simple.nix /etc/nix-darwin/configuration.nix

        nixConfHash=$(shasum -a 256 /etc/nix/nix.conf | cut -d ' ' -f 1)
        sudo /usr/bin/sed -i.bak \
          "s/# programs.fish.enable = true;/ \
            imports = [ \
              ({ options, ... }: { \
                nix.settings.access-tokens = [ \"github.com=\${{ secrets.GITHUB_TOKEN }}\" ]; \
                environment.etc.\"nix\/nix.conf\".knownSha256Hashes = [ \"$nixConfHash\" ]; \
                nix.nixPath = \
                  [ { darwin = \"${PWD////\/}\"; } ] \
                  ++ options.nix.nixPath.default; \
              }) \
            ]; \
          /" \
          /etc/nix-darwin/configuration.nix

        sudo nix run .#darwin-rebuild -- switch \
          -I darwin=. \
          -I darwin-config=/etc/nix-darwin/configuration.nix
    - name: Switch to new configuration
      run: |
        . /etc/bashrc

        sudo /usr/bin/sed -i.bak \
          "s/pkgs.vim/pkgs.hello/" \
          /etc/nix-darwin/configuration.nix

        sudo darwin-rebuild switch

        hello
    - name: Test uninstallation of nix-darwin
      run: |
        # We need to specify `--extra-experimental-features` because `experimental-features` is set by
        # `cachix/install-nix-action` but not by our default config above
        sudo nix run .#darwin-uninstaller \
          --extra-experimental-features "nix-command flakes" \
          --override-input nixpkgs nixpkgs/${{ env.NIXPKGS_BRANCH }}
        sudo nix run .#darwin-uninstaller.tests.uninstaller \
          --extra-experimental-features "nix-command flakes" \
          --override-input nixpkgs nixpkgs/${{ env.NIXPKGS_BRANCH }}

  install-flake:
    runs-on: macos-14
    timeout-minutes: 30
    steps:
    - uses: actions/checkout@v4
    - name: Install Nix
      uses: cachix/install-nix-action@v30
      with:
        install_url: https://releases.nixos.org/nix/nix-${{ env.NIX_VERSION }}/install
    - name: Install nix-darwin
      run: |
        sudo mkdir -p /etc/nix-darwin
        darwin=$(pwd)
        pushd /etc/nix-darwin
          sudo nix flake init -t $darwin
          nixConfHash=$(shasum -a 256 /etc/nix/nix.conf | cut -d ' ' -f 1)
          sudo /usr/bin/sed -i.bak \
            "s/# programs.fish.enable = true;/nix.settings.access-tokens = [ \"github.com=\${{ secrets.GITHUB_TOKEN }}\" ]; environment.etc.\"nix\/nix.conf\".knownSha256Hashes = [ \"$nixConfHash\" ];/" \
            flake.nix
          sudo /usr/bin/sed -i.bak \
            's/darwinConfigurations."simple"/darwinConfigurations."'$(scutil --get LocalHostName)'"/g' \
            flake.nix
          sudo /usr/bin/sed -i.bak \
            's/nixpkgs.hostPlatform = "aarch64-darwin";/nixpkgs.hostPlatform = "'$(nix eval --expr builtins.currentSystem --impure --raw)'";/' \
            flake.nix
        popd
        sudo nix run .#darwin-rebuild -- switch \
          --override-input nix-darwin . \
          --override-input nixpkgs nixpkgs/${{ env.NIXPKGS_BRANCH }}
    - name: Switch to new configuration
      run: |
        . /etc/bashrc

        sudo /usr/bin/sed -i.bak \
          "s/pkgs.vim/pkgs.hello/" \
          /etc/nix-darwin/flake.nix

        sudo darwin-rebuild switch \
          --override-input nix-darwin . \
          --override-input nixpkgs nixpkgs/${{ env.NIXPKGS_BRANCH }}

        hello
    - name: Test uninstallation of nix-darwin
      run: |
        sudo nix run .#darwin-uninstaller --override-input nixpkgs nixpkgs/${{ env.NIXPKGS_BRANCH }}
        sudo nix run .#darwin-uninstaller.tests.uninstaller --override-input nixpkgs nixpkgs/${{ env.NIXPKGS_BRANCH }}
</file>

<file path=".github/workflows/update-website.yml">
name: Update website

on:
  push:
    branches:
      - master

permissions: {}

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build:
    name: Build
    runs-on: macos-14
    steps:
      - name: Checkout repository
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683
        with:
          persist-credentials: false
      - name: Install Nix
        uses: cachix/install-nix-action@02a151ada4993995686f9ed4f1be7cfbb229e56f
      - name: Build website
        run: nix build .#website -o _site
      - name: Upload website
        id: deployment
        uses: actions/upload-pages-artifact@56afc609e74202658d3ffba0e8f6dda462b719fa

  # See: <https://github.com/actions/deploy-pages?tab=readme-ov-file#usage>
  deploy:
    name: Deploy
    needs: build
    permissions:
      pages: write
      id-token: write
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-24.04
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@d6db90164ac5ed86f2b6aed7e0febac5b3c0c03e
</file>

<file path=".github/FUNDING.yml">
github: [emilazy, Enzime]
</file>

<file path="doc/known-files/0235d3c1b6cf21e7043fbc98e239ee4bc648048aafaf6be1a94a576300584ef2">
# System-wide profile for interactive zsh(1) login shells.

# Setup user specific overrides for this in ~/.zprofile. See zshbuiltins(1)
# and zshoptions(1) for more details.

if [ -x /usr/libexec/path_helper ]; then
	eval `/usr/libexec/path_helper -s`
fi
</file>

<file path="doc/known-files/08ffbf991a9e25839d38b80a0d3bce3b5a6c84b9be53a4b68949df4e7e487bb7">
# Nix
if [ -e '/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh' ]; then
    . '/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh'
fi
# End Nix

        
# System-wide .bashrc file for interactive bash(1) shells.
if [ -z "$PS1" ]; then
   return
fi

PS1='\h:\W \u\$ '
# Make bash check its window size after a process completes
shopt -s checkwinsize

[ -r "/etc/bashrc_$TERM_PROGRAM" ] && . "/etc/bashrc_$TERM_PROGRAM"
</file>

<file path="doc/known-files/24797ac05542ff8b52910efc77870faa5f9e3275097227ea4e50c430a5f72916">
# Generated by https://install.lix.systems/.
# See `/nix/nix-installer --version` for the version details.

build-users-group = nixbld
experimental-features = nix-command flakes
bash-prompt-prefix = (nix:$name)\040
max-jobs = auto
substituters = https://cache.nixos.org https://cache.lix.systems
trusted-public-keys = cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY= cache.lix.systems:aBnZUw8zA7H35Cz2RyKFVs3H4PlGTLawyY5KRbvJR8o=
extra-nix-path = nixpkgs=flake:nixpkgs
</file>

<file path="doc/known-files/27274e44b88a1174787f9a3d437d3387edc4f9aaaf40356054130797f5dc7912">
# Nix
if [ -e '/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh' ]; then
    . '/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh'
fi
# End Nix

        
# System-wide profile for interactive zsh(1) shells.

# Setup user specific overrides for this in ~/.zshrc. See zshbuiltins(1)
# and zshoptions(1) for more details.

# Correctly display UTF-8 with combining characters.  We'll assume UTF-8 if the
# locale(1) binary is missing entirely.
if [[ ! -x /usr/bin/locale ]] || [[ "$(locale LC_CTYPE)" == "UTF-8" ]]; then
    setopt COMBINING_CHARS
fi

# Disable the log builtin, so we don't conflict with /usr/bin/log
disable log

# Save command history
HISTFILE=${ZDOTDIR:-$HOME}/.zsh_history
HISTSIZE=2000
SAVEHIST=1000

# Beep on error
setopt BEEP

# Use keycodes (generated via zkbd) if present, otherwise fallback on
# values from terminfo
if [[ -r ${ZDOTDIR:-$HOME}/.zkbd/${TERM}-${VENDOR} ]] ; then
    source ${ZDOTDIR:-$HOME}/.zkbd/${TERM}-${VENDOR}
else
    typeset -g -A key

    [[ -n "$terminfo[kf1]" ]] && key[F1]=$terminfo[kf1]
    [[ -n "$terminfo[kf2]" ]] && key[F2]=$terminfo[kf2]
    [[ -n "$terminfo[kf3]" ]] && key[F3]=$terminfo[kf3]
    [[ -n "$terminfo[kf4]" ]] && key[F4]=$terminfo[kf4]
    [[ -n "$terminfo[kf5]" ]] && key[F5]=$terminfo[kf5]
    [[ -n "$terminfo[kf6]" ]] && key[F6]=$terminfo[kf6]
    [[ -n "$terminfo[kf7]" ]] && key[F7]=$terminfo[kf7]
    [[ -n "$terminfo[kf8]" ]] && key[F8]=$terminfo[kf8]
    [[ -n "$terminfo[kf9]" ]] && key[F9]=$terminfo[kf9]
    [[ -n "$terminfo[kf10]" ]] && key[F10]=$terminfo[kf10]
    [[ -n "$terminfo[kf11]" ]] && key[F11]=$terminfo[kf11]
    [[ -n "$terminfo[kf12]" ]] && key[F12]=$terminfo[kf12]
    [[ -n "$terminfo[kf13]" ]] && key[F13]=$terminfo[kf13]
    [[ -n "$terminfo[kf14]" ]] && key[F14]=$terminfo[kf14]
    [[ -n "$terminfo[kf15]" ]] && key[F15]=$terminfo[kf15]
    [[ -n "$terminfo[kf16]" ]] && key[F16]=$terminfo[kf16]
    [[ -n "$terminfo[kf17]" ]] && key[F17]=$terminfo[kf17]
    [[ -n "$terminfo[kf18]" ]] && key[F18]=$terminfo[kf18]
    [[ -n "$terminfo[kf19]" ]] && key[F19]=$terminfo[kf19]
    [[ -n "$terminfo[kf20]" ]] && key[F20]=$terminfo[kf20]
    [[ -n "$terminfo[kbs]" ]] && key[Backspace]=$terminfo[kbs]
    [[ -n "$terminfo[kich1]" ]] && key[Insert]=$terminfo[kich1]
    [[ -n "$terminfo[kdch1]" ]] && key[Delete]=$terminfo[kdch1]
    [[ -n "$terminfo[khome]" ]] && key[Home]=$terminfo[khome]
    [[ -n "$terminfo[kend]" ]] && key[End]=$terminfo[kend]
    [[ -n "$terminfo[kpp]" ]] && key[PageUp]=$terminfo[kpp]
    [[ -n "$terminfo[knp]" ]] && key[PageDown]=$terminfo[knp]
    [[ -n "$terminfo[kcuu1]" ]] && key[Up]=$terminfo[kcuu1]
    [[ -n "$terminfo[kcub1]" ]] && key[Left]=$terminfo[kcub1]
    [[ -n "$terminfo[kcud1]" ]] && key[Down]=$terminfo[kcud1]
    [[ -n "$terminfo[kcuf1]" ]] && key[Right]=$terminfo[kcuf1]
fi

# Default key bindings
[[ -n ${key[Delete]} ]] && bindkey "${key[Delete]}" delete-char
[[ -n ${key[Home]} ]] && bindkey "${key[Home]}" beginning-of-line
[[ -n ${key[End]} ]] && bindkey "${key[End]}" end-of-line
[[ -n ${key[Up]} ]] && bindkey "${key[Up]}" up-line-or-search
[[ -n ${key[Down]} ]] && bindkey "${key[Down]}" down-line-or-search

# Default prompt
PS1="%n@%m %1~ %# "

# Useful support for interacting with Terminal.app or other terminal programs
[ -r "/etc/zshrc_$TERM_PROGRAM" ] && . "/etc/zshrc_$TERM_PROGRAM"
</file>

<file path="doc/known-files/2af1b563e389d11b76a651b446e858116d7a20370d9120a7e9f78991f3e5f336">
# Nix
if [ -e '/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh' ]; then
    . '/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh'
fi
# End Nix

        
# System-wide profile for interactive zsh(1) shells.

# Setup user specific overrides for this in ~/.zshrc. See zshbuiltins(1)
# and zshoptions(1) for more details.

# Correctly display UTF-8 with combining characters.
if [[ "$(locale LC_CTYPE)" == "UTF-8" ]]; then
    setopt COMBINING_CHARS
fi

# Disable the log builtin, so we don't conflict with /usr/bin/log
disable log

# Save command history
HISTFILE=${ZDOTDIR:-$HOME}/.zsh_history
HISTSIZE=2000
SAVEHIST=1000

# Beep on error
setopt BEEP

# Use keycodes (generated via zkbd) if present, otherwise fallback on
# values from terminfo
if [[ -r ${ZDOTDIR:-$HOME}/.zkbd/${TERM}-${VENDOR} ]] ; then
    source ${ZDOTDIR:-$HOME}/.zkbd/${TERM}-${VENDOR}
else
    typeset -g -A key

    [[ -n "$terminfo[kf1]" ]] && key[F1]=$terminfo[kf1]
    [[ -n "$terminfo[kf2]" ]] && key[F2]=$terminfo[kf2]
    [[ -n "$terminfo[kf3]" ]] && key[F3]=$terminfo[kf3]
    [[ -n "$terminfo[kf4]" ]] && key[F4]=$terminfo[kf4]
    [[ -n "$terminfo[kf5]" ]] && key[F5]=$terminfo[kf5]
    [[ -n "$terminfo[kf6]" ]] && key[F6]=$terminfo[kf6]
    [[ -n "$terminfo[kf7]" ]] && key[F7]=$terminfo[kf7]
    [[ -n "$terminfo[kf8]" ]] && key[F8]=$terminfo[kf8]
    [[ -n "$terminfo[kf9]" ]] && key[F9]=$terminfo[kf9]
    [[ -n "$terminfo[kf10]" ]] && key[F10]=$terminfo[kf10]
    [[ -n "$terminfo[kf11]" ]] && key[F11]=$terminfo[kf11]
    [[ -n "$terminfo[kf12]" ]] && key[F12]=$terminfo[kf12]
    [[ -n "$terminfo[kf13]" ]] && key[F13]=$terminfo[kf13]
    [[ -n "$terminfo[kf14]" ]] && key[F14]=$terminfo[kf14]
    [[ -n "$terminfo[kf15]" ]] && key[F15]=$terminfo[kf15]
    [[ -n "$terminfo[kf16]" ]] && key[F16]=$terminfo[kf16]
    [[ -n "$terminfo[kf17]" ]] && key[F17]=$terminfo[kf17]
    [[ -n "$terminfo[kf18]" ]] && key[F18]=$terminfo[kf18]
    [[ -n "$terminfo[kf19]" ]] && key[F19]=$terminfo[kf19]
    [[ -n "$terminfo[kf20]" ]] && key[F20]=$terminfo[kf20]
    [[ -n "$terminfo[kbs]" ]] && key[Backspace]=$terminfo[kbs]
    [[ -n "$terminfo[kich1]" ]] && key[Insert]=$terminfo[kich1]
    [[ -n "$terminfo[kdch1]" ]] && key[Delete]=$terminfo[kdch1]
    [[ -n "$terminfo[khome]" ]] && key[Home]=$terminfo[khome]
    [[ -n "$terminfo[kend]" ]] && key[End]=$terminfo[kend]
    [[ -n "$terminfo[kpp]" ]] && key[PageUp]=$terminfo[kpp]
    [[ -n "$terminfo[knp]" ]] && key[PageDown]=$terminfo[knp]
    [[ -n "$terminfo[kcuu1]" ]] && key[Up]=$terminfo[kcuu1]
    [[ -n "$terminfo[kcub1]" ]] && key[Left]=$terminfo[kcub1]
    [[ -n "$terminfo[kcud1]" ]] && key[Down]=$terminfo[kcud1]
    [[ -n "$terminfo[kcuf1]" ]] && key[Right]=$terminfo[kcuf1]
fi

# Default key bindings
[[ -n ${key[Delete]} ]] && bindkey "${key[Delete]}" delete-char
[[ -n ${key[Home]} ]] && bindkey "${key[Home]}" beginning-of-line
[[ -n ${key[End]} ]] && bindkey "${key[End]}" end-of-line
[[ -n ${key[Up]} ]] && bindkey "${key[Up]}" up-line-or-search
[[ -n ${key[Down]} ]] && bindkey "${key[Down]}" down-line-or-search

# Default prompt
PS1="%n@%m %1~ %# "

# Useful support for interacting with Terminal.app or other terminal programs
[ -r "/etc/zshrc_$TERM_PROGRAM" ] && . "/etc/zshrc_$TERM_PROGRAM"
</file>

<file path="doc/known-files/2c28f4fe3b4a958cd86b120e7eb799eee6976daa35b228c885f0630c55ef626c">
# Added by tailscaled
nameserver 100.100.100.100
</file>

<file path="doc/known-files/3bd68ef979a42070a44f8d82c205cfd8e8cca425d91253ec2c10a88179bb34aa">
# Written by https://github.com/DeterminateSystems/nix-installer.
# The contents below are based on options specified at installation time.
</file>

<file path="doc/known-files/40b0d8751adae5b0100a4f863be5b75613a49f62706427e92604f7e04d2e2261">
# System-wide profile for interactive zsh(1) shells.

# Setup user specific overrides for this in ~/.zshrc. See zshbuiltins(1)
# and zshoptions(1) for more details.

# Correctly display UTF-8 with combining characters.
if [[ "$(locale LC_CTYPE)" == "UTF-8" ]]; then
    setopt COMBINING_CHARS
fi

# Disable the log builtin, so we don't conflict with /usr/bin/log
disable log

# Save command history
HISTFILE=${ZDOTDIR:-$HOME}/.zsh_history
HISTSIZE=2000
SAVEHIST=1000

# Beep on error
setopt BEEP

# Use keycodes (generated via zkbd) if present, otherwise fallback on
# values from terminfo
if [[ -r ${ZDOTDIR:-$HOME}/.zkbd/${TERM}-${VENDOR} ]] ; then
    source ${ZDOTDIR:-$HOME}/.zkbd/${TERM}-${VENDOR}
else
    typeset -g -A key

    [[ -n "$terminfo[kf1]" ]] && key[F1]=$terminfo[kf1]
    [[ -n "$terminfo[kf2]" ]] && key[F2]=$terminfo[kf2]
    [[ -n "$terminfo[kf3]" ]] && key[F3]=$terminfo[kf3]
    [[ -n "$terminfo[kf4]" ]] && key[F4]=$terminfo[kf4]
    [[ -n "$terminfo[kf5]" ]] && key[F5]=$terminfo[kf5]
    [[ -n "$terminfo[kf6]" ]] && key[F6]=$terminfo[kf6]
    [[ -n "$terminfo[kf7]" ]] && key[F7]=$terminfo[kf7]
    [[ -n "$terminfo[kf8]" ]] && key[F8]=$terminfo[kf8]
    [[ -n "$terminfo[kf9]" ]] && key[F9]=$terminfo[kf9]
    [[ -n "$terminfo[kf10]" ]] && key[F10]=$terminfo[kf10]
    [[ -n "$terminfo[kf11]" ]] && key[F11]=$terminfo[kf11]
    [[ -n "$terminfo[kf12]" ]] && key[F12]=$terminfo[kf12]
    [[ -n "$terminfo[kf13]" ]] && key[F13]=$terminfo[kf13]
    [[ -n "$terminfo[kf14]" ]] && key[F14]=$terminfo[kf14]
    [[ -n "$terminfo[kf15]" ]] && key[F15]=$terminfo[kf15]
    [[ -n "$terminfo[kf16]" ]] && key[F16]=$terminfo[kf16]
    [[ -n "$terminfo[kf17]" ]] && key[F17]=$terminfo[kf17]
    [[ -n "$terminfo[kf18]" ]] && key[F18]=$terminfo[kf18]
    [[ -n "$terminfo[kf19]" ]] && key[F19]=$terminfo[kf19]
    [[ -n "$terminfo[kf20]" ]] && key[F20]=$terminfo[kf20]
    [[ -n "$terminfo[kbs]" ]] && key[Backspace]=$terminfo[kbs]
    [[ -n "$terminfo[kich1]" ]] && key[Insert]=$terminfo[kich1]
    [[ -n "$terminfo[kdch1]" ]] && key[Delete]=$terminfo[kdch1]
    [[ -n "$terminfo[khome]" ]] && key[Home]=$terminfo[khome]
    [[ -n "$terminfo[kend]" ]] && key[End]=$terminfo[kend]
    [[ -n "$terminfo[kpp]" ]] && key[PageUp]=$terminfo[kpp]
    [[ -n "$terminfo[knp]" ]] && key[PageDown]=$terminfo[knp]
    [[ -n "$terminfo[kcuu1]" ]] && key[Up]=$terminfo[kcuu1]
    [[ -n "$terminfo[kcub1]" ]] && key[Left]=$terminfo[kcub1]
    [[ -n "$terminfo[kcud1]" ]] && key[Down]=$terminfo[kcud1]
    [[ -n "$terminfo[kcuf1]" ]] && key[Right]=$terminfo[kcuf1]
fi

# Default key bindings
[[ -n ${key[Delete]} ]] && bindkey "${key[Delete]}" delete-char
[[ -n ${key[Home]} ]] && bindkey "${key[Home]}" beginning-of-line
[[ -n ${key[End]} ]] && bindkey "${key[End]}" end-of-line
[[ -n ${key[Up]} ]] && bindkey "${key[Up]}" up-line-or-search
[[ -n ${key[Down]} ]] && bindkey "${key[Down]}" down-line-or-search

# Default prompt
PS1="%n@%m %1~ %# "

# Useful support for interacting with Terminal.app or other terminal programs
[ -r "/etc/zshrc_$TERM_PROGRAM" ] && . "/etc/zshrc_$TERM_PROGRAM"

# Nix
if [ -e '/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh' ]; then
  . '/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh'
fi
# End Nix
</file>

<file path="doc/known-files/444c716ac2ccd9e1e3347858cb08a00d2ea38e8c12fdc5798380dc261e32e9ef">
# System-wide .bashrc file for interactive bash(1) shells.
if [ -z "$PS1" ]; then
   return
fi

PS1='\h:\W \u\$ '
# Make bash check its window size after a process completes
shopt -s checkwinsize

[ -r "/etc/bashrc_$TERM_PROGRAM" ] && . "/etc/bashrc_$TERM_PROGRAM"
</file>

<file path="doc/known-files/4d1ab5704f9d167a042fecac0d056c8a79a8ebd71e032d3489536c8db9ffe3e0">
# System-wide profile for interactive zsh(1) shells.

# Setup user specific overrides for this in ~/.zshrc. See zshbuiltins(1)
# and zshoptions(1) for more details.

# Correctly display UTF-8 with combining characters.  We'll assume UTF-8 if the
# locale(1) binary is missing entirely.
if [[ ! -x /usr/bin/locale ]] || [[ "$(locale LC_CTYPE)" == "UTF-8" ]]; then
    setopt COMBINING_CHARS
fi

# Disable the log builtin, so we don't conflict with /usr/bin/log
disable log

# Save command history
HISTFILE=${ZDOTDIR:-$HOME}/.zsh_history
HISTSIZE=2000
SAVEHIST=1000

# Beep on error
setopt BEEP

# Use keycodes (generated via zkbd) if present, otherwise fallback on
# values from terminfo
if [[ -r ${ZDOTDIR:-$HOME}/.zkbd/${TERM}-${VENDOR} ]] ; then
    source ${ZDOTDIR:-$HOME}/.zkbd/${TERM}-${VENDOR}
else
    typeset -g -A key

    [[ -n "$terminfo[kf1]" ]] && key[F1]=$terminfo[kf1]
    [[ -n "$terminfo[kf2]" ]] && key[F2]=$terminfo[kf2]
    [[ -n "$terminfo[kf3]" ]] && key[F3]=$terminfo[kf3]
    [[ -n "$terminfo[kf4]" ]] && key[F4]=$terminfo[kf4]
    [[ -n "$terminfo[kf5]" ]] && key[F5]=$terminfo[kf5]
    [[ -n "$terminfo[kf6]" ]] && key[F6]=$terminfo[kf6]
    [[ -n "$terminfo[kf7]" ]] && key[F7]=$terminfo[kf7]
    [[ -n "$terminfo[kf8]" ]] && key[F8]=$terminfo[kf8]
    [[ -n "$terminfo[kf9]" ]] && key[F9]=$terminfo[kf9]
    [[ -n "$terminfo[kf10]" ]] && key[F10]=$terminfo[kf10]
    [[ -n "$terminfo[kf11]" ]] && key[F11]=$terminfo[kf11]
    [[ -n "$terminfo[kf12]" ]] && key[F12]=$terminfo[kf12]
    [[ -n "$terminfo[kf13]" ]] && key[F13]=$terminfo[kf13]
    [[ -n "$terminfo[kf14]" ]] && key[F14]=$terminfo[kf14]
    [[ -n "$terminfo[kf15]" ]] && key[F15]=$terminfo[kf15]
    [[ -n "$terminfo[kf16]" ]] && key[F16]=$terminfo[kf16]
    [[ -n "$terminfo[kf17]" ]] && key[F17]=$terminfo[kf17]
    [[ -n "$terminfo[kf18]" ]] && key[F18]=$terminfo[kf18]
    [[ -n "$terminfo[kf19]" ]] && key[F19]=$terminfo[kf19]
    [[ -n "$terminfo[kf20]" ]] && key[F20]=$terminfo[kf20]
    [[ -n "$terminfo[kbs]" ]] && key[Backspace]=$terminfo[kbs]
    [[ -n "$terminfo[kich1]" ]] && key[Insert]=$terminfo[kich1]
    [[ -n "$terminfo[kdch1]" ]] && key[Delete]=$terminfo[kdch1]
    [[ -n "$terminfo[khome]" ]] && key[Home]=$terminfo[khome]
    [[ -n "$terminfo[kend]" ]] && key[End]=$terminfo[kend]
    [[ -n "$terminfo[kpp]" ]] && key[PageUp]=$terminfo[kpp]
    [[ -n "$terminfo[knp]" ]] && key[PageDown]=$terminfo[knp]
    [[ -n "$terminfo[kcuu1]" ]] && key[Up]=$terminfo[kcuu1]
    [[ -n "$terminfo[kcub1]" ]] && key[Left]=$terminfo[kcub1]
    [[ -n "$terminfo[kcud1]" ]] && key[Down]=$terminfo[kcud1]
    [[ -n "$terminfo[kcuf1]" ]] && key[Right]=$terminfo[kcuf1]
fi

# Default key bindings
[[ -n ${key[Delete]} ]] && bindkey "${key[Delete]}" delete-char
[[ -n ${key[Home]} ]] && bindkey "${key[Home]}" beginning-of-line
[[ -n ${key[End]} ]] && bindkey "${key[End]}" end-of-line
[[ -n ${key[Up]} ]] && bindkey "${key[Up]}" up-line-or-search
[[ -n ${key[Down]} ]] && bindkey "${key[Down]}" down-line-or-search

# Default prompt
PS1="%n@%m %1~ %# "

# Useful support for interacting with Terminal.app or other terminal programs
[ -r "/etc/zshrc_$TERM_PROGRAM" ] && . "/etc/zshrc_$TERM_PROGRAM"
</file>

<file path="doc/known-files/53712b4335030e2dbfb46bb235f8cffcac83fea404bd32dc99417ac89e2dd7c5">
# Generated by https://github.com/DeterminateSystems/nix-installer.
# See `/nix/nix-installer --version` for the version details.

!include nix.custom.conf

experimental-features = nix-command flakes
always-allow-substitutes = true
extra-trusted-substituters = https://cache.flakehub.com
extra-trusted-public-keys = cache.flakehub.com-3:hJuILl5sVK4iKm86JzgdXW12Y2Hwd5G07qKtHTOcDCM= cache.flakehub.com-4:Asi8qIv291s0aYLyH6IOnr5Kf6+OF14WVjkE6t3xMio= cache.flakehub.com-5:zB96CRlL7tiPtzA9/WKyPkp3A2vqxqgdgyTVNGShPDU= cache.flakehub.com-6:W4EGFwAGgBj3he7c5fNh9NkOXw0PUVaxygCVKeuvaqU= cache.flakehub.com-7:mvxJ2DZVHn/kRxlIaxYNMuDG1OvMckZu32um1TadOR8= cache.flakehub.com-8:moO+OVS0mnTjBTcOUh2kYLQEd59ExzyoW1QgQ8XAARQ= cache.flakehub.com-9:wChaSeTI6TeCuV/Sg2513ZIM9i0qJaYsF+lZCXg0J6o= cache.flakehub.com-10:2GqeNlIp6AKp4EF2MVbE1kBOp9iBSyo0UPR9KoR0o1Y=
bash-prompt-prefix = (nix:$name)\040
max-jobs = auto
extra-nix-path = nixpkgs=flake:nixpkgs
upgrade-nix-store-path-url = https://install.determinate.systems/nix-upgrade/stable/universal
</file>

<file path="doc/known-files/5d23e6d7015756c6f300f8cd558ec4d9234ca61deefd4f2478e91a49760b0747">
# Generated by https://github.com/DeterminateSystems/nix-installer.
# See `/nix/nix-installer --version` for the version details.

build-users-group = nixbld
experimental-features = nix-command flakes repl-flake
bash-prompt-prefix = (nix:$name)\040
max-jobs = auto
extra-nix-path = nixpkgs=flake:nixpkgs
upgrade-nix-store-path-url = https://install.determinate.systems/nix-upgrade/stable/universal
</file>

<file path="doc/known-files/617b39e36fa69270ddbee19ddc072497dbe7ead840cbd442d9f7c22924f116f4">
# System-wide .bashrc file for interactive bash(1) shells.
if [ -z "$PS1" ]; then
   return
fi

PS1='\h:\W \u\$ '
# Make bash check its window size after a process completes
shopt -s checkwinsize

[ -r "/etc/bashrc_$TERM_PROGRAM" ] && . "/etc/bashrc_$TERM_PROGRAM"

# Nix
if [ -e '/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh' ]; then
  . '/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh'
fi
# End Nix
</file>

<file path="doc/known-files/6787fade1cf934f82db554e78e1fc788705c2c5257fddf9b59bdd963ca6fec63">
# Written by https://github.com/DeterminateSystems/nix-installer.
# The contents below are based on options specified at installation time.
</file>

<file path="doc/known-files/6bb8d6b0dd16b44ee793a9b8382dac76c926e4c16ffb8ddd2bb4884d1ca3f811">
# Generated by https://github.com/DeterminateSystems/nix-installer.
# See `/nix/nix-installer --version` for the version details.

extra-experimental-features = nix-command flakes
always-allow-substitutes = true
extra-trusted-substituters = https://cache.flakehub.com
extra-trusted-public-keys = cache.flakehub.com-3:hJuILl5sVK4iKm86JzgdXW12Y2Hwd5G07qKtHTOcDCM= cache.flakehub.com-4:Asi8qIv291s0aYLyH6IOnr5Kf6+OF14WVjkE6t3xMio= cache.flakehub.com-5:zB96CRlL7tiPtzA9/WKyPkp3A2vqxqgdgyTVNGShPDU= cache.flakehub.com-6:W4EGFwAGgBj3he7c5fNh9NkOXw0PUVaxygCVKeuvaqU= cache.flakehub.com-7:mvxJ2DZVHn/kRxlIaxYNMuDG1OvMckZu32um1TadOR8= cache.flakehub.com-8:moO+OVS0mnTjBTcOUh2kYLQEd59ExzyoW1QgQ8XAARQ= cache.flakehub.com-9:wChaSeTI6TeCuV/Sg2513ZIM9i0qJaYsF+lZCXg0J6o= cache.flakehub.com-10:2GqeNlIp6AKp4EF2MVbE1kBOp9iBSyo0UPR9KoR0o1Y=
bash-prompt-prefix = (nix:$name)\040
max-jobs = auto
extra-nix-path = nixpkgs=flake:nixpkgs
upgrade-nix-store-path-url = https://install.determinate.systems/nix-upgrade/stable/universal

!include nix.custom.conf
</file>

<file path="doc/known-files/966d22ef5bb9b56d481e8e0d5f7ca2deaf4d24c0f0fc969b2eeaa7ae0aa42907">
# Generated by https://github.com/DeterminateSystems/nix-installer.
# See `/nix/nix-installer --version` for the version details.

build-users-group = nixbld
experimental-features = nix-command flakes
always-allow-substitutes = true
extra-trusted-substituters = https://cache.flakehub.com
extra-trusted-public-keys = cache.flakehub.com-3:hJuILl5sVK4iKm86JzgdXW12Y2Hwd5G07qKtHTOcDCM= cache.flakehub.com-4:Asi8qIv291s0aYLyH6IOnr5Kf6+OF14WVjkE6t3xMio= cache.flakehub.com-5:zB96CRlL7tiPtzA9/WKyPkp3A2vqxqgdgyTVNGShPDU= cache.flakehub.com-6:W4EGFwAGgBj3he7c5fNh9NkOXw0PUVaxygCVKeuvaqU= cache.flakehub.com-7:mvxJ2DZVHn/kRxlIaxYNMuDG1OvMckZu32um1TadOR8= cache.flakehub.com-8:moO+OVS0mnTjBTcOUh2kYLQEd59ExzyoW1QgQ8XAARQ= cache.flakehub.com-9:wChaSeTI6TeCuV/Sg2513ZIM9i0qJaYsF+lZCXg0J6o= cache.flakehub.com-10:2GqeNlIp6AKp4EF2MVbE1kBOp9iBSyo0UPR9KoR0o1Y=
bash-prompt-prefix = (nix:$name)\040
max-jobs = auto
extra-nix-path = nixpkgs=flake:nixpkgs
upgrade-nix-store-path-url = https://install.determinate.systems/nix-upgrade/stable/universal
</file>

<file path="doc/known-files/97f4135d262ca22d65c9554aad795c10a4491fa61b67d9c2430f4d82bbfec9a2">
# Generated by https://github.com/DeterminateSystems/nix-installer.
# See `/nix/nix-installer --version` for the version details.

build-users-group = nixbld
experimental-features = nix-command flakes repl-flake
bash-prompt-prefix = (nix:$name)\040
max-jobs = auto
extra-nix-path = nixpkgs=flake:nixpkgs
</file>

<file path="doc/known-files/9d5aa72f807091b481820d12e693093293ba33c73854909ad7b0fb192c2db193">
# List of acceptable shells for chpass(1).
# Ftpd will not allow users to connect who are not using
# one of these shells.

/bin/bash
/bin/csh
/bin/dash
/bin/ksh
/bin/sh
/bin/tcsh
/bin/zsh
</file>

<file path="doc/known-files/b027b5cad320b5b8123d9d0db9f815c3f3921596c26dc3c471457098e4d3cc40">
# Generated by https://install.lix.systems/.
# See `/nix/nix-installer --version` for the version details.

build-users-group = nixbld
experimental-features = nix-command
bash-prompt-prefix = (nix:$name)\040
max-jobs = auto
substituters = https://cache.nixos.org https://cache.lix.systems
trusted-public-keys = cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY= cache.lix.systems:aBnZUw8zA7H35Cz2RyKFVs3H4PlGTLawyY5KRbvJR8o=
</file>

<file path="doc/known-files/bf76c5ed8e65e616f4329eccf662ee91be33b8bfd33713ce9946f2fe94fea7fa">
# System-wide profile for interactive zsh(1) shells.

# Setup user specific overrides for this in ~/.zshrc. See zshbuiltins(1)
# and zshoptions(1) for more details.

# Correctly display UTF-8 with combining characters.  We'll assume UTF-8 if the
# locale(1) binary is missing entirely.
if [[ ! -x /usr/bin/locale ]] || [[ "$(locale LC_CTYPE)" == "UTF-8" ]]; then
    setopt COMBINING_CHARS
fi

# Disable the log builtin, so we don't conflict with /usr/bin/log
disable log

# Save command history
HISTFILE=${ZDOTDIR:-$HOME}/.zsh_history
HISTSIZE=2000
SAVEHIST=1000

# Beep on error
setopt BEEP

# Use keycodes (generated via zkbd) if present, otherwise fallback on
# values from terminfo
if [[ -r ${ZDOTDIR:-$HOME}/.zkbd/${TERM}-${VENDOR} ]] ; then
    source ${ZDOTDIR:-$HOME}/.zkbd/${TERM}-${VENDOR}
else
    typeset -g -A key

    [[ -n "$terminfo[kf1]" ]] && key[F1]=$terminfo[kf1]
    [[ -n "$terminfo[kf2]" ]] && key[F2]=$terminfo[kf2]
    [[ -n "$terminfo[kf3]" ]] && key[F3]=$terminfo[kf3]
    [[ -n "$terminfo[kf4]" ]] && key[F4]=$terminfo[kf4]
    [[ -n "$terminfo[kf5]" ]] && key[F5]=$terminfo[kf5]
    [[ -n "$terminfo[kf6]" ]] && key[F6]=$terminfo[kf6]
    [[ -n "$terminfo[kf7]" ]] && key[F7]=$terminfo[kf7]
    [[ -n "$terminfo[kf8]" ]] && key[F8]=$terminfo[kf8]
    [[ -n "$terminfo[kf9]" ]] && key[F9]=$terminfo[kf9]
    [[ -n "$terminfo[kf10]" ]] && key[F10]=$terminfo[kf10]
    [[ -n "$terminfo[kf11]" ]] && key[F11]=$terminfo[kf11]
    [[ -n "$terminfo[kf12]" ]] && key[F12]=$terminfo[kf12]
    [[ -n "$terminfo[kf13]" ]] && key[F13]=$terminfo[kf13]
    [[ -n "$terminfo[kf14]" ]] && key[F14]=$terminfo[kf14]
    [[ -n "$terminfo[kf15]" ]] && key[F15]=$terminfo[kf15]
    [[ -n "$terminfo[kf16]" ]] && key[F16]=$terminfo[kf16]
    [[ -n "$terminfo[kf17]" ]] && key[F17]=$terminfo[kf17]
    [[ -n "$terminfo[kf18]" ]] && key[F18]=$terminfo[kf18]
    [[ -n "$terminfo[kf19]" ]] && key[F19]=$terminfo[kf19]
    [[ -n "$terminfo[kf20]" ]] && key[F20]=$terminfo[kf20]
    [[ -n "$terminfo[kbs]" ]] && key[Backspace]=$terminfo[kbs]
    [[ -n "$terminfo[kich1]" ]] && key[Insert]=$terminfo[kich1]
    [[ -n "$terminfo[kdch1]" ]] && key[Delete]=$terminfo[kdch1]
    [[ -n "$terminfo[khome]" ]] && key[Home]=$terminfo[khome]
    [[ -n "$terminfo[kend]" ]] && key[End]=$terminfo[kend]
    [[ -n "$terminfo[kpp]" ]] && key[PageUp]=$terminfo[kpp]
    [[ -n "$terminfo[knp]" ]] && key[PageDown]=$terminfo[knp]
    [[ -n "$terminfo[kcuu1]" ]] && key[Up]=$terminfo[kcuu1]
    [[ -n "$terminfo[kcub1]" ]] && key[Left]=$terminfo[kcub1]
    [[ -n "$terminfo[kcud1]" ]] && key[Down]=$terminfo[kcud1]
    [[ -n "$terminfo[kcuf1]" ]] && key[Right]=$terminfo[kcuf1]
fi

# Default key bindings
[[ -n ${key[Delete]} ]] && bindkey "${key[Delete]}" delete-char
[[ -n ${key[Home]} ]] && bindkey "${key[Home]}" beginning-of-line
[[ -n ${key[End]} ]] && bindkey "${key[End]}" end-of-line
[[ -n ${key[Up]} ]] && bindkey "${key[Up]}" up-line-or-search
[[ -n ${key[Down]} ]] && bindkey "${key[Down]}" down-line-or-search

# Default prompt
PS1="%n@%m %1~ %# "

# Useful support for interacting with Terminal.app or other terminal programs
[ -r "/etc/zshrc_$TERM_PROGRAM" ] && . "/etc/zshrc_$TERM_PROGRAM"

# Nix
if [ -e '/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh' ]; then
  . '/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh'
fi
# End Nix
</file>

<file path="doc/known-files/c06b0c6080dd1d62e61a30cfad100c0cfed2d3bcd378e296632dc3b28b31dc69">
build-users-group = nixbld
</file>

<file path="doc/known-files/c6080216f2a170611e339c3f46e4e1d61aaf0d8b417ad93ade8d647da1382c11">
# Generated by https://github.com/DeterminateSystems/nix-installer, version 0.14.0.
build-users-group = nixbld
experimental-features = nix-command flakes repl-flake
bash-prompt-prefix = (nix:$name)\040
max-jobs = auto
extra-nix-path = nixpkgs=flake:nixpkgs
</file>

<file path="doc/known-files/d07015be6875f134976fce84c6c7a77b512079c1c5f9594dfa65c70b7968b65f">
# Set up Nix only on SSH connections
# See: https://github.com/DeterminateSystems/nix-installer/pull/714
if [ -e '/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh' ] && [ -n "${SSH_CONNECTION}" ] && [ "${SHLVL}" -eq 1 ]; then
    . '/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh'
fi
# End Nix
</file>

<file path="doc/known-files/e4974acb79c56148cb8e92137fa4f2de9b7356e897b332fc4e6769e8c0b83e18">
# Generated by https://github.com/DeterminateSystems/nix-installer.
# See `/nix/nix-installer --version` for the version details.

build-users-group = nixbld
experimental-features = nix-command flakes
always-allow-substitutes = true
bash-prompt-prefix = (nix:$name)\040
max-jobs = auto
extra-nix-path = nixpkgs=flake:nixpkgs
upgrade-nix-store-path-url = https://install.determinate.systems/nix-upgrade/stable/universal
</file>

<file path="doc/known-files/ef78f401a9b5a42fd15e967c50da384f99ec62f9dbc66ea38f1390b46b63e1ff">
build-users-group = nixbld

max-jobs = 32
cores = 1
sandbox = false
</file>

<file path="doc/known-files/f320016e2cf13573731fbee34f9fe97ba867dd2a31f24893d3120154e9306e92">
# System-wide profile for interactive zsh(1) login shells.

# Setup user specific overrides for this in ~/.zprofile. See zshbuiltins(1)
# and zshoptions(1) for more details.

if [ -z "$LANG" ]; then
	export LANG=C.UTF-8
fi

if [ -x /usr/libexec/path_helper ]; then
	eval `/usr/libexec/path_helper -s`
fi
</file>

<file path="doc/known-files/f3e03d851c240c1aa7daccd144ee929f0f5971982424c868c434eb6030e961d4">
# Generated by https://github.com/DeterminateSystems/nix-installer, version 0.10.0.
experimental-features = nix-command flakes auto-allocate-uids
build-users-group = nixbld
auto-optimise-store = true
extra-nix-path = nixpkgs=flake:nixpkgs
bash-prompt-prefix = (nix:$name)\040
</file>

<file path="doc/known-files/fb5827cb4712b7e7932d438067ec4852c8955a9ff0f55e282473684623ebdfa1">
# System-wide profile for interactive zsh(1) shells.

# Setup user specific overrides for this in ~/.zshrc. See zshbuiltins(1)
# and zshoptions(1) for more details.

# Correctly display UTF-8 with combining characters.
if [[ "$(locale LC_CTYPE)" == "UTF-8" ]]; then
    setopt COMBINING_CHARS
fi

# Disable the log builtin, so we don't conflict with /usr/bin/log
disable log

# Save command history
HISTFILE=${ZDOTDIR:-$HOME}/.zsh_history
HISTSIZE=2000
SAVEHIST=1000

# Beep on error
setopt BEEP

# Use keycodes (generated via zkbd) if present, otherwise fallback on
# values from terminfo
if [[ -r ${ZDOTDIR:-$HOME}/.zkbd/${TERM}-${VENDOR} ]] ; then
    source ${ZDOTDIR:-$HOME}/.zkbd/${TERM}-${VENDOR}
else
    typeset -g -A key

    [[ -n "$terminfo[kf1]" ]] && key[F1]=$terminfo[kf1]
    [[ -n "$terminfo[kf2]" ]] && key[F2]=$terminfo[kf2]
    [[ -n "$terminfo[kf3]" ]] && key[F3]=$terminfo[kf3]
    [[ -n "$terminfo[kf4]" ]] && key[F4]=$terminfo[kf4]
    [[ -n "$terminfo[kf5]" ]] && key[F5]=$terminfo[kf5]
    [[ -n "$terminfo[kf6]" ]] && key[F6]=$terminfo[kf6]
    [[ -n "$terminfo[kf7]" ]] && key[F7]=$terminfo[kf7]
    [[ -n "$terminfo[kf8]" ]] && key[F8]=$terminfo[kf8]
    [[ -n "$terminfo[kf9]" ]] && key[F9]=$terminfo[kf9]
    [[ -n "$terminfo[kf10]" ]] && key[F10]=$terminfo[kf10]
    [[ -n "$terminfo[kf11]" ]] && key[F11]=$terminfo[kf11]
    [[ -n "$terminfo[kf12]" ]] && key[F12]=$terminfo[kf12]
    [[ -n "$terminfo[kf13]" ]] && key[F13]=$terminfo[kf13]
    [[ -n "$terminfo[kf14]" ]] && key[F14]=$terminfo[kf14]
    [[ -n "$terminfo[kf15]" ]] && key[F15]=$terminfo[kf15]
    [[ -n "$terminfo[kf16]" ]] && key[F16]=$terminfo[kf16]
    [[ -n "$terminfo[kf17]" ]] && key[F17]=$terminfo[kf17]
    [[ -n "$terminfo[kf18]" ]] && key[F18]=$terminfo[kf18]
    [[ -n "$terminfo[kf19]" ]] && key[F19]=$terminfo[kf19]
    [[ -n "$terminfo[kf20]" ]] && key[F20]=$terminfo[kf20]
    [[ -n "$terminfo[kbs]" ]] && key[Backspace]=$terminfo[kbs]
    [[ -n "$terminfo[kich1]" ]] && key[Insert]=$terminfo[kich1]
    [[ -n "$terminfo[kdch1]" ]] && key[Delete]=$terminfo[kdch1]
    [[ -n "$terminfo[khome]" ]] && key[Home]=$terminfo[khome]
    [[ -n "$terminfo[kend]" ]] && key[End]=$terminfo[kend]
    [[ -n "$terminfo[kpp]" ]] && key[PageUp]=$terminfo[kpp]
    [[ -n "$terminfo[knp]" ]] && key[PageDown]=$terminfo[knp]
    [[ -n "$terminfo[kcuu1]" ]] && key[Up]=$terminfo[kcuu1]
    [[ -n "$terminfo[kcub1]" ]] && key[Left]=$terminfo[kcub1]
    [[ -n "$terminfo[kcud1]" ]] && key[Down]=$terminfo[kcud1]
    [[ -n "$terminfo[kcuf1]" ]] && key[Right]=$terminfo[kcuf1]
fi

# Default key bindings
[[ -n ${key[Delete]} ]] && bindkey "${key[Delete]}" delete-char
[[ -n ${key[Home]} ]] && bindkey "${key[Home]}" beginning-of-line
[[ -n ${key[End]} ]] && bindkey "${key[End]}" end-of-line
[[ -n ${key[Up]} ]] && bindkey "${key[Up]}" up-line-or-search
[[ -n ${key[Down]} ]] && bindkey "${key[Down]}" down-line-or-search

# Default prompt
PS1="%n@%m %1~ %# "

# Useful support for interacting with Terminal.app or other terminal programs
[ -r "/etc/zshrc_$TERM_PROGRAM" ] && . "/etc/zshrc_$TERM_PROGRAM"
</file>

<file path="doc/known-files/ff08c12813680da98c4240328f828647b67a65ba7aa89c022bd8072cba862cf1">
build-users-group = nixbld
</file>

<file path="doc/manual/default.nix">
{ pkgs
, options
, config
, version
, revision
, nixpkgsRevision
, extraSources ? []
, prefix ? ../..
}:

with pkgs;

let
  lib = pkgs.lib;

  gitHubDeclaration = user: repo: ref: subpath:
    # Default to `master` if we don't know what revision the system
    # configuration is using (custom nixpkgs, etc.).
    let urlRef = if ref != null then ref else "master";
    in {
      url = "https://github.com/${user}/${repo}/blob/${urlRef}/${subpath}";
      name = "<${repo}/${subpath}>";
    };

  optionsDoc = buildPackages.nixosOptionsDoc {
    inherit options;
    transformOptions = opt: opt // {
      # Clean up declaration sites to not refer to the nix-darwin source tree.
      # TODO: handle `extraSources`? (it's not set anywhere)
      declarations = map
        (decl:
          if lib.hasPrefix (toString prefix) (toString decl) then
            gitHubDeclaration "nix-darwin" "nix-darwin" revision
              (lib.removePrefix "/"
                (lib.removePrefix (toString prefix) (toString decl)))
          # TODO: handle this in a better way (may require upstream
          # changes to nixpkgs)
          else if decl == "lib/modules.nix" then
            gitHubDeclaration "NixOS" "nixpkgs" nixpkgsRevision decl
          else decl)
        opt.declarations;
    };
  };

in rec {
  # TODO: Use `optionsDoc.optionsJSON` directly once upstream
  # `nixosOptionsDoc` is more customizable.
  optionsJSON = runCommand "options.json"
    { meta.description = "List of nix-darwin options in JSON format"; }
    ''
      mkdir -p $out/{share/doc,nix-support}
      cp -a ${optionsDoc.optionsJSON}/share/doc/nixos $out/share/doc/darwin
      substitute \
        ${optionsDoc.optionsJSON}/nix-support/hydra-build-products \
        $out/nix-support/hydra-build-products \
        --replace-fail \
          '${optionsDoc.optionsJSON}/share/doc/nixos' \
          "$out/share/doc/darwin"
    '';

  # Generate the nix-darwin manual.
  manualHTML = runCommand "darwin-manual-html"
    { nativeBuildInputs = [ buildPackages.nixos-render-docs ];
      styles = lib.sourceFilesBySuffices (pkgs.path + "/doc") [ ".css" ];
      meta.description = "The Darwin manual in HTML format";
      allowedReferences = ["out"];
    }
    ''
      # Generate the HTML manual.
      dst=$out/share/doc/darwin
      mkdir -p $dst

      cp $styles/style.css $dst
      cp -r ${pkgs.documentation-highlighter} $dst/highlightjs

      substitute ${./manual.md} manual.md \
        --replace-fail '@DARWIN_VERSION@' "${version}" \
        --replace-fail \
          '@DARWIN_OPTIONS_JSON@' \
          ${optionsJSON}/share/doc/darwin/options.json

      # Pass --redirects option if nixos-render-docs supports it
      if nixos-render-docs manual html --help | grep --silent -E '^\s+--redirects\s'; then
        redirects_opt="--redirects ${./redirects.json}"
      fi

      # TODO: --manpage-urls?
      nixos-render-docs -j $NIX_BUILD_CORES manual html \
        --manpage-urls ${pkgs.writeText "manpage-urls.json" "{}"} \
        --revision ${lib.escapeShellArg revision} \
        --generator "nixos-render-docs ${lib.version}" \
        $redirects_opt \
        --stylesheet style.css \
        --stylesheet highlightjs/mono-blue.css \
        --script ./highlightjs/highlight.pack.js \
        --script ./highlightjs/loader.js \
        --toc-depth 1 \
        --chunk-toc-depth 1 \
        ./manual.md \
        $dst/index.html

      mkdir -p $out/nix-support
      echo "nix-build out $out" >> $out/nix-support/hydra-build-products
      echo "doc manual $dst" >> $out/nix-support/hydra-build-products
    '';

  # Index page of the nix-darwin manual.
  manualHTMLIndex = "${manualHTML}/share/doc/darwin/index.html";

  manualEpub = builtins.throw "The nix-darwin EPUB manual has been removed.";

  # Generate the nix-darwin manpages.
  manpages = runCommand "darwin-manpages"
    { nativeBuildInputs = [ buildPackages.nixos-render-docs ];
      allowedReferences = ["out"];
    }
    ''
      # Generate manpages.
      mkdir -p $out/share/man/man5
      nixos-render-docs -j $NIX_BUILD_CORES options manpage \
        --revision ${lib.escapeShellArg revision} \
        ${optionsJSON}/share/doc/darwin/options.json \
        $out/share/man/man5/configuration.nix.5

      # TODO: get these parameterized in upstream nixos-render-docs
      sed -i -e '
        /^\.TH / s|NixOS|nix-darwin|g

        /^\.SH "NAME"$/ {
          N
          s|NixOS|nix-darwin|g
        }

        /^\.SH "DESCRIPTION"$/ {
          N; N
          s|/etc/nixos/configuration|configuration|g
          s|NixOS|nix-darwin|g
          s|nixos|nix-darwin|g
        }

        /\.SH "AUTHORS"$/ {
          N; N
          s|Eelco Dolstra and the Nixpkgs/NixOS contributors|Daiderd Jordan and the nix-darwin contributors|g
        }
      ' $out/share/man/man5/configuration.nix.5
    '';
}
</file>

<file path="doc/manual/manual.md">
# nix-darwin Configuration Options {#book-darwin-manual}
## Version @DARWIN_VERSION@

```{=include=} options
id-prefix: opt-
list-id: configuration-variable-list
source: @DARWIN_OPTIONS_JSON@
```
</file>

<file path="doc/manual/redirects.json">
{
  "book-darwin-manual": [
    "index.html#book-darwin-manual"
  ]
}
</file>

<file path="doc/website/index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>nix-darwin</title>
    <script>
      window.location.replace("https://github.com/nix-darwin/nix-darwin#readme");
    </script>
    <noscript>
      <meta
        http-equiv="refresh"
        content="0; url=https://github.com/nix-darwin/nix-darwin#readme">
    </noscript>
  </head>
  <body>
    <h1>nix-darwin</h1>
    <p>
      nix-darwin is a declarative configuration system for macOS, based
      on Nix. See the
      <a href="https://github.com/nix-darwin/nix-darwin#readme">GitHub
      repository</a> for more information.
    </p>
  </body>
</html>
</file>

<file path="modules/config/system-path.nix">
# This module defines the packages that appear in
# /run/current-system/sw.
{
  config,
  lib,
  pkgs,
  ...
}:
let

  makeDrvBinPath = lib.concatMapStringsSep ":" (p: if lib.isDerivation p then "${p}/bin" else p);

  defaultPackageNames = [ ];
  defaultPackages = map (
    n:
    let
      pkg = pkgs.${n};
    in
    lib.setPrio ((pkg.meta.priority or lib.meta.defaultPriority) + 3) pkg
  ) defaultPackageNames;
  defaultPackagesText = "[ ${lib.concatMapStringsSep " " (n: "pkgs.${n}") defaultPackageNames} ]";

in

{
  imports = [
    (lib.mkRenamedOptionModule ["environment" "postBuild"] ["environment" "extraSetup"])
  ];

  options = {

    environment = {
      systemPath = lib.mkOption {
        type = lib.types.listOf (lib.types.either lib.types.path lib.types.str);
        description = "The set of paths that are added to PATH.";
        apply = x: if lib.isList x then makeDrvBinPath x else x;
      };

      systemPackages = lib.mkOption {
        type = lib.types.listOf lib.types.package;
        default = [ ];
        example = lib.literalExpression "[ pkgs.firefox pkgs.thunderbird ]";
        description = ''
          The set of packages that appear in
          /run/current-system/sw.  These packages are
          automatically available to all users, and are
          automatically updated every time you rebuild the system
          configuration.  (The latter is the main difference with
          installing them in the default profile,
          {file}`/nix/var/nix/profiles/default`.
        '';
      };

      defaultPackages = lib.mkOption {
        type = lib.types.listOf lib.types.package;
        default = defaultPackages;
        defaultText = lib.literalMD ''
          these packages, with their `meta.priority` numerically increased
          (thus lowering their installation priority):

              ${defaultPackagesText}
        '';
        example = [ ];
        description = ''
          Set of default packages that aren't strictly necessary
          for a running system, entries can be removed for a more
          minimal NixOS installation.

          Like with systemPackages, packages are installed to
          {file}`/run/current-system/sw`. They are
          automatically available to all users, and are
          automatically updated every time you rebuild the system
          configuration.
        '';
      };

      pathsToLink = lib.mkOption {
        type = lib.types.listOf lib.types.str;
        # According to https://github.com/NixOS/nixpkgs/blob/2795c506fe8fb7b03c36ccb51f75b6df0ab2553f/nixos/modules/config/system-path.nix#L108-L109
        # `/lib` needs to be added to make NSS modules work, however currently we don't add it
        # and it's unclear whether the comment applies on macOS as well.
        default = [ ];
        example = [ "/share/doc" ];
        description = "List of directories to be symlinked in {file}`/run/current-system/sw`.";
      };

      extraOutputsToInstall = lib.mkOption {
        type = lib.types.listOf lib.types.str;
        default = [ ];
        example = [
          "dev"
          "info"
        ];
        description = ''
          Entries listed here will be appended to the `meta.outputsToInstall` attribute for each package in `environment.systemPackages`, and the files from the corresponding derivation outputs symlinked into {file}`/run/current-system/sw`.

          For example, this can be used to install the `dev` and `info` outputs for all packages in the system environment, if they are available.

          To use specific outputs instead of configuring them globally, select the corresponding attribute on the package derivation, e.g. `libxml2.dev` or `coreutils.info`.
        '';
      };

      extraSetup = lib.mkOption {
        type = lib.types.lines;
        default = "";
        description = "Shell fragments to be run after the system environment has been created. This should only be used for things that need to modify the internals of the environment, e.g. generating MIME caches. The environment being built can be accessed at $out.";
      };

    };

    system = {

      path = lib.mkOption {
        internal = true;
        description = ''
          The packages you want in the system environment.
        '';
      };

    };

  };

  config = {

    environment.systemPackages = config.environment.defaultPackages;

    environment.pathsToLink = [
      "/bin"
      "/share/locale"
    ];

    system.path = pkgs.buildEnv {
      name = "system-path";
      paths = config.environment.systemPackages;
      inherit (config.environment) pathsToLink extraOutputsToInstall;
      ignoreCollisions = true;
      # !!! Hacky, should modularise.
      # outputs TODO: note that the tools will often not be linked by default
      postBuild = ''
        # Remove wrapped binaries, they shouldn't be accessible via PATH.
        find $out/bin -maxdepth 1 -name ".*-wrapped" -type l -delete

        ${config.environment.extraSetup}
      '';
    };

  };
}
</file>

<file path="modules/config/terminfo.nix">
# This module manages the terminfo database
# and its integration in the system.
{
  config,
  lib,
  pkgs,
  ...
}:
{

  options = {
    environment.enableAllTerminfo = lib.mkOption {
      default = false;
      type = lib.types.bool;
      description = ''
        Whether to install all terminfo outputs
      '';
    };

    security.sudo.keepTerminfo = lib.mkOption {
      default = true;
      type = lib.types.bool;
      description = ''
        Whether to preserve the `TERMINFO` and `TERMINFO_DIRS`
        environment variables, for `root` and the `admin` group.
      '';
    };
  };

  config = {

    # This should not contain packages that are broken or can't build, since it
    # will break this expression
    #
    # can be generated with:
    # lib.attrNames (lib.filterAttrs
    #  (_: drv: (builtins.tryEval (
    #    lib.isDerivation drv && drv ? terminfo && drv.meta.available && !drv.meta.broken && !drv.meta.unsupported)).value)
    #  pkgs)
    environment.systemPackages = lib.mkIf config.environment.enableAllTerminfo (
      map (x: x.terminfo) (
        with pkgs.pkgsBuildBuild;
        [
          alacritty
          kitty
          mtm
          rio
          rxvt-unicode-unwrapped
          rxvt-unicode-unwrapped-emoji
          st
          termite
          tmux
          wezterm
        ] ++ lib.optional (pkgs ? ghostty-bin) ghostty-bin
      )
    );

    environment.pathsToLink = [
      "/share/terminfo"
    ];

    environment.etc.terminfo = {
      source = "${config.system.path}/share/terminfo";
    };

    # TODO: use `environment.profileRelativeSessionVariables`
    environment.variables = {
      TERMINFO_DIRS = map (path: path + "/share/terminfo") config.environment.profiles ++ [ "/usr/share/terminfo" ];
    };

    environment.extraInit = ''
      # reset TERM with new TERMINFO available (if any)
      export TERM=$TERM
    '';

    security =
      let
        extraConfig = ''

          # Keep terminfo database for root and %admin.
          Defaults:root,%admin env_keep+=TERMINFO_DIRS
          Defaults:root,%admin env_keep+=TERMINFO
        '';
      in
      lib.mkIf config.security.sudo.keepTerminfo {
        sudo = { inherit extraConfig; };
      };
  };
}
</file>

<file path="modules/documentation/default.nix">
{ config, lib, pkgs, baseModules, modules, ... }:

with lib;

let
  cfg = config.documentation;

  # To reference the regular configuration from inside the docs evaluation further down.
  # While not strictly necessary, this extra binding avoids accidental name capture in
  # the future.
  regularConfig = config;

  argsModule = {
    config._module.args = lib.mkForce (regularConfig._module.args // {
      modules = [ ];
    });
  };

  /* For the purpose of generating docs, evaluate options with each derivation
    in `pkgs` (recursively) replaced by a fake with path "\${pkgs.attribute.path}".
    It isn't perfect, but it seems to cover a vast majority of use cases.
    Caveat: even if the package is reached by a different means,
    the path above will be shown and not e.g. `${config.services.foo.package}`. */
  manual = import ../../doc/manual {
    inherit pkgs config;
    version = config.system.darwinVersion;
    revision = config.system.darwinRevision;
    inherit (config.system) nixpkgsRevision;
    options =
      let
        scrubbedEval = import ../../eval-config.nix {
          inherit lib;
          modules = [ argsModule ];
          specialArgs = { pkgs = scrubDerivations "pkgs" pkgs; };
        };
        scrubDerivations = namePrefix: pkgSet: mapAttrs
          (name: value:
            let wholeName = "${namePrefix}.${name}"; in
            if isAttrs value then
              scrubDerivations wholeName value
              // (optionalAttrs (isDerivation value) { outPath = "\${${wholeName}}"; })
            else value
          )
          pkgSet;
      in scrubbedEval.options;
  };

  helpScript = pkgs.writeScriptBin "darwin-help"
    ''
      #! ${pkgs.stdenv.shell} -e
      open ${manual.manualHTMLIndex}
    '';
in

{
  options = {
    documentation.enable = mkOption {
      type = types.bool;
      default = true;
      description = ''
        Whether to install documentation of packages from
        {option}`environment.systemPackages` into the generated system path.

        See "Multiple-output packages" chapter in the nixpkgs manual for more info.
      '';
      # which is at ../../../doc/multiple-output.xml
    };

    documentation.man.enable = mkOption {
      type = types.bool;
      default = true;
      description = ''
        Whether to install manual pages and the {command}`man` command.
        This also includes "man" outputs.
      '';
    };

    documentation.info.enable = mkOption {
      type = types.bool;
      default = true;
      description = ''
        Whether to install info pages and the {command}`info` command.
        This also includes "info" outputs.
      '';
    };

    documentation.doc.enable = mkOption {
      type = types.bool;
      default = true;
      description = ''
        Whether to install documentation distributed in packages' `/share/doc`.
        Usually plain text and/or HTML.
        This also includes "doc" outputs.
      '';
    };
  };

  config = mkIf cfg.enable {

    programs.man.enable = cfg.man.enable;
    programs.info.enable = cfg.info.enable;

    environment.systemPackages = mkMerge [
      (mkIf cfg.man.enable [ manual.manpages ])
      (mkIf cfg.doc.enable [ manual.manualHTML helpScript ])
    ];

    system.build.manual = manual;

  };
}
</file>

<file path="modules/environment/default.nix">
{ options, config, lib, pkgs, ... }:

with lib;

let
  cfg = config.environment;

  exportVariables =
    mapAttrsToList (n: v: ''export ${n}="${v}"'') cfg.variables;

  aliasCommands =
    mapAttrsToList (n: v: ''alias ${n}=${escapeShellArg v}'')
      (filterAttrs (k: v: v != null) cfg.shellAliases);
in

{
  imports = [
    (mkRemovedOptionModule [ "environment" "loginShell" ] ''
      This option was only used to change the default command in tmux.

      This has been removed in favour of changing the default command or default shell in tmux directly.
    '')
  ];

  options = {
    environment.profiles = mkOption {
      type = types.listOf types.str;
      description = "A list of profiles used to setup the global environment.";
    };

    environment.darwinConfig = mkOption {
      type = types.nullOr (types.either types.path types.str);
      default =
        if config.nixpkgs.flake.setNixPath then
          # Don‚Äôt set this for flake‚Äêbased systems.
          null
        else if config.system.stateVersion >= 6 then
          "/etc/nix-darwin/configuration.nix"
        else
          "${config.system.primaryUserHome}/.nixpkgs/darwin-configuration.nix";
      defaultText = literalExpression ''
        if config.nixpkgs.flake.setNixPath then
          # Don‚Äôt set this for flake‚Äêbased systems.
          null
        else if config.system.stateVersion >= 6 then
          "/etc/nix-darwin/configuration.nix"
        else
          "''${config.system.primaryUserHome}/.nixpkgs/darwin-configuration.nix"
      '';
      description = ''
        The path of the darwin configuration.nix used to configure the system,
        this updates the default darwin-config entry in NIX_PATH. Since this
        changes an environment variable it will only apply to new shells.

        NOTE: Changing this requires running {command}`darwin-rebuild switch -I darwin-config=/path/to/configuration.nix`
        the first time to make darwin-rebuild aware of the custom location.
      '';
    };

    environment.variables = mkOption {
      type = types.attrsOf (types.either types.str (types.listOf types.str));
      default = {};
      example = { EDITOR = "vim"; LANG = "nl_NL.UTF-8"; };
      description = ''
        A set of environment variables used in the global environment.
        These variables will be set on shell initialisation.
        The value of each variable can be either a string or a list of
        strings.  The latter is concatenated, interspersed with colon
        characters.
      '';
      apply = mapAttrs (n: v: if isList v then concatStringsSep ":" v else v);
    };

    environment.shellAliases = mkOption {
      type = types.attrsOf types.str;
      default = {};
      example = { ll = "ls -l"; };
      description = ''
        An attribute set that maps aliases (the top level attribute names in
        this option) to command strings or directly to build outputs. The
        alises are added to all users' shells.
      '';
    };

    environment.extraInit = mkOption {
      type = types.lines;
      default = "";
      description = ''
        Shell script code called during global environment initialisation
        after all variables and profileVariables have been set.
        This code is asumed to be shell-independent, which means you should
        stick to pure sh without sh word split.
      '';
    };

    environment.shellInit = mkOption {
      default = "";
      description = ''
        Shell script code called during shell initialisation.
        This code is asumed to be shell-independent, which means you should
        stick to pure sh without sh word split.
      '';
      type = types.lines;
    };

    environment.loginShellInit = mkOption {
      default = "";
      description = ''
        Shell script code called during login shell initialisation.
        This code is asumed to be shell-independent, which means you should
        stick to pure sh without sh word split.
      '';
      type = types.lines;
    };

    environment.interactiveShellInit = mkOption {
      default = "";
      description = ''
        Shell script code called during interactive shell initialisation.
        This code is asumed to be shell-independent, which means you should
        stick to pure sh without sh word split.
      '';
      type = types.lines;
    };
  };

  config = {

    # This is horrible, sorry.
    system.requiresPrimaryUser = mkIf (
      config.nix.enable
      && !config.nixpkgs.flake.setNixPath
      && config.system.stateVersion < 6
      && options.environment.darwinConfig.highestPrio == (mkOptionDefault {}).priority
    ) [
      "environment.darwinConfig"
    ];

    environment.systemPath = mkMerge [
      [ (makeBinPath cfg.profiles) ]
      (mkOrder 1200 [ "/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin" ])
    ];

    # Use user, default and system profiles.
    environment.profiles = mkMerge [
      (mkOrder 800 [ "$HOME/.nix-profile" ])
      [ "/run/current-system/sw" "/nix/var/nix/profiles/default" ]
    ];

    environment.extraInit = ''
       export NIX_USER_PROFILE_DIR="/nix/var/nix/profiles/per-user/$USER"
       export NIX_PROFILES="${concatStringsSep " " (reverseList cfg.profiles)}"
    '';

    environment.variables =
      {
        XDG_CONFIG_DIRS = map (path: path + "/etc/xdg") cfg.profiles;
        XDG_DATA_DIRS = map (path: path + "/share") cfg.profiles;
        EDITOR = mkDefault "nano";
        PAGER = mkDefault "less -R";
      };

    system.build.setEnvironment = pkgs.writeText "set-environment" ''
      # Prevent this file from being sourced by child shells.
      export __NIX_DARWIN_SET_ENVIRONMENT_DONE=1

      export PATH=${config.environment.systemPath}
      ${concatStringsSep "\n" exportVariables}

      # Extra initialisation
      ${cfg.extraInit}
    '';

    system.build.setAliases = pkgs.writeText "set-aliases" ''
      ${concatStringsSep "\n" aliasCommands}
    '';
  };
}
</file>

<file path="modules/examples/flake/flake.nix">
{
  description = "Example nix-darwin system flake";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";
    nix-darwin.url = "github:nix-darwin/nix-darwin/master";
    nix-darwin.inputs.nixpkgs.follows = "nixpkgs";
  };

  outputs = inputs@{ self, nix-darwin, nixpkgs }:
  let
    configuration = { pkgs, ... }: {
      # List packages installed in system profile. To search by name, run:
      # $ nix-env -qaP | grep wget
      environment.systemPackages =
        [ pkgs.vim
        ];

      # Necessary for using flakes on this system.
      nix.settings.experimental-features = "nix-command flakes";

      # Enable alternative shell support in nix-darwin.
      # programs.fish.enable = true;

      # Set Git commit hash for darwin-version.
      system.configurationRevision = self.rev or self.dirtyRev or null;

      # Used for backwards compatibility, please read the changelog before changing.
      # $ darwin-rebuild changelog
      system.stateVersion = 6;

      # The platform the configuration will be used on.
      nixpkgs.hostPlatform = "aarch64-darwin";
    };
  in
  {
    # Build darwin flake using:
    # $ darwin-rebuild build --flake .#simple
    darwinConfigurations."simple" = nix-darwin.lib.darwinSystem {
      modules = [ configuration ];
    };
  };
}
</file>

<file path="modules/examples/hydra.nix">
{ config, lib, pkgs, ... }:

let
  environment = lib.concatStringsSep " "
    [ "NIX_REMOTE=daemon"
      "NIX_SSL_CERT_FILE=${pkgs.cacert}/etc/ssl/certs/ca-bundle.crt"
    ];
in

{
  nix.settings.substituters = [ "http://cache1" ];
  nix.settings.trusted-public-keys = [ "cache.daiderd.com-1:R8KOWZ8lDaLojqD+v9dzXAqGn29gEzPTTbr/GIpCTrI=" ];

  nix.settings.trusted-users = [ "@admin" "@hydra" ];

  nix.extraOptions = ''
    pre-build-hook =
  '';

  nix.gc.automatic = true;
  nix.gc.options = "--max-freed $((25 * 1024**3 - 1024 * $(df -P -k /nix/store | tail -n 1 | awk '{ print $4 }')))";

  environment.etc."per-user/hydra/ssh/authorized_keys".text = lib.concatStringsSep "\n"
    [ "command=\"${environment} ${config.nix.package}/bin/nix-store --serve --write\" ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQCVsc0pHGsskoayziMhA2e59bHPWe0bbKgusmqhuJFBGQ1BAk9UmPzKCWE3nCiV6CLD1+SygVkBjb06DYtc+94BnzviCa9qZtL0G4+2vhp6x8OvXh8xlf/eWw3k5MWlvu+kjJFpbW8wHWTiUqzH+uEeHklAosT0lFNjiIYd/Vs3JAezhUR62a6c7ZjWOd5F7ALGEKzOiwC4i37kSgGsIWNCbe0Ku7gyr718zhMGeyxax6saHhnkSpIB+7d6oHhKeiJSFMWctNmz1/qxXUPbxNaJvqgdKlVHhN+B7x/TIbkVr5pTC59Okx9LTcpflFIv79VT+Gf1K7VypZpSvJjG0xFRt8iDs1+ssWFBfvpo94vUbZ+ZwMDcBGR5iJeO41Gj5fYn5aaDl32RXfJ9Fkwael1L6pcXtkIc66jk+KQQpgoeNj8Y3Emntpqva/2AM41wDDvr5tKp5KhEKFLM95CoiWq+g88pZLcpqLK7wooDVqNkVUEbMaj9lBN0AzU9mcsIRGvTa6CmWAdBvwqS2fRZD97Oarqct9AWgb0X6mOUq9BJNi4i4xvjgnVkylLwtLUnibR/PeXMtkb9bv6BEZXNf5ACqxSjKXJyaIHI65I5TILCr5eEgaujgvmkREn6U3T1NZAUIeVe9aVYLqehYh79OHUBzggoHqidRrXBB/6zdg9UgQ=="
      "command=\"${environment} ${config.nix.package}/bin/nix-store --serve --write\" ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQCnubA1pRqlpoAXkZ1q5nwhqi1RY2z840wFLFDj7vAMSups9E2U8PNIVtuVYApZpkBWIpzD4GGbQTF5Itnu5uBpJswc2Yat9yGWO/guuVyXIaRoBIM0Pg1WBWcWsz+k4rNludu9UQ74FHqEiqZIuIuOcgV+RIZn8xQlGt2kUqN9TWboHhZz8Zhx7EtGSJH6MJRLn3mA/pPjOF6k1jiiFG1pVDuqBTZPANkelWYCWAJ46jCyhxXltWE/jkBYGc/XbB8yT7DFE1XC6TVsSEp68R9PhVG3yqxqY06sniEyduSoGt/TDr6ycERd93bvLElXFATes85YiFszeaUgayYSKwQPe0q7YeHMhIXL0UYJYaKVVgT9saFDiHDzde7kKe+NA+J4+TbIk7Y/Ywn0jepsYV13M7TyEqgqbu9fvVGF3JI9+4g0m1gAzHTa7n6iiAedtz+Pi79uCEpRD2hWSSoLWroyPlep8j1p2tygtFsrieePEukesoToCTwqg1Ejnjh+yKdtUbc6xpyRvl3hKeO8QbCpfaaVd27e4vE4lP2JMW6nOo8b0wlVXQIFe5K2zh52q1MSwhLAq6Kg8oPmgj0lru4IivmPc+/NVwd3Qj3E9ZB8LRfTesfbcxHrC8lF5dL/QpLMeLwebrwCxL19gI0kxmDIaUQuHSyP3B2z+EmBKcN/Xw=="
    ];

  users.knownGroups = [ "hydra" ];
  users.knownUsers = [ "hydra" ];
  users.groups.hydra = { gid = 530; description = "Hydra builder group"; members = [ "hydra" ]; };
  users.users.hydra = { uid = 530; gid = 530; description = "Hydra"; home = "/Users/hydra"; shell = "/bin/bash"; };

  system.activationScripts.postActivation.text = ''
    printf "disabling spotlight indexing... "
    mdutil -i off -d / &> /dev/null
    mdutil -E / &> /dev/null
    echo "ok"

    printf "configuring ssh keys for hydra... "
    mkdir -p ~hydra/.ssh
    cp -f /etc/per-user/hydra/ssh/authorized_keys ~hydra/.ssh/authorized_keys
    chown hydra:hydra ~hydra ~hydra/.ssh ~hydra/.ssh/authorized_keys
    echo "ok"
  '';

  system.stateVersion = 6;
}
</file>

<file path="modules/examples/lnl.nix">
{ config, lib, inputs, pkgs, ... }:

{
  system.primaryUser = "lnl";

  system.defaults.NSGlobalDomain.AppleKeyboardUIMode = 3;
  system.defaults.NSGlobalDomain.ApplePressAndHoldEnabled = false;
  system.defaults.NSGlobalDomain.InitialKeyRepeat = 10;
  system.defaults.NSGlobalDomain.KeyRepeat = 1;
  system.defaults.NSGlobalDomain.NSAutomaticCapitalizationEnabled = false;
  system.defaults.NSGlobalDomain.NSAutomaticInlinePredictionEnabled = false;
  system.defaults.NSGlobalDomain.NSAutomaticDashSubstitutionEnabled = false;
  system.defaults.NSGlobalDomain.NSAutomaticPeriodSubstitutionEnabled = false;
  system.defaults.NSGlobalDomain.NSAutomaticQuoteSubstitutionEnabled = false;
  system.defaults.NSGlobalDomain.NSAutomaticSpellingCorrectionEnabled = false;
  system.defaults.NSGlobalDomain.NSNavPanelExpandedStateForSaveMode = true;
  system.defaults.NSGlobalDomain.NSNavPanelExpandedStateForSaveMode2 = true;
  system.defaults.NSGlobalDomain._HIHideMenuBar = true;

  system.defaults.dock.autohide = true;
  system.defaults.dock.mru-spaces = false;
  system.defaults.dock.orientation = "left";
  system.defaults.dock.showhidden = true;

  system.defaults.finder.AppleShowAllExtensions = true;
  system.defaults.finder.QuitMenuItem = true;
  system.defaults.finder.FXEnableExtensionChangeWarning = false;

  system.defaults.trackpad.Clicking = true;
  system.defaults.trackpad.TrackpadThreeFingerDrag = true;

  system.keyboard.enableKeyMapping = true;
  system.keyboard.remapCapsLockToControl = true;

  environment.systemPackages =
    [
      config.programs.vim.package

      pkgs.awscli
      pkgs.brotli
      pkgs.ctags
      pkgs.curl
      pkgs.direnv
      pkgs.entr
      pkgs.fzf
      pkgs.gettext
      pkgs.git
      pkgs.gnupg
      pkgs.htop
      pkgs.jq
      pkgs.ripgrep
      pkgs.shellcheck

      pkgs.qes
    ];

  services.yabai.enable = true;
  services.yabai.package = pkgs.yabai;
  services.skhd.enable = true;

  # security.sandbox.profiles.fetch-nixpkgs-updates.closure = [ pkgs.cacert pkgs.git ];
  # security.sandbox.profiles.fetch-nixpkgs-updates.allowNetworking = true;
  # security.sandbox.profiles.fetch-nixpkgs-updates.writablePaths = [ (toString ~/Code/nixos/nixpkgs) ];

  # launchd.user.agents.fetch-nixpkgs-updates = {
  #   command = "/usr/bin/sandbox-exec -f ${config.security.sandbox.profiles.fetch-nixpkgs-updates.profile} ${pkgs.git}/bin/git -C ${toString ~/Code/nixos/nixpkgs} fetch origin master";
  #   environment.HOME = "";
  #   environment.NIX_SSL_CERT_FILE = "${pkgs.cacert}/etc/ssl/certs/ca-bundle.crt";
  #   serviceConfig.KeepAlive = false;
  #   serviceConfig.ProcessType = "Background";
  #   serviceConfig.StartInterval = 360;
  # };

  # Dotfiles.
  # launchd.user.agents.letty = {
  #   serviceConfig.Program = "${pkgs.lnl.letty}/bin/letty-blink";
  #   serviceConfig.WatchPaths = ["/var/mail/lnl"];
  #   serviceConfig.KeepAlive = false;
  #   serviceConfig.ProcessType = "Background";
  # };

  # services.nix-daemon.enableSocketListener = true;

  nix.extraOptions = ''
    gc-keep-derivations = true
    gc-keep-outputs = true
    min-free = 17179870000
    max-free = 17179870000
    log-lines = 128
  '';

  nix.settings.trusted-public-keys = [ "cache.daiderd.com-1:R8KOWZ8lDaLojqD+v9dzXAqGn29gEzPTTbr/GIpCTrI=" ];
  nix.settings.trusted-substituters = [ "https://d3i7ezr9vxxsfy.cloudfront.net" ];

  nix.settings.sandbox = true;
  nix.settings.extra-sandbox-paths = [ "/private/tmp" "/private/var/tmp" "/usr/bin/env" ];

  programs.nix-index.enable = true;

  # programs.gnupg.agent.enable = true;
  # programs.gnupg.agent.enableSSHSupport = true;

  programs.tmux.enable = true;
  programs.tmux.enableSensible = true;
  programs.tmux.enableMouse = true;
  programs.tmux.enableFzf = true;
  programs.tmux.enableVim = true;

  programs.tmux.extraConfig = ''
    bind 0 set status
    bind S choose-session

    bind-key -r "<" swap-window -t -1
    bind-key -r ">" swap-window -t +1

    bind-key -n M-c run "tmux send-keys -t .+ C-\\\\ && tmux send-keys -t .+ C-a C-k C-l Up && tmux send-keys -t .+ Enter"
    bind-key -n M-r run "tmux send-keys -t .+ C-a C-k C-l Up && tmux send-keys -t .+ Enter"

    set -g pane-active-border-style fg=black
    set -g pane-border-style fg=black
    set -g status-bg black
    set -g status-fg white
    set -g status-right '#[fg=white]#(id -un)@#(hostname)   #(jq --raw-output '.darwinLabel' /run/current-system/darwin-version.json)'
  '';

  environment.etc."nix/user-sandbox.sb".text = ''
    (version 1)
    (allow default)
    (deny file-write*
          (subpath "/nix"))
    (allow file-write*
           (subpath "/nix/var/nix/gcroots/per-user")
           (subpath "/nix/var/nix/profiles/per-user"))

    (allow process-exec
          (literal "/bin/ps")
          (with no-sandbox))
  '';

  # programs.vim.enable = true;
  # programs.vim.enableSensible = true;
  programs.vim.package = pkgs.neovim.override {
    configure = {
      packages.darwin.start = with pkgs.vimPlugins; [
        vim-sensible
        vim-surround
        ReplaceWithRegister
        polyglot
        fzfWrapper
        ale
        deoplete-nvim
      ];

      customRC = ''
        set completeopt=menuone
        set encoding=utf-8
        set hlsearch
        set list
        set number
        set showcmd
        set splitright

        cnoremap %% <C-r>=expand('%:h') . '/'<CR>
        nnoremap // :nohlsearch<CR>

        let mapleader = ' '

        " fzf
        nnoremap <Leader>p :FZF<CR>

        " vim-surround
        vmap s S

        " ale
        nnoremap <Leader>d :ALEGoToDefinition<CR>
        nnoremap <Leader>D :ALEGoToDefinitionInVSplit<CR>
        nnoremap <Leader>k :ALESignature<CR>
        nnoremap <Leader>K :ALEHover<CR>
        nnoremap [a :ALEPreviousWrap<CR>
        nnoremap ]a :ALENextWrap<CR>

        " deoplete
        inoremap <expr><C-g> deoplete#undo_completion()
        inoremap <expr><C-l> deoplete#refresh()
        inoremap <silent><expr><C-Tab> deoplete#mappings#manual_complete()
        inoremap <silent><expr><Tab> pumvisible() ? "\<C-n>" : "\<TAB>"

        let g:deoplete#enable_at_startup = 1
      '';
    };
  };

  # Dotfiles.
  # programs.vim.package = mkForce pkgs.lnl.vim;

  programs.bash.completion.enable = true;

  programs.zsh.enable = true;
  programs.zsh.enableBashCompletion = true;
  programs.zsh.enableFzfCompletion = true;
  programs.zsh.enableFzfGit = true;
  programs.zsh.enableFzfHistory = true;

  programs.zsh.variables.cfg = "/etc/nix-darwin/configuration.nix";
  programs.zsh.variables.darwin = "$HOME/.nix-defexpr/darwin";
  programs.zsh.variables.nixpkgs = "$HOME/.nix-defexpr/nixpkgs";


  programs.zsh.promptInit = ''
    autoload -U promptinit && promptinit

    setopt PROMPTSUBST

    _prompt_nix() {
      [ -z "$IN_NIX_SHELL" ] || echo "%F{yellow}%B[''${name:+$name}]%b%f "
    }

    PS1='%F{red}%B%(?..%? )%b%f%# '
    RPS1='$(_prompt_nix)%F{green}%~%f'

    if [ -n "$IN_NIX_SANDBOX" ]; then
      PS1+='%F{red}[sandbox]%f '
    fi
  '';

  programs.zsh.loginShellInit = ''
    reexec() {
        unset __NIX_DARWIN_SET_ENVIRONMENT_DONE
        unset __ETC_ZPROFILE_SOURCED __ETC_ZSHENV_SOURCED __ETC_ZSHRC_SOURCED
        exec $SHELL -c 'echo >&2 "reexecuting shell: $SHELL" && exec $SHELL -l'
    }

    reexec-tmux() {
        unset __NIX_DARWIN_SET_ENVIRONMENT_DONE
        unset __ETC_ZPROFILE_SOURCED __ETC_ZSHENV_SOURCED __ETC_ZSHRC_SOURCED
        exec tmux new-session -A -s _ "$@"
    }

    reexec-sandbox() {
        unset __NIX_DARWIN_SET_ENVIRONMENT_DONE
        unset __ETC_ZPROFILE_SOURCED __ETC_ZSHENV_SOURCED __ETC_ZSHRC_SOURCED
        export IN_NIX_SANDBOX=1
        exec /usr/bin/sandbox-exec -f /etc/nix/user-sandbox.sb $SHELL -l
    }

    ls() {
        ${pkgs.coreutils}/bin/ls --color=auto "$@"
    }

    install_name_tool() {
        ${pkgs.darwin.cctools}/bin/install_name_tool "$@"
    }

    nm() {
        ${pkgs.darwin.cctools}/bin/nm "$@"
    }

    otool() {
        ${pkgs.darwin.cctools}/bin/otool "$@"
    }
  '';

  programs.zsh.interactiveShellInit = ''
    setopt AUTOCD AUTOPUSHD

    autoload -U down-line-or-beginning-search
    autoload -U up-line-or-beginning-search
    bindkey '^[[A' down-line-or-beginning-search
    bindkey '^[[A' up-line-or-beginning-search
    zle -N down-line-or-beginning-search
    zle -N up-line-or-beginning-search
  '';

  environment.variables.SHELL = "${pkgs.zsh}/bin/zsh";

  environment.variables.LANG = "en_US.UTF-8";

  environment.shellAliases.g = "git log --pretty=color -32";
  environment.shellAliases.gb = "git branch";
  environment.shellAliases.gc = "git checkout";
  environment.shellAliases.gcb = "git checkout -B";
  environment.shellAliases.gd = "git diff --minimal --patch";
  environment.shellAliases.gf = "git fetch";
  environment.shellAliases.ga = "git log --pretty=color --all";
  environment.shellAliases.gg = "git log --pretty=color --graph";
  environment.shellAliases.gl = "git log --pretty=nocolor";
  environment.shellAliases.grh = "git reset --hard";
  environment.shellAliases.l = "ls -lh";

  environment.extraInit = ''
    # Load and export variables from environment.d.
    if [ -d /etc/environment.d ]; then
        set -a
        . /etc/environment.d/*
        set +a
    fi
  '';

  nixpkgs.config.allowUnfree = true;

  nixpkgs.overlays = [
    (self: super: {
      vim_configurable = super.vim_configurable.override {
        guiSupport = "no";
      };
    })
  ];

  # Dotfiles.
  # nixpkgs.overlays = mkAfter inputs.dotfiles.darwinOverlays;

  # Dotfiles.
  # services.yabai.enable = true;
  # services.yabai.package = pkgs.yabai;
  # services.skhd.skhdConfig = builtins.readFile "${inputs.dotfiles}/skhd/skhdrc";
  # services.yabai.extraConfig = builtins.readFile "${inputs.dotfiles}/yabai/yabairc";

  # Dotfiles.
  # $ cat ~/.gitconfig
  # [include]
  #     path = /etc/per-user/lnl/gitconfig
  # environment.etc."per-user/lnl/gitconfig".text = builtins.readFile "${inputs.dotfiles}/git/gitconfig";

  nix.nrBuildUsers = 32;

  system.stateVersion = 6;
}
</file>

<file path="modules/examples/simple.nix">
{ config, pkgs, ... }:

{
  # List packages installed in system profile. To search by name, run:
  # $ nix-env -qaP | grep wget
  environment.systemPackages =
    [ pkgs.vim
    ];

  # Enable alternative shell support in nix-darwin.
  # programs.fish.enable = true;

  # Used for backwards compatibility, please read the changelog before changing.
  # $ darwin-rebuild changelog
  system.stateVersion = 6;
}
</file>

<file path="modules/fonts/default.nix">
{ config, lib, pkgs, ... }:

let
  cfg = config.fonts;
in

{
  imports = [
    (lib.mkRemovedOptionModule [ "fonts" "enableFontDir" ] "No nix-darwin equivalent to this NixOS option. This is not required to install fonts.")
    (lib.mkRemovedOptionModule [ "fonts" "fontDir" "enable" ] "No nix-darwin equivalent to this NixOS option. This is not required to install fonts.")
    (lib.mkRemovedOptionModule [ "fonts" "fonts" ] ''
      This option has been renamed to `fonts.packages' for consistency with NixOS.

      Note that the implementation now keeps fonts in `/Library/Fonts/Nix Fonts' to allow them to coexist with fonts not managed by nix-darwin; existing fonts will be left directly in `/Library/Fonts' without getting updates and should be manually removed.'')
  ];

  options = {
    fonts.packages = lib.mkOption {
      type = lib.types.listOf lib.types.path;
      default = [ ];
      example = lib.literalExpression "[ pkgs.dejavu_fonts ]";
      description = ''
        List of fonts to install into {file}`/Library/Fonts/Nix Fonts`.
      '';
    };
  };

  config = {

    system.build.fonts = pkgs.runCommand "fonts"
      { preferLocalBuild = true; }
      ''
        mkdir -p $out/Library/Fonts
        store_dir=${lib.escapeShellArg builtins.storeDir}
        while IFS= read -rd "" f; do
          dest="$out/Library/Fonts/Nix Fonts/''${f#"$store_dir/"}"
          mkdir -p "''${dest%/*}"
          ln -sf "$f" "$dest"
        done < <(
          find -L ${lib.escapeShellArgs cfg.packages} \
            -type f \
            -regex '.*\.\(ttf\|ttc\|otf\|dfont\)' \
            -print0
        )
      '';

    system.activationScripts.fonts.text = ''
      printf >&2 'setting up /Library/Fonts/Nix Fonts...\n'

      # rsync uses the mtime + size of files to determine whether they
      # need to be copied by default. This is inadequate for Nix store
      # paths, but we don't want to use `--checksum` as it makes
      # activation consistently slow when you have large fonts
      # installed. Instead, we ensure that fonts are linked according to
      # their full store paths in `system.build.fonts`, so that any
      # given font path should only ever have one possible content.
      ${pkgs.rsync}/bin/rsync \
        --archive \
        --copy-links \
        --delete-during \
        --delete-missing-args \
        "$systemConfig/Library/Fonts/Nix Fonts" \
        '/Library/Fonts/'
    '';

  };
}
</file>

<file path="modules/launchd/default.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  inherit (pkgs) stdenv;

  cfg = config.launchd;

  toEnvironmentText = name: value: {
    name = "${value.serviceConfig.Label}.plist";
    value.text = generators.toPlist { escape = true; } value.serviceConfig;
  };

  launchdConfig = import ./launchd.nix;

  makeDrvBinPath = ps: concatMapStringsSep ":" (p: if isDerivation p then "${p}/bin" else p) ps;

  serviceOptions =
    { config, name, ... }:
    let

      env = config.environment // optionalAttrs (config.path != "") { PATH = config.path; };

    in

    { options = {
        environment = mkOption {
          type = types.attrsOf (types.either types.str (types.listOf types.str));
          default = {};
          example = { PATH = "/foo/bar/bin"; LANG = "nl_NL.UTF-8"; };
          description = "Environment variables passed to the service's processes.";
          apply = mapAttrs (n: v: if isList v then concatStringsSep ":" v else v);
        };

        path = mkOption {
          type = types.listOf (types.either types.path types.str);
          default = [];
          description = ''
            Packages added to the service's {env}`PATH`
            environment variable.  Only the {file}`bin`
            and subdirectories of each package is added.
          '';
          apply = ps: if isList ps then (makeDrvBinPath ps) else ps;
        };

        command = mkOption {
          type = types.either types.str types.path;
          default = "";
          description = "Command executed as the service's main process.";
        };

        script = mkOption {
          type = types.lines;
          default = "";
          description = "Shell commands executed as the service's main process.";
        };

        # preStart = mkOption {
        #   type = types.lines;
        #   default = "";
        #   description = ''
        #     Shell commands executed before the service's main process
        #     is started.
        #   '';
        # };

        serviceConfig = mkOption {
          type = types.submodule launchdConfig;
          example =
            { Program = "/run/current-system/sw/bin/nix-daemon";
              KeepAlive = true;
            };
          default = {};
          description = ''
            Each attribute in this set specifies an option for a key in the plist.
            <https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man5/launchd.plist.5.html>
          '';
        };
      };

      config = {
        command = mkIf (config.script != "") (pkgs.writeScript "${name}-start" ''
          #! ${stdenv.shell}

          ${config.script}
        '');

        serviceConfig.Label = mkDefault "${cfg.labelPrefix}.${name}";
        serviceConfig.ProgramArguments = mkIf (config.command != "") [
          "/bin/sh"
          "-c"
          "/bin/wait4path /nix/store && exec ${config.command}"
        ];
        serviceConfig.EnvironmentVariables = mkIf (env != {}) env;
      };
    };
in

{
  options = {
    launchd.labelPrefix = mkOption {
      type = types.str;
      default = "org.nixos";
      description = ''
        The default prefix of the service label. Individual services can
        override this by setting the Label attribute.
      '';
    };

    launchd.envVariables = mkOption {
      type = types.attrsOf (types.either types.str (types.listOf types.str));
      default = {};
      example = { LANG = "nl_NL.UTF-8"; };
      description = ''
        A set of environment variables to be set on all future
        processes launched by launchd in the caller's context.
        The value of each variable can be either a string or a list of
        strings.  The latter is concatenated, interspersed with colon
        characters.
      '';
      apply = mapAttrs (n: v: if isList v then concatStringsSep ":" v else v);
    };

    launchd.user.envVariables = mkOption {
      type = types.attrsOf (types.either types.str (types.listOf types.str));
      default = {};
      example = { LANG = "nl_NL.UTF-8"; };
      description = ''
        A set of environment variables to be set on all future
        processes launched by launchd in the caller's context.
        The value of each variable can be either a string or a list of
        strings.  The latter is concatenated, interspersed with colon
        characters.
      '';
      apply = mapAttrs (n: v: if isList v then concatStringsSep ":" v else v);
    };

    launchd.agents = mkOption {
      default = {};
      type = types.attrsOf (types.submodule serviceOptions);
      description = ''
        Definition of per-user launchd agents.

        When a user logs in, a per-user launchd is started.
        It does the following:
        1. It loads the parameters for each launch-on-demand user agent from the property list files found in /System/Library/LaunchAgents, /Library/LaunchAgents, and the user‚Äôs individual Library/LaunchAgents directory.
        2. It registers the sockets and file descriptors requested by those user agents.
        3. It launches any user agents that requested to be running all the time.
        4. As requests for a particular service arrive, it launches the corresponding user agent and passes the request to it.
        5. When the user logs out, it sends a SIGTERM signal to all of the user agents that it started.
      '';
    };

    launchd.daemons = mkOption {
      default = {};
      type = types.attrsOf (types.submodule serviceOptions);
      description = ''
        Definition of launchd daemons.

        After the system is booted and the kernel is running, launchd is run to finish the system initialization.
        As part of that initialization, it goes through the following steps:
        1. It loads the parameters for each launch-on-demand system-level daemon from the property list files found in /System/Library/LaunchDaemons/ and /Library/LaunchDaemons/.
        2. It registers the sockets and file descriptors requested by those daemons.
        3. It launches any daemons that requested to be running all the time.
        4. As requests for a particular service arrive, it launches the corresponding daemon and passes the request to it.
        5. When the system shuts down, it sends a SIGTERM signal to all of the daemons that it started.
      '';
    };

    launchd.user.agents = mkOption {
      default = {};
      type = types.attrsOf (types.submodule [
        serviceOptions
        ({ name, ... }: {
          options.managedBy = lib.mkOption {
            type = lib.types.str;
            internal = true;
            default = lib.showOption [ "launchd" "user" "agents" name ];
          };
        })
      ]);
      description = ''
        Definition of per-user launchd agents.

        When a user logs in, a per-user launchd is started.
        It does the following:
        1. It loads the parameters for each launch-on-demand user agent from the property list files found in /System/Library/LaunchAgents, /Library/LaunchAgents, and the user‚Äôs individual Library/LaunchAgents directory.
        2. It registers the sockets and file descriptors requested by those user agents.
        3. It launches any user agents that requested to be running all the time.
        4. As requests for a particular service arrive, it launches the corresponding user agent and passes the request to it.
        5. When the user logs out, it sends a SIGTERM signal to all of the user agents that it started.
      '';
    };
  };

  config = {

    system.requiresPrimaryUser =
      lib.map (
        name:
        lib.showOption [
          "launchd"
          "user"
          "envVariables"
          name
        ]
      ) (attrNames cfg.user.envVariables)
      ++ lib.map ({ managedBy, ... }: managedBy) (attrValues cfg.user.agents);

    environment.launchAgents = mapAttrs' toEnvironmentText cfg.agents;
    environment.launchDaemons = mapAttrs' toEnvironmentText cfg.daemons;

    environment.userLaunchAgents = mapAttrs' toEnvironmentText cfg.user.agents;

  };
}
</file>

<file path="modules/launchd/launchd.nix">
{ config, lib, ... }:

with lib;

let
  launchdTypes = import ./types.nix { inherit config lib; };
in

{
  options = {
    Label = mkOption {
      type = types.str;
      description = "This required key uniquely identifies the job to launchd.";
    };

    Disabled = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        This optional key is used as a hint to `launchctl(1)` that it should not submit this job to launchd when
        loading a job or jobs. The value of this key does NOT reflect the current state of the job on the running
        system. If you wish to know whether a job is loaded in launchd, reading this key from a configuration
        file yourself is not a sufficient test. You should query launchd for the presence of the job using
        the `launchctl(1)` list subcommand or use the ServiceManagement framework's
        `SMJobCopyDictionary()` method.

        Note that as of Mac OS X v10.6, this key's value in a configuration file conveys a default value, which
        is changed with the [-w] option of the `launchctl(1)` load and unload subcommands. These subcommands no
        longer modify the configuration file, so the value displayed in the configuration file is not necessarily
        the value that `launchctl(1)` will apply. See `launchctl(1)` for more information.

        Please also be mindful that you should only use this key if the provided on-demand and KeepAlive criteria
        are insufficient to describe the conditions under which your job needs to run. The cost to have a
        job loaded in launchd is negligible, so there is no harm in loading a job which only runs once or very
        rarely.
      '';
    };

    UserName = mkOption {
      type = types.nullOr types.str;
      default = null;
      description = ''
        This optional key specifies the user to run the job as. This key is only applicable when launchd is
        running as root.
      '';
    };

    GroupName = mkOption {
      type = types.nullOr types.str;
      default = null;
      description = ''
        This optional key specifies the group to run the job as. This key is only applicable when launchd is
        running as root. If UserName is set and GroupName is not, the the group will be set to the default
        group of the user.
      '';
    };

    inetdCompatibility = mkOption {
      default = null;
      example = { Wait = true; };
      description = ''
        The presence of this key specifies that the daemon expects to be run as if it were launched from inetd.
      '';
      type = types.nullOr (types.submodule {
        options = {
          Wait = mkOption {
            type = types.nullOr (types.either types.bool types.str);
            default = null;
            description = ''
              This flag corresponds to the "wait" or "nowait" option of inetd. If true, then the listening
              socket is passed via the standard in/out/error file descriptors. If false, then `accept(2)` is
              called on behalf of the job, and the result is passed via the standard in/out/error descriptors.
            '';
          };
        };
      });
    };

    LimitLoadToHosts = mkOption {
      type = types.nullOr (types.listOf types.str);
      default = null;
      description = ''
        This configuration file only applies to the hosts listed with this key. Note: One should set kern.hostname
        in `sysctl.conf(5)` for this feature to work reliably.
      '';
    };

    LimitLoadFromHosts = mkOption {
      type = types.nullOr (types.listOf types.str);
      default = null;
      description = ''
        This configuration file only applies to hosts NOT listed with this key. Note: One should set kern.hostname
        in `sysctl.conf(5)` for this feature to work reliably.
      '';
    };

    LimitLoadToSessionType = mkOption {
      type = types.nullOr (types.oneOf [types.str (types.listOf types.str)]);
      default = null;
      description = ''
        This configuration file only applies to sessions of the type specified. This key is used in concert
        with the -S flag to {command}`launchctl`.
      '';
    };

    Program = mkOption {
      type = types.nullOr types.path;
      default = null;
      description = ''
        This key maps to the first argument of `execvp(3)`.  If this key is missing, then the first element of
        the array of strings provided to the ProgramArguments will be used instead.  This key is required in
        the absence of the ProgramArguments key.
      '';
    };

    ProgramArguments = mkOption {
      type = types.nullOr (types.listOf types.str);
      default = null;
      description = ''
        This key maps to the second argument of `execvp(3)`.  This key is required in the absence of the Program
        key. Please note: many people are confused by this key. Please read `execvp(3)` very carefully!
      '';
      # TODO: Remove this some time after 25.11.
      apply =
        val:
        if (builtins.isNull val) then
          val
        else
          (map (
            item:
            lib.warnIf (lib.hasInfix "&amp;" item)
              "A value for `ProgramArguments` contains the literal string `&amp;`. This is no longer necessary and will lead to double-escaping, as nix-darwin now automatically escapes special characters."
            item
          ) val);
    };

    EnableGlobbing = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        This flag causes launchd to use the `glob(3)` mechanism to update the program arguments before invocation.
      '';
    };

    EnableTransactions = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        This flag instructs launchd that the job promises to use `vproc_transaction_begin(3)` and
        `vproc_transaction_end(3)` to track outstanding transactions that need to be reconciled before the
        process can safely terminate. If no outstanding transactions are in progress, then launchd is free to
        send the SIGKILL signal.
      '';
    };

    OnDemand = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        This key was used in Mac OS X 10.4 to control whether a job was kept alive or not. The default was
        true.  This key has been deprecated and replaced in Mac OS X 10.5 and later with the more powerful
        KeepAlive option.
      '';
    };

    KeepAlive = mkOption {
      type = types.nullOr (types.either types.bool (types.submodule {
        options = {

          SuccessfulExit = mkOption {
            type = types.nullOr types.bool;
            default = null;
            description = ''
              If true, the job will be restarted as long as the program exits and with an exit status of zero.
              If false, the job will be restarted in the inverse condition.  This key implies that "RunAtLoad"
              is set to true, since the job needs to run at least once before we can get an exit status.
            '';
          };

          NetworkState = mkOption {
            type = types.nullOr types.bool;
            default = null;
            description = ''
              If true, the job will be kept alive as long as the network is up, where up is defined as at least
              one non-loopback interface being up and having IPv4 or IPv6 addresses assigned to them.  If
              false, the job will be kept alive in the inverse condition.
            '';
          };

          PathState = mkOption {
            type = types.nullOr (types.attrsOf types.bool);
            default = null;
            description = ''
              Each key in this dictionary is a file-system path. If the value of the key is true, then the job
              will be kept alive as long as the path exists.  If false, the job will be kept alive in the
              inverse condition. The intent of this feature is that two or more jobs may create semaphores in
              the file-system namespace.
            '';
          };

          OtherJobEnabled = mkOption {
            type = types.nullOr (types.attrsOf types.bool);
            default = null;
            description = ''
              Each key in this dictionary is the label of another job. If the value of the key is true, then
              this job is kept alive as long as that other job is enabled. Otherwise, if the value is false,
              then this job is kept alive as long as the other job is disabled.  This feature should not be
              considered a substitute for the use of IPC.
            '';
          };

          Crashed = mkOption {
            type = types.nullOr types.bool;
            default = null;
            description = ''
              If true, the the job will be restarted as long as it exited due to a signal which is typically
              associated with a crash (SIGILL, SIGSEGV, etc.). If false, the job will be restarted in the
              inverse condition.
            '';
          };

          AfterInitialDemand = mkOption {
            type = types.nullOr types.bool;
            default = null;
          };

        };
      }));
      default = null;
      description = ''
        This optional key is used to control whether your job is to be kept continuously running or to let
        demand and conditions control the invocation. The default is false and therefore only demand will start
        the job. The value may be set to true to unconditionally keep the job alive. Alternatively, a dictionary
        of conditions may be specified to selectively control whether launchd keeps a job alive or not. If
        multiple keys are provided, launchd ORs them, thus providing maximum flexibility to the job to refine
        the logic and stall if necessary. If launchd finds no reason to restart the job, it falls back on
        demand based invocation.  Jobs that exit quickly and frequently when configured to be kept alive will
        be throttled to converve system resources.
      '';
    };

    RunAtLoad = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        This optional key is used to control whether your job is launched once at the time the job is loaded.
        The default is false.
      '';
    };

    RootDirectory = mkOption {
      type = types.nullOr types.str;
      default = null;
      description = ''
        This optional key is used to specify a directory to `chroot(2)` to before running the job.
      '';
    };

    WorkingDirectory = mkOption {
      type = types.nullOr types.str;
      default = null;
      description = ''
        This optional key is used to specify a directory to `chdir(2)` to before running the job.
      '';
    };

    EnvironmentVariables = mkOption {
      type = types.nullOr (types.attrsOf types.str);
      default = null;
      description = ''
        This optional key is used to specify additional environment variables to be set before running the
        job.
      '';
    };

    Umask = mkOption {
      type = types.nullOr types.int;
      default = null;
      description = ''
        This optional key specifies what value should be passed to `umask(2)` before running the job. Known bug:
        Property lists don't support octal, so please convert the value to decimal.
      '';
    };

    TimeOut = mkOption {
      type = types.nullOr types.int;
      default = null;
      description = ''
        The recommended idle time out (in seconds) to pass to the job. If no value is specified, a default time
        out will be supplied by launchd for use by the job at check in time.
      '';
    };

    ExitTimeOut = mkOption {
      type = types.nullOr types.int;
      default = null;
      description = ''
        The amount of time launchd waits before sending a SIGKILL signal. The default value is 20 seconds. The
        value zero is interpreted as infinity.
      '';
    };

    ThrottleInterval = mkOption {
      type = types.nullOr types.int;
      default = null;
      description = ''
        This key lets one override the default throttling policy imposed on jobs by launchd.  The value is in
        seconds, and by default, jobs will not be spawned more than once every 10 seconds.  The principle
        behind this is that jobs should linger around just in case they are needed again in the near future.
        This not only reduces the latency of responses, but it encourages developers to amortize the cost of
        program invocation.
      '';
    };

    InitGroups = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        This optional key specifies whether `initgroups(3)` should be called before running the job.  The default
        is true in 10.5 and false in 10.4. This key will be ignored if the UserName key is not set.
      '';
    };

    WatchPaths = mkOption {
      type = types.nullOr (types.listOf types.path);
      default = null;
      description = ''
        This optional key causes the job to be started if any one of the listed paths are modified.
      '';
    };

    QueueDirectories = mkOption {
      type = types.nullOr (types.listOf types.str);
      default = null;
      description = ''
        Much like the WatchPaths option, this key will watch the paths for modifications. The difference being
        that the job will only be started if the path is a directory and the directory is not empty.
      '';
    };

    StartOnMount = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        This optional key causes the job to be started every time a filesystem is mounted.
      '';
    };

    StartInterval = mkOption {
      type = types.nullOr types.int;
      default = null;
      description = ''
        This optional key causes the job to be started every N seconds.  If the system is asleep, the job will
        be started the next time the computer wakes up.  If multiple intervals transpire before the computer is
        woken, those events will be coalesced into one event upon wake from sleep.
      '';
    };

    StartCalendarInterval = mkOption {
      default = null;
      example = [{ Hour = 2; Minute = 30; }];
      description = ''
        This optional key causes the job to be started every calendar interval as specified. The semantics are
        much like {manpage}`crontab(5)`: Missing attributes are considered to be wildcard. Unlike cron which skips
        job invocations when the computer is asleep, launchd will start the job the next time the computer wakes
        up.  If multiple intervals transpire before the computer is woken, those events will be coalesced into
        one event upon waking from sleep.

        ::: {.important}
        The list must not be empty and must not contain duplicate entries (attrsets which compare equally).
        :::

        ::: {.caution}
        Since missing attrs become wildcards, an empty attrset effectively means "every minute".
        :::
      '';
      type = types.nullOr launchdTypes.StartCalendarInterval;
    };

    StandardInPath = mkOption {
      type = types.nullOr types.path;
      default = null;
      description = ''
        This optional key specifies what file should be used for data being supplied to stdin when using
        `stdio(3)`.
      '';
    };

    StandardOutPath = mkOption {
      type = types.nullOr types.path;
      default = null;
      description = ''
        This optional key specifies what file should be used for data being sent to stdout when using `stdio(3)`.
      '';
    };

    StandardErrorPath = mkOption {
      type = types.nullOr types.path;
      default = null;
      description = ''
        This optional key specifies what file should be used for data being sent to stderr when using `stdio(3)`.
      '';
    };

    Debug = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        This optional key specifies that launchd should adjust its log mask temporarily to LOG_DEBUG while
        dealing with this job.
      '';
    };

    WaitForDebugger = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        This optional key specifies that launchd should instruct the kernel to have the job wait for a debugger
        to attach before any code in the job is executed.
      '';
    };

    SoftResourceLimits = mkOption {
      default = null;
      description = ''
        Resource limits to be imposed on the job. These adjust variables set with `setrlimit(2)`.  The following
        keys apply:
      '';
      type = types.nullOr (types.submodule {
        options = {
          Core = mkOption {
            type = types.nullOr types.int;
            default = null;
            description = ''
              The largest size (in bytes) core file that may be created.
            '';
          };

          CPU = mkOption {
            type = types.nullOr types.int;
            default = null;
            description = ''
              The maximum amount of cpu time (in seconds) to be used by each process.
            '';
          };

          Data = mkOption {
            type = types.nullOr types.int;
            default = null;
            description = ''
              The maximum size (in bytes) of the data segment for a process; this defines how far a program may
              extend its break with the `sbrk(2)` system call.
            '';
          };

          FileSize = mkOption {
            type = types.nullOr types.int;
            default = null;
            description = ''
              The largest size (in bytes) file that may be created.
            '';
          };

          MemoryLock = mkOption {
            type = types.nullOr types.int;
            default = null;
            description = ''
              The maximum size (in bytes) which a process may lock into memory using the mlock(2) function.
            '';
          };

          NumberOfFiles = mkOption {
            type = types.nullOr types.int;
            default = null;
            description = ''
              The maximum number of open files for this process.  Setting this value in a system wide daemon
              will set the `sysctl(3)` kern.maxfiles (SoftResourceLimits) or kern.maxfilesperproc (HardResourceLimits)
              value in addition to the `setrlimit(2)` values.
            '';
          };

          NumberOfProcesses = mkOption {
            type = types.nullOr types.int;
            default = null;
            description = ''
              The maximum number of simultaneous processes for this user id.  Setting this value in a system
              wide daemon will set the `sysctl(3)` kern.maxproc (SoftResourceLimits) or kern.maxprocperuid
              (HardResourceLimits) value in addition to the `setrlimit(2)` values.
            '';
          };

          ResidentSetSize = mkOption {
            type = types.nullOr types.int;
            default = null;
            description = ''
              The maximum size (in bytes) to which a process's resident set size may grow.  This imposes a
              limit on the amount of physical memory to be given to a process; if memory is tight, the system
              will prefer to take memory from processes that are exceeding their declared resident set size.
            '';
          };

          Stack = mkOption {
            type = types.nullOr types.int;
            default = null;
            description = ''
              The maximum size (in bytes) of the stack segment for a process; this defines how far a program's
              stack segment may be extended.  Stack extension is performed automatically by the system.
            '';
          };
        };
      });
    };

    HardResourceLimits = mkOption {
      default = null;
      example = { NumberOfFiles = 4096; };
      description = ''
        Resource limits to be imposed on the job. These adjust variables set with `setrlimit(2)`.  The following
        keys apply:
      '';
      type = types.nullOr (types.submodule {
        options = {
          Core = mkOption {
            type = types.nullOr types.int;
            default = null;
            description = ''
              The largest size (in bytes) core file that may be created.
            '';
          };

          CPU = mkOption {
            type = types.nullOr types.int;
            default = null;
            description = ''
              The maximum amount of cpu time (in seconds) to be used by each process.
            '';
          };

          Data = mkOption {
            type = types.nullOr types.int;
            default = null;
            description = ''
              The maximum size (in bytes) of the data segment for a process; this defines how far a program may
              extend its break with the `sbrk(2)` system call.
            '';
          };

          FileSize = mkOption {
            type = types.nullOr types.int;
            default = null;
            description = ''
              The largest size (in bytes) file that may be created.
            '';
          };

          MemoryLock = mkOption {
            type = types.nullOr types.int;
            default = null;
            description = ''
              The maximum size (in bytes) which a process may lock into memory using the `mlock(2)` function.
            '';
          };

          NumberOfFiles = mkOption {
            type = types.nullOr types.int;
            default = null;
            description = ''
              The maximum number of open files for this process.  Setting this value in a system wide daemon
              will set the `sysctl(3)` kern.maxfiles (SoftResourceLimits) or kern.maxfilesperproc (HardResourceLimits)
              value in addition to the `setrlimit(2)` values.
            '';
          };

          NumberOfProcesses = mkOption {
            type = types.nullOr types.int;
            default = null;
            description = ''
              The maximum number of simultaneous processes for this user id.  Setting this value in a system
              wide daemon will set the `sysctl(3)` kern.maxproc (SoftResourceLimits) or kern.maxprocperuid
              (HardResourceLimits) value in addition to the `setrlimit(2)` values.
            '';
          };

          ResidentSetSize = mkOption {
            type = types.nullOr types.int;
            default = null;
            description = ''
              The maximum size (in bytes) to which a process's resident set size may grow.  This imposes a
              limit on the amount of physical memory to be given to a process; if memory is tight, the system
              will prefer to take memory from processes that are exceeding their declared resident set size.
            '';
          };

          Stack = mkOption {
            type = types.nullOr types.int;
            default = null;
            description = ''
              The maximum size (in bytes) of the stack segment for a process; this defines how far a program's
              stack segment may be extended.  Stack extension is performed automatically by the system.
            '';
          };
        };
      });
    };

    Nice = mkOption {
      type = types.nullOr types.int;
      default = null;
      description = ''
        This optional key specifies what nice(3) value should be applied to the daemon.
      '';
    };

    ProcessType = mkOption {
      type = types.nullOr (types.enum [ "Background" "Standard" "Adaptive" "Interactive" ]);
      default = null;
      example = "Background";
      description = ''
        This optional key describes, at a high level, the intended purpose of the job.  The system will apply
        resource limits based on what kind of job it is. If left unspecified, the system will apply light
        resource limits to the job, throttling its CPU usage and I/O bandwidth. The following are valid values:

        Background
        : Background jobs are generally processes that do work that was not directly requested by the user.
          The resource limits applied to Background jobs are intended to prevent them from disrupting the
          user experience.

        Standard
        : Standard jobs are equivalent to no ProcessType being set.

        Adaptive
        : Adaptive jobs move between the Background and Interactive classifications based on activity over
          XPC connections. See `xpc_transaction_begin(3)` for details.

        Interactive
        : Interactive jobs run with the same resource limitations as apps, that is to say, none. Interactive
          jobs are critical to maintaining a responsive user experience, and this key should only be
          used if an app's ability to be responsive depends on it, and cannot be made Adaptive.
      '';
    };

    AbandonProcessGroup = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        When a job dies, launchd kills any remaining processes with the same process group ID as the job. Setting
        this key to true disables that behavior.
      '';
    };

    LowPriorityIO = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        This optional key specifies whether the kernel should consider this daemon to be low priority when
        doing file system I/O.
      '';
    };

    LowPriorityBackgroundIO = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        This optional key specifies whether the kernel should consider this daemon to be low priority when
        doing file system I/O when the process is throttled with the Darwin-background classification.
      '';
    };

    LaunchOnlyOnce = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        This optional key specifies whether the job can only be run once and only once.  In other words, if the
        job cannot be safely respawned without a full machine reboot, then set this key to be true.
      '';
    };

    MachServices = mkOption {
      default = null;
      example = { "org.nixos.service" = { ResetAtClose = true; }; };
      description = ''
        This optional key is used to specify Mach services to be registered with the Mach bootstrap sub-system.
        Each key in this dictionary should be the name of service to be advertised. The value of the key must
        be a boolean and set to true.  Alternatively, a dictionary can be used instead of a simple true value.

        Finally, for the job itself, the values will be replaced with Mach ports at the time of check-in with
        launchd.
      '';
      type = types.nullOr (types.attrsOf (types.either types.bool (types.submodule {
        options = {
          ResetAtClose = mkOption {
            type = types.nullOr types.bool;
            default = null;
            description = ''
              If this boolean is false, the port is recycled, thus leaving clients to remain oblivious to the
              demand nature of job. If the value is set to true, clients receive port death notifications when
              the job lets go of the receive right. The port will be recreated atomically with respect to bootstrap_look_up()
              calls, so that clients can trust that after receiving a port death notification,
              the new port will have already been recreated. Setting the value to true should be done with
              care. Not all clients may be able to handle this behavior. The default value is false.
            '';
          };

          HideUntilCheckIn = mkOption {
            type = types.nullOr types.bool;
            default = null;
            description = ''
              Reserve the name in the namespace, but cause bootstrap_look_up() to fail until the job has
              checked in with launchd.
            '';
          };
        };
      })));
    };

    LaunchEvents = mkOption {
      type = types.nullOr (types.attrs);
      default = null;
      description = ''
        Specifies higher-level event types to be used as launch-on-demand event
        sources.  Each sub-dictionary defines events for a particular event
        subsystem, such as "com.apple.iokit.matching", which can be used to
        launch jobs based on the appearance of nodes in the IORegistry. Each
        dictionary within the sub-dictionary specifies an event descriptor that
        is specified to each event subsystem. With this key, the job promises to
        use the xpc_set_event_stream_handler(3) API to consume events. See
        xpc_events(3) for more details on event sources.
      '';
      example = {
        "com.apple.iokit.matching" = {
          "com.apple.usb.device" = {
            IOMatchLaunchStream = true;
            IOProviderClass = "IOUSBDevice";
            idProduct = "*";
            idVendor = "*";
          };
        };
      };
    };

    ServiceIPC = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        This optional key specifies whether the job participates in advanced
        communication with launchd. The default is false. This flag is
        incompatible with the inetdCompatibility key.
      '';
    };

    SessionCreate = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        This key specifies that the job should be spawned into a new security
        audit session rather than the default session for the context is belongs
        to. See auditon(2) for details.
      '';
    };

    Sockets = mkOption {
      default = null;
      description = ''
        This optional key is used to specify launch on demand sockets that can be used to let launchd know when
        to run the job. The job must check-in to get a copy of the file descriptors using APIs outlined in
        launch(3).  The keys of the top level Sockets dictionary can be anything. They are meant for the application
        developer to use to differentiate which descriptors correspond to which application level protocols
        (e.g. http vs. ftp vs. DNS...).  At check-in time, the value of each Sockets dictionary key will
        be an array of descriptors. Daemon/Agent writers should consider all descriptors of a given key to be
        to be effectively equivalent, even though each file descriptor likely represents a different networking
        protocol which conforms to the criteria specified in the job configuration file.

        The parameters below are used as inputs to call `getaddrinfo(3)`.
      '';
      type = types.nullOr (types.attrsOf (types.submodule {
        options = {
          SockType = mkOption {
            type = types.nullOr (types.enum [ "stream" "dgram" "seqpacket" ]);
            default = null;
            description = ''
              This optional key tells launchctl what type of socket to create. The default is "stream" and
              other valid values for this key are "dgram" and "seqpacket" respectively.
            '';
          };

          SockPassive = mkOption {
            type = types.nullOr types.bool;
            default = null;
            description = ''
              This optional key specifies whether `listen(2)` or `connect(2)` should be called on the created file
              descriptor. The default is true ("to listen").
            '';
          };

          SockNodeName = mkOption {
            type = types.nullOr types.str;
            default = null;
            description = ''
              This optional key specifies the node to `connect(2)` or `bind(2)` to.
            '';
          };

          SockServiceName = mkOption {
            type = types.nullOr types.str;
            default = null;
            description = ''
              This optional key specifies the service on the node to `connect(2)` or `bind(2)` to.
            '';
          };

          SockFamily = mkOption {
            type = types.nullOr (types.enum [ "IPv4" "IPv6" ]);
            default = null;
            description = ''
              This optional key can be used to specifically request that "IPv4" or "IPv6" socket(s) be created.
            '';
          };

          SockProtocol = mkOption {
            type = types.nullOr (types.enum [ "TCP" ]);
            default = null;
            description = ''
              This optional key specifies the protocol to be passed to `socket(2)`.  The only value understood by
              this key at the moment is "TCP".
            '';
          };

          SockPathName = mkOption {
            type = types.nullOr types.path;
            default = null;
            description = ''
              This optional key implies SockFamily is set to "Unix". It specifies the path to `connect(2)` or
              `bind(2)` to.
            '';
          };

          SecureSocketWithKey = mkOption {
            type = types.nullOr types.str;
            default = null;
            description = ''
              This optional key is a variant of SockPathName. Instead of binding to a known path, a securely
              generated socket is created and the path is assigned to the environment variable that is inherited
              by all jobs spawned by launchd.
            '';
          };

          SockPathMode = mkOption {
            type = types.nullOr types.int;
            default = null;
            description = ''
              This optional key specifies the mode of the socket. Known bug: Property lists don't support
              octal, so please convert the value to decimal.
            '';
          };

          Bonjour = mkOption {
            type = types.nullOr (types.either types.bool (types.listOf types.str));
            default = null;
            description = ''
              This optional key can be used to request that the service be registered with the
              `mDNSResponder(8)`.  If the value is boolean, the service name is inferred from the SockServiceName.
            '';
          };

          MulticastGroup = mkOption {
            type = types.nullOr types.str;
            default = null;
            description = ''
              This optional key can be used to request that the datagram socket join a multicast group.  If the
              value is a hostname, then `getaddrinfo(3)` will be used to join the correct multicast address for a
              given socket family.  If an explicit IPv4 or IPv6 address is given, it is required that the SockFamily
              family also be set, otherwise the results are undefined.
            '';
          };
        };
      }));
    };
  };

  config = {};
}
</file>

<file path="modules/launchd/types.nix">
{ lib, ... }:

let
  inherit (lib) imap1 types mkOption showOption optionDescriptionPhrase mergeDefinitions;
  inherit (builtins) map filter length deepSeq throw toString concatLists;
  inherit (lib.options) showDefs;
  wildcardText = lib.literalMD "`*`";

  /**
    A type of list which does not allow duplicate elements. The base/inner
    list type to use (e.g. `types.listOf` or `types.nonEmptyListOf`) is passed
    via argument `listType`, which must be the final type and not a function.

    NOTE: The extra check for duplicates is quadratic and strict, so use this
    type sparingly and only:

      * when needed, and
      * when the list is expected to be recursively short (e.g. < 10 elements)
        and shallow (i.e. strict evaluation of the list won't take too long)

    The implementation of this function is similar to that of
    `types.nonEmptyListOf`.
  */
  types'.uniqueList = listType: listType // {
      description = "unique ${types.optionDescriptionPhrase (class: class == "noun") listType}";
      substSubModules = m: types'.uniqueList (listType.substSubModules m);
      # This has been taken from the implementation of `types.listOf`, but has
      # been modified to throw on duplicates. This check cannot be done in the
      # `check` fn as this check is deep/strict, and because `check` runs
      # prior to merging.
      merge = loc: defs:
        let
          # Each element of `dupes` is a list. When there are duplicates,
          # later lists will be duplicates of earlier lists, so just throw on
          # the first set of duplicates found so that we don't have duplicate
          # error msgs.
          checked = filter (li:
            if length li > 1
            then throw "The option `${showOption loc}' contains duplicate entries after merging:\n${showDefs li}"
            else false) dupes;
          dupes = map (def: filter (def': def'.value == def.value) merged) merged;
          merged = filter (x: x ? value) (concatLists (imap1 (n: def:
            imap1 (m: el:
              let
                inherit (def) file;
                loc' = loc ++ ["[definition ${toString n}-entry ${toString m}]"];
              in
                (mergeDefinitions
                  loc'
                  listType.nestedTypes.elemType
                  [{ inherit file; value = el; }]
                ).optionalValue // {inherit loc' file;}
            ) def.value
          ) defs));
      in
        deepSeq checked (map (x: x.value) merged);
    };
in {
  StartCalendarInterval = let
    CalendarIntervalEntry = types.submodule {
      options = {
        Minute = mkOption {
          type = types.nullOr (types.ints.between 0 59);
          default = null;
          defaultText = wildcardText;
          description = ''
            The minute on which this job will be run.
          '';
        };

        Hour = mkOption {
          type = types.nullOr (types.ints.between 0 23);
          default = null;
          defaultText = wildcardText;
          description = ''
            The hour on which this job will be run.
          '';
        };

        Day = mkOption {
          type = types.nullOr (types.ints.between 1 31);
          default = null;
          defaultText = wildcardText;
          description = ''
            The day on which this job will be run.
          '';
        };

        Weekday = mkOption {
          type = types.nullOr (types.ints.between 0 7);
          default = null;
          defaultText = wildcardText;
          description = ''
            The weekday on which this job will be run (0 and 7 are Sunday).
          '';
        };

        Month = mkOption {
          type = types.nullOr (types.ints.between 1 12);
          default = null;
          defaultText = wildcardText;
          description = ''
            The month on which this job will be run.
          '';
        };
      };
    };
  in
    types.either CalendarIntervalEntry (types'.uniqueList (types.nonEmptyListOf CalendarIntervalEntry));
}
</file>

<file path="modules/lib/write-text.nix">
{ lib, mkTextDerivation }:

{ config, name, ... }:

with lib;

let
  fileName = file: last (splitString "/" file);
  mkDefaultIf = cond: value: mkIf cond (mkDefault value);

  drv = mkTextDerivation (fileName name) config.text;
in

{
  options = {
    enable = mkOption {
      type = types.bool;
      default = true;
      description = ''
        Whether this file should be generated.
        This option allows specific files to be disabled.
      '';
    };

    text = mkOption {
      type = types.lines;
      default = "";
      description = ''
        Text of the file.
      '';
    };

    target = mkOption {
      type = types.str;
      default = name;
      description = ''
        Name of symlink.  Defaults to the attribute name.
      '';
    };

    source = mkOption {
      type = types.path;
      description = ''
        Path of the source file.
      '';
    };

    knownSha256Hashes = mkOption {
      internal = true;
      type = types.listOf types.str;
      default = [];
    };
  };

  config = {

    source = mkDefault drv;

  };
}
</file>

<file path="modules/misc/ids.nix">
# Based on: https://github.com/NixOS/nixpkgs/blob/master/nixos/modules/misc/ids.nix

# This module defines the global list of uids and gids.  We keep a
# central list to prevent id collisions.

# IMPORTANT!
# We only add static uids and gids for services where it is not feasible
# to change uids/gids on service start, in example a service with a lot of
# files.

{ lib, config, ... }:

let
  inherit (lib) types;
in
{
  options = {

    ids.uids = lib.mkOption {
      internal = true;
      description = ''
        The user IDs used in NixOS.
      '';
      type = types.attrsOf types.int;
    };

    ids.gids = lib.mkOption {
      internal = true;
      description = ''
        The group IDs used in NixOS.
      '';
      type = types.attrsOf types.int;
    };

  };

  config = {

    ids.uids = {
      nixbld = lib.mkDefault 350;
      _prometheus-node-exporter = 534;
      _dnscrypt-proxy = 535;
    };

    ids.gids = {
      nixbld = lib.mkDefault (if config.system.stateVersion < 5 then 30000 else 350);
      _prometheus-node-exporter = 534;
      _dnscrypt-proxy = 535;
    };

  };

}
</file>

<file path="modules/misc/lib.nix">
{ lib, ... }:

{
  options = {
    lib = lib.mkOption {
      default = { };

      type = lib.types.attrsOf lib.types.attrs;

      description = ''
        This option allows modules to define helper functions, constants, etc.
      '';
    };
  };
}
</file>

<file path="modules/networking/applicationFirewall.nix">
{ config, lib, ... }:
let
  cfg = config.networking.applicationFirewall;

  socketfilterfw =
    option: value:
    lib.concatStringsSep " " [
      "/usr/libexec/ApplicationFirewall/socketfilterfw"
      "--${option}"
      (if value then "on" else "off")
    ];
in
{
  meta.maintainers = [
    (lib.maintainers.prince213 or "prince213")
  ];

  options.networking.applicationFirewall = {
    enable = lib.mkOption {
      type = lib.types.nullOr lib.types.bool;
      default = null;
      example = true;
      description = "Whether to enable application firewall.";
    };
    blockAllIncoming = lib.mkEnableOption "blocking all incoming connections";
    allowSigned = lib.mkEnableOption "built-in software to receive incoming connections" // {
      default = true;
    };
    allowSignedApp =
      lib.mkEnableOption "downloaded signed software to receive incoming connections"
      // {
        default = true;
      };
    enableStealthMode = lib.mkEnableOption "stealth mode";
  };

  config = {
    system.activationScripts.networking.text = ''
      echo "configuring application firewall..." >&2

      ${lib.optionalString (cfg.enable != null) (socketfilterfw "setglobalstate" cfg.enable)}
      ${lib.optionalString (cfg.enable == true) (socketfilterfw "setblockall" cfg.blockAllIncoming)}
      ${socketfilterfw "setallowsigned" cfg.allowSigned}
      ${socketfilterfw "setallowsignedapp" cfg.allowSignedApp}
      ${socketfilterfw "setstealthmode" cfg.enableStealthMode}
    '';
  };
}
</file>

<file path="modules/networking/default.nix">
{ config, lib, ... }:

with lib;

let
  cfg = config.networking;

  hostnameRegEx = ''^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\-]*[A-Za-z0-9])$'';

  emptyList = lst: if lst != [] then lst else ["empty"];

  onOff = cond: if cond then "on" else "off";

  setNetworkServices = optionalString (cfg.knownNetworkServices != []) ''
    networkservices=$(networksetup -listallnetworkservices)
    ${concatMapStringsSep "\n" (srv: ''
      case "$networkservices" in
        *${lib.escapeShellArg srv}*)
          networksetup -setdnsservers ${lib.escapeShellArgs ([ srv ] ++ (emptyList cfg.dns))}
          networksetup -setsearchdomains ${lib.escapeShellArgs ([ srv ] ++ (emptyList cfg.search))}
          ;;
      esac
    '') cfg.knownNetworkServices}
  '';
in

{
  options = {
    networking.computerName = mkOption {
      type = types.nullOr types.str;
      default = null;
      example = "John‚Äôs MacBook Pro";
      description = ''
        The user-friendly name for the system, set in System Preferences > Sharing > Computer Name.

        Setting this option is equivalent to running `scutil --set ComputerName`.

        This name can contain spaces and Unicode characters.
      '';
    };

    networking.hostName = mkOption {
      type = types.nullOr (types.strMatching hostnameRegEx);
      default = null;
      example = "Johns-MacBook-Pro";
      description = ''
        The hostname of your system, as visible from the command line and used by local and remote
        networks when connecting through SSH and Remote Login.

        Setting this option is equivalent to running the command `scutil --set HostName`.

        (Note that networking.localHostName defaults to the value of this option.)
      '';
    };

    networking.localHostName = mkOption {
      type = types.nullOr (types.strMatching hostnameRegEx);
      default = cfg.hostName;
      example = "Johns-MacBook-Pro";
      description = ''
        The local hostname, or local network name, is displayed beneath the computer's name at the
        top of the Sharing preferences pane. It identifies your Mac to Bonjour-compatible services.

        Setting this option is equivalent to running the command `scutil --set LocalHostName`, where
        running, e.g., `scutil --set LocalHostName 'Johns-MacBook-Pro'`, would set
        the systems local hostname to "Johns-MacBook-Pro.local". The value of this option defaults
        to the value of the networking.hostName option.

        By default on macOS the local hostname is your computer's name with ".local" appended, with
        any spaces replaced with hyphens, and invalid characters omitted.
      '';
    };

    networking.domain = mkOption {
      default = null;
      example = "home.arpa";
      type = types.nullOr types.str;
      description = ''
        The domain.  It can be left empty if it is auto-detected through DHCP.
      '';
    };

    networking.fqdn = mkOption {
      type = types.str;
      default =
        if (cfg.hostName != "" && cfg.domain != null) then
          "${cfg.hostName}.${cfg.domain}"
        else
          throw ''
            The FQDN is required but cannot be determined from `networking.hostName`
            and `networking.domain`. Please ensure these options are set properly or
            set `networking.fqdn` directly.
          '';
      defaultText = literalExpression ''"''${networking.hostName}.''${networking.domain}"'';
      description = ''
        The fully qualified domain name (FQDN) of this host. By default, it is
        the result of combining `networking.hostName` and `networking.domain.`

        Using this option will result in an evaluation error if the hostname is empty or
        no domain is specified.

        Modules that accept a mere `networking.hostName` but prefer a fully qualified
        domain name may use `networking.fqdnOrHostName` instead.
      '';
    };

    networking.fqdnOrHostName = mkOption {
      readOnly = true;
      type = types.str;
      default = if cfg.domain == null then cfg.hostName else cfg.fqdn;
      defaultText = literalExpression ''
        if cfg.domain == null then cfg.hostName else cfg.fqdn
      '';
      description = ''
        Either the fully qualified domain name (FQDN), or just the host name if
        it does not exists.

        This is a convenience option for modules to read instead of `fqdn` when
        a mere `hostName` is also an acceptable value; this option does not
        throw an error when `domain` is unset.
      '';
    };

    networking.knownNetworkServices = mkOption {
      type = types.listOf types.str;
      default = [];
      example = [ "Wi-Fi" "Ethernet Adaptor" "Thunderbolt Ethernet" ];
      description = ''
        List of networkservices that should be configured.

        To display a list of all the network services on the server's
        hardware ports, use {command}`networksetup -listallnetworkservices`.
      '';
    };

    networking.dns = mkOption {
      type = types.listOf types.str;
      default = [];
      example = [ "8.8.8.8" "8.8.4.4" "2001:4860:4860::8888" "2001:4860:4860::8844" ];
      description = "The list of dns servers used when resolving domain names.";
    };

    networking.search = mkOption {
      type = types.listOf types.str;
      default = [];
      description = "The list of search paths used when resolving domain names.";
    };

    networking.wakeOnLan.enable = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Enable Wake-on-LAN for the device.

        Battery powered devices may require being connected to power.
      '';
    };
  };

  config = {

    warnings = [
      (mkIf (cfg.knownNetworkServices == [] && cfg.dns != []) "networking.knownNetworkServices is empty, dns servers will not be configured.")
      (mkIf (cfg.knownNetworkServices == [] && cfg.search != []) "networking.knownNetworkServices is empty, dns searchdomains will not be configured.")
    ];

    system.activationScripts.networking.text = ''
      echo "configuring networking..." >&2

      ${optionalString (cfg.computerName != null) ''
        scutil --set ComputerName ${escapeShellArg cfg.computerName}
      ''}
      ${optionalString (cfg.hostName != null) ''
        scutil --set HostName ${escapeShellArg cfg.hostName}
      ''}
      ${optionalString (cfg.localHostName != null) ''
        scutil --set LocalHostName ${escapeShellArg cfg.localHostName}
      ''}

      ${setNetworkServices}

      ${optionalString (cfg.wakeOnLan.enable != null) ''
        systemsetup -setWakeOnNetworkAccess '${onOff cfg.wakeOnLan.enable}' &> /dev/null
      ''}

      if [ -e /etc/hosts.before-nix-darwin ]; then
        echo "restoring /etc/hosts..." >&2
        sudo mv /etc/hosts{.before-nix-darwin,}
      fi
    '';

  };
}
</file>

<file path="modules/nix/default.nix">
# Based off: https://github.com/NixOS/nixpkgs/blob/master/nixos/modules/services/misc/nix-daemon.nix
# When making changes please try to keep it in sync and keep the diff NixOS module clean.
{ config, lib, pkgs, ... }:

with lib;

let

  cfg = config.nix;

  nixPackage = cfg.package.out;

  isNixAtLeast = versionAtLeast (getVersion nixPackage);

  configureBuildUsers = !(config.nix.settings.auto-allocate-uids or false);

  makeNixBuildUser = nr: {
    name = "_nixbld${toString nr}";
    value = {
      description = "Nix build user ${toString nr}";

      /*
        For consistency with the setgid(2), setuid(2), and setgroups(2)
        calls in `libstore/build.cc', don't add any supplementary group
        here except "nixbld".
      */
      uid = builtins.add config.ids.uids.nixbld nr;
      gid = config.ids.gids.nixbld;
    };
  };

  nixbldUsers = listToAttrs (map makeNixBuildUser (range 1 cfg.nrBuildUsers));

  nixConf =
    assert isNixAtLeast "2.2";
    let

      mkValueString = v:
        if v == null then ""
        else if isInt v then toString v
        else if isBool v then boolToString v
        else if isFloat v then strings.floatToString v
        else if isList v then toString v
        else if isDerivation v then toString v
        else if builtins.isPath v then toString v
        else if isString v then v
        else if isCoercibleToString v then toString v
        else abort "The nix conf value: ${toPretty {} v} can not be encoded";

      mkKeyValue = k: v: "${escape [ "=" ] k} = ${mkValueString v}";

      mkKeyValuePairs = attrs: concatStringsSep "\n" (mapAttrsToList mkKeyValue attrs);

      isExtra = key: hasPrefix "extra-" key;

    in
    pkgs.writeTextFile {
      name = "nix.conf";
      text = ''
        # WARNING: this file is generated from the nix.* options in
        # your nix-darwin configuration. Do not edit it!
        ${mkKeyValuePairs (filterAttrs (key: value: !(isExtra key)) cfg.settings)}
        ${mkKeyValuePairs (filterAttrs (key: value: isExtra key) cfg.settings)}
        ${cfg.extraOptions}
      '';
      checkPhase =
        if pkgs.stdenv.hostPlatform != pkgs.stdenv.buildPlatform then ''
          echo "Ignoring validation for cross-compilation"
        ''
        else
        let
          showCommand = if isNixAtLeast "2.20pre" then "config show" else "show-config";
        in
        ''
          echo "Validating generated nix.conf"
          ln -s $out ./nix.conf
          set -e
          set +o pipefail
          NIX_CONF_DIR=$PWD \
            ${cfg.package}/bin/nix ${showCommand} ${optionalString (isNixAtLeast "2.3pre") "--no-net"} \
              ${optionalString (isNixAtLeast "2.4pre") "--option experimental-features nix-command"} \
            |& sed -e 's/^warning:/error:/' \
            | (! grep '${if cfg.checkConfig then "^error:" else "^error: unknown setting"}')
          set -o pipefail
        '';
    };

  legacyConfMappings = {
    useSandbox = "sandbox";
    buildCores = "cores";
    maxJobs = "max-jobs";
    sandboxPaths = "extra-sandbox-paths";
    binaryCaches = "substituters";
    trustedBinaryCaches = "trusted-substituters";
    binaryCachePublicKeys = "trusted-public-keys";
    autoOptimiseStore = "auto-optimise-store";
    requireSignedBinaryCaches = "require-sigs";
    trustedUsers = "trusted-users";
    allowedUsers = "allowed-users";
    # systemFeatures = "system-features";
  };

  semanticConfType = with types;
    let
      confAtom = nullOr
        (oneOf [
          bool
          int
          float
          str
          path
          package
        ]) // {
        description = "Nix config atom (null, bool, int, float, str, path or package)";
      };
    in
    attrsOf (either confAtom (listOf confAtom));

  # Not in NixOS module
  nixPathType = mkOptionType {
    name = "nix path";
    merge = loc: defs:
      let
        values = flatten (map (def:
          (map (x:
            if isAttrs x then (mapAttrsToList nameValuePair x)
            else if isString x then x
            else throw "The option value `${showOption loc}` in `${def.file}` is not a attset or string.")
            (if isList def.value then def.value else [def.value]))) defs);

        namedPaths = mapAttrsToList (n: v: "${n}=${(head v).value}")
          (zipAttrs
            (map (x: { "${x.name}" = { inherit (x) value; }; })
            (filter isAttrs values)));

        searchPaths = unique
          (filter isString values);
      in
        namedPaths ++ searchPaths;
  };

  handleUnmanaged = managedConfig: mkMerge [
    (mkIf cfg.enable managedConfig)
    (mkIf (!cfg.enable) {
      system.activationScripts.nix-daemon.text = ''
        # Restore unmanaged Nix daemon if present
        unmanagedNixProfile=/nix/var/nix/profiles/default
        if [[
          -e /run/current-system/Library/LaunchDaemons/org.nixos.nix-daemon.plist
          && -e $unmanagedNixProfile/Library/LaunchDaemons/org.nixos.nix-daemon.plist
        ]]; then
          printf >&2 'restoring unmanaged Nix daemon...\n'
          cp \
            "$unmanagedNixProfile/Library/LaunchDaemons/org.nixos.nix-daemon.plist" \
            /Library/LaunchDaemons
          launchctl load -w /Library/LaunchDaemons/org.nixos.nix-daemon.plist
        fi
      '';
    })
  ];

  managedDefault = name: default: {
    default = if cfg.enable then default else throw ''
      ${name}: accessed when `nix.enable` is off; this is a bug in
      nix-darwin or a third‚Äêparty module
    '';
    defaultText = default;
  };

in

{
  imports =
    let
      altOption = alt: "No `nix-darwin` equivalent to this NixOS option, consider using `${alt}` instead.";
      consider = alt: "Consider using `${alt}` instead.";
    in
    [
      # Only ever in NixOS
      (mkRemovedOptionModule [ "nix" "daemonCPUSchedPolicy" ] (altOption "nix.daemonProcessType"))
      (mkRemovedOptionModule [ "nix" "daemonIOSchedClass" ] (altOption "nix.daemonProcessType"))
      (mkRemovedOptionModule [ "nix" "daemonIOSchedPriority" ] (altOption "nix.daemonIOLowPriority"))
      (mkRemovedOptionModule [ "nix" "readOnlyStore" ] "No `nix-darwin` equivalent to this NixOS option.")

      # Option changes in `nix-darwin`
      (mkRemovedOptionModule [ "nix" "profile" ] "Use `nix.package` instead.")
      (mkRemovedOptionModule [ "nix" "version" ] (consider "nix.package.version"))
      (mkRenamedOptionModule [ "users" "nix" "configureBuildUsers" ] [ "nix" "configureBuildUsers" ])
      (mkRenamedOptionModule [ "users" "nix" "nrBuildUsers" ] [ "nix" "nrBuildUsers" ])
      (mkRenamedOptionModule [ "nix" "daemonIONice" ] [ "nix" "daemonIOLowPriority" ])
      (mkRemovedOptionModule [ "nix" "daemonNiceLevel" ] (consider "nix.daemonProcessType"))
      (mkRemovedOptionModule [ "nix" "useDaemon" ] ''
        nix-darwin now only supports managing multi‚Äêuser daemon
        installations of Nix.
      '')
      (mkRemovedOptionModule [ "nix" "configureBuildUsers" ] ''
        nix-darwin now manages build users unconditionally when
        `nix.enable` is on.
      '')
    ] ++ mapAttrsToList (oldConf: newConf: mkRenamedOptionModule [ "nix" oldConf ] [ "nix" "settings" newConf ]) legacyConfMappings;

  ###### interface

  options = {

    nix = {

      enable = lib.mkOption {
        type = lib.types.bool;
        default = true;
        description = ''
          Whether to enable Nix.

          Disabling this will stop nix-darwin from managing the
          installed version of Nix, the nix-daemon launchd daemon, and
          the settings in {file}`/etc/nix/nix.conf`.

          This allows you to use nix-darwin without it taking over your
          system installation of Nix. Some nix-darwin functionality
          that relies on managing the Nix installation, like the
          `nix.*` options to adjust Nix settings or configure a Linux
          builder, will be unavailable. You will also have to upgrade
          Nix yourself, as nix-darwin will no longer do so.

          ::: {.warning}
          If you have already removed your global system installation
          of Nix, this will break nix-darwin and you will have to
          reinstall Nix to fix it.
          :::
        '';
      };

      package = mkOption {
        type = types.package;
        inherit (managedDefault "nix.package" pkgs.nix) default;
        defaultText = literalExpression "pkgs.nix";
        description = ''
          This option specifies the Nix package instance to use throughout the system.
        '';
      };

      distributedBuilds = mkOption {
        type = types.bool;
        inherit (managedDefault "nix.distributedBuilds" false) default defaultText;
        description = ''
          Whether to distribute builds to the machines listed in
          {option}`nix.buildMachines`.
        '';
      };

      # Not in NixOS module
      daemonProcessType = mkOption {
        type = types.enum [ "Background" "Standard" "Adaptive" "Interactive" ];
        inherit (managedDefault "nix.daemonProcessType" "Standard") default defaultText;
        description = ''
          Nix daemon process resource limits class. These limits propagate to
          build processes. `Standard` is the default process type
          and will apply light resource limits, throttling its CPU usage and I/O
          bandwidth.

          See {command}`man launchd.plist` for explanation of other
          process types.
        '';
      };

      # Not in NixOS module
      daemonIOLowPriority = mkOption {
        type = types.bool;
        inherit (managedDefault "nix.daemonIOLowPriority" false) default defaultText;
        description = ''
          Whether the Nix daemon process should considered to be low priority when
          doing file system I/O.
        '';
      };

      buildMachines = mkOption {
        type = types.listOf (types.submodule {
          options = {
            hostName = mkOption {
              type = types.str;
              example = "nixbuilder.example.org";
              description = ''
                The hostname of the build machine.
              '';
            };
            protocol = mkOption {
              type = types.enum [ null "ssh" "ssh-ng" ];
              default = "ssh";
              example = "ssh-ng";
              description = ''
                The protocol used for communicating with the build machine.
                Use `ssh-ng` if your remote builder and your
                local Nix version support that improved protocol.

                Use `null` when trying to change the special localhost builder
                without a protocol which is for example used by hydra.
              '';
            };
            system = mkOption {
              type = types.nullOr types.str;
              default = null;
              example = "x86_64-linux";
              description = ''
                The system type the build machine can execute derivations on.
                Either this attribute or {var}`systems` must be
                present, where {var}`system` takes precedence if
                both are set.
              '';
            };
            systems = mkOption {
              type = types.listOf types.str;
              default = [ ];
              example = [ "x86_64-linux" "aarch64-linux" ];
              description = ''
                The system types the build machine can execute derivations on.
                Either this attribute or {var}`system` must be
                present, where {var}`system` takes precedence if
                both are set.
              '';
            };
            sshUser = mkOption {
              type = types.nullOr types.str;
              default = null;
              example = "builder";
              description = ''
                The username to log in as on the remote host. This user must be
                able to log in and run nix commands non-interactively. It must
                also be privileged to build derivations, so must be included in
                {option}`nix.settings.trusted-users`.
              '';
            };
            sshKey = mkOption {
              type = types.nullOr types.str;
              default = null;
              example = "/root/.ssh/id_buildhost_builduser";
              description = ''
                The path to the SSH private key with which to authenticate on
                the build machine. The private key must not have a passphrase.
                If null, the building user (root on NixOS machines) must have an
                appropriate ssh configuration to log in non-interactively.

                Note that for security reasons, this path must point to a file
                in the local filesystem, *not* to the nix store.
              '';
            };
            maxJobs = mkOption {
              type = types.int;
              default = 1;
              description = ''
                The number of concurrent jobs the build machine supports. The
                build machine will enforce its own limits, but this allows hydra
                to schedule better since there is no work-stealing between build
                machines.
              '';
            };
            speedFactor = mkOption {
              type = types.int;
              default = 1;
              description = ''
                The relative speed of this builder. This is an arbitrary integer
                that indicates the speed of this builder, relative to other
                builders. Higher is faster.
              '';
            };
            mandatoryFeatures = mkOption {
              type = types.listOf types.str;
              default = [ ];
              example = [ "big-parallel" ];
              description = ''
                A list of features mandatory for this builder. The builder will
                be ignored for derivations that don't require all features in
                this list. All mandatory features are automatically included in
                {var}`supportedFeatures`.
              '';
            };
            supportedFeatures = mkOption {
              type = types.listOf types.str;
              default = [ ];
              example = [ "kvm" "big-parallel" ];
              description = ''
                A list of features supported by this builder. The builder will
                be ignored for derivations that require features not in this
                list.
              '';
            };
            publicHostKey = mkOption {
              type = types.nullOr types.str;
              default = null;
              description = ''
                The (base64-encoded) public host key of this builder. The field
                is calculated via {command}`base64 -w0 /etc/ssh/ssh_host_type_key.pub`.
                If null, SSH will use its regular known-hosts file when connecting.
              '';
            };
          };
        });
        inherit (managedDefault "nix.buildMachines" [ ]) default defaultText;
        description = ''
          This option lists the machines to be used if distributed builds are
          enabled (see {option}`nix.distributedBuilds`).
          Nix will perform derivations on those machines via SSH by copying the
          inputs to the Nix store on the remote machine, starting the build,
          then copying the output back to the local Nix store.
        '';
      };

      # Environment variables for running Nix.
      envVars = mkOption {
        type = types.attrs;
        internal = true;
        inherit (managedDefault "nix.envVars" { }) default defaultText;
        description = "Environment variables used by Nix.";
      };

      nrBuildUsers = mkOption {
        type = types.int;
        inherit (managedDefault "nix.nrBuildUsers" 0) default defaultText;
        description = ''
          Number of `nixbld` user accounts created to
          perform secure concurrent builds.  If you receive an error
          message saying that ‚Äúall build users are currently in use‚Äù,
          you should increase this value.
        '';
      };

      channel = {
        enable = mkOption {
          description = ''
            Whether the `nix-channel` command and state files are made available on the machine.

            The following files are initialized when enabled:
              - `/nix/var/nix/profiles/per-user/root/channels`
              - `$HOME/.nix-defexpr/channels` (on login)

            Disabling this option will not remove the state files from the system.
          '';
          type = types.bool;
          default = true;
        };
      };

      # Definition differs substantially from NixOS module
      nixPath = mkOption {
        type = nixPathType;
        inherit (managedDefault "nix.nixPath" (
          lib.optionals cfg.channel.enable (
            lib.optionals (config.environment.darwinConfig != null) [
              # Include default path <darwin-config>.
              { darwin-config = "${config.environment.darwinConfig}"; }
            ] ++ [
              "/nix/var/nix/profiles/per-user/root/channels"
            ]
          )
        )) default;

        defaultText = lib.literalExpression ''
          lib.optionals cfg.channel.enable [
            # Include default path <darwin-config>.
            { darwin-config = "''${config.environment.darwinConfig}"; }
            "/nix/var/nix/profiles/per-user/root/channels"
          ]
        '';
        description = ''
          The default Nix expression search path, used by the Nix
          evaluator to look up paths enclosed in angle brackets
          (e.g. `<nixpkgs>`).

          Named entries can be specified using an attribute set, if an
          entry is configured multiple times the value with the lowest
          ordering will be used.
        '';
      };

      checkConfig = mkOption {
        type = types.bool;
        inherit (managedDefault "nix.checkConfig" true) default defaultText;
        description = ''
          If enabled (the default), checks for data type mismatches and that Nix
          can parse the generated nix.conf.
        '';
      };

      registry = mkOption {
        type = types.attrsOf (types.submodule (
          let
            referenceAttrs = with types; attrsOf (oneOf [
              str
              int
              bool
              package
            ]);
          in
          { config, name, ... }:
          {
            options = {
              from = mkOption {
                type = referenceAttrs;
                example = { type = "indirect"; id = "nixpkgs"; };
                description = "The flake reference to be rewritten.";
              };
              to = mkOption {
                type = referenceAttrs;
                example = { type = "github"; owner = "my-org"; repo = "my-nixpkgs"; };
                description = "The flake reference {option}`from` is rewritten to.";
              };
              flake = mkOption {
                type = types.nullOr types.attrs;
                default = null;
                example = literalExpression "nixpkgs";
                description = ''
                  The flake input {option}`from` is rewritten to.
                '';
              };
              exact = mkOption {
                type = types.bool;
                default = true;
                description = ''
                  Whether the {option}`from` reference needs to match exactly. If set,
                  a {option}`from` reference like `nixpkgs` does not
                  match with a reference like `nixpkgs/nixos-20.03`.
                '';
              };
            };
            config = {
              from = mkDefault { type = "indirect"; id = name; };
              to = mkIf (config.flake != null) (mkDefault (
                {
                  type = "path";
                  path = config.flake.outPath;
                } // filterAttrs
                  (n: _: n == "lastModified" || n == "rev" || n == "revCount" || n == "narHash")
                  config.flake
              ));
            };
          }
        ));
        inherit (managedDefault "nix.registry" { }) default defaultText;
        description = ''
          A system-wide flake registry.
        '';
      };

      extraOptions = mkOption {
        type = types.lines;
        inherit (managedDefault "nix.extraOptions" "") default defaultText;
        example = ''
          keep-outputs = true
          keep-derivations = true
        '';
        description = "Additional text appended to {file}`nix.conf`.";
      };

      settings = mkOption {
        type = types.submodule {
          freeformType = semanticConfType;

          options = {
            max-jobs = mkOption {
              type = types.either types.int (types.enum [ "auto" ]);
              default = "auto";
              example = 64;
              description = ''
                This option defines the maximum number of jobs that Nix will try to
                build in parallel. The default is auto, which means it will use all
                available logical cores. It is recommend to set it to the total
                number of logical cores in your system (e.g., 16 for two CPUs with 4
                cores each and hyper-threading).
              '';
            };

            auto-optimise-store = mkOption {
              type = types.bool;
              default = false;
              example = true;
              description = ''
                If set to true, Nix automatically detects files in the store that have
                identical contents, and replaces them with hard links to a single copy.
                This saves disk space. If set to false (the default), you can enable
                {option}`nix.optimise.automatic` to run {command}`nix-store --optimise`
                periodically to get rid of duplicate files. You can also run
                {command}`nix-store --optimise` manually.
              '';
            };

            cores = mkOption {
              type = types.int;
              default = 0;
              example = 64;
              description = ''
                This option defines the maximum number of concurrent tasks during
                one build. It affects, e.g., -j option for make.
                The special value 0 means that the builder should use all
                available CPU cores in the system. Some builds may become
                non-deterministic with this option; use with care! Packages will
                only be affected if enableParallelBuilding is set for them.
              '';
            };

            sandbox = mkOption {
              type = types.either types.bool (types.enum [ "relaxed" ]);
              default = false;
              description = ''
                If set, Nix will perform builds in a sandboxed environment that it
                will set up automatically for each build. This prevents impurities
                in builds by disallowing access to dependencies outside of the Nix
                store by using network and mount namespaces in a chroot environment. It
                doesn't affect derivation hashes, so changing this option will not
                trigger a rebuild of packages.
              '';
            };

            extra-sandbox-paths = mkOption {
              type = types.listOf types.str;
              default = [ ];
              example = [ "/dev" "/proc" ];
              description = ''
                Directories from the host filesystem to be included
                in the sandbox.
              '';
            };

            substituters = mkOption {
              type = types.listOf types.str;
              description = ''
                List of binary cache URLs used to obtain pre-built binaries
                of Nix packages.

                By default https://cache.nixos.org/ is added.
              '';
            };

            trusted-substituters = mkOption {
              type = types.listOf types.str;
              default = [ ];
              example = [ "https://hydra.nixos.org/" ];
              description = ''
                List of binary cache URLs that non-root users can use (in
                addition to those specified using
                {option}`nix.settings.substituters`) by passing
                `--option binary-caches` to Nix commands.
              '';
            };

            require-sigs = mkOption {
              type = types.bool;
              default = true;
              description = ''
                If enabled (the default), Nix will only download binaries from binary caches if
                they are cryptographically signed with any of the keys listed in
                {option}`nix.settings.trusted-public-keys`. If disabled, signatures are neither
                required nor checked, so it's strongly recommended that you use only
                trustworthy caches and https to prevent man-in-the-middle attacks.
              '';
            };

            trusted-public-keys = mkOption {
              type = types.listOf types.str;
              example = [ "hydra.nixos.org-1:CNHJZBh9K4tP3EKF6FkkgeVYsS3ohTl+oS0Qa8bezVs=" ];
              description = ''
                List of public keys used to sign binary caches. If
                {option}`nix.settings.trusted-public-keys` is enabled,
                then Nix will use a binary from a binary cache if and only
                if it is signed by *any* of the keys
                listed here. By default, only the key for
                `cache.nixos.org` is included.
              '';
            };

            trusted-users = mkOption {
              type = types.listOf types.str;
              example = [ "root" "alice" "@admin" ];
              description = ''
                A list of names of users that have additional rights when
                connecting to the Nix daemon, such as the ability to specify
                additional binary caches, or to import unsigned NARs. You
                can also specify groups by prefixing them with
                `@`; for instance,
                `@admin` means all users in the wheel
                group.
              '';
            };

            # Not implemented yet
            # system-features = mkOption {
            #   type = types.listOf types.str;
            #   example = [ "kvm" "big-parallel" "gccarch-skylake" ];
            #   description = ''
            #     The set of features supported by the machine. Derivations
            #     can express dependencies on system features through the
            #     <literal>requiredSystemFeatures</literal> attribute.

            #     By default, pseudo-features <literal>nixos-test</literal>, <literal>benchmark</literal>,
            #     and <literal>big-parallel</literal> used in Nixpkgs are set, <literal>kvm</literal>
            #     is also included in it is avaliable.
            #   '';
            # };

            allowed-users = mkOption {
              type = types.listOf types.str;
              default = [ "*" ];
              example = [ "@admin" "@builders" "alice" "bob" ];
              description = ''
                A list of names of users (separated by whitespace) that are
                allowed to connect to the Nix daemon. As with
                {option}`nix.settings.trusted-users`, you can specify groups by
                prefixing them with `@`. Also, you can
                allow all users by specifying `*`. The
                default is `*`. Note that trusted users are
                always allowed to connect.
              '';
            };
          };
        };
        inherit (managedDefault "nix.settings" { }) default defaultText;
        description = ''
          Configuration for Nix, see
          <https://nixos.org/manual/nix/stable/#sec-conf-file>
          for avalaible options.
          The value declared here will be translated directly to the key-value pairs Nix expects.

          Nix configurations defined under {option}`nix.*` will be translated and applied to this
          option. In addition, configuration specified in {option}`nix.extraOptions` which will be appended
          verbatim to the resulting config file.
        '';
      };
    };
  };


  ###### implementation

  config = handleUnmanaged {
    environment.systemPackages =
      [
        nixPackage
        pkgs.nix-info
      ]
      ++ optional (config.programs.bash.completion.enable) pkgs.nix-bash-completions;

    environment.etc."nix/nix.conf".source = nixConf;

    # Not in NixOS module
    environment.etc."nix/nix.conf".knownSha256Hashes = [
      "7c2d80499b39256b03ee9abd3d6258343718306aca8d472c26ac32c9b0949093"  # official Nix installer
      "19299897fa312d9d32b3c968c2872dd143085aa727140cec51f57c59083e93b9"
      "c4ecc3d541c163c8fcc954ccae6b8cab28c973dc283fea5995c69aaabcdf785f"
      "ef78f401a9b5a42fd15e967c50da384f99ec62f9dbc66ea38f1390b46b63e1ff"  # official Nix installer 2.0
      "c06b0c6080dd1d62e61a30cfad100c0cfed2d3bcd378e296632dc3b28b31dc69"  # official Nix installer as of 2.0.1
      "ff08c12813680da98c4240328f828647b67a65ba7aa89c022bd8072cba862cf1"  # official Nix installer as of 2.4
      "f3e03d851c240c1aa7daccd144ee929f0f5971982424c868c434eb6030e961d4"  # DeterminateSystems Nix installer 0.10.0
      "c6080216f2a170611e339c3f46e4e1d61aaf0d8b417ad93ade8d647da1382c11"  # DeterminateSystems Nix installer 0.14.0
      "97f4135d262ca22d65c9554aad795c10a4491fa61b67d9c2430f4d82bbfec9a2"  # DeterminateSystems Nix installer 0.15.1
      "5d23e6d7015756c6f300f8cd558ec4d9234ca61deefd4f2478e91a49760b0747"  # DeterminateSystems Nix installer 0.16.0
      "e4974acb79c56148cb8e92137fa4f2de9b7356e897b332fc4e6769e8c0b83e18"  # DeterminateSystems Nix installer 0.20.0
      "966d22ef5bb9b56d481e8e0d5f7ca2deaf4d24c0f0fc969b2eeaa7ae0aa42907"  # DeterminateSystems Nix installer 0.22.0
      "53712b4335030e2dbfb46bb235f8cffcac83fea404bd32dc99417ac89e2dd7c5"  # DeterminateSystems Nix installer 0.33.0
      "6bb8d6b0dd16b44ee793a9b8382dac76c926e4c16ffb8ddd2bb4884d1ca3f811"  # DeterminateSystems Nix installer 0.34.0
      "24797ac05542ff8b52910efc77870faa5f9e3275097227ea4e50c430a5f72916"  # lix-installer 0.17.1 with flakes
      "b027b5cad320b5b8123d9d0db9f815c3f3921596c26dc3c471457098e4d3cc40"  # lix-installer 0.17.1 without flakes
    ];

    environment.etc."nix/registry.json".text = builtins.toJSON {
      version = 2;
      flakes = mapAttrsToList (n: v: { inherit (v) from to exact; }) cfg.registry;
    };

    # List of machines for distributed Nix builds in the format
    # expected by build-remote.pl.
    environment.etc."nix/machines" = mkIf (cfg.buildMachines != [ ]) {
      text =
        concatMapStrings
          (machine:
            (concatStringsSep " " ([
              "${optionalString (machine.protocol != null) "${machine.protocol}://"}${optionalString (machine.sshUser != null) "${machine.sshUser}@"}${machine.hostName}"
              (if machine.system != null then machine.system else if machine.systems != [ ] then concatStringsSep "," machine.systems else "-")
              (if machine.sshKey != null then machine.sshKey else "-")
              (toString machine.maxJobs)
              (toString machine.speedFactor)
              (let res = (machine.supportedFeatures ++ machine.mandatoryFeatures);
               in if (res == []) then "-" else (concatStringsSep "," res))
              (let res = machine.mandatoryFeatures;
               in if (res == []) then "-" else (concatStringsSep "," machine.mandatoryFeatures))
            ]
            ++ optional (isNixAtLeast "2.4pre") (if machine.publicHostKey != null then machine.publicHostKey else "-")))
            + "\n"
          )
          cfg.buildMachines;
    };

    assertions =
      let
        badMachine = m: m.system == null && m.systems == [ ];

        # Not in NixOS module
        createdGroups = mapAttrsToList (n: v: v.name) config.users.groups;
        createdUsers = mapAttrsToList (n: v: v.name) config.users.users;
      in
      [
        {
          assertion = !(any badMachine cfg.buildMachines);
          message = ''
            At least one system type (via <varname>system</varname> or
              <varname>systems</varname>) must be set for every build machine.
              Invalid machine specifications:
          '' + "      " +
          (concatStringsSep "\n      "
            (map (m: m.hostName)
              (filter (badMachine) cfg.buildMachines)));
        }

        # Not in NixOS module
        { assertion = elem "nixbld" config.users.knownGroups -> elem "nixbld" createdGroups; message = "refusing to delete group nixbld in users.knownGroups, this would break nix"; }
        { assertion = elem "_nixbld1" config.users.knownUsers -> elem "_nixbld1" createdUsers; message = "refusing to delete user _nixbld1 in users.knownUsers, this would break nix"; }
        { assertion = config.users.groups ? "nixbld" -> config.users.groups.nixbld.members != []; message = "refusing to remove all members from nixbld group, this would break nix"; }

        {
          # Should be fixed in Lix by https://gerrit.lix.systems/c/lix/+/2100
          # Lix 2.92.0 will set `VERSION_SUFFIX` to `""`; `lib.versionAtLeast "" "pre20241107"` will return `true`.
          assertion = cfg.settings.auto-optimise-store -> (cfg.package.pname == "lix" && (isNixAtLeast "2.92.0" && versionAtLeast (strings.removePrefix "-" cfg.package.VERSION_SUFFIX) "pre20241107"));
          message = "`nix.settings.auto-optimise-store` is known to corrupt the Nix Store, please use `nix.optimise.automatic` instead.";
        }
      ];

    # Not in NixOS module
    warnings = [
      (mkIf (!cfg.distributedBuilds && cfg.buildMachines != []) "nix.distributedBuilds is not enabled, build machines won't be configured.")
    ];

    # Not in NixOS module
    nix.nixPath = mkIf (config.system.stateVersion < 2) (mkDefault [
      "darwin=${config.system.primaryUserHome}/.nix-defexpr/darwin"
      "darwin-config=${config.system.primaryUserHome}/.nixpkgs/darwin-configuration.nix"
      "/nix/var/nix/profiles/per-user/root/channels"
    ]);

    system.requiresPrimaryUser = mkIf (
      config.system.stateVersion < 2
      && options.nix.nixPath.highestPrio == (mkDefault {}).priority
    ) [
      "nix.nixPath"
    ];

    # Set up the environment variables for running Nix.
    environment.variables = cfg.envVars // { NIX_PATH = cfg.nixPath; };

    environment.extraInit = mkIf cfg.channel.enable ''
      if [ -e "$HOME/.nix-defexpr/channels" ]; then
        export NIX_PATH="$HOME/.nix-defexpr/channels''${NIX_PATH:+:$NIX_PATH}"
      fi
    '';

    environment.extraSetup = mkIf (!cfg.channel.enable) ''
      rm --force $out/bin/nix-channel
    '';

    nix.nrBuildUsers = mkDefault (max 32 (if cfg.settings.max-jobs == "auto" then 0 else cfg.settings.max-jobs));

    users.users = mkIf configureBuildUsers nixbldUsers;

    # Not in NixOS module
    users.groups.nixbld = mkIf configureBuildUsers {
      description = "Nix build group for nix-daemon";
      gid = config.ids.gids.nixbld;
      members = attrNames nixbldUsers;
    };
    users.knownUsers =
      let nixbldUserNames = attrNames nixbldUsers;
      in
      mkMerge [
        nixbldUserNames
        (map (removePrefix "_") nixbldUserNames) # delete old style nixbld users
      ];
    users.knownGroups = [ "nixbld" ];

    # The Determinate Systems installer puts user‚Äêspecified settings in
    # `/etc/nix/nix.custom.conf` since v0.33.0. Supplement the
    # `/etc/nix/nix.conf` hash check so that we don‚Äôt accidentally
    # clobber user configuration.
    #
    # TODO: Maybe this could use a more general file placement mechanism
    # to express that we want it deleted and know only one hash?
    system.activationScripts.checks.text = mkAfter ''
      nixCustomConfKnownSha256Hashes=(
        # v0.33.0
        6787fade1cf934f82db554e78e1fc788705c2c5257fddf9b59bdd963ca6fec63
        # v0.34.0
        3bd68ef979a42070a44f8d82c205cfd8e8cca425d91253ec2c10a88179bb34aa
      )
      if [[ -e /etc/nix/nix.custom.conf ]]; then
        nixCustomConfSha256Output=$(shasum -a 256 /etc/nix/nix.custom.conf)
        nixCustomConfSha256Hash=''${nixCustomConfSha256Output%% *}
        nixCustomConfIsKnown=
        for nixCustomConfKnownSha256Hash
          in "''${nixCustomConfKnownSha256Hashes[@]}"
        do
          if
            [[ $nixCustomConfSha256Hash == "$nixCustomConfKnownSha256Hash" ]]
          then
            nixCustomConfIsKnown=1
            break
          fi
        done
        if [[ ! $nixCustomConfIsKnown ]]; then
          printf >&2 '\e[1;31merror: custom settings in `/etc/nix/nix.custom.conf`, aborting activation\e[0m\n'
          printf >&2 'You will need to migrate these to nix-darwin `nix.*` settings if you\n'
          printf >&2 'wish to keep them. Check the manual for the appropriate settings and\n'
          printf >&2 'add them to your system configuration, then run:\n'
          printf >&2 '\n'
          printf >&2 '  $ sudo mv /etc/nix/nix.custom.conf{,.before-nix-darwin}\n'
          printf >&2 '\n'
          printf >&2 'and activate your system again.\n'
          exit 2
        fi
      fi
    '';

    # Unrelated to use in NixOS module
    system.activationScripts.nix-daemon.text = ''
      # Follow up on the `/etc/nix/nix.custom.conf` check.
      # TODO: Use a more generalized file placement mechanism for this.
      if [[ -e /etc/nix/nix.custom.conf ]]; then
        mv /etc/nix/nix.custom.conf{,.before-nix-darwin}
      fi

      if ! diff /etc/nix/nix.conf /run/current-system/etc/nix/nix.conf &> /dev/null || ! diff /etc/nix/machines /run/current-system/etc/nix/machines &> /dev/null; then
          echo "reloading nix-daemon..." >&2
          launchctl kill HUP system/org.nixos.nix-daemon
      fi
      while ! nix-store --store daemon -q --hash ${pkgs.stdenv.shell} &>/dev/null; do
          echo "waiting for nix-daemon" >&2
          launchctl kickstart system/org.nixos.nix-daemon
      done
    '';

    nix.settings = mkMerge [
      {
        trusted-public-keys = [ "cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY=" ];
        trusted-users = [ "root" ];
        substituters = mkAfter [ "https://cache.nixos.org/" ];

        # Not in NixOS module
        build-users-group = "nixbld";

        # Not implemented yet
        # system-features = mkDefault (
        #   [ "nixos-test" "benchmark" "big-parallel" "kvm" ] ++
        #   optionals (pkgs.hostPlatform ? gcc.arch) (
        #     # a builder can run code for `gcc.arch` and inferior architectures
        #     [ "gccarch-${pkgs.hostPlatform.gcc.arch}" ] ++
        #     map (x: "gccarch-${x}") systems.architectures.inferiors.${pkgs.hostPlatform.gcc.arch}
        #   )
        # );
      }

      (mkIf (!cfg.distributedBuilds) { builders = null; })

      (mkIf (isNixAtLeast "2.3pre") { sandbox-fallback = false; })

    ];

  };

}
</file>

<file path="modules/nix/linux-builder.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.nix.linux-builder;
in

{
  imports = [
    (mkRemovedOptionModule [ "nix" "linux-builder" "modules" ] "This option has been replaced with `nix.linux-builder.config` which allows setting options directly like `nix.linux-builder.config.networking.hostName = \"banana\";.")
  ];

  options.nix.linux-builder = {
    enable = mkEnableOption "Linux builder";

    package = mkOption {
      type = types.package;
      default = pkgs.darwin.linux-builder;
      defaultText = "pkgs.darwin.linux-builder";
      apply = pkg: pkg.override (old: {
        # the linux-builder package requires `modules` as an argument, so it's
        # always non-null.
        modules = old.modules ++ [ cfg.config ];
      });
      description = ''
        This option specifies the Linux builder to use.
      '';
    };

    config = mkOption {
      type = types.deferredModule;
      default = { };
      example = literalExpression ''
        ({ pkgs, ... }:

        {
          environment.systemPackages = [ pkgs.neovim ];
        })
      '';
      description = ''
        This option specifies extra NixOS configuration for the builder. You should first use the Linux builder
        without changing the builder configuration otherwise you may not be able to build the Linux builder.
      '';
    };

    mandatoryFeatures = mkOption {
      type = types.listOf types.str;
      default = [];
      defaultText = literalExpression ''[]'';
      example = literalExpression ''[ "big-parallel" ]'';
      description = ''
        A list of features mandatory for the Linux builder. The builder will
        be ignored for derivations that don't require all features in
        this list. All mandatory features are automatically included in
        {var}`supportedFeatures`.

        This sets the corresponding `nix.buildMachines.*.mandatoryFeatures` option.
      '';
    };

    maxJobs = mkOption {
      type = types.ints.positive;
      default = cfg.package.nixosConfig.virtualisation.cores;
      defaultText = ''
        The `virtualisation.cores` of the build machine's final NixOS configuration.
      '';
      example = 2;
      description = ''
        Instead of setting this directly, you should set
        {option}`nix.linux-builder.config.virtualisation.cores` to configure
        the amount of cores the Linux builder should have.

        The number of concurrent jobs the Linux builder machine supports. The
        build machine will enforce its own limits, but this allows hydra
        to schedule better since there is no work-stealing between build
        machines.

        This sets the corresponding `nix.buildMachines.*.maxJobs` option.
      '';
    };

    protocol = mkOption {
      type = types.str;
      default = "ssh-ng";
      defaultText = literalExpression ''"ssh-ng"'';
      example = literalExpression ''"ssh"'';
      description = ''
        The protocol used for communicating with the build machine.  Use
        `ssh-ng` if your remote builder and your local Nix version support that
        improved protocol.

        Use `null` when trying to change the special localhost builder without a
        protocol which is for example used by hydra.
      '';
    };

    speedFactor = mkOption {
      type = types.ints.positive;
      default = 1;
      defaultText = literalExpression ''1'';
      description = ''
        The relative speed of the Linux builder. This is an arbitrary integer
        that indicates the speed of this builder, relative to other
        builders. Higher is faster.

        This sets the corresponding `nix.buildMachines.*.speedFactor` option.
      '';
    };

    supportedFeatures = mkOption {
      type = types.listOf types.str;
      default = [ "kvm" "benchmark" "big-parallel" ];
      defaultText = literalExpression ''[ "kvm" "benchmark" "big-parallel" ]'';
      example = literalExpression ''[ "kvm" "big-parallel" ]'';
      description = ''
        A list of features supported by the Linux builder. The builder will
        be ignored for derivations that require features not in this
        list.

        This sets the corresponding `nix.buildMachines.*.supportedFeatures` option.
      '';
    };

    systems = mkOption {
      type = types.listOf types.str;
      default = [ cfg.package.nixosConfig.nixpkgs.hostPlatform.system ];
      defaultText = ''
        The `nixpkgs.hostPlatform.system` of the build machine's final NixOS configuration.
      '';
      example = literalExpression ''
        [
          "x86_64-linux"
          "aarch64-linux"
        ]
      '';
      description = ''
        This option specifies system types the build machine can execute derivations on.

        This sets the corresponding `nix.buildMachines.*.systems` option.
      '';
    };


    workingDirectory = mkOption {
      type = types.str;
      default = "/var/lib/linux-builder";
      description = ''
        The working directory of the Linux builder daemon process.
      '';
    };

    ephemeral = mkEnableOption ''
      wipe the builder's filesystem on every restart.

      This is disabled by default as maintaining the builder's Nix Store reduces
      rebuilds. You can enable this if you don't want your builder to accumulate
      state.
    '';
  };

  config = mkMerge [
    (mkIf (!cfg.enable) {
      system.activationScripts.preActivation.text = ''
        rm -rf ${cfg.workingDirectory}
      '';
    })
    (mkIf cfg.enable {
      assertions = [
        {
          assertion = config.nix.enable;
          message = ''`nix.linux-builder.enable` requires `nix.enable`'';
        }
      ];

      system.activationScripts.preActivation.text = ''
        # Migrate if using the old working directory
        if [ -e /var/lib/darwin-builder ] && [ ! -e ${cfg.workingDirectory} ]; then
          mv /var/lib/darwin-builder ${cfg.workingDirectory}
        fi

        mkdir -p ${cfg.workingDirectory}
      '';

      launchd.daemons.linux-builder = {
        environment = {
          inherit (config.environment.variables) NIX_SSL_CERT_FILE;
        };

        # create-builder uses TMPDIR to share files with the builder, notably certs.
        # macOS will clean up files in /tmp automatically that haven't been accessed in 3+ days.
        # If we let it use /tmp, leaving the computer asleep for 3 days makes the certs vanish.
        # So we'll use /run/org.nixos.linux-builder instead and clean it up ourselves.
        script = ''
          export TMPDIR=/run/org.nixos.linux-builder USE_TMPDIR=1
          rm -rf $TMPDIR
          mkdir -p $TMPDIR
          trap "rm -rf $TMPDIR" EXIT
          ${lib.optionalString cfg.ephemeral ''
            rm -f ${cfg.workingDirectory}/${cfg.package.nixosConfig.networking.hostName}.qcow2
          ''}
          ${cfg.package}/bin/create-builder
        '';

        serviceConfig = {
          KeepAlive = true;
          RunAtLoad = true;
          WorkingDirectory = cfg.workingDirectory;
        };
      };

      environment.etc."ssh/ssh_config.d/100-linux-builder.conf".text = ''
        Host linux-builder
          User builder
          Hostname localhost
          HostKeyAlias linux-builder
          Port 31022
          IdentityFile /etc/nix/builder_ed25519
      '';

      nix.distributedBuilds = true;

      nix.buildMachines = [{
        hostName = "linux-builder";
        sshUser = "builder";
        sshKey = "/etc/nix/builder_ed25519";
        publicHostKey = "c3NoLWVkMjU1MTkgQUFBQUMzTnphQzFsWkRJMU5URTVBQUFBSUpCV2N4Yi9CbGFxdDFhdU90RStGOFFVV3JVb3RpQzVxQkorVXVFV2RWQ2Igcm9vdEBuaXhvcwo=";
        inherit (cfg) mandatoryFeatures maxJobs protocol speedFactor supportedFeatures systems;
      }];

      nix.settings.builders-use-substitutes = true;
    })
  ];
}
</file>

<file path="modules/nix/nix-darwin.nix">
{ config, pkgs, lib, ... }:

let
  nix-tools = pkgs.callPackage ../../pkgs/nix-tools {
    inherit (config.system) profile;
    inherit (config.environment) systemPath;
    nixPath = lib.optionalString config.nix.enable (lib.concatStringsSep ":" config.nix.nixPath);
    nixPackage = if config.nix.enable then config.nix.package else null;
  };

  darwin-uninstaller = pkgs.callPackage ../../pkgs/darwin-uninstaller { };

  mkToolModule = { name, package ? nix-tools.${name} }: { config, ... }: {
    options.system.tools.${name}.enable = lib.mkEnableOption "${name} script" // {
      default = config.system.tools.enable;
    };

    config = lib.mkIf config.system.tools.${name}.enable {
      environment.systemPackages = [ package ];
    };
  };
in

{
  options.system = {
    tools.enable = lib.mkOption {
      type = lib.types.bool;
      internal = true;
      default = true;
      description = ''
        Disable internal tools, such as darwin-rebuild and darwin-option. This
        is useful to shrink systems which are not expected to rebuild or
        reconfigure themselves. Use at your own risk!
    '';
    };
  };

  imports = [
    (lib.mkRenamedOptionModule [ "system" "includeUninstaller" ] [ "system" "tools" "darwin-uninstaller" "enable" ])
    (lib.mkRemovedOptionModule [ "system" "disableInstallerTools" ] "Please use system.tools.enable instead")

    (mkToolModule { name = "darwin-option"; })
    (mkToolModule { name = "darwin-rebuild"; })
    (mkToolModule { name = "darwin-version"; })
    (mkToolModule { name = "darwin-uninstaller"; package = darwin-uninstaller; })
  ];

  config = {
    system.build = {
      inherit (nix-tools) darwin-option darwin-rebuild darwin-version;
    };
  };
}
</file>

<file path="modules/nix/nixpkgs-flake.nix">
{ config, options, lib, ... }:

with lib;

let
  cfg = config.nixpkgs.flake;
in
{
  options.nixpkgs.flake = {
    source = mkOption {
      # In newer Nix versions, particularly with lazy trees, outPath of
      # flakes becomes a Nix-language path object. We deliberately allow this
      # to gracefully come through the interface in discussion with @roberth.
      #
      # See: https://github.com/NixOS/nixpkgs/pull/278522#discussion_r1460292639
      type = types.nullOr (types.either types.str types.path);

      default = null;
      defaultText = "if (using nix-darwin.lib.darwinSystem) then nixpkgs.source else null";

      example = ''builtins.fetchTarball { name = "source"; sha256 = "${lib.fakeHash}"; url = "https://github.com/nixos/nixpkgs/archive/somecommit.tar.gz"; }'';

      description = ''
        The path to the nixpkgs sources used to build the system. This is automatically set up to be
        the store path of the nixpkgs flake used to build the system if using
        `nixpkgs.lib.darwinSystem`, and is otherwise null by default.

        This can also be optionally set if the nix-darwin system is not built with a flake but still uses
        pinned sources: set this to the store path for the nixpkgs sources used to build the system,
        as may be obtained by `builtins.fetchTarball`, for example.

        Note: the name of the store path must be "source" due to
        <https://github.com/NixOS/nix/issues/7075>.
      '';
    };

    setNixPath = mkOption {
      type = types.bool;

      default = config.nix.enable && cfg.source != null;
      defaultText = literalExpression ''config.nix.enable && nixpkgs.flake.source != null'';

      description = ''
        Whether to set {env}`NIX_PATH` to include `nixpkgs=flake:nixpkgs` such that `<nixpkgs>`
        lookups receive the version of nixpkgs that the system was built with, in concert with
        {option}`nixpkgs.flake.setFlakeRegistry`.

        This is on by default for nix-darwin configurations built with flakes.

        This makes {command}`nix-build '<nixpkgs>' -A hello` work out of the box on flake systems.

        Note that this option makes the nix-darwin closure depend on the nixpkgs sources, which may add
        undesired closure size if the system will not have any nix commands run on it.
      '';
    };

    setFlakeRegistry = mkOption {
      type = types.bool;

      default = config.nix.enable && cfg.source != null;
      defaultText = literalExpression ''config.nix.enable && config.nixpkgs.flake.source != null'';

      description = ''
        Whether to pin nixpkgs in the system-wide flake registry (`/etc/nix/registry.json`) to the
        store path of the sources of nixpkgs used to build the nix-darwin system.

        This is on by default for nix-darwin configurations built with flakes.

        This option makes {command}`nix run nixpkgs#hello` reuse dependencies from the system, avoid
        refetching nixpkgs, and have a consistent result every time.

        Note that this option makes the nix-darwin closure depend on the nixpkgs sources, which may add
        undesired closure size if the system will not have any nix commands run on it.
      '';
    };
  };

  config = mkIf (cfg.source != null) (mkMerge [
    {
      assertions = [
        {
          assertion = cfg.setNixPath -> cfg.setFlakeRegistry;
          message = ''
            Setting `nixpkgs.flake.setNixPath` requires that `nixpkgs.flake.setFlakeRegistry` also
            be set, since it is implemented in terms of indirection through the flake registry.
          '';
        }

        # TODO: Upstream these to NixOS.

        {
          assertion = cfg.setNixPath -> config.nix.enable;
          message = ''`nixpkgs.flake.setNixPath` requires `nix.enable`'';
        }

        {
          assertion = cfg.setFlakeRegistry -> config.nix.enable;
          message = ''`nixpkgs.flake.setFlakeRegistry` requires `nix.enable`'';
        }
      ];
    }
    (mkIf cfg.setFlakeRegistry {
      nix.registry.nixpkgs.to = mkDefault {
        type = "path";
        path = cfg.source;
      };
    })
    (mkIf cfg.setNixPath {
      # N.B. This does not include darwin-config in NIX_PATH unlike modules/nix/default.nix
      # because we would need some kind of evil shim taking the *calling* flake's self path,
      # perhaps, to ever make that work (in order to know where the Nix expr for the system came
      # from and how to call it).
      nix.nixPath = mkDefault ([ "nixpkgs=flake:nixpkgs" ]
        ++ optional config.nix.channel.enable "/nix/var/nix/profiles/per-user/root/channels");
    })
  ]);
}
</file>

<file path="modules/nix/nixpkgs.nix">
{
  config,
  options,
  lib,
  pkgs,
  ...
}:

let
  cfg = config.nixpkgs;
  opt = options.nixpkgs;

  isConfig = x: builtins.isAttrs x || lib.isFunction x;

  optCall = f: x: if lib.isFunction f then f x else f;

  mergeConfig =
    lhs_: rhs_:
    let
      lhs = optCall lhs_ { inherit pkgs; };
      rhs = optCall rhs_ { inherit pkgs; };
    in
    lib.recursiveUpdate lhs rhs
    // lib.optionalAttrs (lhs ? packageOverrides) {
      packageOverrides =
        pkgs:
        optCall lhs.packageOverrides pkgs // optCall (lib.attrByPath [ "packageOverrides" ] { } rhs) pkgs;
    }
    // lib.optionalAttrs (lhs ? perlPackageOverrides) {
      perlPackageOverrides =
        pkgs:
        optCall lhs.perlPackageOverrides pkgs
        // optCall (lib.attrByPath [ "perlPackageOverrides" ] { } rhs) pkgs;
    };

  configType = lib.mkOptionType {
    name = "nixpkgs-config";
    description = "nixpkgs config";
    check =
      x:
      let
        traceXIfNot = c: if c x then true else lib.traceSeqN 1 x false;
      in
      traceXIfNot isConfig;
    merge = args: lib.foldr (def: mergeConfig def.value) { };
  };

  overlayType = lib.mkOptionType {
    name = "nixpkgs-overlay";
    description = "nixpkgs overlay";
    check = lib.isFunction;
    merge = lib.mergeOneOption;
  };

  pkgsType = lib.types.pkgs // {
    # This type is only used by itself, so let's elaborate the description a bit
    # for the purpose of documentation.
    description = "An evaluation of Nixpkgs; the top level attribute set of packages";
  };

  hasBuildPlatform = opt.buildPlatform.highestPrio < (lib.mkOptionDefault { }).priority;
  hasHostPlatform = opt.hostPlatform.isDefined;
  hasPlatform = hasHostPlatform || hasBuildPlatform;

  # Context for messages
  hostPlatformLine = lib.optionalString hasHostPlatform "${lib.showOptionWithDefLocs opt.hostPlatform}";
  buildPlatformLine = lib.optionalString hasBuildPlatform "${lib.showOptionWithDefLocs opt.buildPlatform}";

  legacyOptionsDefined = lib.optional (
    opt.system.highestPrio < (lib.mkDefault { }).priority
  ) opt.system;

  defaultPkgs =
    if opt.hostPlatform.isDefined then
      let
        isCross = cfg.buildPlatform != cfg.hostPlatform;
        systemArgs =
          if isCross then
            {
              localSystem = cfg.buildPlatform;
              crossSystem = cfg.hostPlatform;
            }
          else
            {
              localSystem = cfg.hostPlatform;
            };
      in
      import cfg.source (
        {
          inherit (cfg) config overlays;
        }
        // systemArgs
      )
    else
      import cfg.source {
        inherit (cfg) config overlays;
        localSystem = { inherit (cfg) system; };
      };

  finalPkgs = if opt.pkgs.isDefined then cfg.pkgs.appendOverlays cfg.overlays else defaultPkgs;

in

{
  options.nixpkgs = {
    pkgs = lib.mkOption {
      type = pkgsType;
      example = lib.literalExpression "import <nixpkgs> {}";
      description = ''
        If set, the pkgs argument to all nix-darwin modules is the value of
        this option, extended with `nixpkgs.overlays`, if
        that is also set. The nix-darwin and Nixpkgs architectures must
        match. Any other options in `nixpkgs.*`, notably `config`,
        will be ignored.

        The default value imports the Nixpkgs from
        [](#opt-nixpkgs.source). The `config`, `overlays`, `localSystem`,
        and `crossSystem` are based on this option's siblings.

        This option can be used to increase
        the performance of evaluation, or to create packages that depend
        on a container that should be built with the exact same evaluation
        of Nixpkgs, for example. Applications like this should set
        their default value using `lib.mkDefault`, so
        user-provided configuration can override it without using
        `lib`.
      '';
    };

    config = lib.mkOption {
      default = { };
      example = lib.literalExpression ''
        { allowBroken = true; allowUnfree = true; }
      '';
      type = configType;
      description = ''
        Global configuration for Nixpkgs.
        The complete list of [Nixpkgs configuration options](https://nixos.org/manual/nixpkgs/unstable/#sec-config-options-reference) is in the [Nixpkgs manual section on global configuration](https://nixos.org/manual/nixpkgs/unstable/#chap-packageconfig).

        Ignored when {option}`nixpkgs.pkgs` is set.
      '';
    };

    overlays = lib.mkOption {
      default = [ ];
      example = lib.literalExpression ''
        [
          (self: super: {
            openssh = super.openssh.override {
              hpnSupport = true;
              kerberos = self.libkrb5;
            };
          })
        ]
      '';
      type = lib.types.listOf overlayType;
      description = ''
        List of overlays to apply to Nixpkgs.
        This option allows modifying the Nixpkgs package set accessed through the `pkgs` module argument.

        For details, see the [Overlays chapter in the Nixpkgs manual](https://nixos.org/manual/nixpkgs/stable/#chap-overlays).

        If the {option}`nixpkgs.pkgs` option is set, overlays specified using `nixpkgs.overlays` will be applied after the overlays that were already included in `nixpkgs.pkgs`.
      '';
    };

    hostPlatform = lib.mkOption {
      type = lib.types.either lib.types.str lib.types.attrs; # TODO utilize lib.systems.parsedPlatform
      example = {
        system = "aarch64-darwin";
      };
      # Make sure that the final value has all fields for sake of other modules
      # referring to this. TODO make `lib.systems` itself use the module system.
      apply = lib.systems.elaborate;
      description = ''
        Specifies the platform where the nix-darwin configuration will run.

        To cross-compile, set also `nixpkgs.buildPlatform`.

        Ignored when `nixpkgs.pkgs` is set.
      '';
    };

    buildPlatform = lib.mkOption {
      type = lib.types.either lib.types.str lib.types.attrs; # TODO utilize lib.systems.parsedPlatform
      default = cfg.hostPlatform;
      example = {
        system = "x86_64-darwin";
      };
      # Make sure that the final value has all fields for sake of other modules
      # referring to this.
      apply =
        inputBuildPlatform:
        let
          elaborated = lib.systems.elaborate inputBuildPlatform;
        in
        if lib.systems.equals elaborated cfg.hostPlatform then
          cfg.hostPlatform # make identical, so that `==` equality works; see https://github.com/NixOS/nixpkgs/issues/278001
        else
          elaborated;
      defaultText = lib.literalExpression ''config.nixpkgs.hostPlatform'';
      description = ''
        Specifies the platform on which nix-darwin should be built.
        By default, nix-darwin is built on the system where it runs, but you can
        change where it's built. Setting this option will cause nix-darwin to be
        cross-compiled.

        For instance, if you're doing distributed multi-platform deployment,
        or if you're building machines, you can set this to match your
        development system and/or build farm.

        Ignored when `nixpkgs.pkgs` is set.
      '';
    };

    system = lib.mkOption {
      type = lib.types.str;
      example = "x86_64-darwin";
      default =
        if opt.hostPlatform.isDefined then
          throw ''
            Neither ${opt.system} nor any other option in nixpkgs.* is meant
            to be read by modules and configurations.
            Use pkgs.stdenv.hostPlatform instead.
          ''
        else
          throw ''
            Neither ${opt.hostPlatform} nor the legacy option ${opt.system} has been set.
            The option ${opt.system} is still fully supported for interoperability,
            but will be deprecated in the future, so we recommend to set ${opt.hostPlatform}.
          '';
      defaultText = lib.literalMD ''
        Traditionally `builtins.currentSystem`, but unset when invoking nix-darwin through `lib.darwinSystem`.
      '';
      description = ''
        Specifies the Nix platform type on which nix-darwin should be built.
        It is better to specify `nixpkgs.hostPlatform` instead.

        Ignored when `nixpkgs.pkgs` or `nixpkgs.hostPlatform` is set.
      '';
    };

    # nix-darwin only

    source = lib.mkOption {
      type = lib.types.path;
      defaultText = lib.literalMD ''
        `<nixpkgs>` or nix-darwin's `nixpkgs` flake input
      '';
      description = ''
        The path to import Nixpkgs from. If you're setting a custom
        [](#opt-nixpkgs.pkgs) or `_module.args.pkgs`, setting this
        to something with `rev` and `shortRev` attributes (such as a
        flake input or `builtins.fetchGit` result) will also set
        `system.nixpkgsRevision` and related options.
        (nix-darwin only)
      '';
    };

    constructedByUs = lib.mkOption {
      type = lib.types.bool;
      internal = true;
      description = ''
        Whether `pkgs` was constructed by this module. This is false when any of
        `nixpkgs.pkgs` or `_module.args.pkgs` is set. (nix-darwin only)
      '';
    };
  };

  config = {
    _module.args = {
      pkgs =
        # We explicitly set the default override priority, so that we do not need
        # to evaluate finalPkgs in case an override is placed on `_module.args.pkgs`.
        # After all, to determine a definition priority, we need to evaluate `._type`,
        # which is somewhat costly for Nixpkgs. With an explicit priority, we only
        # evaluate the wrapper to find out that the priority is lower, and then we
        # don't need to evaluate `finalPkgs`.
        lib.mkOverride lib.modules.defaultOverridePriority finalPkgs.__splicedPackages;
    };

    nixpkgs.constructedByUs =
      # We set it with default priority and it can not be merged, so if the
      # pkgs module argument has that priority, it's from us.
      (lib.modules.mergeAttrDefinitionsWithPrio options._module.args).pkgs.highestPrio
      == lib.modules.defaultOverridePriority
      # Although, if nixpkgs.pkgs is set, we did forward it, but we did not construct it.
      && !opt.pkgs.isDefined;

    assertions = [
      (
        let
          pkgsSystem = finalPkgs.stdenv.targetPlatform.system;
        in
        {
          assertion = cfg.constructedByUs -> !hasPlatform -> cfg.system == pkgsSystem;
          message = "The nix-darwin nixpkgs.pkgs option was set to a Nixpkgs invocation that compiles to target system ${pkgsSystem} but nix-darwin was configured for system ${config.nixpkgs.system} via nix-darwin option nixpkgs.system. The nix-darwin system settings must match the Nixpkgs target system.";
        }
      )
      {
        assertion = cfg.constructedByUs -> hasPlatform -> legacyOptionsDefined == [ ];
        message = ''
          Your system configures nixpkgs with the platform parameter${lib.optionalString hasBuildPlatform "s"}:
          ${hostPlatformLine}${buildPlatformLine}
          However, it also defines the legacy options:
          ${lib.concatMapStrings lib.showOptionWithDefLocs legacyOptionsDefined}
          For a future proof system configuration, we recommend to remove
          the legacy definitions.
        '';
      }
      {
        assertion = opt.pkgs.isDefined -> cfg.config == { };
        message = ''
          Your system configures nixpkgs with an externally created instance.
          `nixpkgs.config` options should be passed when creating the instance instead.

          Current value:
          ${lib.generators.toPretty { multiline = true; } cfg.config}

          Defined in:
          ${lib.concatMapStringsSep "\n" (file: "  - ${file}") opt.config.files}
        '';
      }
    ];
  };
}
</file>

<file path="modules/power/default.nix">
{ config, lib, ... }:

let
  cfg = config.power;

  types = lib.types;

  onOff = cond: if cond then "on" else "off";
in

{
  options = {
    power.restartAfterPowerFailure = lib.mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to restart the computer after a power failure.

        Option is not supported on all devices.
      '';
    };

    power.restartAfterFreeze = lib.mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to restart the computer after a system freeze.
      '';
    };
  };

  config = {

    system.activationScripts.power.text = ''
      echo "configuring power..." >&2

      ${lib.optionalString (cfg.restartAfterPowerFailure != null) ''
        systemsetup -setRestartPowerFailure \
          '${onOff cfg.restartAfterPowerFailure}' &> /dev/null
      ''}

      ${lib.optionalString (cfg.restartAfterFreeze != null) ''
        systemsetup -setRestartFreeze \
          '${onOff cfg.restartAfterFreeze}' &> /dev/null
      ''}
    '';

  };
}
</file>

<file path="modules/power/sleep.nix">
{ config, lib, ... }:

let
  cfg = config.power.sleep;

  types = lib.types;

  onOff = cond: if cond then "on" else "off";
in

{
  options = {
    power.sleep.computer = lib.mkOption {
      type = types.nullOr (types.either types.ints.positive (types.enum ["never"]));
      default = null;
      example = "never";
      description = ''
        Amount of idle time (in minutes) until the computer sleeps.

        `"never"` disables computer sleeping.

        The system might not be considered idle before connected displays sleep, as
        per the `power.sleep.display` option.
      '';
    };

    power.sleep.display = lib.mkOption {
      type = types.nullOr (types.either types.ints.positive (types.enum ["never"]));
      default = null;
      example = "never";
      description = ''
        Amount of idle time (in minutes) until displays sleep.

        `"never"` disables display sleeping.
      '';
    };

    power.sleep.harddisk = lib.mkOption {
      type = types.nullOr (types.either types.ints.positive (types.enum ["never"]));
      default = null;
      example = "never";
      description = ''
        Amount of idle time (in minutes) until hard disks sleep.

        `"never"` disables hard disk sleeping.
      '';
    };

    power.sleep.allowSleepByPowerButton = lib.mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether the power button can sleep the computer.
      '';
    };
  };

  config = {

    system.activationScripts.power.text = lib.mkAfter ''
      ${lib.optionalString (cfg.computer != null) ''
        systemsetup -setComputerSleep '${toString cfg.computer}' &> /dev/null
      ''}

      ${lib.optionalString (cfg.display != null) ''
        systemsetup -setDisplaySleep '${toString cfg.display}' &> /dev/null
      ''}

      ${lib.optionalString (cfg.harddisk != null) ''
        systemsetup -setHardDiskSleep '${toString cfg.harddisk}' &> /dev/null
      ''}

      ${lib.optionalString (cfg.allowSleepByPowerButton != null) ''
        systemsetup -setAllowPowerButtonToSleepComputer \
          '${onOff cfg.allowSleepByPowerButton}' &> /dev/null
      ''}
    '';

  };
}
</file>

<file path="modules/programs/bash/default.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.programs.bash;
in

{
  imports = [
    (mkRenamedOptionModule [ "programs" "bash" "enableCompletion" ] [ "programs" "bash" "completion" "enable" ])
  ];

  options = {

    programs.bash.enable = mkOption {
      type = types.bool;
      default = true;
      description = "Whether to configure bash as an interactive shell.";
    };

    programs.bash.interactiveShellInit = mkOption {
      default = "";
      description = "Shell script code called during interactive bash shell initialisation.";
      type = types.lines;
    };

    programs.bash.completion = {
      enable = mkOption {
        type = types.bool;
        default = false;
        description = ''
          Enable bash completion for all interactive bash shells.

          NOTE: This doesn't work with bash 3.2, which is installed by default on macOS by Apple.
        '';
      };

      package = mkPackageOption pkgs "bash-completion" { };
    };

  };

  config = mkIf cfg.enable {

    environment.systemPackages =
      [ # Include bash package
        pkgs.bashInteractive
      ] ++ optional cfg.completion.enable cfg.completion.package;

    environment.pathsToLink = optionals cfg.completion.enable
      [ "/etc/bash_completion.d"
        "/share/bash-completion/completions"
      ];

    environment.etc."bashrc".text = ''
      # /etc/bashrc: DO NOT EDIT -- this file has been generated automatically.
      # This file is read for interactive shells.

      [ -r "/etc/bashrc_$TERM_PROGRAM" ] && . "/etc/bashrc_$TERM_PROGRAM"

      # Only execute this file once per shell.
      if [ -n "$__ETC_BASHRC_SOURCED" -o -n "$NOSYSBASHRC" ]; then return; fi
      __ETC_BASHRC_SOURCED=1

      if [ -z "$__NIX_DARWIN_SET_ENVIRONMENT_DONE" ]; then
        . ${config.system.build.setEnvironment}
      fi

      # Return early if not running interactively, but after basic nix setup.
      [[ $- != *i* ]] && return

      # Make bash check its window size after a process completes
      shopt -s checkwinsize

      ${config.system.build.setAliases.text}

      ${config.environment.interactiveShellInit}
      ${cfg.interactiveShellInit}

      ${optionalString cfg.completion.enable ''
        if [ "$TERM" != "dumb" ]; then
          source "${cfg.completion.package}/etc/profile.d/bash_completion.sh"

          nullglobStatus=$(shopt -p nullglob)
          shopt -s nullglob
          for p in $NIX_PROFILES; do
            for m in "$p/etc/bash_completion.d/"*; do
              source $m
            done
          done
          eval "$nullglobStatus"
          unset nullglobStatus p m
        fi
      ''}

      # Read system-wide modifications.
      if test -f /etc/bash.local; then
        source /etc/bash.local
      fi
    '';

    environment.etc."bashrc".knownSha256Hashes = [
      "444c716ac2ccd9e1e3347858cb08a00d2ea38e8c12fdc5798380dc261e32e9ef"  # macOS
      "617b39e36fa69270ddbee19ddc072497dbe7ead840cbd442d9f7c22924f116f4"  # official Nix installer
      "6be16cf7c24a3c6f7ae535c913347a3be39508b3426f5ecd413e636e21031e66"  # official Nix installer
      "08ffbf991a9e25839d38b80a0d3bce3b5a6c84b9be53a4b68949df4e7e487bb7"  # DeterminateSystems installer
    ];

  };
}
</file>

<file path="modules/programs/info/default.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.programs.info;
in

{
  options = {
    programs.info.enable = mkOption {
      type = types.bool;
      default = true;
      description = "Whether to enable info pages and the {command}`info` command.";
    };
  };

  config = mkIf cfg.enable {

    environment.systemPackages = [ pkgs.texinfoInteractive ];

    environment.pathsToLink = [ "/info" "/share/info" ];
    environment.extraOutputsToInstall = [ "info" ];

    environment.extraSetup = ''
      if test -w $out/share/info; then
        shopt -s nullglob
        for i in $out/share/info/*.info $out/share/info/*.info.gz; do
          ${pkgs.texinfoInteractive}/bin/install-info $i $out/share/info/dir
        done
      fi
    '';

  };
}
</file>

<file path="modules/programs/nix-index/default.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.programs.nix-index;
in

{
  options = {
    programs.nix-index.enable = mkOption {
      type = types.bool;
      default = false;
      description = "Whether to enable nix-index and its command-not-found helper.";
    };

    programs.nix-index.package = mkOption {
      type = types.package;
      default = pkgs.nix-index;
      defaultText = "pkgs.nix-index";
      description = "This option specifies the nix-index package to use.";
    };
  };


  config = mkIf config.programs.nix-index.enable {

    environment.systemPackages = [ cfg.package ];

    environment.interactiveShellInit = "source ${cfg.package}/etc/profile.d/command-not-found.sh";

  };
}
</file>

<file path="modules/programs/zsh/default.nix">
{ config, lib, options, pkgs, ... }:

with lib;

let
  cfg = config.programs.zsh;
  opt = options.programs.zsh;

  zshVariables =
    mapAttrsToList (n: v: ''${n}="${v}"'') cfg.variables;

  fzfCompletion = ./fzf-completion.zsh;
  fzfGit = ./fzf-git.zsh;
  fzfHistory = ./fzf-history.zsh;
in

{
  options = {
    programs.zsh.enable = mkOption {
      type = types.bool;
      default = true;
      description = "Whether to configure zsh as an interactive shell.";
    };

    programs.zsh.variables = mkOption {
      type = types.attrsOf (types.either types.str (types.listOf types.str));
      default = {};
      description = ''
        A set of environment variables used in the global environment.
        These variables will be set on shell initialisation.
        The value of each variable can be either a string or a list of
        strings.  The latter is concatenated, interspersed with colon
        characters.
      '';
      apply = mapAttrs (n: v: if isList v then concatStringsSep ":" v else v);
    };

    programs.zsh.shellInit = mkOption {
      type = types.lines;
      default = "";
      description = "Shell script code called during zsh shell initialisation.";
    };

    programs.zsh.loginShellInit = mkOption {
      type = types.lines;
      default = "";
      description = "Shell script code called during zsh login shell initialisation.";
    };

    programs.zsh.interactiveShellInit = mkOption {
      type = types.lines;
      default = "";
      description = "Shell script code called during interactive zsh shell initialisation.";
    };

    programs.zsh.promptInit = mkOption {
      type = types.lines;
      default = "autoload -U promptinit && promptinit && prompt suse && setopt prompt_sp";
      description = "Shell script code used to initialise the zsh prompt.";
    };

    programs.zsh.enableCompletion = mkOption {
      type = types.bool;
      default = true;
      description = "Enable zsh completion for all interactive zsh shells.";
    };

    programs.zsh.enableBashCompletion = mkOption {
      type = types.bool;
      default = true;
      description = "Enable bash completion for all interactive zsh shells.";
    };

    programs.zsh.enableGlobalCompInit = mkOption {
      type = types.bool;
      default = cfg.enableCompletion;
      defaultText = literalExpression "config.${opt.enableCompletion}";
      description = ''
        Enable execution of compinit call for all interactive zsh shells.

        This option can be disabled if the user wants to extend its
        `fpath` and a custom `compinit`
        call in the local config is required.
      '';
    };

    programs.zsh.enableFzfCompletion = mkOption {
      type = types.bool;
      default = false;
      description = "Enable fzf completion.";
    };

    programs.zsh.enableFzfGit = mkOption {
      type = types.bool;
      default = false;
      description = "Enable fzf keybindings for C-g git browsing.";
    };

    programs.zsh.enableFzfHistory = mkOption {
      type = types.bool;
      default = false;
      description = "Enable fzf keybinding for Ctrl-r history search.";
    };

    programs.zsh.enableAutosuggestions = mkOption {
      type = types.bool;
      default = false;
      description = "Enable zsh-autosuggestions.";
    };

    programs.zsh.enableSyntaxHighlighting = mkOption {
      type = types.bool;
      default = false;
      description = "Enable zsh-syntax-highlighting.";
    };

    programs.zsh.enableFastSyntaxHighlighting = mkEnableOption "zsh-fast-syntax-highlighting";
  };

  config = mkIf cfg.enable {

    assertions = [
      {
        assertion = !(cfg.enableSyntaxHighlighting && cfg.enableFastSyntaxHighlighting);
        message = "zsh-syntax-highlighting and zsh-fast-syntax-highlighting are mutually exclusive, please disable one of them.";
      }
    ];
    environment.systemPackages =
      [ # Include zsh package
        pkgs.zsh
      ] ++ optional cfg.enableCompletion pkgs.nix-zsh-completions
        ++ optional cfg.enableAutosuggestions pkgs.zsh-autosuggestions
        ++ optional cfg.enableSyntaxHighlighting pkgs.zsh-syntax-highlighting
        ++ optional cfg.enableFastSyntaxHighlighting pkgs.zsh-fast-syntax-highlighting;

    environment.pathsToLink = [ "/share/zsh" ];

    environment.etc."zshenv".text = ''
      # /etc/zshenv: DO NOT EDIT -- this file has been generated automatically.
      # This file is read for all shells.

      # Only execute this file once per shell.
      if [ -n "''${__ETC_ZSHENV_SOURCED-}" ]; then return; fi
      __ETC_ZSHENV_SOURCED=1

      if [[ -o rcs ]]; then
        if [ -z "''${__NIX_DARWIN_SET_ENVIRONMENT_DONE-}" ]; then
          . ${config.system.build.setEnvironment}
        fi

        # Tell zsh how to find installed completions
        for p in ''${(z)NIX_PROFILES}; do
          fpath=($p/share/zsh/site-functions $p/share/zsh/$ZSH_VERSION/functions $p/share/zsh/vendor-completions $fpath)
        done

        ${cfg.shellInit}
      fi

      # Read system-wide modifications.
      if test -f /etc/zshenv.local; then
        source /etc/zshenv.local
      fi
    '';

    environment.etc."zprofile".text = ''
      # /etc/zprofile: DO NOT EDIT -- this file has been generated automatically.
      # This file is read for login shells.

      # Only execute this file once per shell.
      if [ -n "''${__ETC_ZPROFILE_SOURCED-}" ]; then return; fi
      __ETC_ZPROFILE_SOURCED=1

      ${concatStringsSep "\n" zshVariables}
      ${config.system.build.setAliases.text}

      ${cfg.loginShellInit}

      # Read system-wide modifications.
      if test -f /etc/zprofile.local; then
        source /etc/zprofile.local
      fi
    '';

    environment.etc."zshrc".text = ''
      # /etc/zshrc: DO NOT EDIT -- this file has been generated automatically.
      # This file is read for interactive shells.

      # Only execute this file once per shell.
      if [ -n "$__ETC_ZSHRC_SOURCED" -o -n "$NOSYSZSHRC" ]; then return; fi
      __ETC_ZSHRC_SOURCED=1

      # history defaults
      SAVEHIST=2000
      HISTSIZE=2000
      HISTFILE=$HOME/.zsh_history

      setopt HIST_IGNORE_DUPS SHARE_HISTORY HIST_FCNTL_LOCK

      bindkey -e

      ${config.environment.interactiveShellInit}
      ${cfg.interactiveShellInit}

      ${cfg.promptInit}

      ${optionalString cfg.enableGlobalCompInit "autoload -U compinit && compinit"}
      ${optionalString cfg.enableBashCompletion "autoload -U bashcompinit && bashcompinit"}

      ${optionalString cfg.enableAutosuggestions
        "source ${pkgs.zsh-autosuggestions}/share/zsh-autosuggestions/zsh-autosuggestions.zsh"
      }

      ${optionalString cfg.enableSyntaxHighlighting
        "source ${pkgs.zsh-syntax-highlighting}/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh"
      }

      ${optionalString cfg.enableFastSyntaxHighlighting
        "source ${pkgs.zsh-fast-syntax-highlighting}/share/zsh/site-functions/fast-syntax-highlighting.plugin.zsh"
      }

      ${optionalString cfg.enableFzfCompletion "source ${fzfCompletion}"}
      ${optionalString cfg.enableFzfGit "source ${fzfGit}"}
      ${optionalString cfg.enableFzfHistory "source ${fzfHistory}"}

      # Read system-wide modifications.
      if test -f /etc/zshrc.local; then
        source /etc/zshrc.local
      fi
    '';

    environment.etc."zprofile".knownSha256Hashes = [
      "db8422f92d8cff684e418f2dcffbb98c10fe544b5e8cd588b2009c7fa89559c5"
      "0235d3c1b6cf21e7043fbc98e239ee4bc648048aafaf6be1a94a576300584ef2"  # macOS
      "f320016e2cf13573731fbee34f9fe97ba867dd2a31f24893d3120154e9306e92"  # macOS 26b1 and higher
    ];

    environment.etc."zshrc".knownSha256Hashes = [
      "19a2d673ffd47b8bed71c5218ff6617dfc5e8533b240b9ba79142a45f8823c23"
      "fb5827cb4712b7e7932d438067ec4852c8955a9ff0f55e282473684623ebdfa1"  # macOS
      "4d1ab5704f9d167a042fecac0d056c8a79a8ebd71e032d3489536c8db9ffe3e0"  # macOS 26b1 and higher
      "c5a00c072c920f46216454978c44df044b2ec6d03409dc492c7bdcd92c94a110"  # official Nix installer
      "40b0d8751adae5b0100a4f863be5b75613a49f62706427e92604f7e04d2e2261"  # official Nix installer
      "bf76c5ed8e65e616f4329eccf662ee91be33b8bfd33713ce9946f2fe94fea7fa"  # official Nix installer (macOS 26b1 and higher)
      "2af1b563e389d11b76a651b446e858116d7a20370d9120a7e9f78991f3e5f336"  # DeterminateSystems installer
      "27274e44b88a1174787f9a3d437d3387edc4f9aaaf40356054130797f5dc7912"  # DeterminateSystems installer (macOS 26b1 and higher)
    ];

    environment.etc."zshenv".knownSha256Hashes = [
      "d07015be6875f134976fce84c6c7a77b512079c1c5f9594dfa65c70b7968b65f"  # DeterminateSystems installer
    ];

  };
}
</file>

<file path="modules/programs/zsh/fzf-completion.zsh">
#     ____      ____
#    / __/___  / __/
#   / /_/_  / / /_
#  / __/ / /_/ __/
# /_/   /___/_/-completion.zsh
#
# - $FZF_TMUX               (default: 0)
# - $FZF_TMUX_HEIGHT        (default: '40%')
# - $FZF_COMPLETION_TRIGGER (default: '**')
# - $FZF_COMPLETION_OPTS    (default: empty)

# To use custom commands instead of find, override _fzf_compgen_{path,dir}
if ! declare -f _fzf_compgen_path > /dev/null; then
  _fzf_compgen_path() {
    echo "$1"
    command find -L "$1" \
      -name .git -prune -o -name .svn -prune -o \( -type d -o -type f -o -type l \) \
      -a -not -path "$1" -print 2> /dev/null | sed 's@^\./@@'
  }
fi

if ! declare -f _fzf_compgen_dir > /dev/null; then
  _fzf_compgen_dir() {
    command find -L "$1" \
      -name .git -prune -o -name .svn -prune -o -type d \
      -a -not -path "$1" -print 2> /dev/null | sed 's@^\./@@'
  }
fi

###########################################################

__fzfcmd_complete() {
  [ -n "$TMUX_PANE" ] && [ "${FZF_TMUX:-0}" != 0 ] && [ ${LINES:-40} -gt 15 ] &&
    echo "fzf-tmux -d${FZF_TMUX_HEIGHT:-40%}" || echo "fzf"
}

__fzf_generic_path_completion() {
  local base lbuf compgen fzf_opts suffix tail fzf dir leftover matches
  # (Q) flag removes a quoting level: "foo\ bar" => "foo bar"
  base=${(Q)1}
  lbuf=$2
  compgen=$3
  fzf_opts=$4
  suffix=$5
  tail=$6
  fzf="$(__fzfcmd_complete)"

  setopt localoptions nonomatch
  dir="$base"
  while [ 1 ]; do
    if [[ -z "$dir" || -d ${~dir} ]]; then
      leftover=${base/#"$dir"}
      leftover=${leftover/#\/}
      [ -z "$dir" ] && dir='.'
      [ "$dir" != "/" ] && dir="${dir/%\//}"
      dir=${~dir}
      matches=$(eval "$compgen $(printf %q "$dir")" | FZF_DEFAULT_OPTS="--height ${FZF_TMUX_HEIGHT:-40%} --reverse $FZF_DEFAULT_OPTS $FZF_COMPLETION_OPTS" ${=fzf} ${=fzf_opts} -q "$leftover" | while read item; do
        echo -n "${(q)item}$suffix "
      done)
      matches=${matches% }
      if [ -n "$matches" ]; then
        LBUFFER="$lbuf$matches$tail"
      fi
      zle redisplay
      typeset -f zle-line-init >/dev/null && zle zle-line-init
      break
    fi
    dir=$(dirname "$dir")
    dir=${dir%/}/
  done
}

_fzf_path_completion() {
  __fzf_generic_path_completion "$1" "$2" _fzf_compgen_path \
    "-m" "" " "
}

_fzf_dir_completion() {
  __fzf_generic_path_completion "$1" "$2" _fzf_compgen_dir \
    "" "/" ""
}

_fzf_feed_fifo() (
  command rm -f "$1"
  mkfifo "$1"
  cat <&0 > "$1" &
)

_fzf_complete() {
  local fifo fzf_opts lbuf fzf matches post
  fifo="${TMPDIR:-/tmp}/fzf-complete-fifo-$$"
  fzf_opts=$1
  lbuf=$2
  post="${funcstack[2]}_post"
  type $post > /dev/null 2>&1 || post=cat

  fzf="$(__fzfcmd_complete)"

  _fzf_feed_fifo "$fifo"
  matches=$(cat "$fifo" | FZF_DEFAULT_OPTS="--height ${FZF_TMUX_HEIGHT:-40%} --reverse $FZF_DEFAULT_OPTS $FZF_COMPLETION_OPTS" ${=fzf} ${=fzf_opts} -q "${(Q)prefix}" | $post | tr '\n' ' ')
  if [ -n "$matches" ]; then
    LBUFFER="$lbuf$matches"
  fi
  zle redisplay
  typeset -f zle-line-init >/dev/null && zle zle-line-init
  command rm -f "$fifo"
}

_fzf_complete_docker() {
  local cmd
  cmd=${tokens[2]}
  case $cmd in
    image|push|rmi|run)
      FZF_DEFAULT_OPTS="--min-height 15 $FZF_DEFAULT_OPTS --preview 'docker ps -af ancestor={+3} -n 4' --preview-window down:5:wrap" \
        _fzf_complete '-m --header-lines=1' "$@" < <(docker images)
      ;;
    *)
      FZF_DEFAULT_OPTS="--min-height 15 $FZF_DEFAULT_OPTS --preview 'docker logs --tail=5 {+1}' --preview-window down:5:wrap" \
        _fzf_complete '-m --header-lines=1' "$@" < <(docker ps --all)
      ;;
  esac
}

_fzf_complete_docker_post() {
  local cmd
  cmd=${tokens[2]}
  case $cmd in
    image|push|rmi|run) awk '{ print ($2 == "<none>") ? $3 : $1 ":" $2}' ;;
    *) awk '{print $NF}' ;;
  esac
}

_fzf_complete_git() {
  FZF_DEFAULT_OPTS="--min-height 15 $FZF_DEFAULT_OPTS --preview 'git log -5 --oneline {+1}' --preview-window down:5:wrap" \
    _fzf_complete '-m' "$@" < <(git branch -v)
}

_fzf_complete_git_post() {
  awk '{print $1}'
}

_fzf_complete_telnet() {
  _fzf_complete '+m' "$@" < <(
    command grep -v '^\s*\(#\|$\)' /etc/hosts | command grep -Fv '0.0.0.0' |
        awk '{if (length($2) > 0) {print $2}}' | sort -u
  )
}

_fzf_complete_kill() {
  FZF_DEFAULT_OPTS="--min-height 15 $FZF_DEFAULT_OPTS --preview 'echo {}' --preview-window down:3:wrap" \
    _fzf_complete '-m --header-lines 1' "$@" < <(command ps -ef -r)
}

_fzf_complete_kill_post() {
  awk '{print $2}'
}

_fzf_complete_ssh() {
  _fzf_complete '+m' "$@" < <(
    command cat <(cat ~/.ssh/config /etc/ssh/ssh_config 2> /dev/null | command grep -i '^host' | command grep -v '*') \
        <(command grep -oE '^[a-z0-9.,:-]+' ~/.ssh/known_hosts | tr ',' '\n' | awk '{ print $1 " " $1 }') \
        <(command grep -v '^\s*\(#\|$\)' /etc/hosts | command grep -Fv '0.0.0.0') |
        awk '{if (length($2) > 0) {print $2}}' | sort -u
  )
}

_fzf_complete_export() {
  _fzf_complete '-m' "$@" < <(
    declare -xp | sed 's/=.*//' | sed 's/.* //'
  )
}

_fzf_complete_unset() {
  _fzf_complete '-m' "$@" < <(
    declare -xp | sed 's/=.*//' | sed 's/.* //'
  )
}

_fzf_complete_unalias() {
  _fzf_complete '+m' "$@" < <(
    alias | sed 's/=.*//'
  )
}

fzf-completion() {
  local tokens cmd prefix trigger tail fzf matches lbuf d_cmds
  setopt localoptions noshwordsplit noksh_arrays noposixbuiltins

  # http://zsh.sourceforge.net/FAQ/zshfaq03.html
  # http://zsh.sourceforge.net/Doc/Release/Expansion.html#Parameter-Expansion-Flags
  tokens=(${(z)LBUFFER})
  if [ ${#tokens} -lt 1 ]; then
    zle ${fzf_default_completion:-expand-or-complete}
    return
  fi

  cmd=${tokens[1]}

  # Explicitly allow for empty trigger.
  trigger=${FZF_COMPLETION_TRIGGER-'**'}
  [ -z "$trigger" -a ${LBUFFER[-1]} = ' ' ] && tokens+=("")

  tail=${LBUFFER:$(( ${#LBUFFER} - ${#trigger} ))}
  # Trigger sequence given
  if [ ${#tokens} -gt 1 -a "$tail" = "$trigger" ]; then
    d_cmds=(${=FZF_COMPLETION_DIR_COMMANDS:-cd pushd rmdir})

    [ -z "$trigger"      ] && prefix=${tokens[-1]} || prefix=${tokens[-1]:0:-${#trigger}}
    [ -z "${tokens[-1]}" ] && lbuf=$LBUFFER        || lbuf=${LBUFFER:0:-${#tokens[-1]}}

    if eval "type _fzf_complete_${cmd} > /dev/null"; then
      eval "prefix=\"$prefix\" _fzf_complete_${cmd} \"$lbuf\""
    elif [ ${d_cmds[(i)$cmd]} -le ${#d_cmds} ]; then
      _fzf_dir_completion "$prefix" "$lbuf"
    else
      _fzf_path_completion "$prefix" "$lbuf"
    fi
  # Fall back to default completion
  else
    zle ${fzf_default_completion:-expand-or-complete}
  fi
}

[ -z "$fzf_default_completion" ] && {
  binding=$(bindkey '^I')
  [[ $binding =~ 'undefined-key' ]] || fzf_default_completion=$binding[(s: :w)2]
  unset binding
}

zle     -N   fzf-completion
bindkey '^I' fzf-completion
</file>

<file path="modules/programs/zsh/fzf-git.zsh">
__fzf_is_git__() {
  git rev-parse HEAD > /dev/null 2>&1
}

__fzfcmd_down() {
  fzf --height 50% "$@" --border
}

fzf-gitf() {
  __fzf_is_git__ || return
  git -c color.status=always status --short |
  __fzfcmd_down -m --ansi --nth 2..,.. \
    --preview '(git diff --color=always -- {-1} | sed 1,4d; cat {-1}) | head -500' |
  cut -c4- | sed 's/.* -> //'
}

fzf-gitb() {
  __fzf_is_git__ || return
  git branch -a --color=always | grep -v '/HEAD\s' | sort |
  __fzfcmd_down --ansi --multi --tac --preview-window right:70% \
    --preview 'git log --oneline --graph --date=short --pretty="format:%C(auto)%cd %h%d %s" $(sed s/^..// <<< {} | cut -d" " -f1) | head -'$LINES |
  sed 's/^..//' | cut -d' ' -f1 |
  sed 's#^remotes/##'
}

fzf-gitt() {
  __fzf_is_git__ || return
  git tag --sort -version:refname |
  __fzfcmd_down --multi --preview-window right:70% \
    --preview 'git show --color=always {} | head -'$LINES
}

fzf-gith() {
  __fzf_is_git__ || return
  git log --date=short --format="%C(green)%C(bold)%cd %C(auto)%h%d %s (%an)" --graph --color=always |
  __fzfcmd_down --ansi --no-sort --reverse --multi --bind 'ctrl-s:toggle-sort' \
    --header 'Press CTRL-S to toggle sort' \
    --preview 'grep -o "[a-f0-9]\{7,\}" <<< {} | xargs git show --color=always | head -'$LINES |
  grep -o "[a-f0-9]\{7,\}"
}

fzf-gitr() {
  __fzf_is_git__ || return
  git remote -v | awk '{print $1 "\t" $2}' | uniq |
  __fzfcmd_down --tac \
    --preview 'git log --oneline --graph --date=short --pretty="format:%C(auto)%cd %h%d %s" {1} | head -200' |
  cut -d$'\t' -f1
}

join-lines() {
  local item
  while read item; do
    echo -n "${(q)item} "
  done
}

bind-git-helper() {
  local char
  for c in $@; do
    eval "fzf-git$c-widget() { local result=\$(fzf-git$c | join-lines); zle reset-prompt; LBUFFER+=\$result }"
    eval "zle -N fzf-git$c-widget"
    eval "bindkey '^g$c' fzf-git$c-widget"
  done
}

bind-git-helper f b t r h
unset -f bind-git-helper
</file>

<file path="modules/programs/zsh/fzf-history.zsh">
__fzf_use_tmux__() {
  [ -n "$TMUX_PANE" ] && [ "${FZF_TMUX:-0}" != 0 ] && [ ${LINES:-40} -gt 15 ]
}

__fzfcmd() {
  __fzf_use_tmux__ &&
    echo "fzf-tmux -d${FZF_TMUX_HEIGHT:-40%}" || echo "fzf"
}

# CTRL-R - Paste the selected command from history into the command line
fzf-history-widget() {
  local selected num
  setopt localoptions noglobsubst pipefail 2> /dev/null
  selected=( $(fc -l 1 |
    FZF_DEFAULT_OPTS="--height ${FZF_TMUX_HEIGHT:-40%} --reverse $FZF_DEFAULT_OPTS +s --tac -n2..,.. --tiebreak=index --bind=ctrl-r:toggle-sort $FZF_CTRL_R_OPTS --query=${(q)LBUFFER} +m" $(__fzfcmd)) )
  local ret=$?
  if [ -n "$selected" ]; then
    num=$selected[1]
    if [ -n "$num" ]; then
      zle vi-fetch-history -n $num
    fi
  fi
  zle redisplay
  typeset -f zle-line-init >/dev/null && zle zle-line-init
  return $ret
}

zle     -N   fzf-history-widget
bindkey '^R' fzf-history-widget
</file>

<file path="modules/programs/_1password-gui.nix">
{
  config,
  pkgs,
  lib,
  ...
}:

let
  cfg = config.programs._1password-gui;
in
{
  options = {
    programs._1password-gui = {
      enable = lib.mkEnableOption "the 1Password GUI application";

      package = lib.mkPackageOption pkgs "1Password GUI" {
        default = [ "_1password-gui" ];
      };
    };
  };

  config = lib.mkIf cfg.enable {
    # Based on https://github.com/reckenrode/nixos-configs/blob/22b8357fc6ffbd0df5ce50dc417c23a807a268a2/modules/by-name/1p/1password/darwin-module.nix
    system.activationScripts.applications.text = lib.mkAfter ''
      install -o root -g wheel -m0555 -d "/Applications/1Password.app"

      rsyncFlags=(
        # mtime is standardized in the nix store, which would leave only file size to distinguish files.
        # Thus we need checksums, despite the speed penalty.
        --checksum
        # Converts all symlinks pointing outside of the copied tree (thus unsafe) into real files and directories.
        # This neatly converts all the symlinks pointing to application bundles in the nix store into
        # real directories, without breaking any relative symlinks inside of application bundles.
        # This is good enough, because the make-symlinks-relative.sh setup hook converts all $out internal
        # symlinks to relative ones.
        --copy-unsafe-links
        --archive
        --delete
        --chmod=-w
        --no-group
        --no-owner
      )

      ${lib.getExe pkgs.rsync} "''${rsyncFlags[@]}" \
        ${cfg.package}/Applications/1Password.app/ /Applications/1Password.app
    '';
  };
}
</file>

<file path="modules/programs/_1password.nix">
{
  config,
  pkgs,
  lib,
  ...
}:

let
  cfg = config.programs._1password;
in
{
  options = {
    programs._1password = {
      enable = lib.mkEnableOption "the 1Password CLI tool";

      package = lib.mkPackageOption pkgs "1Password CLI" {
        default = [ "_1password-cli" ];
      };
    };
  };

  config = lib.mkIf cfg.enable {
    # Integration with the 1Password GUI will only work if the CLI at `/usr/local/bin/op`
    # Based on https://github.com/reckenrode/nixos-configs/blob/22b8357fc6ffbd0df5ce50dc417c23a807a268a2/modules/by-name/1p/1password/darwin-module.nix
    system.activationScripts.applications.text = lib.mkAfter ''
      install -o root -g wheel -m0555 -D \
        ${lib.getExe cfg.package} /usr/local/bin/op
    '';
  };
}
</file>

<file path="modules/programs/arqbackup.nix">
{
  config,
  pkgs,
  lib,
  ...
}:

let
  cfg = config.programs.arqbackup;
in
{
  options = {
    programs.arqbackup = {
      enable = lib.mkEnableOption "Arq backup";

      # If `arq` is not available then we set `default` to `null` to prevent
      # eval from breaking while `arq` hasn't been merged yet. Only if a user
      # enables the module will they be required to set this option.
      package = lib.mkPackageOption pkgs "arq" (lib.optionalAttrs (!pkgs ? arq) { default = null; });
    };
  };

  config = lib.mkIf cfg.enable {
    environment.systemPackages = [ cfg.package ];

    launchd.daemons.arqagent = {
      command = "${cfg.package}/Applications/Arq.app/Contents/Resources/ArqAgent.app/Contents/MacOS/ArqAgent";
      serviceConfig.Label = "com.haystacksoftware.arqagent";
      serviceConfig.RunAtLoad = true;
      serviceConfig.KeepAlive = true;
    };

    launchd.user.agents.ArqMonitor = {
      command = "${cfg.package}/Applications/Arq.app/Contents/Resources/ArqMonitor.app/Contents/MacOS/ArqMonitor";
      serviceConfig.Label = "com.haystacksoftware.ArqMonitor";
      serviceConfig.RunAtLoad = true;
      serviceConfig.KeepAlive = true;
      managedBy = "programs.arqbackup.enable";
    };
  };
}
</file>

<file path="modules/programs/direnv.nix">
{
  lib,
  config,
  pkgs,
  ...
}: let
  cfg = config.programs.direnv;
  format = pkgs.formats.toml {};
in {
  meta.maintainers = [
    lib.maintainers.mattpolzin or "mattpolzin"
  ];
  options.programs.direnv = {
    enable = lib.mkEnableOption ''
      direnv integration. Takes care of both installation and
      setting up the sourcing of the shell. Additionally enables nix-direnv
      integration.
    '';

    package = lib.mkPackageOption pkgs "direnv" {};

    finalPackage = lib.mkOption {
      type = lib.types.package;
      readOnly = true;
      description = "The wrapped direnv package.";
    };

    direnvrcExtra = lib.mkOption {
      type = lib.types.lines;
      default = "";
      example = ''
        export FOO="foo"
        echo "loaded direnv!"
      '';
      description = ''
        Extra lines to append to the sourced direnvrc
      '';
    };

    silent = lib.mkEnableOption ''
      the hiding of direnv logging
    '';

    loadInNixShell =
      (lib.mkEnableOption ''
        loading direnv in `nix-shell` `nix shell` or `nix develop`
      '')
      // {
        default = true;
      };

    nix-direnv = {
      enable =
        (lib.mkEnableOption ''
          a faster, persistent implementation of use_nix and use_flake, to replace the built-in one
        '')
        // {
          default = true;
        };

      package = lib.mkPackageOption pkgs "nix-direnv" {};
    };

    settings = lib.mkOption {
      inherit (format) type;
      default = {};
      example = lib.literalExpression ''
        {
          global = {
            log_format = "-";
            log_filter = "^$";
          };
        }
      '';
      description = ''
        Direnv configuration. Refer to {manpage}`direnv.toml(1)`.
      '';
    };
  };

  config = lib.mkIf cfg.enable {
    programs = {
      direnv = {
        finalPackage = pkgs.symlinkJoin {
          inherit (cfg.package) name;
          paths = [cfg.package];
          # direnv has a fish library which automatically sources direnv for some reason
          postBuild = ''
            rm -rf "$out/share/fish"
          '';
          meta.mainProgram = "direnv";
        };
        settings = lib.mkIf cfg.silent {
          global = {
            log_format = lib.mkDefault "-";
            log_filter = lib.mkDefault "^$";
          };
        };
      };
      zsh.interactiveShellInit = ''
        if ${lib.boolToString cfg.loadInNixShell} || printenv PATH | grep -vqc '/nix/store'; then
         eval "$(${lib.getExe cfg.finalPackage} hook zsh)"
        fi
      '';

      #$NIX_GCROOT for "nix develop" https://github.com/NixOS/nix/blob/6db66ebfc55769edd0c6bc70fcbd76246d4d26e0/src/nix/develop.cc#L530
      #$IN_NIX_SHELL for "nix-shell"
      bash.interactiveShellInit = ''
        if ${lib.boolToString cfg.loadInNixShell} || [ -z "$IN_NIX_SHELL$NIX_GCROOT$(printenv PATH | grep '/nix/store')" ] ; then
         eval "$(${lib.getExe cfg.finalPackage} hook bash)"
        fi
      '';

      fish.interactiveShellInit = ''
        if ${lib.boolToString cfg.loadInNixShell};
        or printenv PATH | grep -vqc '/nix/store';
         ${lib.getExe cfg.finalPackage} hook fish | source
        end
      '';
    };

    environment = {
      systemPackages = [
        cfg.finalPackage
      ];
      variables = {
        DIRENV_CONFIG = "/etc/direnv";
      };
      etc = {
        "direnv/direnv.toml".source = lib.mkIf (cfg.settings != {}) (
          format.generate "direnv.toml" cfg.settings
        );
        "direnv/direnvrc".text = ''
          ${lib.optionalString cfg.nix-direnv.enable ''
            #Load nix-direnv
            source ${cfg.nix-direnv.package}/share/nix-direnv/direnvrc
          ''}

           #Load direnvrcExtra
           ${cfg.direnvrcExtra}

           #Load user-configuration if present (~/.direnvrc or ~/.config/direnv/direnvrc)
           direnv_config_dir_home="''${DIRENV_CONFIG_HOME:-''${XDG_CONFIG_HOME:-$HOME/.config}/direnv}"
           if [[ -f $direnv_config_dir_home/direnvrc ]]; then
             source "$direnv_config_dir_home/direnvrc" >&2
           elif [[ -f $HOME/.direnvrc ]]; then
             source "$HOME/.direnvrc" >&2
           fi

           unset direnv_config_dir_home
        '';

        "direnv/lib/zz-user.sh".text = ''
          direnv_config_dir_home="''${DIRENV_CONFIG_HOME:-''${XDG_CONFIG_HOME:-$HOME/.config}/direnv}"

          for lib in "$direnv_config_dir_home/lib/"*.sh; do
            source "$lib"
          done

          unset direnv_config_dir_home
        '';
      };
    };
  };
}
</file>

<file path="modules/programs/fish.nix">
{ config, lib, pkgs, ... }:

with lib;

let

  cfge = config.environment;

  cfg = config.programs.fish;

  fishAbbrs = concatStringsSep "\n" (
    mapAttrsToList (k: v: "abbr -a ${k} -- ${escapeShellArg v}") cfg.shellAbbrs
  );

  fishAliases = concatStringsSep "\n" (
    mapAttrsToList (k: v: "alias ${k} ${escapeShellArg v}")
      (filterAttrs (k: v: v != null) cfg.shellAliases)
  );

  envShellInit = pkgs.writeText "shellInit" cfge.shellInit;

  envLoginShellInit = pkgs.writeText "loginShellInit" cfge.loginShellInit;

  envInteractiveShellInit = pkgs.writeText "interactiveShellInit" cfge.interactiveShellInit;

  fenv = pkgs.fishPlugins.foreign-env or pkgs.fish-foreign-env;

  # fishPlugins.foreign-env and fish-foreign-env have different function paths
  fenvFunctionsDir = if (pkgs ? fishPlugins.foreign-env)
    then "${fenv}/share/fish/vendor_functions.d"
    else "${fenv}/share/fish-foreign-env/functions";

  sourceEnv = file:
  if cfg.useBabelfish then
    "source /etc/fish/${file}.fish"
  else
    ''
      set fish_function_path ${fenvFunctionsDir} $fish_function_path
      fenv source /etc/fish/foreign-env/${file} > /dev/null
      set -e fish_function_path[1]
    '';

  babelfishTranslate = path: name:
    pkgs.runCommand "${name}.fish" {} ''
      ${cfg.babelfishPackage}/bin/babelfish < ${path} > $out
    '';

in

{

  options = {

    programs.fish = {

      enable = mkOption {
        default = false;
        description = ''
          Whether to configure fish as an interactive shell.
        '';
        type = types.bool;
      };

      package = lib.mkPackageOption pkgs "fish" { };

      useBabelfish = mkOption {
        type = types.bool;
        default = false;
        description = ''
          If enabled, the configured environment will be translated to native fish using [babelfish](https://github.com/bouk/babelfish).
          Otherwise, [foreign-env](https://github.com/oh-my-fish/plugin-foreign-env) will be used.
        '';
      };

      babelfishPackage = mkOption {
        type = types.package;
        default = pkgs.babelfish;
        description = ''
          The babelfish package to use when useBabelfish is
          set to true.
        '';
      };

      vendor.config.enable = mkOption {
        type = types.bool;
        default = true;
        description = ''
          Whether fish should source configuration snippets provided by other packages.
        '';
      };

      vendor.completions.enable = mkOption {
        type = types.bool;
        default = true;
        description = ''
          Whether fish should use completion files provided by other packages.
        '';
      };

      vendor.functions.enable = mkOption {
        type = types.bool;
        default = true;
        description = ''
          Whether fish should autoload fish functions provided by other packages.
        '';
      };

      shellAbbrs = mkOption {
        default = {};
        example = {
          gco = "git checkout";
          npu = "nix-prefetch-url";
        };
        description = ''
          Set of fish abbreviations.
        '';
        type = with types; attrsOf str;
      };

      shellAliases = mkOption {
        default = config.environment.shellAliases;
        description = ''
          Set of aliases for fish shell. See {option}`environment.shellAliases`
          for an option format description.
        '';
        type = types.attrs;
      };

      shellInit = mkOption {
        default = "";
        description = ''
          Shell script code called during fish shell initialisation.
        '';
        type = types.lines;
      };

      loginShellInit = mkOption {
        default = "";
        description = ''
          Shell script code called during fish login shell initialisation.
        '';
        type = types.lines;
      };

      interactiveShellInit = mkOption {
        default = "";
        description = ''
          Shell script code called during interactive fish shell initialisation.
        '';
        type = types.lines;
      };

      promptInit = mkOption {
        default = "";
        description = ''
          Shell script code used to initialise fish prompt.
        '';
        type = types.lines;
      };

    };

  };

  config = mkIf cfg.enable {

    environment = mkMerge [
      (mkIf cfg.useBabelfish
      {
        etc."fish/setEnvironment.fish".source = babelfishTranslate config.system.build.setEnvironment "setEnvironment";
        etc."fish/shellInit.fish".source = babelfishTranslate envShellInit "shellInit";
        etc."fish/loginShellInit.fish".source = babelfishTranslate envLoginShellInit "loginShellInit";
        etc."fish/interactiveShellInit.fish".source = babelfishTranslate envInteractiveShellInit "interactiveShellInit";
     })

      (mkIf (!cfg.useBabelfish)
      {
        etc."fish/foreign-env/shellInit".source = envShellInit;
        etc."fish/foreign-env/loginShellInit".source = envLoginShellInit;
        etc."fish/foreign-env/interactiveShellInit".source = envInteractiveShellInit;
      })

      {
        etc."fish/nixos-env-preinit.fish".text =
        if cfg.useBabelfish
        then ''
          # source the NixOS environment config
          if [ -z "$__NIX_DARWIN_SET_ENVIRONMENT_DONE" ]
            source /etc/fish/setEnvironment.fish
          end
        ''
        else ''
          # This happens before $__fish_datadir/config.fish sets fish_function_path, so it is currently
          # unset. We set it and then completely erase it, leaving its configuration to $__fish_datadir/config.fish
          set fish_function_path ${fenvFunctionsDir} $__fish_datadir/functions

          # source the NixOS environment config
          if [ -z "$__NIX_DARWIN_SET_ENVIRONMENT_DONE" ]
            fenv source ${config.system.build.setEnvironment}
          end

          # clear fish_function_path so that it will be correctly set when we return to $__fish_datadir/config.fish
          set -e fish_function_path
        '';
      }
      {
        etc."fish/config.fish".text = ''
        # /etc/fish/config.fish: DO NOT EDIT -- this file has been generated automatically.

        # if we haven't sourced the general config, do it
        if not set -q __fish_nix_darwin_general_config_sourced
          ${sourceEnv "shellInit"}

          ${cfg.shellInit}

          # and leave a note so we don't source this config section again from
          # this very shell (children will source the general config anew)
          set -g __fish_nix_darwin_general_config_sourced 1
        end

        # if we haven't sourced the login config, do it
        status --is-login; and not set -q __fish_nix_darwin_login_config_sourced
        and begin
          ${sourceEnv "loginShellInit"}

          ${cfg.loginShellInit}

          # and leave a note so we don't source this config section again from
          # this very shell (children will source the general config anew)
          set -g __fish_nix_darwin_login_config_sourced 1
        end

        # if we haven't sourced the interactive config, do it
        status --is-interactive; and not set -q __fish_nix_darwin_interactive_config_sourced
        and begin
          ${fishAbbrs}
          ${fishAliases}

          ${sourceEnv "interactiveShellInit"}

          ${cfg.promptInit}
          ${cfg.interactiveShellInit}

          # and leave a note so we don't source this config section again from
          # this very shell (children will source the general config anew,
          # allowing configuration changes in, e.g, aliases, to propagate)
          set -g __fish_nix_darwin_interactive_config_sourced 1
        end
      '';
      }

      # include programs that bring their own completions
      {
        pathsToLink = []
          ++ optional cfg.vendor.config.enable "/share/fish/vendor_conf.d"
          ++ optional cfg.vendor.completions.enable "/share/fish/vendor_completions.d"
          ++ optional cfg.vendor.functions.enable "/share/fish/vendor_functions.d";
      }

      { systemPackages = [ cfg.package ]; }
    ];
  };

}
</file>

<file path="modules/programs/gnupg.nix">
{ config, lib, pkgs, ... }:

with lib;

let

  cfg = config.programs.gnupg;

in

{
  options.programs.gnupg = {
    agent.enable = mkOption {
      type = types.bool;
      default = false;
      description = ''
        Enables GnuPG agent for every user session.
      '';
    };

    agent.enableSSHSupport = mkOption {
      type = types.bool;
      default = false;
      description = ''
        Enable SSH agent support in GnuPG agent. Also sets SSH_AUTH_SOCK
        environment variable correctly.
      '';
    };
  };

  config = mkIf cfg.agent.enable {
    launchd.user.agents.gnupg-agent.serviceConfig = {
      ProgramArguments = [
        "${pkgs.gnupg}/bin/gpg-connect-agent" "/bye"
      ];
      RunAtLoad = cfg.agent.enableSSHSupport;
      KeepAlive.SuccessfulExit = false;
    };

    environment.extraInit = ''
      # Bind gpg-agent to this TTY if gpg commands are used.
      export GPG_TTY=$(tty)
    '' + (optionalString cfg.agent.enableSSHSupport ''
      # SSH agent protocol doesn't support changing TTYs, so bind the agent
      # to every new TTY.
      ${pkgs.gnupg}/bin/gpg-connect-agent --quiet updatestartuptty /bye > /dev/null 2>&1

      export SSH_AUTH_SOCK=$(${pkgs.gnupg}/bin/gpgconf --list-dirs agent-ssh-socket)
    '');
  };
}
</file>

<file path="modules/programs/man.nix">
{ config, lib, pkgs, ... }:

with lib;

{
  options = {

    programs.man.enable = mkOption {
      type = types.bool;
      default = true;
      description = ''
        Whether to enable manual pages and the {command}`man` command.
        This also includes "man" outputs of all `systemPackages`.
      '';
    };

  };


  config = mkIf config.programs.man.enable {

    environment.pathsToLink = [ "/share/man" ];

    environment.extraOutputsToInstall = [ "man" ];

  };
}
</file>

<file path="modules/programs/ssh.nix">
{ config, lib, ... }:

let
  cfg = config.programs.ssh;

  knownHosts = builtins.attrValues cfg.knownHosts;

  host =
    { name, config, ... }:
    {
      options = {
        certAuthority = lib.mkOption {
          type = lib.types.bool;
          default = false;
          description = ''
            This public key is an SSH certificate authority, rather than an
            individual host's key.
          '';
        };
        hostNames = lib.mkOption {
          type = lib.types.listOf lib.types.str;
          default = [ name ] ++ config.extraHostNames;
          description = ''
            The set of system-wide known SSH hosts. To make simple setups more
            convenient the name of an attribute in this set is used as a host name
            for the entry. This behaviour can be disabled by setting
            `hostNames` explicitly. You can use
            `extraHostNames` to add additional host names without
            disabling this default.
          '';
        };
        extraHostNames = lib.mkOption {
          type = lib.types.listOf lib.types.str;
          default = [];
          description = ''
            A list of additional host names and/or IP numbers used for
            accessing the host's ssh service. This list is ignored if
            `hostNames` is set explicitly.
          '';
        };
        publicKey = lib.mkOption {
          default = null;
          type = lib.types.nullOr lib.types.str;
          example = "ecdsa-sha2-nistp521 AAAAE2VjZHN...UEPg==";
          description = ''
            The public key data for the host. You can fetch a public key
            from a running SSH server with the {command}`ssh-keyscan`
            command. The public key should not include any host names, only
            the key type and the key itself.
          '';
        };
        publicKeyFile = lib.mkOption {
          default = null;
          type = lib.types.nullOr lib.types.path;
          description = ''
            The path to the public key file for the host. The public
            key file is read at build time and saved in the Nix store.
            You can fetch a public key file from a running SSH server
            with the {command}`ssh-keyscan` command. The content
            of the file should follow the same format as described for
            the `publicKey` option.
          '';
        };
      };
    };
  # Taken from: https://github.com/NixOS/nixpkgs/blob/f4aa6afa5f934ece2d1eb3157e392d056be01617/nixos/modules/services/networking/ssh/sshd.nix#L46-L93
  userOptions = {

    options.openssh.authorizedKeys = {
      keys = lib.mkOption {
        type = lib.types.listOf lib.types.str;
        default = [];
        description = ''
          A list of verbatim OpenSSH public keys that should be added to the
          user's authorized keys. The keys are added to a file that the SSH
          daemon reads in addition to the the user's authorized_keys file.
          You can combine the `keys` and
          `keyFiles` options.
          Warning: If you are using `NixOps` then don't use this
          option since it will replace the key required for deployment via ssh.
        '';
      };

      keyFiles = lib.mkOption {
        type = lib.types.listOf lib.types.path;
        default = [];
        description = ''
          A list of files each containing one OpenSSH public key that should be
          added to the user's authorized keys. The contents of the files are
          read at build time and added to a file that the SSH daemon reads in
          addition to the the user's authorized_keys file. You can combine the
          `keyFiles` and `keys` options.
        '';
      };
    };

  };

  authKeysFiles = let
    mkAuthKeyFile = u: lib.nameValuePair "ssh/nix_authorized_keys.d/${u.name}" {
      text = ''
        ${builtins.concatStringsSep "\n" u.openssh.authorizedKeys.keys}
        ${lib.concatMapStrings (f: builtins.readFile f + "\n") u.openssh.authorizedKeys.keyFiles}
      '';
    };
    usersWithKeys = builtins.attrValues (lib.flip lib.filterAttrs config.users.users (n: u:
      lib.length u.openssh.authorizedKeys.keys != 0 || lib.length u.openssh.authorizedKeys.keyFiles != 0
    ));
  in lib.listToAttrs (map mkAuthKeyFile usersWithKeys);

  oldAuthorizedKeysHash = "5a5dc1e20e8abc162ad1cc0259bfd1dbb77981013d87625f97d9bd215175fc0a";
in

{
  imports = [
    (lib.mkRemovedOptionModule [ "services" "openssh" "authorizedKeysFiles" ] "No `nix-darwin` equivalent to this NixOS option.")
  ];

  options = {

    users.users = lib.mkOption {
      type = with lib.types; attrsOf (submodule userOptions);
    };

    programs.ssh.extraConfig = lib.mkOption {
      type = lib.types.lines;
      default = "";
      description = ''
        Extra configuration text loaded in {file}`ssh_config`.
        See {manpage}`ssh_config(5)` for help.
      '';
    };

    programs.ssh.knownHosts = lib.mkOption {
      default = {};
      type = lib.types.attrsOf (lib.types.submodule host);
      description = ''
        The set of system-wide known SSH hosts. To make simple setups more
        convenient the name of an attribute in this set is used as a host name
        for the entry. This behaviour can be disabled by setting
        `hostNames` explicitly. You can use
        `extraHostNames` to add additional host names without
        disabling this default.
      '';
      example = lib.literalExpression ''
        {
          myhost = {
            extraHostNames = [ "myhost.mydomain.com" "10.10.1.4" ];
            publicKeyFile = ./pubkeys/myhost_ssh_host_dsa_key.pub;
          };
          "myhost2.net".publicKey = "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAILIRuJ8p1Fi+m6WkHV0KWnRfpM1WxoW8XAS+XvsSKsTK";
          "myhost2.net/dsa" = {
            hostNames = [ "myhost2.net" ];
            publicKeyFile = ./pubkeys/myhost2_ssh_host_dsa_key.pub;
          };
        }
      '';
    };
  };

  config = {

    assertions = lib.flip lib.mapAttrsToList cfg.knownHosts (name: data: {
      assertion = (data.publicKey == null && data.publicKeyFile != null) ||
                  (data.publicKey != null && data.publicKeyFile == null);
      message = "knownHost ${name} must contain either a publicKey or publicKeyFile";
    });

    environment.etc = authKeysFiles //
      { "ssh/ssh_known_hosts" = lib.mkIf (builtins.length knownHosts > 0) {
          text = (lib.flip (lib.concatMapStringsSep "\n") knownHosts
            (h: assert h.hostNames != [];
              lib.optionalString h.certAuthority "@cert-authority " + builtins.concatStringsSep "," h.hostNames + " "
              + (if h.publicKey != null then h.publicKey else builtins.readFile h.publicKeyFile)
            )) + "\n";
        };
        "ssh/ssh_config.d/100-nix-darwin.conf".text = config.programs.ssh.extraConfig;
        "ssh/sshd_config.d/101-authorized-keys.conf" = {
          text = ''
            # sshd doesn't like reading from symbolic links, so we cat
            # the file ourselves.
            AuthorizedKeysCommand /bin/cat /etc/ssh/nix_authorized_keys.d/%u
            # Just a simple cat, fine to use _sshd.
            AuthorizedKeysCommandUser _sshd
          '';
          # Allows us to automatically migrate from using a file to a symlink
          knownSha256Hashes = [ oldAuthorizedKeysHash ];
        };
      };

    system.activationScripts.etc.text = ''
      # Clean up .before-nix-darwin file left over from using knownSha256Hashes
      auth_keys_orig=/etc/ssh/sshd_config.d/101-authorized-keys.conf.before-nix-darwin

      if [ -e "$auth_keys_orig" ] && [ "$(shasum -a 256 $auth_keys_orig | cut -d ' ' -f 1)" = "${oldAuthorizedKeysHash}" ]; then
        rm "$auth_keys_orig"
      fi
    '';
  };
}
</file>

<file path="modules/programs/tmux.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  inherit (pkgs) stdenv;

  cfg = config.programs.tmux;

  tmux = pkgs.runCommand pkgs.tmux.name
    { buildInputs = [ pkgs.makeWrapper ]; }
    ''
      source $stdenv/setup

      mkdir -p $out/bin
      makeWrapper ${pkgs.tmux}/bin/tmux $out/bin/tmux \
        --set __ETC_BASHRC_SOURCED "" \
        --set __ETC_ZPROFILE_SOURCED  "" \
        --set __ETC_ZSHENV_SOURCED "" \
        --set __ETC_ZSHRC_SOURCED "" \
        --set __NIX_DARWIN_SET_ENVIRONMENT_DONE "" \
        --add-flags -f --add-flags /etc/tmux.conf
    '';

  text = import ../lib/write-text.nix {
    inherit lib;
    mkTextDerivation = name: text: pkgs.writeText "tmux-options-${name}" text;
  };

  tmuxOptions = concatMapStringsSep "\n" (attr: attr.text) (attrValues cfg.tmuxOptions);

  fzfTmuxSession = pkgs.writeScript "fzf-tmux-session" ''
    #! ${stdenv.shell}
    set -e

    session=$(tmux list-sessions -F '#{session_name}' | fzf --query="$1" --exit-0)
    tmux switch-client -t "$session"
  '';
in

{
  imports = [
    (mkRenamedOptionModule [ "programs" "tmux" "tmuxConfig" ] [ "programs" "tmux" "extraConfig" ])
    (mkRemovedOptionModule [ "programs" "tmux" "defaultCommand" ] "Use `programs.tmux.extraConfig` to configure the default command instead. If unset, tmux will default to using your system configured login shell.")
  ];
  options = {
    programs.tmux.enable = mkOption {
      type = types.bool;
      default = false;
      description = "Whether to configure tmux.";
    };

    programs.tmux.enableSensible = mkOption {
      type = types.bool;
      default = false;
      example = true;
      description = "Enable sensible configuration options for tmux.";
    };

    programs.tmux.enableMouse = mkOption {
      type = types.bool;
      default = false;
      example = true;
      description = "Enable mouse support for tmux.";
    };

    programs.tmux.enableFzf = mkOption {
      type = types.bool;
      default = false;
      example = true;
      description = "Enable fzf keybindings for selecting tmux sessions and panes.";
    };

    programs.tmux.enableVim = mkOption {
      type = types.bool;
      default = false;
      example = true;
      description = "Enable vim style keybindings for copy mode, and navigation of tmux panes.";
    };

    programs.tmux.iTerm2 = mkOption {
      type = types.bool;
      default = false;
      example = true;
      description = "Cater to iTerm2 and its tmux integration, as appropriate.";
    };

    programs.tmux.tmuxOptions = mkOption {
      internal = true;
      type = types.attrsOf (types.submodule text);
      default = {};
    };

    programs.tmux.extraConfig = mkOption {
      type = types.lines;
      default = "";
      description = "Extra configuration to add to {file}`tmux.conf`.";
    };
  };

  config = mkIf cfg.enable {

    warnings = mkIf cfg.iTerm2 [
      "The programs.tmux.iTerm2 is no longer needed and doesn't do anything anymore"
    ];

    environment.systemPackages =
      [ # Include wrapped tmux package.
        tmux
      ];

    environment.etc."tmux.conf".text = ''
      ${tmuxOptions}
      ${cfg.extraConfig}

      source-file -q /etc/tmux.conf.local
    '';

    programs.tmux.tmuxOptions.sensible.text = mkIf cfg.enableSensible ''
      set -g default-terminal "screen-256color"
      setw -g aggressive-resize on

      set -g base-index 1
      set -g renumber-windows on

      set -g status-keys emacs
      set -s escape-time 0

      bind c new-window -c '#{pane_current_path}'
      bind % split-window -v -c '#{pane_current_path}'
      bind '"' split-window -h -c '#{pane_current_path}'

      # TODO: make these interactive
      bind C new-session
      bind S switch-client -l

      # set -g status-utf8 on
      # set -g utf8 on
    '';

    programs.tmux.tmuxOptions.mouse.text = mkIf cfg.enableMouse ''
      set -g mouse on
      setw -g mouse on
      set -g terminal-overrides 'xterm*:smcup@:rmcup@'
    '';

    programs.tmux.tmuxOptions.fzf.text = mkIf cfg.enableFzf ''
      bind-key -n M-p run "tmux split-window -p 40 -c '#{pane_current_path}' 'tmux send-keys -t #{pane_id} \"$(fzf -m | paste -sd\\  -)\"'"
      bind-key -n M-s run "tmux split-window -p 40 'tmux send-keys -t #{pane_id} \"$(${fzfTmuxSession})\"'"
    '';

    programs.tmux.tmuxOptions.vim.text = mkIf cfg.enableVim (''
      setw -g mode-keys vi

      bind h select-pane -L
      bind j select-pane -D
      bind k select-pane -U
      bind l select-pane -R
      bind s split-window -v -c '#{pane_current_path}'
      bind v split-window -h -c '#{pane_current_path}'

      bind-key -T copy-mode-vi p send-keys -X copy-pipe-and-cancel "tmux paste-buffer"
      bind-key -T copy-mode-vi v send-keys -X begin-selection
    '' + optionalString stdenv.isLinux ''
      bind-key -T copy-mode-vi y send-keys -X copy-selection-and-cancel
    '' + optionalString stdenv.isDarwin ''
      bind-key -T copy-mode-vi y send-keys -X copy-pipe-and-cancel "pbcopy"
    '');

  };
}
</file>

<file path="modules/programs/vim.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.programs.vim;

  text = import ../lib/write-text.nix {
    inherit lib;
    mkTextDerivation = name: text: pkgs.writeText "vim-options-${name}" text;
  };

  vimOptions = concatMapStringsSep "\n" (attr: attr.text) (attrValues cfg.vimOptions);
in

{
  options = {
    programs.vim.enable = mkOption {
      type = types.bool;
      default = false;
      description = "Whether to configure vim.";
    };

    programs.vim.enableSensible = mkOption {
      type = types.bool;
      default = false;
      example = true;
      description = "Enable sensible configuration options for vim.";
    };

    programs.vim.extraKnownPlugins = mkOption {
      type = types.attrsOf types.package;
      default = {};
      example = literalExpression
        ''
        {
          vim-jsx = pkgs.vimUtils.buildVimPluginFrom2Nix {
            name = "vim-javascript-2016-07-29";
            src = pkgs.fetchgit {
              url = "git://github.com/mxw/vim-jsx";
              rev = "261114c925ea81eeb4db1651cc1edced66d6b5d6";
              sha256 = "17pffzwnvsimnnr4ql1qifdh4a0sqqsmcwfiqqzgglvsnzw5vpls";
            };
            dependencies = [];

          };
        }
        '';
      description = "Custom plugin declarations to add to VAM's knownPlugins.";
    };

    programs.vim.plugins = mkOption {
      type = types.listOf types.attrs;
      default = [];
      example = [ { names = [ "surround" "vim-nix" ]; } ];
      description = "VAM plugin dictionaries to use for vim_configurable.";
    };

    programs.vim.package = mkOption {
      internal = true;
      type = types.package;
    };

    programs.vim.vimOptions = mkOption {
      internal = true;
      type = types.attrsOf (types.submodule text);
      default = {};
    };

    programs.vim.vimConfig = mkOption {
      type = types.lines;
      default = "";
      description = "Extra vimrcConfig to use for vim_configurable.";
    };
  };

  config = mkIf cfg.enable {

    environment.systemPackages =
      [ # Include vim_configurable package.
        cfg.package
      ];

    environment.variables.EDITOR = "${cfg.package}/bin/vim";

    environment.etc."vimrc".text = ''
      ${vimOptions}
      ${cfg.vimConfig}

      if filereadable('/etc/vimrc.local')
        source /etc/vimrc.local
      endif
    '';

    programs.vim.package = pkgs.vim_configurable.customize {
      name = "vim";
      vimrcConfig.customRC = config.environment.etc."vimrc".text;
      vimrcConfig.vam = {
        knownPlugins = pkgs.vimPlugins // cfg.extraKnownPlugins;
        pluginDictionaries = cfg.plugins;
      };
    };

    programs.vim.plugins = mkIf cfg.enableSensible [
      { names = [ "fugitive" "surround" "vim-nix" ]; }
    ];

    programs.vim.vimOptions.sensible.text = mkIf cfg.enableSensible ''
      set nocompatible
      filetype plugin indent on
      syntax on

      set et sw=2 ts=2
      set bs=indent,start

      set hlsearch
      set incsearch
      nnoremap // :nohlsearch<CR>

      set list
      set listchars=tab:¬ª¬∑,trail:¬∑,extends:‚ü©,precedes:‚ü®
      set fillchars+=vert:\ ,stl:\ ,stlnc:\ 

      set number

      set lazyredraw
      set nowrap
      set showcmd
      set showmatch
    '';

  };
}
</file>

<file path="modules/security/pki/default.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.security.pki;

  cacertPackage = pkgs.cacert.override {
    blacklist = cfg.caCertificateBlacklist;
  };

  caCertificates = pkgs.runCommand "ca-certificates.crt"
    { files =
        cfg.certificateFiles ++
        [ (builtins.toFile "extra.crt" (concatStringsSep "\n" cfg.certificates)) ];
     }
    ''
      cat $files > $out
    '';
in

{
  options = {
    security.pki.installCACerts = mkOption {
      type = types.bool;
      default = true;
      description = ''
        Whether to enable certificate management with nix-darwin.
      '';
    };

    security.pki.certificateFiles = mkOption {
      type = types.listOf types.path;
      default = [];
      example = literalExpression "[ \"\${pkgs.cacert}/etc/ssl/certs/ca-bundle.crt\" ]";
      description = ''
        A list of files containing trusted root certificates in PEM
        format. These are concatenated to form
        {file}`/etc/ssl/certs/ca-certificates.crt`, which is
        used by many programs that use OpenSSL, such as
        {command}`curl` and {command}`git`.
      '';
    };

    security.pki.certificates = mkOption {
      type = types.listOf types.str;
      default = [];
      example = literalExpression ''
        [ '''
            NixOS.org
            =========
            -----BEGIN CERTIFICATE-----
            MIIGUDCCBTigAwIBAgIDD8KWMA0GCSqGSIb3DQEBBQUAMIGMMQswCQYDVQQGEwJJ
            TDEWMBQGA1UEChMNU3RhcnRDb20gTHRkLjErMCkGA1UECxMiU2VjdXJlIERpZ2l0
            ...
            -----END CERTIFICATE-----
          '''
        ]
      '';
      description = ''
        A list of trusted root certificates in PEM format.
      '';
    };

    security.pki.caCertificateBlacklist = mkOption {
      type = types.listOf types.str;
      default = [];
      example = [
        "WoSign" "WoSign China"
        "CA WoSign ECC Root"
        "Certification Authority of WoSign G2"
      ];
      description = ''
        A list of blacklisted CA certificate names that won't be imported from
        the Mozilla Trust Store into
        {file}`/etc/ssl/certs/ca-certificates.crt`. Use the
        names from that file.
      '';
    };
  };

  config = mkIf cfg.installCACerts {

    security.pki.certificateFiles = [ "${cacertPackage}/etc/ssl/certs/ca-bundle.crt" ];

    environment.etc."ssl/certs/ca-certificates.crt".source = caCertificates;
    environment.variables.NIX_SSL_CERT_FILE = mkDefault "/etc/ssl/certs/ca-certificates.crt";

  };
}
</file>

<file path="modules/security/sandbox/default.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.security.sandbox;

  profile =
    { config, name, ... }:
    {
      options = {
        profile = mkOption {
          type = types.lines;
          internal = true;
          apply = text: pkgs.runCommand "sandbox.sb" { } ''
            for f in $(< ${config.closure}/store-paths); do
                storePaths+="(subpath \"$f\")"
            done

            cat <<-EOF > $out
            ${text}
            EOF
          '';
        };

        closure = mkOption {
          type = types.listOf types.package;
          default = [ ];
          apply = paths: pkgs.closureInfo { rootPaths = paths; };
          description = "List of store paths to make accessible.";
        };

        readablePaths = mkOption {
          type = types.listOf types.path;
          default = [ ];
          description = "List of paths that should be read-only inside the sandbox.";
        };

        writablePaths = mkOption {
          type = types.listOf types.path;
          default = [ ];
          description = "List of paths that should be read/write inside the sandbox.";
        };

        allowSystemPaths = mkOption {
          type = types.bool;
          default = false;
          description = "Whether to allow read access to FHS paths like /etc and /var.";
        };

        allowLocalNetworking = mkOption {
          type = types.bool;
          default = false;
          description = "Whether to allow localhost network access inside the sandbox.";
        };

        allowNetworking = mkOption {
          type = types.bool;
          default = false;
          description = "Whether to allow network access inside the sandbox.";
        };
      };

      config = {

        allowSystemPaths = mkDefault (config.allowLocalNetworking || config.allowNetworking);

        profile = mkOrder 0 ''
          (version 1)
          (deny default)

          (allow file-read*
                 (subpath "/usr/lib")
                 (subpath "/System/Library/Frameworks")
                 (subpath "/System/Library/PrivateFrameworks"))

          (allow file-read-metadata
                 (literal "/dev"))
          (allow file*
                 (literal "/dev/null")
                 (literal "/dev/random")
                 (literal "/dev/stdin")
                 (literal "/dev/stdout")
                 (literal "/dev/tty")
                 (literal "/dev/urandom")
                 (literal "/dev/zero")
                 (subpath "/dev/fd"))

          (allow process-fork)
          (allow signal (target same-sandbox))
          (allow file-read* process-exec
                 $storePaths)

          ${optionalString (config.readablePaths != []) ''
          (allow file-read*
                 ${concatMapStrings (x: ''(subpath "${x}")'') config.readablePaths})
          ''}
          ${optionalString (config.writablePaths != []) ''
          (allow file*
                 ${concatMapStrings (x: ''(subpath "${x}")'') config.writablePaths})
          ''}
          ${optionalString config.allowSystemPaths ''
          (allow file-read-metadata
                 (literal "/")
                 (literal "/etc")
                 (literal "/run")
                 (literal "/tmp")
                 (literal "/var"))
          (allow file-read*
                 (literal "/private/etc/group")
                 (literal "/private/etc/hosts")
                 (literal "/private/etc/passwd")
                 (literal "/private/var/run/resolv.conf"))
          ''}
          ${optionalString config.allowLocalNetworking ''
          (allow network* (local ip) (local tcp) (local udp))
          ''}
          ${optionalString config.allowNetworking ''
          (allow network*
                 (local ip)
                 (remote ip))
          (allow network-outbound
                 (remote unix-socket (path-literal "/private/var/run/mDNSResponder")))
          ''}
        '';

      };
    };
in

{
  options = {
    security.sandbox.profiles = mkOption {
      type = types.attrsOf (types.submodule profile);
      default = { };
      description = "Definition of sandbox profiles.";
    };
  };

  config = { };
}
</file>

<file path="modules/security/pam.nix">
{ config, lib, pkgs, ... }:

let
  cfg = config.security.pam.services.sudo_local;
in
{
  imports = [
    (lib.mkRemovedOptionModule [ "security" "pam" "enableSudoTouchIdAuth" ] ''
      This option has been renamed to `security.pam.services.sudo_local.touchIdAuth` for consistency with NixOS.
    '')
  ];

  options = {
    security.pam.services.sudo_local = {
      enable = lib.mkEnableOption "managing {file}`/etc/pam.d/sudo_local` with nix-darwin" // {
        default = true;
        example = false;
      };

      text = lib.mkOption {
        type = lib.types.lines;
        default = "";
        description = ''
          Contents of {file}`/etc/pam.d/sudo_local`
        '';
      };

      touchIdAuth = lib.mkEnableOption "" // {
        description = ''
          Whether to enable Touch ID with sudo.

          This will also allow your Apple Watch to be used for sudo. If this doesn't work,
          you can go into `System Settings > Touch ID & Password` and toggle the switch for
          your Apple Watch.
        '';
      };

      watchIdAuth = lib.mkEnableOption "" // {
        description = ''
          Use Apple Watch for sudo authentication, for devices without Touch ID or 
          laptops with lids closed, consider using this.

          When enabled, you can use your Apple Watch to authenticate sudo commands.
          If this doesn't work, you can go into `System Settings > Touch ID & Password`
          and toggle the switch for your Apple Watch.
        '';
      };

      reattach = lib.mkEnableOption "" // {
        description = ''
          Whether to enable reattaching a program to the user's bootstrap session.

          This fixes Touch ID for sudo not working inside tmux and screen.

          This allows programs like tmux and screen that run in the background to
          survive across user sessions to work with PAM services that are tied to the
          bootstrap session.
        '';
      };
    };
  };

  config = {
    security.pam.services.sudo_local.text = lib.concatLines (
      (lib.optional cfg.reattach "auth       optional       ${pkgs.pam-reattach}/lib/pam/pam_reattach.so")
      ++ (lib.optional cfg.touchIdAuth "auth       sufficient     pam_tid.so")
      ++ (lib.optional cfg.watchIdAuth "auth       sufficient     ${pkgs.pam-watchid}/lib/pam_watchid.so")
    );

    environment.etc."pam.d/sudo_local" = {
      inherit (cfg) enable text;
    };

    system.activationScripts.pam.text =
    let
      file = "/etc/pam.d/sudo";
      marker = "security.pam.services.sudo_local";
      deprecatedOption = "security.pam.enableSudoTouchIdAuth";
      sed = lib.getExe pkgs.gnused;
    in
    ''
      # PAM settings
      echo >&2 "setting up pam..."

      # REMOVEME when macOS 13 no longer supported as macOS automatically
      # nukes this file on system upgrade
      # Always clear out older implementation if it is present
      if grep '${deprecatedOption}' ${file} > /dev/null; then
        ${sed} -i '/${deprecatedOption}/d' ${file}
      fi

      ${if cfg.enable then ''
        # REMOVEME when macOS 13 no longer supported
        # `sudo_local` is automatically included after macOS 14
        if ! grep 'sudo_local' ${file} > /dev/null; then
          ${sed} -i '2iauth       include        sudo_local # nix-darwin: ${marker}' ${file}
        fi
      '' else ''
        # Remove include line if we added it
        if grep '${marker}' ${file} > /dev/null; then
          ${sed} -i '/${marker}/d' ${file}
        fi
      ''}
    '';
  };
}
</file>

<file path="modules/security/sudo.nix">
{ config, lib, ... }:

with lib;

let
  cfg = config.security.sudo;
in
{
  meta.maintainers = [
    lib.maintainers.samasaur or "samasaur"
  ];

  options = {
    security.sudo.extraConfig = mkOption {
      type = types.nullOr types.lines;
      default = null;
      description = ''
        Extra configuration text appended to {file}`sudoers`.
      '';
    };
  };

  config = {
    environment.etc = {
      "sudoers.d/10-nix-darwin-extra-config" = mkIf (cfg.extraConfig != null) {
        text = cfg.extraConfig;
      };
    };
  };
}
</file>

<file path="modules/services/activate-system/default.nix">
{ config, lib, pkgs, ... }:

let
  activationPath =
    lib.makeBinPath (
      [
        pkgs.gnugrep
        pkgs.coreutils
      ] ++ lib.optionals config.nix.enable [ config.nix.package ]
    )
    + lib.optionalString (!config.nix.enable) ''
      $(
        # If `nix.enable` is off, there might be an unmanaged Nix
        # installation (say in `/nix/var/nix/profiles/default`) that
        # activation scripts (such as Home Manager) want to find on the
        # `$PATH`. Search for it directly to avoid polluting the
        # activation script environment with everything on the
        # `environment.systemPath`.
        if nixEnvPath=$(
          PATH="${config.environment.systemPath}" command -v nix-env
        ); then
          printf ':'
          ${lib.getExe' pkgs.coreutils "dirname"} -- "$(
            ${lib.getExe' pkgs.coreutils "readlink"} \
              --canonicalize-missing \
              -- "$nixEnvPath"
          )"
        fi
      )''
    + ":/usr/bin:/bin:/usr/sbin:/sbin";
in

{
  imports = [
    (lib.mkRemovedOptionModule [ "services" "activate-system" "enable" ] "The `activate-system` service is now always enabled as it is necessary for a working `nix-darwin` setup.")
  ];

  config = {
    launchd.daemons.activate-system = {
      script = ''
        set -e
        set -o pipefail

        PATH="${activationPath}"

        export PATH
        export USER=root
        export LOGNAME=root
        export HOME=~root
        export MAIL=/var/mail/root
        export SHELL=$BASH
        export LANG=C
        export LC_CTYPE=UTF-8

        systemConfig=$(cat ${config.system.profile}/systemConfig)

        # Make this configuration the current configuration.
        # The readlink is there to ensure that when $systemConfig = /system
        # (which is a symlink to the store), /run/current-system is still
        # used as a garbage collection root.
        ln -sfn $(cat ${config.system.profile}/systemConfig) /run/current-system

        # Prevent the current configuration from being garbage-collected.
        if [[ -d /nix/var/nix/gcroots ]]; then
          ln -sfn /run/current-system /nix/var/nix/gcroots/current-system
        fi

        ${config.system.activationScripts.checks.text}
        ${config.system.activationScripts.etc.text}
        ${config.system.activationScripts.keyboard.text}
      '';
      serviceConfig.RunAtLoad = true;
    };
  };
}
</file>

<file path="modules/services/aerospace/default.nix">
{
  config,
  lib,
  pkgs,
  ...
}:

let
  cfg = config.services.aerospace;

  format = pkgs.formats.toml { };
  filterAttrsRecursive = pred: set:
    lib.listToAttrs (
      lib.concatMap (
        name: let
          v = set.${name};
        in
          if pred v
          then [
            (lib.nameValuePair name (
              if lib.isAttrs v
              then filterAttrsRecursive pred v
              else if lib.isList v
              then
                (map (i:
                  if lib.isAttrs i
                  then filterAttrsRecursive pred i
                  else i) (lib.filter pred v))
              else v
            ))
          ]
          else []
      ) (lib.attrNames set)
    );
  filterNulls = filterAttrsRecursive (v: v != null);
  configFile = format.generate "aerospace.toml" (filterNulls cfg.settings);
in

{
  options = {
    services.aerospace = with lib.types; {
      enable = lib.mkEnableOption "AeroSpace window manager";

      package = lib.mkPackageOption pkgs "aerospace" { };

      settings = lib.mkOption {
        type = submodule {
          freeformType = format.type;
          options = {
            start-at-login = lib.mkOption {
              type = bool;
              default = false;
              description = "Do not start AeroSpace at login. (Managed by launchd instead)";
            };
            after-login-command = lib.mkOption {
              type = listOf str;
              default = [ ];
              description = "Do not use AeroSpace to run commands after login. (Managed by launchd instead)";
            };
            after-startup-command = lib.mkOption {
              type = listOf str;
              default = [ ];
              description = "Add commands that run after AeroSpace startup";
              example = [ "layout tiles" ];
            };
            enable-normalization-flatten-containers = lib.mkOption {
              type = bool;
              default = true;
              description = "Containers that have only one child are \"flattened\".";
            };
            enable-normalization-opposite-orientation-for-nested-containers = lib.mkOption {
              type = bool;
              default = true;
              description = "Containers that nest into each other must have opposite orientations.";
            };
            accordion-padding = lib.mkOption {
              type = int;
              default = 30;
              description = "Padding between windows in an accordion container.";
            };
            default-root-container-layout = lib.mkOption {
              type = enum [
                "tiles"
                "accordion"
              ];
              default = "tiles";
              description = "Default layout for the root container.";
            };
            default-root-container-orientation = lib.mkOption {
              type = enum [
                "horizontal"
                "vertical"
                "auto"
              ];
              default = "auto";
              description = "Default orientation for the root container.";
            };
            on-window-detected = lib.mkOption {
              type = listOf (submodule {
                options = {
                  "if" = lib.mkOption {
                    type = submodule {
                      options = {
                        app-id = lib.mkOption {
                          type = nullOr str;
                          default = null;
                          description = "The application ID to match (optional).";
                        };
                        workspace = lib.mkOption {
                          type = nullOr str;
                          default = null;
                          description = "The workspace name to match (optional).";
                        };
                        window-title-regex-substring = lib.mkOption {
                          type = nullOr str;
                          default = null;
                          description = "Substring to match in the window title (optional).";
                        };
                        app-name-regex-substring = lib.mkOption {
                          type = nullOr str;
                          default = null;
                          description = "Regex substring to match the app name (optional).";
                        };
                        during-aerospace-startup = lib.mkOption {
                          type = nullOr bool;
                          default = null;
                          description = "Whether to match during aerospace startup (optional).";
                        };
                      };
                    };
                    default = { };
                    description = "Conditions for detecting a window.";
                  };
                  check-further-callbacks = lib.mkOption {
                    type = nullOr bool;
                    default = null;
                    description = "Whether to check further callbacks after this rule (optional).";
                  };
                  run = lib.mkOption {
                    type = oneOf [str (listOf str)];
                    example = ["move-node-to-workspace m" "resize-node"];
                    description = "Commands to execute when the conditions match (required).";
                  };
                };
              });
              default = [ ];
              example = [
                {
                  "if" = {
                    app-id = "Another.Cool.App";
                    workspace = "cool-workspace";
                    window-title-regex-substring = "Title";
                    app-name-regex-substring = "CoolApp";
                    during-aerospace-startup = false;
                  };
                  check-further-callbacks = false;
                  run = ["move-node-to-workspace m" "resize-node"];
                }
              ];
              description = "Commands to run every time a new window is detected with optional conditions.";
            };
            workspace-to-monitor-force-assignment = lib.mkOption {
              type = attrsOf (oneOf [int str (listOf str)]);
              default = { };
              description = ''
                Map workspaces to specific monitors.
                Left-hand side is the workspace name, and right-hand side is the monitor pattern.
              '';
              example = {
                "1" = 1; # First monitor from left to right.
                "2" = "main"; # Main monitor.
                "3" = "secondary"; # Secondary monitor (non-main).
                "4" = "built-in"; # Built-in display.
                "5" = "^built-in retina display$"; # Regex for the built-in retina display.
                "6" = ["secondary" "dell"]; # Match first pattern in the list.
              };
            };
            on-focus-changed = lib.mkOption {
              type = listOf str;
              default = [ ];
              description = "Commands to run every time focused window or workspace changes.";
            };
            on-focused-monitor-changed = lib.mkOption {
              type = listOf str;
              default = [ "move-mouse monitor-lazy-center" ];
              description = "Commands to run every time focused monitor changes.";
            };
            exec-on-workspace-change = lib.mkOption {
              type = listOf str;
              default = [ ];
              example = [
                "/bin/bash"
                "-c"
                "sketchybar --trigger aerospace_workspace_change FOCUSED=$AEROSPACE_FOCUSED_WORKSPACE"
              ];
              description = "Commands to run every time workspace changes.";
            };
            key-mapping.preset = lib.mkOption {
              type = enum [
                "qwerty"
                "dvorak"
                "colemak"
              ];
              default = "qwerty";
              description = "Keymapping preset.";
            };
          };
        };
        default = { };
        example = lib.literalExpression ''
          {
            gaps = {
              outer.left = 8;
              outer.bottom = 8;
              outer.top = 8;
              outer.right = 8;
            };
            mode.main.binding = {
              alt-h = "focus left";
              alt-j = "focus down";
              alt-k = "focus up";
              alt-l = "focus right";
            };
          }
        '';
        description = ''
          AeroSpace configuration, see
          <link xlink:href="https://nikitabobko.github.io/AeroSpace/guide#configuring-aerospace"/>
          for supported values.
        '';
      };
    };
  };

  config = (
    lib.mkIf (cfg.enable) {
      assertions = [
        {
          assertion = !cfg.settings.start-at-login;
          message = "AeroSpace started at login is managed by home-manager and launchd instead of itself via this option.";
        }
        {
          assertion = cfg.settings.after-login-command == [ ];
          message = "AeroSpace will not run these commands as it does not start itself.";
        }
      ];
      environment.systemPackages = [ cfg.package ];

      launchd.user.agents.aerospace = {
        command =
          "${cfg.package}/Applications/AeroSpace.app/Contents/MacOS/AeroSpace"
          + (lib.optionalString (cfg.settings != { }) " --config-path ${configFile}");
        serviceConfig = {
          KeepAlive = true;
          RunAtLoad = true;
        };
        managedBy = "services.aerospace.enable";
      };
    }
  );
}
</file>

<file path="modules/services/github-runner/default.nix">
{
  imports = [
    ./options.nix
    ./service.nix
  ];
}
</file>

<file path="modules/services/github-runner/options.nix">
{ lib
, pkgs
, ...
}:

let
  inherit (lib) literalExpression mkOption mkPackageOption types;
in
{
  options.services.github-runners = mkOption {
    description = ''
      Multiple GitHub Runners.

      If `user` and `group` are set to `null`, the module will configure nix-darwin to
      manage the `_github-runner` user and group. Note that multiple runner
      configurations share the same user/group, which means they can access
      resources from other runners. Make each runner use its own user and group if
      this is not what you want. In this case, you will have to do the user and
      group creation yourself. If only `user` is set, while `group` is set to
      `null`, the service will infer the primary group of the `user`.

      For each GitHub runner, the system activation script creates the following
      directories:

      * `/var/lib/github-runners/<name>`:
        State directory to store the runner registration credentials
      * `/var/lib/github-runners/_work/<name>`:
        Working directory for workflow files. The runner only uses this
        directory if `workDir` is `null` (see the `workDir` option for details).
      * `/var/log/github-runners/<name>`:
        The launchd service writes the stdout and stderr streams to this
        directory.
    '';
    example = {
      runner1 = {
        enable = true;
        url = "https://github.com/owner/repo";
        name = "runner1";
        tokenFile = "/secrets/token1";
      };

      runner2 = {
        enable = true;
        url = "https://github.com/owner/repo";
        name = "runner2";
        tokenFile = "/secrets/token2";
      };
    };
    default = { };
    type = types.attrsOf (types.submodule ({ name, ... }: {
      options = {
        enable = mkOption {
          default = false;
          example = true;
          description = ''
            Whether to enable GitHub Actions runner.

            Note: GitHub recommends using self-hosted runners with private repositories only. Learn more here:
            [About self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/about-self-hosted-runners).
          '';
          type = types.bool;
        };

        url = mkOption {
          type = types.str;
          description = ''
            Repository to add the runner to.

            Changing this option triggers a new runner registration.

            IMPORTANT: If your token is org-wide (not per repository), you need to
            provide a github org link, not a single repository, so do it like this
            `https://github.com/nixos`, not like this
            `https://github.com/nixos/nixpkgs`.
            Otherwise, you are going to get a `404 NotFound`
            from `POST https://api.github.com/actions/runner-registration`
            in the configure script.
          '';
          example = "https://github.com/nixos/nixpkgs";
        };

        tokenFile = mkOption {
          type = types.path;
          description = ''
            The full path to a file which contains either

            * a fine-grained personal access token (PAT),
            * a classic PAT
            * or a runner registration token

            Changing this option or the `tokenFile`‚Äôs content triggers a new runner registration.

            You can also manually trigger a new runner registration by deleting
            {file}`/var/lib/github-runners/<name>/.runner` and restarting the service.

            We suggest using the fine-grained PATs. A runner registration token is valid
            only for 1 hour after creation, so the next time the runner configuration changes
            this will give you hard-to-debug HTTP 404 errors in the configure step.

            The file should contain exactly one line with the token without any newline.
            (Use `echo -n '‚Ä¶token‚Ä¶' > ‚Ä¶token file‚Ä¶` to make sure no newlines sneak in.)

            If the file contains a PAT, the service creates a new registration token
            on startup as needed.
            If a registration token is given, it can be used to re-register a runner of the same
            name but is time-limited as noted above.

            For fine-grained PATs:

            Give it "Read and Write access to organization/repository self hosted runners",
            depending on whether it is organization wide or per-repository. You might have to
            experiment a little, fine-grained PATs are a `beta` Github feature and still subject
            to change; nonetheless they are the best option at the moment.

            For classic PATs:

            Make sure the PAT has a scope of `admin:org` for organization-wide registrations
            or a scope of `repo` for a single repository.

            For runner registration tokens:

            Nothing special needs to be done, but updating will break after one hour,
            so these are not recommended.
          '';
          example = "/run/secrets/github-runner/nixos.token";
        };

        name = mkOption {
          type = types.nullOr types.str;
          description = ''
            Name of the runner to configure. If null, defaults to the hostname.

            Changing this option triggers a new runner registration.
          '';
          example = "nixos";
          default = name;
        };

        runnerGroup = mkOption {
          type = types.nullOr types.str;
          description = ''
            Name of the runner group to add this runner to (defaults to the default runner group).

            Changing this option triggers a new runner registration.
          '';
          default = null;
        };

        extraLabels = mkOption {
          type = types.listOf types.str;
          description = ''
            Extra labels in addition to the default (unless disabled through the `noDefaultLabels` option).

            Changing this option triggers a new runner registration.
          '';
          example = literalExpression ''[ "nixos" ]'';
          default = [ ];
        };

        noDefaultLabels = mkOption {
          type = types.bool;
          description = ''
            Disables adding the default labels. Also see the `extraLabels` option.

            Changing this option triggers a new runner registration.
          '';
          default = false;
        };

        replace = mkOption {
          type = types.bool;
          description = ''
            Replace any existing runner with the same name.

            Without this flag, registering a new runner with the same name fails.
          '';
          default = false;
        };

        extraPackages = mkOption {
          type = types.listOf types.package;
          description = ''
            Extra packages to add to `PATH` of the service to make them available to workflows.
          '';
          default = [ ];
        };

        extraEnvironment = mkOption {
          type = types.attrs;
          description = ''
            Extra environment variables to set for the runner, as an attrset.
          '';
          example = {
            GIT_CONFIG = "/path/to/git/config";
          };
          default = { };
        };

        serviceOverrides = mkOption {
          type = types.attrs;
          description = ''
            Modify the service. Can be used to, e.g., adjust the sandboxing options.
          '';
          default = { };
        };

        package = mkPackageOption pkgs "github-runner" { };

        ephemeral = mkOption {
          type = types.bool;
          description = ''
            If enabled, causes the following behavior:

            - Passes the `--ephemeral` flag to the runner configuration script
            - De-registers and stops the runner with GitHub after it has processed one job
            - Restarts the service after its successful exit
            - On start, wipes the state directory and configures a new runner

            You should only enable this option if `tokenFile` points to a file which contains a
            personal access token (PAT). If you're using the option with a registration token, restarting the
            service will fail as soon as the registration token expired.

            Changing this option triggers a new runner registration.
          '';
          default = false;
        };

        user = mkOption {
          type = types.nullOr types.str;
          description = ''
            User under which to run the service.

            If this option and the `group` option is set to `null`, nix-darwin creates
            the `github-runner` user and group.
          '';
          defaultText = literalExpression "username";
          default = null;
        };

        group = mkOption {
          type = types.nullOr types.str;
          description = ''
            Group under which to run the service.

            If this option and the `user` option is set to `null`, nix-darwin creates
            the `github-runner` user and group.
          '';
          defaultText = literalExpression "groupname";
          default = null;
        };

        workDir = mkOption {
          type = with types; nullOr str;
          description = ''
            Working directory, available as `$GITHUB_WORKSPACE` during workflow runs
            and used as a default for [repository checkouts](https://github.com/actions/checkout).
            The service cleans this directory on every service start.

            Changing this option triggers a new runner registration.
          '';
          default = null;
        };

        nodeRuntimes = mkOption {
          type = with types; nonEmptyListOf (enum [ "node20" "node24" ]);
          default = [ "node20" "node24" ];
          description = ''
            List of Node.js runtimes the runner should support.
          '';
        };
      };
    }));
  };
}
</file>

<file path="modules/services/github-runner/service.nix">
{ config, lib, pkgs, ... }:

let
  inherit (lib) any attrValues boolToString concatStringsSep escapeShellArg
    flatten flip getExe getExe' hasAttr hasPrefix mapAttrsToList mapAttrs' mkBefore
    mkDefault mkIf mkMerge nameValuePair optionalAttrs optionalString replaceStrings;

  mkSvcName = name: "github-runner-${name}";
  mkStateDir = cfg: "/var/lib/github-runners/${cfg.name}";
  mkLogDir = cfg: "/var/log/github-runners/${cfg.name}";
  mkWorkDir = cfg: if (cfg.workDir != null) then cfg.workDir else "/var/lib/github-runners/_work/${cfg.name}";
in
{
  config.assertions = flatten (
    flip mapAttrsToList config.services.github-runners (name: cfg: map (mkIf cfg.enable) [
      # TODO: Upstream this to NixOS.
      {
        assertion = config.nix.enable;
        message = ''`services.github-runners.${name}.enable` requires `nix.enable`'';
      }
      {
        assertion = (cfg.user == null && cfg.group == null) || (cfg.user != null);
        message = "`services.github-runners.${name}`: Either set `user` and `group` to `null` to have nix-darwin manage them or set at least `user` explicitly";
      }
      {
        assertion = !cfg.noDefaultLabels || (cfg.extraLabels != [ ]);
        message = "`services.github-runners.${name}`: The `extraLabels` option is mandatory if `noDefaultLabels` is set";
      }
      {
        assertion = cfg.workDir == null || !(hasPrefix "/run/" cfg.workDir || hasPrefix "/var/run/" cfg.workDir || hasPrefix "/private/var/run/" cfg.workDir);
        message = "`services.github-runners.${name}`: `workDir` being inside /run is not supported";
      }
    ])
  );

  config.warnings = flatten (
    flip mapAttrsToList config.services.github-runners (name: cfg: map (mkIf cfg.enable) [
      (
        mkIf (hasPrefix builtins.storeDir cfg.tokenFile)
          "`services.github-runners.${name}`: `tokenFile` contains a secret but points to the world-readable Nix store."
      )
    ])
  );

  # Create the necessary directories and make the service user/group their owner
  # This has to happen *after* nix-darwin user creation and *before* any launchd service gets started.
  config.system.activationScripts = mkMerge (flip mapAttrsToList config.services.github-runners (name: cfg:
    let
      user = config.launchd.daemons.${mkSvcName name}.serviceConfig.UserName;
      group =
        if config.launchd.daemons.${mkSvcName name}.serviceConfig.GroupName != null
        then config.launchd.daemons.${mkSvcName name}.serviceConfig.GroupName
        else "";
    in
    {
      launchd = mkIf cfg.enable {
        text = mkBefore (''
          echo >&2 "setting up GitHub Runner '${cfg.name}'..."

          # shellcheck disable=SC2174
          ${getExe' pkgs.coreutils "mkdir"} -p -m u=rwx,g=rx,o= ${escapeShellArg (mkStateDir cfg)}
          ${getExe' pkgs.coreutils "chown"} ${user}:${group} ${escapeShellArg (mkStateDir cfg)}

          # shellcheck disable=SC2174
          ${getExe' pkgs.coreutils "mkdir"} -p -m u=rwx,g=rx,o= ${escapeShellArg (mkLogDir cfg)}
          ${getExe' pkgs.coreutils "chown"} ${user}:${group} ${escapeShellArg (mkLogDir cfg)}

          ${optionalString (cfg.workDir == null) ''
            # shellcheck disable=SC2174
            ${getExe' pkgs.coreutils "mkdir"} -p -m u=rwx,g=rx,o= ${escapeShellArg (mkWorkDir cfg)}
            ${getExe' pkgs.coreutils "chown"} ${user}:${group} ${escapeShellArg (mkWorkDir cfg)}
          ''}
        '');
      };
    }));

  config.launchd.daemons = flip mapAttrs' config.services.github-runners (name: cfg:
    let
      package = cfg.package.override { inherit (cfg) nodeRuntimes; };
      stateDir = mkStateDir cfg;
      logDir = mkLogDir cfg;
      workDir = mkWorkDir cfg;
    in
    nameValuePair
      (mkSvcName name)
      (mkIf cfg.enable {
        environment = {
          HOME = stateDir;
          RUNNER_ROOT = stateDir;
        } // cfg.extraEnvironment;

        # Minimal package set for `actions/checkout`
        path = (with pkgs; [
          bash
          coreutils
          git
          gnutar
          gzip
        ]) ++ [
          config.nix.package
        ] ++ cfg.extraPackages;

        script =
          let
            # https://github.com/NixOS/nixpkgs/pull/333744 introduced an inconsistency with different
            # versions of nixpkgs. Use the old version of escapeShellArg to make sure that labels
            # are always escaped to avoid https://www.shellcheck.net/wiki/SC2054
            escapeShellArgAlways = string: "'${replaceStrings ["'"] ["'\\''"] (toString string)}'";
            configure = pkgs.writeShellApplication {
              name = "configure-github-runner-${name}";
              text = /*bash*/''
                export RUNNER_ROOT

                args=(
                  --unattended
                  --disableupdate
                  --work ${escapeShellArg workDir}
                  --url ${escapeShellArg cfg.url}
                  --labels ${escapeShellArgAlways (concatStringsSep "," cfg.extraLabels)}
                  ${optionalString (cfg.name != null ) "--name ${escapeShellArg cfg.name}"}
                  ${optionalString cfg.replace "--replace"}
                  ${optionalString (cfg.runnerGroup != null) "--runnergroup ${escapeShellArg cfg.runnerGroup}"}
                  ${optionalString cfg.ephemeral "--ephemeral"}
                  ${optionalString cfg.noDefaultLabels "--no-default-labels"}
                )
                # If the token file contains a PAT (i.e., it starts with "ghp_" or "github_pat_"), we have to use the --pat option,
                # if it is not a PAT, we assume it contains a registration token and use the --token option
                token=$(<"${cfg.tokenFile}")
                if [[ "$token" =~ ^ghp_* ]] || [[ "$token" =~ ^github_pat_* ]]; then
                  args+=(--pat "$token")
                else
                  args+=(--token "$token")
                fi
                ${getExe' package "config.sh"} "''${args[@]}"
              '';
            };
          in
          ''
            echo "Configuring GitHub Actions Runner"

            # Always clean the working directory
            ${getExe pkgs.findutils} ${escapeShellArg workDir} -mindepth 1 -delete

            # Clean the $RUNNER_ROOT if we are in ephemeral mode
            if ${boolToString cfg.ephemeral}; then
              echo "Cleaning $RUNNER_ROOT"
              ${getExe pkgs.findutils} "$RUNNER_ROOT" -mindepth 1 -delete
            fi

            # If the `.runner` file does not exist, we assume the runner is not configured
            if [[ ! -f "$RUNNER_ROOT/.runner" ]]; then
              ${getExe configure}
            fi

            # Start the service
            ${getExe' package "Runner.Listener"} run --startuptype service
          '';

        serviceConfig = mkMerge [
          {
            GroupName = cfg.group;
            KeepAlive = {
              Crashed = false;
            } // mkIf cfg.ephemeral {
              SuccessfulExit = true;
            };
            ProcessType = "Interactive";
            RunAtLoad = true;
            StandardErrorPath = "${logDir}/launchd-stderr.log";
            StandardOutPath = "${logDir}/launchd-stdout.log";
            ThrottleInterval = 30;
            UserName = if (cfg.user != null) then cfg.user else "_github-runner";
            WatchPaths = [
              "/etc/resolv.conf"
              "/Library/Preferences/SystemConfiguration/NetworkInterfaces.plist"
              cfg.tokenFile
            ];
            WorkingDirectory = stateDir;
          }
          cfg.serviceOverrides
        ];
      }));

  # If any GitHub runner configuration has set both `user` and `group` set to `null`,
  # manage the user and group `_github-runner` through nix-darwin.
  config.users = mkIf (any (cfg: cfg.enable && cfg.user == null && cfg.group == null) (attrValues config.services.github-runners)) {
    users."_github-runner" = {
      createHome = false;
      description = "GitHub Runner service user";
      gid = config.users.groups."_github-runner".gid;
      home = "/var/lib/github-runners";
      shell = "/bin/bash";
      uid = mkDefault 533;
    };
    knownUsers = [ "_github-runner" ];

    groups."_github-runner" = {
      gid = mkDefault 533;
      description = "GitHub Runner service user group";
    };
    knownGroups = [ "_github-runner" ];
  };
}
</file>

<file path="modules/services/hercules-ci-agent/common.nix">
/*

  This file is for options that NixOS and nix-darwin have in common.

  Platform-specific code is in the respective default.nix files.

*/

{ config, lib, options, pkgs, ... }:
let
  inherit (lib)
    filterAttrs
    literalExpression
    mkIf
    mkOption
    mkRemovedOptionModule
    mkRenamedOptionModule
    types
    ;
  literalMD = lib.literalMD or (x: lib.literalDocBook "Documentation not rendered. Please upgrade to a newer NixOS with markdown support.");

  cfg = config.services.hercules-ci-agent;

  inherit (import ./settings.nix { inherit pkgs lib; }) format settingsModule;

in
{
  imports = [
    (mkRenamedOptionModule [ "services" "hercules-ci-agent" "extraOptions" ] [ "services" "hercules-ci-agent" "settings" ])
    (mkRenamedOptionModule [ "services" "hercules-ci-agent" "baseDirectory" ] [ "services" "hercules-ci-agent" "settings" "baseDirectory" ])
    (mkRenamedOptionModule [ "services" "hercules-ci-agent" "concurrentTasks" ] [ "services" "hercules-ci-agent" "settings" "concurrentTasks" ])
    (mkRemovedOptionModule [ "services" "hercules-ci-agent" "patchNix" ] "Nix versions packaged in this version of Nixpkgs don't need a patched nix-daemon to work correctly in Hercules CI Agent clusters.")
  ];

  options.services.hercules-ci-agent = {
    enable = mkOption {
      type = types.bool;
      default = false;
      description = ''
        Enable to run Hercules CI Agent as a system service.

        [Hercules CI](https://hercules-ci.com) is a
        continuous integation service that is centered around Nix.

        Support is available at [help@hercules-ci.com](mailto:help@hercules-ci.com).
      '';
    };
    package = mkOption {
      description = ''
        Package containing the bin/hercules-ci-agent executable.
      '';
      type = types.package;
      default = pkgs.hercules-ci-agent;
      defaultText = literalExpression "pkgs.hercules-ci-agent";
    };
    settings = mkOption {
      description = ''
        These settings are written to the `agent.toml` file.

        Not all settings are listed as options, can be set nonetheless.

        For the exhaustive list of settings, see <https://docs.hercules-ci.com/hercules-ci/reference/agent-config/>.
      '';
      type = types.submoduleWith { modules = [ settingsModule ]; };
    };

    /*
      Internal and/or computed values.

      These are written as options instead of let binding to allow sharing with
      default.nix on both NixOS and nix-darwin.
    */
    tomlFile = mkOption {
      type = types.path;
      internal = true;
      defaultText = literalMD "generated `hercules-ci-agent.toml`";
      description = ''
        The fully assembled config file.
      '';
    };
  };

  config = mkIf cfg.enable {
    nix.extraOptions = ''
      # A store path that was missing at first may well have finished building,
      # even shortly after the previous lookup. This *also* applies to the daemon.
      narinfo-cache-negative-ttl = 0
    '';
    services.hercules-ci-agent = {
      tomlFile =
        format.generate "hercules-ci-agent.toml" cfg.settings;
      settings.config._module.args = {
        packageOption = options.services.hercules-ci-agent.package;
        inherit pkgs;
      };
    };
  };
}
</file>

<file path="modules/services/hercules-ci-agent/default.nix">
{ config, lib, pkgs, ... }:

with lib;
let
  cfg = config.services.hercules-ci-agent;
  user = config.users.users._hercules-ci-agent;
in
{
  imports = [ ./common.nix ];

  meta.maintainers = [
    lib.maintainers.roberth or "roberth"
  ];

  options.services.hercules-ci-agent = {

    logFile = mkOption {
      type = types.path;
      default = "/var/log/hercules-ci-agent.log";
      description = "Stdout and sterr of hercules-ci-agent process.";
    };
  };

  config = mkIf cfg.enable {
    # TODO: Upstream this to NixOS.
    assertions = [
      {
        assertion = config.nix.enable;
        message = ''`services.hercules-ci-agent.enable` requires `nix.enable`'';
      }
    ];

    launchd.daemons.hercules-ci-agent = {
      script = "exec ${cfg.package}/bin/hercules-ci-agent --config ${cfg.tomlFile}";

      path = [ config.nix.package config.environment.systemPath ];
      environment = {
        NIX_SSL_CERT_FILE = "${pkgs.cacert}/etc/ssl/certs/ca-bundle.crt";
      };

      serviceConfig.KeepAlive = true;
      serviceConfig.RunAtLoad = true;
      serviceConfig.StandardErrorPath = cfg.logFile;
      serviceConfig.StandardOutPath = cfg.logFile;
      serviceConfig.GroupName = "_hercules-ci-agent";
      serviceConfig.UserName = "_hercules-ci-agent";
      serviceConfig.WorkingDirectory = user.home;
      serviceConfig.WatchPaths = [
        cfg.settings.staticSecretsDirectory
      ];
    };

    system.activationScripts.preActivation.text = ''
      touch '${cfg.logFile}'
      chown ${toString user.uid}:${toString user.gid} '${cfg.logFile}'
    '';

    # Trusted user allows simplified configuration and better performance
    # when operating in a cluster.
    nix.settings.trusted-users = [ "_hercules-ci-agent" ];
    services.hercules-ci-agent.settings.nixUserIsTrusted = true;

    users.knownGroups = [ "hercules-ci-agent" "_hercules-ci-agent" ];
    users.knownUsers = [ "hercules-ci-agent" "_hercules-ci-agent" ];

    users.users._hercules-ci-agent = {
      uid = mkDefault 399;
      gid = mkDefault config.users.groups._hercules-ci-agent.gid;
      home = mkDefault cfg.settings.baseDirectory;
      name = "_hercules-ci-agent";
      createHome = true;
      shell = "/bin/bash";
      description = "System user for the Hercules CI Agent";
    };
    users.groups._hercules-ci-agent = {
      gid = mkDefault 32001;
      name = "_hercules-ci-agent";
      description = "System group for the Hercules CI Agent";
    };

    services.hercules-ci-agent.settings.labels = {
      darwin.label = config.system.darwinLabel;
      darwin.revision = config.system.darwinRevision;
      darwin.version = config.system.darwinVersion;
      darwin.nix.daemon = true;
      darwin.nix.sandbox = config.nix.settings.sandbox;
    };
  };
}
</file>

<file path="modules/services/hercules-ci-agent/settings.nix">
# Not a module
{ pkgs, lib }:
let
  inherit (lib)
    types
    literalExpression
    mkOption
    ;
  literalMD = lib.literalMD or (x: lib.literalDocBook "Documentation not rendered. Please upgrade to a newer NixOS with markdown support.");

  format = pkgs.formats.toml { };

  settingsModule = { config, packageOption, pkgs, ... }: {
    freeformType = format.type;
    options = {
      apiBaseUrl = mkOption {
        description = ''
          API base URL that the agent will connect to.

          When using Hercules CI Enterprise, set this to the URL where your
          Hercules CI server is reachable.
        '';
        type = types.str;
        default = "https://hercules-ci.com";
      };
      baseDirectory = mkOption {
        type = types.path;
        default = "/var/lib/hercules-ci-agent";
        description = ''
          State directory (secrets, work directory, etc) for agent
        '';
      };
      concurrentTasks = mkOption {
        description = ''
          Number of tasks to perform simultaneously.

          A task is a single derivation build, an evaluation or an effect run.
          At minimum, you need 2 concurrent tasks for `x86_64-linux`
          in your cluster, to allow for import from derivation.

          `concurrentTasks` can be around the CPU core count or lower if memory is
          the bottleneck.

          The optimal value depends on the resource consumption characteristics of your workload,
          including memory usage and in-task parallelism. This is typically determined empirically.

          When scaling, it is generally better to have a double-size machine than two machines,
          because each split of resources causes inefficiencies; particularly with regards
          to build latency because of extra downloads.
        '';
        type = types.either types.ints.positive (types.enum [ "auto" ]);
        default = "auto";
        defaultText = literalMD ''
          `"auto"`, meaning equal to the number of CPU cores.
        '';
      };
      labels = mkOption {
        description = ''
          A key-value map of user data.

          This data will be available to organization members in the dashboard and API.

          The values can be of any TOML type that corresponds to a JSON type, but arrays
          can not contain tables/objects due to limitations of the TOML library. Values
          involving arrays of non-primitive types may not be representable currently.
        '';
        type = format.type;
        defaultText = literalExpression ''
          {
            agent.source = "..."; # One of "nixpkgs", "flake", "override"
            lib.version = "...";
            pkgs.version = "...";
          }
        '';
      };
      workDirectory = mkOption {
        description = ''
          The directory in which temporary subdirectories are created for task state. This includes sources for Nix evaluation.
        '';
        type = types.path;
        default = config.baseDirectory + "/work";
        defaultText = literalExpression ''baseDirectory + "/work"'';
      };
      staticSecretsDirectory = mkOption {
        description = ''
          This is the default directory to look for statically configured secrets like `cluster-join-token.key`.

          See also `clusterJoinTokenPath` and `binaryCachesPath` for fine-grained configuration.
        '';
        type = types.path;
        default = config.baseDirectory + "/secrets";
        defaultText = literalExpression ''baseDirectory + "/secrets"'';
      };
      clusterJoinTokenPath = mkOption {
        description = ''
          Location of the cluster-join-token.key file.

          You can retrieve the contents of the file when creating a new agent via
          <https://hercules-ci.com/dashboard>.

          As this value is confidential, it should not be in the store, but
          installed using other means, such as agenix, NixOps
          `deployment.keys`, or manual installation.

          The contents of the file are used for authentication between the agent and the API.
        '';
        type = types.path;
        default = config.staticSecretsDirectory + "/cluster-join-token.key";
        defaultText = literalExpression ''staticSecretsDirectory + "/cluster-join-token.key"'';
      };
      binaryCachesPath = mkOption {
        description = ''
          Path to a JSON file containing binary cache secret keys.

          As these values are confidential, they should not be in the store, but
          copied over using other means, such as agenix, NixOps
          `deployment.keys`, or manual installation.

          The format is described on <https://docs.hercules-ci.com/hercules-ci-agent/binary-caches-json/>.
        '';
        type = types.path;
        default = config.staticSecretsDirectory + "/binary-caches.json";
        defaultText = literalExpression ''staticSecretsDirectory + "/binary-caches.json"'';
      };
      secretsJsonPath = mkOption {
        description = ''
          Path to a JSON file containing secrets for effects.

          As these values are confidential, they should not be in the store, but
          copied over using other means, such as agenix, NixOps
          `deployment.keys`, or manual installation.

          The format is described on <https://docs.hercules-ci.com/hercules-ci-agent/secrets-json/>.
        '';
        type = types.path;
        default = config.staticSecretsDirectory + "/secrets.json";
        defaultText = literalExpression ''staticSecretsDirectory + "/secrets.json"'';
      };
    };
    config = {
      labels = {
        agent.source =
          if packageOption.highestPrio == (lib.modules.mkOptionDefault { }).priority
          then "nixpkgs"
          else lib.mkOptionDefault "override";
        pkgs.version = pkgs.lib.version;
        lib.version = lib.version;
      };
    };
  };
in
{
  inherit format settingsModule;
}
</file>

<file path="modules/services/jankyborders/default.nix">
{
  config,
  lib,
  pkgs,
  ...
}: let
  inherit (lib) maintainers mkEnableOption mkIf mkPackageOption mkOption types;

  cfg = config.services.jankyborders;
  joinStrings = strings: builtins.concatStringsSep "," strings;

  optionalArg = arg: value:
    if value != null && value != ""
    then
      if lib.isList value
      then lib.map (val: "${arg}=${val}") value
      else ["${arg}=${value}"]
    else [];
in {
  meta.maintainers = [
    maintainers.amsynist or "amsynist"
  ];

  options.services.jankyborders = {
    enable = mkEnableOption "Enable the jankyborders service.";

    package = mkPackageOption pkgs "jankyborders" {};

    width = mkOption {
      type = types.float;
      default = 5.0;
      description = ''
        Determines the width of the border. For example, width=5.0 creates a border 5.0 points wide.
      '';
    };

    hidpi = mkOption {
      type = types.bool;
      default = false;
      description = ''
        If set to on, the border will be drawn with retina resolution.
      '';
    };

    active_color = mkOption {
      type = types.str;
      default = "0xFFFFFFFF";
      example = "0xFFFFFFFF";
      description = ''
        Sets the border color for the focused window (format: 0xAARRGGBB). For instance, active_color="0xff00ff00" creates a green border.
        For Gradient Border : active_color="gradient(top_right=0x9992B3F5,bottom_left=0x9992B3F5)"
      '';
    };

    inactive_color = mkOption {
      type = types.str;
      default = "0xFFFFFFFF";
      example = "0xFFFFFFFF";
      description = ''
        Sets the border color for all windows not in focus (format: 0xAARRGGBB).
        For Gradient Border : inactive_color="gradient(top_right=0x9992B3F5,bottom_left=0x9992B3F5)"
      '';
    };

    background_color = mkOption {
      type = types.str;
      default = "";
      example = "0xFFFFFFFF";
      description = ''
        Sets the background fill color for all windows (only 0xAARRGGBB arguments supported).
      '';
    };

    style = mkOption {
      type = types.str;
      default = "round";
      example = "square/round";
      description = ''
        Specifies the style of the border (either round or square).
      '';
    };

    order = mkOption {
      type = types.enum [ "above" "below" ];
      default = "below";
      example = "above";
      description = ''
        Specifies whether borders should be drawn above or below windows.
      '';
    };

    blur_radius = mkOption {
      type = types.float;
      default = 0.0;
      example = 5.0;
      description = ''
        Sets the blur radius applied to the borders or backgrounds with transparency.
      '';
    };

    ax_focus = mkOption {
      type = types.bool;
      default = false;
      description = ''
        If set to true, the (slower) accessibility API is used to resolve the focused window.
      '';
    };

    blacklist = mkOption {
      type = types.listOf types.str;
      default = [];
      example = ["Safari" "kitty"];
      description = ''
        The applications specified here are excluded from being bordered.
        For example, blacklist = [ "Safari" "kitty" ] excludes Safari and kitty from being bordered.
      '';
    };

    whitelist = mkOption {
      type = types.listOf types.str;
      default = [];
      example = ["Arc" "USB Overdrive"];
      description = ''
        Once this list is populated, only applications listed here are considered for receiving a border.
        If the whitelist is empty (default) it is inactive.
      '';
    };
  };

  config = mkIf cfg.enable {
    assertions = [
      {
        assertion = !(cfg.blacklist != [] && cfg.whitelist != []);
        message = "Cannot define both a blacklist and a whitelist for jankyborders.";
      }
    ];
    environment.systemPackages = [cfg.package];

    launchd.user.agents.jankyborders = {
      serviceConfig.ProgramArguments =
        [
          "${cfg.package}/bin/borders"
        ]
        ++ (optionalArg "width" (toString cfg.width))
        ++ (optionalArg "hidpi" (
          if cfg.hidpi
          then "on"
          else "off"
        ))
        ++ (optionalArg "active_color" cfg.active_color)
        ++ (optionalArg "inactive_color" cfg.inactive_color)
        ++ (optionalArg "background_color" cfg.background_color)
        ++ (optionalArg "style" cfg.style)
        ++ (optionalArg "blur_radius" (toString cfg.blur_radius))
        ++ (optionalArg "ax_focus" (
          if cfg.ax_focus
          then "on"
          else "off"
        ))
        ++ (optionalArg "blacklist" (joinStrings cfg.blacklist))
        ++ (optionalArg "whitelist" (joinStrings cfg.whitelist))
        ++ (optionalArg "order" cfg.order);
      serviceConfig.KeepAlive = true;
      serviceConfig.RunAtLoad = true;
      managedBy = "services.jankyborders.enable";
    };
  };
}
</file>

<file path="modules/services/karabiner-elements/default.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.services.karabiner-elements;

  parentAppDir = "/Applications/.Nix-Karabiner";
in

{
  options.services.karabiner-elements = {
    enable = mkEnableOption "Karabiner-Elements";
    package = mkPackageOption pkgs "karabiner-elements" { };
  };

  config = mkIf cfg.enable {
    environment.systemPackages = [ cfg.package ];

    system.activationScripts.preActivation.text = ''
      rm -rf ${parentAppDir}
      mkdir -p ${parentAppDir}
      # Kernel extensions must reside inside of /Applications, they cannot be symlinks
      cp -r ${cfg.package.driver}/Applications/.Karabiner-VirtualHIDDevice-Manager.app ${parentAppDir}
    '';

    system.activationScripts.postActivation.text = ''
      echo "attempt to activate karabiner system extension and start daemons" >&2
      launchctl unload /Library/LaunchDaemons/org.nixos.start_karabiner_daemons.plist
      launchctl load -w /Library/LaunchDaemons/org.nixos.start_karabiner_daemons.plist
    '';

    # We need the karabiner_grabber and karabiner_observer daemons to run after the
    # Nix Store has been mounted, but we can't use wait4path as they need to be
    # executed directly for the Input Monitoring permission. We also want these
    # daemons to auto restart but if they start up without the Nix Store they will
    # refuse to run again until they've been unloaded and loaded back in so we can
    # use a helper daemon to start them. We also only want to run the daemons after
    # the system extension is activated, so we can call activate from the manager
    # which will block until the system extension is activated.
    launchd.daemons.start_karabiner_daemons = {
      script = ''
          ${parentAppDir}/.Karabiner-VirtualHIDDevice-Manager.app/Contents/MacOS/Karabiner-VirtualHIDDevice-Manager activate
          launchctl kickstart system/org.pqrs.karabiner.karabiner_grabber
          launchctl kickstart system/org.pqrs.karabiner.karabiner_observer
      '';
      serviceConfig.Label = "org.nixos.start_karabiner_daemons";
      serviceConfig.RunAtLoad = true;
    };

    launchd.daemons.karabiner_grabber = {
      serviceConfig.ProgramArguments = [
        "${cfg.package}/Library/Application Support/org.pqrs/Karabiner-Elements/bin/karabiner_grabber"
      ];
      serviceConfig.ProcessType = "Interactive";
      serviceConfig.Label = "org.pqrs.karabiner.karabiner_grabber";
      serviceConfig.KeepAlive.SuccessfulExit = true;
      serviceConfig.KeepAlive.Crashed = true;
      serviceConfig.KeepAlive.AfterInitialDemand = true;
    };

    launchd.daemons.karabiner_observer = {
      serviceConfig.ProgramArguments = [
        "${cfg.package}/Library/Application Support/org.pqrs/Karabiner-Elements/bin/karabiner_observer"
      ];

      serviceConfig.Label = "org.pqrs.karabiner.karabiner_observer";
      serviceConfig.KeepAlive.SuccessfulExit = true;
      serviceConfig.KeepAlive.Crashed = true;
      serviceConfig.KeepAlive.AfterInitialDemand = true;
    };

    launchd.daemons.Karabiner-DriverKit-VirtualHIDDeviceClient = {
      command = "\"${cfg.package.driver}/Library/Application Support/org.pqrs/Karabiner-DriverKit-VirtualHIDDevice/Applications/Karabiner-DriverKit-VirtualHIDDeviceClient.app/Contents/MacOS/Karabiner-DriverKit-VirtualHIDDeviceClient\"";
      serviceConfig.ProcessType = "Interactive";
      serviceConfig.Label = "org.pqrs.Karabiner-DriverKit-VirtualHIDDeviceClient";
      serviceConfig.KeepAlive = true;
    };

    # Normally karabiner_console_user_server calls activate on the manager but
    # because we use a custom location we need to call activate manually.
    launchd.user.agents.activate_karabiner_system_ext = {
      serviceConfig.ProgramArguments = [
        "${parentAppDir}/.Karabiner-VirtualHIDDevice-Manager.app/Contents/MacOS/Karabiner-VirtualHIDDevice-Manager" "activate"
      ];
      serviceConfig.RunAtLoad = true;
      managedBy = "services.karabiner-elements.enable";
    };

    # We need this to run every reboot as /run gets nuked so we can't put this
    # inside the preActivation script as it only gets run on darwin-rebuild switch.
    launchd.daemons.setsuid_karabiner_session_monitor = {
      script = ''
          rm -rf /run/wrappers
          mkdir -p /run/wrappers/bin
          install -m4555 "${cfg.package}/Library/Application Support/org.pqrs/Karabiner-Elements/bin/karabiner_session_monitor" /run/wrappers/bin
      '';
      serviceConfig.RunAtLoad = true;
      serviceConfig.KeepAlive.SuccessfulExit = false;
    };

    launchd.user.agents.karabiner_session_monitor = {
      serviceConfig.ProgramArguments = [
        "/bin/sh" "-c"
        "/bin/wait4path /run/wrappers/bin && /run/wrappers/bin/karabiner_session_monitor"
      ];
      serviceConfig.Label = "org.pqrs.karabiner.karabiner_session_monitor";
      serviceConfig.KeepAlive = true;
      managedBy = "services.karabiner-elements.enable";
    };

    environment.userLaunchAgents."org.pqrs.karabiner.agent.karabiner_grabber.plist".source = "${cfg.package}/Library/LaunchAgents/org.pqrs.karabiner.agent.karabiner_grabber.plist";
    environment.userLaunchAgents."org.pqrs.karabiner.agent.karabiner_observer.plist".source = "${cfg.package}/Library/LaunchAgents/org.pqrs.karabiner.agent.karabiner_observer.plist";
    environment.userLaunchAgents."org.pqrs.karabiner.karabiner_console_user_server.plist".source = "${cfg.package}/Library/LaunchAgents/org.pqrs.karabiner.karabiner_console_user_server.plist";
  };
}
</file>

<file path="modules/services/khd/default.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.services.khd;

  i3Config = import ./i3.nix { inherit pkgs; };
in

{
  options = {
    services.khd.enable = mkOption {
      type = types.bool;
      default = false;
      description = "Whether to enable the khd hotkey daemon.";
    };

    services.khd.package = mkOption {
      type = types.package;
      default = pkgs.khd;
      defaultText = "pkgs.khd";
      description = "This option specifies the khd package to use.";
    };

    services.khd.khdConfig = mkOption {
      type = types.lines;
      default = "";
      example = "alt + shift - r   :   kwmc quit";
      description = "Config to use for {file}`khdrc`.";
    };

    services.khd.i3Keybindings = mkOption {
      type = types.bool;
      default = false;
      description = "Wether to configure i3 style keybindings for kwm.";
    };
  };

  config = mkIf cfg.enable {

    services.khd.khdConfig = mkIf cfg.i3Keybindings i3Config;

    security.accessibilityPrograms = [ "${cfg.package}/bin/khd" ];

    environment.etc."khdrc".text = cfg.khdConfig;

    launchd.user.agents.khd = {
      path = [ cfg.package config.environment.systemPath ];

      serviceConfig.ProgramArguments = [ "${cfg.package}/bin/khd" ]
        ++ optionals (cfg.khdConfig != "") [ "-c" "/etc/khdrc" ];
      serviceConfig.KeepAlive = true;
      serviceConfig.ProcessType = "Interactive";
      serviceConfig.Sockets.Listeners =
        { SockServiceName = "3021";
          SockType = "dgram";
          SockFamily = "IPv4";
        };

      managedBy = "services.khd.enable";
    };

  };
}
</file>

<file path="modules/services/khd/i3.nix">
{ pkgs }:

''
  alt - return        : open -b com.apple.Terminal ""
  alt - j             : kwmc window -f west
  alt - k             : kwmc window -f south
  alt - l             : kwmc window -f north
  alt - 0x29          : kwmc window -f east
  alt - space         : kwmc config focus-follows-mouse toggle

  alt + shift - j     : kwmc window -m west
  alt + shift - k     : kwmc window -m south
  alt + shift - l     : kwmc window -m north
  alt + shift - 0x29  : kwmc window -m east

  alt - f             : kwmc window -z fullscreen
  alt - v             : kwmc display -c vertical
  alt - h             : kwmc display -c horizontal
  alt - r             : print "maybe with prefix?"

  alt - e             : kwmc window -c type bsp
  alt - s             : kwmc window -c type monocle
  alt - w             : kwmc window -c type monocle

  alt + shift - space : kwmc window -t focused

  alt - 1             : kwmc space -fExperimental 2
  alt - 2             : kwmc space -fExperimental 3
  alt - 3             : kwmc space -fExperimental 4
  alt - 4             : kwmc space -fExperimental 5
  alt - 5             : kwmc space -fExperimental 6
  alt - 6             : kwmc space -fExperimental 7

  alt + shift - 1     : kwmc window -m space 1
  alt + shift - 2     : kwmc window -m space 2
  alt + shift - 3     : kwmc window -m space 3
  alt + shift - 4     : kwmc window -m space 4
  alt + shift - 5     : kwmc window -m space 5
  alt + shift - 6     : kwmc window -m space 6

  alt + shift - c     : kwmc config reload
  alt + shift - r     : kwmc quit
  alt + shift - e     : kwmc quit
''
</file>

<file path="modules/services/kwm/default.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.services.kwm;
in

{
  options = {
    services.kwm.enable = mkOption {
      type = types.bool;
      default = false;
      description = "Whether to enable the khd window manager.";
    };

    services.kwm.package = mkOption {
      type = types.path;
      default = pkgs.kwm;
      defaultText = "pkgs.kwm";
      description = "This option specifies the kwm package to use.";
    };

    services.kwm.kwmConfig = mkOption {
      type = types.lines;
      default = "";
      example = ''kwmc rule owner="iTerm2" properties={role="AXDialog"}'';
      description = "Config to use for {file}`kwmrc`.";
    };
  };

  config = mkIf cfg.enable {

    security.accessibilityPrograms = [ "${cfg.package}/kwm" ];

    environment.systemPackages = [ cfg.package ];

    environment.etc."kwmrc".text = cfg.kwmConfig;

    launchd.user.agents.kwm = {
      serviceConfig.ProgramArguments = [ "${cfg.package}/kwm" ]
        ++ optionals (cfg.kwmConfig != "") [ "-c" "/etc/kwmrc" ];
      serviceConfig.KeepAlive = true;
      serviceConfig.ProcessType = "Interactive";
      serviceConfig.Sockets.Listeners =
        { SockServiceName = "3020";
          SockType = "dgram";
          SockFamily = "IPv4";
        };
      managedBy = "services.kwm.enable";
    };

  };
}
</file>

<file path="modules/services/mail/offlineimap.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.services.offlineimap;
in {

  options.services.offlineimap = {
    enable = mkEnableOption "Offlineimap, a software to dispose your mailbox(es) as a local Maildir(s)";

    package = mkOption {
      type = types.package;
      default = pkgs.offlineimap;
      defaultText = "pkgs.offlineimap";
      description = "Offlineimap derivation to use.";
    };

    path = mkOption {
      type = types.listOf types.path;
      default = [];
      example = literalExpression "[ pkgs.pass pkgs.bash pkgs.notmuch ]";
      description = "List of derivations to put in Offlineimap's path.";
    };

    startInterval = mkOption {
      type = types.nullOr types.int;
      default = 300;
      description = "Optional key to start offlineimap services each N seconds";
    };

    runQuick = mkOption {
      type = types.bool;
      default = false;
      description = ''
        Run only quick synchronizations.
        Ignore any flag updates on IMAP servers. If a flag on the remote IMAP changes, and we have the message locally, it will be left untouched in a quick run.
      '';
    };

    extraConfig = mkOption {
      type = types.lines;
      default = "";
      description = "Additional text to be appended to {file}`offlineimaprc`.";
    };
  };

  config = mkIf cfg.enable {
    environment.systemPackages = [ cfg.package ];
    environment.etc."offlineimaprc".text = cfg.extraConfig;
    launchd.user.agents.offlineimap = {
      path                            = [ cfg.package ];
      command                         = "${cfg.package}/bin/offlineimap -c /etc/offlineimaprc" + optionalString (cfg.runQuick) " -q";
      serviceConfig.KeepAlive         = false;
      serviceConfig.RunAtLoad         = true;
      serviceConfig.StartInterval     = cfg.startInterval;
      serviceConfig.StandardErrorPath = "/var/log/offlineimap.log";
      serviceConfig.StandardOutPath   = "/var/log/offlineimap.log";
      managedBy = "services.offlineimap.enable";
    };
  };
}
</file>

<file path="modules/services/monitoring/netdata.nix">
{ config, lib, pkgs, ... }:
with lib;
let
  cfg = config.services.netdata;

in {
  meta.maintainers = [ lib.maintainers.rsrohitsingh682 or "rsrohitsingh682" ];

  options = {
    services.netdata = {
      enable = mkEnableOption "Netdata daemon";

      package = lib.mkPackageOption pkgs "netdata" {};

      config = mkOption {
        type = types.lines;
        default = "";
        description = "Custom configuration for Netdata";
      };

      workDir = mkOption {
        type = types.path;
        default = "/var/lib/netdata";
        description = "Working directory for Netdata";
      };

      logDir = mkOption {
        type = types.path;
        default = "/var/log/netdata";
        description = "Log directory for Netdata";
      };

      cacheDir = mkOption {
        type = types.path;
        default = "/var/cache/netdata";
        description = "Cache directory for Netdata";
      };
    };
  };

  config = mkIf cfg.enable {
    environment.systemPackages = [ cfg.package ];

    launchd.daemons.netdata = {
      serviceConfig = {
        Label = "netdata";
        KeepAlive = true;
        WorkingDirectory = cfg.workDir;
        StandardErrorPath = "${cfg.logDir}/netdata.log";
        StandardOutPath = "${cfg.logDir}/netdata.log";
      };
      command = lib.getExe cfg.package;
    };

    environment.etc."netdata/netdata.conf".text = cfg.config;

    system.activationScripts.preActivation.text = ''
      mkdir -p ${cfg.workDir}
      mkdir -p ${cfg.cacheDir}
    '';
  };
}
</file>

<file path="modules/services/monitoring/prometheus-node-exporter.nix">
{
  config,
  lib,
  pkgs,
  ...
}:

let
  inherit (lib)
    concatStringsSep
    escapeShellArgs
    getExe
    mkEnableOption
    mkIf
    mkOption
    mkPackageOption
    mkRemovedOptionModule
    types
  ;

  cfg = config.services.prometheus.exporters.node;
in {
  imports = [
    (mkRemovedOptionModule [ "services" "prometheus" "exporters" "node" "openFirewall" ] "No nix-darwin equivalent to this NixOS option.")
    (mkRemovedOptionModule [ "services" "prometheus" "exporters" "node" "firewallFilter" ] "No nix-darwin equivalent to this NixOS option.")
    (mkRemovedOptionModule [ "services" "prometheus" "exporters" "node" "firewallRules" ] "No nix-darwin equivalent to this NixOS option.")
  ];

  options = {
    services.prometheus.exporters.node = {
      enable = mkEnableOption "Prometheus Node exporter";

      package = mkPackageOption pkgs "prometheus-node-exporter" { };

      listenAddress = mkOption {
        type = types.str;
        default = "";
        example = "0.0.0.0";
        description = ''
          Address where Node exporter exposes its HTTP interface. Leave empty to bind to all addresses.
        '';
      };

      port = mkOption {
        type = types.port;
        default = 9100;
        description = ''
          Port where the Node exporter exposes its HTTP interface.
        '';
      };

      extraFlags = mkOption {
        type = types.listOf types.str;
        default = [ ];
        example = [ "--log.level=debug" ];
        description = ''
          Extra commandline options to pass to the Node exporter executable.
        '';
      };

      enabledCollectors = mkOption {
        type = types.listOf types.str;
        default = [ ];
        description = ''
          Collectors to enable in addition to the ones that are [enabled by default](https://github.com/prometheus/node_exporter#enabled-by-default).
        '';
      };

      disabledCollectors = mkOption {
        type = types.listOf types.str;
        default = [ ];
        example = [ "boottime" ];
        description = ''
          Collectors to disable from the list of collectors that are [enabled by default](https://github.com/prometheus/node_exporter#enabled-by-default).
        '';
      };
    };
  };

  config = mkIf cfg.enable {
    users.users._prometheus-node-exporter = {
      uid = config.ids.uids._prometheus-node-exporter;
      gid = config.ids.gids._prometheus-node-exporter;
      home = "/var/lib/prometheus-node-exporter";
      createHome = true;
      shell = "/usr/bin/false";
      description = "System user for the Prometheus Node exporter";
    };

    users.groups._prometheus-node-exporter = {
      gid = config.ids.gids._prometheus-node-exporter;
      description = "System group for the Prometheus Node exporter";
    };

    users.knownGroups = [ "_prometheus-node-exporter" ];
    users.knownUsers = [ "_prometheus-node-exporter" ];

    launchd.daemons.prometheus-node-exporter = {
      script = concatStringsSep " "
        ([
          (getExe cfg.package)
          "--web.listen-address"
          "${cfg.listenAddress}:${toString cfg.port}"
        ]
        ++ (map (collector: "--collector.${collector}") cfg.enabledCollectors)
        ++ (map (collector: "--no-collector.${collector}") cfg.disabledCollectors)
      ) + escapeShellArgs cfg.extraFlags;
      serviceConfig = let
        logPath = config.users.users._prometheus-node-exporter.home
          + "/prometheus-node-exporter.log";
      in {
        KeepAlive = true;
        RunAtLoad = true;
        StandardErrorPath = logPath;
        StandardOutPath = logPath;
        GroupName = "_prometheus-node-exporter";
        UserName = "_prometheus-node-exporter";
      };
    };
  };
}
</file>

<file path="modules/services/monitoring/telegraf.nix">
{ config, lib, pkgs, ... }:

let
  inherit (lib) mkEnableOption mkOption types mkIf;

  cfg = config.services.telegraf;

  settingsFormat = pkgs.formats.toml { };
  configFile = settingsFormat.generate "config.toml" cfg.extraConfig;
in {
  options = {
    services.telegraf = {
      enable = mkEnableOption "telegraf agent";

      package = mkOption {
        default = pkgs.telegraf;
        defaultText = lib.literalExpression "pkgs.telegraf";
        description = "Which telegraf derivation to use";
        type = types.package;
      };

      environmentFiles = mkOption {
        type = types.listOf types.path;
        default = [ ];
        example = [ "/run/keys/telegraf.env" ];
        description = ''
          File to load as environment file.
          This is useful to avoid putting secrets into the nix store.
        '';
      };

      extraConfig = mkOption {
        default = { };
        description = "Extra configuration options for telegraf";
        type = settingsFormat.type;
        example = {
          outputs.influxdb = {
            urls = [ "http://localhost:8086" ];
            database = "telegraf";
          };
          inputs.statsd = {
            service_address = ":8125";
            delete_timings = true;
          };
        };
      };

      configUrl = mkOption {
        default = null;
        description = "Url to fetch config from";
        type = types.nullOr types.str;
      };
    };
  };

  config = mkIf cfg.enable {
    launchd.daemons.telegraf = {
      script = ''
        ${lib.concatStringsSep "\n"
        (map (file: "source ${file}") cfg.environmentFiles)}
        ${cfg.package}/bin/telegraf --config ${
          if cfg.configUrl == null then configFile else cfg.configUrl
        }
      '';
      serviceConfig = {
        KeepAlive = true;
        RunAtLoad = true;
      };

      # https://github.com/influxdata/telegraf/issues/17607
      environment.HOME = "/var/root";
    };
  };
}
</file>

<file path="modules/services/nextdns/default.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.services.nextdns;
  nextdns = pkgs.nextdns;

in {
  options = {
    services.nextdns = {
      enable = mkOption {
        type = types.bool;
        default = false;
        description =
          "Whether to enable the NextDNS DNS/53 to DoH Proxy service.";
      };
      arguments = mkOption {
        type = types.listOf types.str;
        default = [ ];
        example = [ "-config" "10.0.3.0/24=abcdef" ];
        description = "Additional arguments to be passed to nextdns run.";
      };
    };
  };

  config = mkIf cfg.enable {

    environment.systemPackages = [ nextdns ];

    launchd.daemons.nextdns = {
      path = [ nextdns ];
      command = concatStringsSep " " (["${pkgs.nextdns}/bin/nextdns run"] ++ cfg.arguments);
      serviceConfig.KeepAlive = true;
      serviceConfig.RunAtLoad = true;
    };

  };
}
</file>

<file path="modules/services/nix-gc/default.nix">
# Based off: https://github.com/NixOS/nixpkgs/blob/master/nixos/modules/services/misc/nix-gc.nix
# When making changes please try to keep it in sync.
{ config, lib, ... }:

with lib;

let
  cfg = config.nix.gc;
  launchdTypes = import ../../launchd/types.nix { inherit config lib; };
in

{
  imports = [
    (mkRemovedOptionModule [ "nix" "gc" "dates" ] "Use `nix.gc.interval` instead.")
    (mkRemovedOptionModule [ "nix" "gc" "randomizedDelaySec" ] "No `nix-darwin` equivalent to this NixOS option.")
    (mkRemovedOptionModule [ "nix" "gc" "persistent" ] "No `nix-darwin` equivalent to this NixOS option.")
    (mkRemovedOptionModule [ "nix" "gc" "user" ] "The garbage collection service now always runs as `root`.")
  ];

  ###### interface

  options = {

    nix.gc = {

      automatic = mkOption {
        default = false;
        type = types.bool;
        description = "Automatically run the garbage collector at a specific time.";
      };

      interval = mkOption {
        type = launchdTypes.StartCalendarInterval;
        default = [{ Weekday = 7; Hour = 3; Minute = 15; }];
        description = ''
          The calendar interval at which the garbage collector will run.
          See the {option}`serviceConfig.StartCalendarInterval` option of
          the {option}`launchd` module for more info.
        '';
      };

      options = mkOption {
        default = "";
        example = "--max-freed $((64 * 1024**3))";
        type = types.str;
        description = ''
          Options given to {file}`nix-collect-garbage` when the
          garbage collector is run automatically.
        '';
      };

    };

  };


  ###### implementation

  config = {
    assertions = [
      {
        assertion = cfg.automatic -> config.nix.enable;
        message = ''nix.gc.automatic requires nix.enable'';
      }
    ];

    launchd.daemons.nix-gc = mkIf cfg.automatic {
      command = "${config.nix.package}/bin/nix-collect-garbage ${cfg.options}";
      serviceConfig.RunAtLoad = false;
      serviceConfig.StartCalendarInterval = cfg.interval;
    };
  };
}
</file>

<file path="modules/services/nix-optimise/default.nix">
# Based off:
# https://github.com/NixOS/nixpkgs/blob/master/nixos/modules/services/misc/nix-optimise.nix
# When making changes please try to keep it in sync.
{ config, lib, ... }:


let
  inherit (lib)
    mkIf
    mkOption
    mkRemovedOptionModule
    optionalString
    types
    ;

  cfg = config.nix.optimise;
  launchdTypes = import ../../launchd/types.nix { inherit config lib; };
in

{
  imports = [
    (mkRemovedOptionModule [ "nix" "optimise" "dates" ] "Use `nix.optimise.interval` instead.")
    (mkRemovedOptionModule [ "nix" "optimise" "user" ] "The store optimisation service now always runs as `root`.")
  ];

  ###### interface

  options = {

    nix.optimise = {

      automatic = mkOption {
        type = types.bool;
        default = false;
        description = "Automatically run the nix store optimiser at a specific time.";
      };

      interval = mkOption {
        type = launchdTypes.StartCalendarInterval;
        default = [{ Weekday = 7; Hour = 4; Minute = 15; }];
        description = ''
          The calendar interval at which the optimiser will run.
          See the {option}`serviceConfig.StartCalendarInterval` option of
          the {option}`launchd` module for more info.
        '';
      };

    };

  };


  ###### implementation

  config = {
    assertions = [
      {
        assertion = cfg.automatic -> config.nix.enable;
        message = ''nix.optimise.automatic requires nix.enable'';
      }
    ];

    launchd.daemons.nix-optimise = mkIf cfg.automatic {
      command = "${lib.getExe' config.nix.package "nix-store"} --optimise";
      serviceConfig = {
        RunAtLoad = false;
        StartCalendarInterval = cfg.interval;
      };
    };
  };
}
</file>

<file path="modules/services/postgresql/default.nix">
{ config, lib, pkgs, ... }:

with lib;

let

  cfg = config.services.postgresql;

  postgresql =
    if cfg.extraPlugins == []
      then cfg.package
      else cfg.package.withPackages (_: cfg.extraPlugins);

  toStr = value:
    if true == value then "yes"
    else if false == value then "no"
    else if isString value then "'${lib.replaceStrings ["'"] ["''"] value}'"
    else toString value;

  # The main PostgreSQL configuration file.
  configFile = pkgs.writeTextDir "postgresql.conf" (concatStringsSep "\n" (mapAttrsToList (n: v: "${n} = ${toStr v}") cfg.settings));

  configFileCheck = pkgs.runCommand "postgresql-configfile-check" {} ''
    ${cfg.package}/bin/postgres -D${configFile} -C config_file >/dev/null
    touch $out
  '';

  groupAccessAvailable = versionAtLeast postgresql.version "11.0";

in

{
  imports = [
    (mkRemovedOptionModule [ "services" "postgresql" "extraConfig" ] "Use services.postgresql.settings instead.")
  ];

  ###### interface

  options = {

    services.postgresql = {

      enable = mkEnableOption "PostgreSQL Server";

      package = mkOption {
        type = types.package;
        example = literalExpression "pkgs.postgresql_11";
        description = ''
          PostgreSQL package to use.
        '';
      };

      port = mkOption {
        type = types.int;
        default = 5432;
        description = ''
          The port on which PostgreSQL listens.
        '';
      };

      checkConfig = mkOption {
        type = types.bool;
        default = true;
        description = "Check the syntax of the configuration file at compile time";
      };

      dataDir = mkOption {
        type = types.path;
        defaultText = literalExpression ''"/var/lib/postgresql/''${config.services.postgresql.package.psqlSchema}"'';
        example = "/var/lib/postgresql/11";
        description = ''
          The data directory for PostgreSQL. If left as the default value
          this directory will automatically be created before the PostgreSQL server starts, otherwise
          the sysadmin is responsible for ensuring the directory exists with appropriate ownership
          and permissions.
        '';
      };

      authentication = mkOption {
        type = types.lines;
        default = "";
        description = ''
          Defines how users authenticate themselves to the server. See the
          [
          PostgreSQL documentation for pg_hba.conf](https://www.postgresql.org/docs/current/auth-pg-hba-conf.html)
          for details on the expected format of this option. By default,
          peer based authentication will be used for users connecting
          via the Unix socket, and md5 password authentication will be
          used for users connecting via TCP. Any added rules will be
          inserted above the default rules. If you'd like to replace the
          default rules entirely, you can use `lib.mkForce` in your
          module.
        '';
      };

      identMap = mkOption {
        type = types.lines;
        default = "";
        description = ''
          Defines the mapping from system users to database users.

          The general form is:

          map-name system-username database-username
        '';
      };

      initdbArgs = mkOption {
        type = with types; listOf str;
        default = [];
        example = [ "--data-checksums" "--allow-group-access" ];
        description = ''
          Additional arguments passed to `initdb` during data dir
          initialisation.
        '';
      };

      initialScript = mkOption {
        type = types.nullOr types.path;
        default = null;
        description = ''
          A file containing SQL statements to execute on first startup.
        '';
      };

      ensureDatabases = mkOption {
        type = types.listOf types.str;
        default = [];
        description = ''
          Ensures that the specified databases exist.
          This option will never delete existing databases, especially not when the value of this
          option is changed. This means that databases created once through this option or
          otherwise have to be removed manually.
        '';
        example = [
          "gitea"
          "nextcloud"
        ];
      };

      ensureUsers = mkOption {
        type = types.listOf (types.submodule {
          options = {
            name = mkOption {
              type = types.str;
              description = ''
                Name of the user to ensure.
              '';
            };
            ensurePermissions = mkOption {
              type = types.attrsOf types.str;
              default = {};
              description = ''
                Permissions to ensure for the user, specified as an attribute set.
                The attribute names specify the database and tables to grant the permissions for.
                The attribute values specify the permissions to grant. You may specify one or
                multiple comma-separated SQL privileges here.

                For more information on how to specify the target
                and on which privileges exist, see the
                [GRANT syntax](https://www.postgresql.org/docs/current/sql-grant.html).
                The attributes are used as `GRANT ''${attrValue} ON ''${attrName}`.
              '';
              example = literalExpression ''
                {
                  "DATABASE \"nextcloud\"" = "ALL PRIVILEGES";
                  "ALL TABLES IN SCHEMA public" = "ALL PRIVILEGES";
                }
              '';
            };
          };
        });
        default = [];
        description = ''
          Ensures that the specified users exist and have at least the ensured permissions.
          The PostgreSQL users will be identified using peer authentication. This authenticates the Unix user with the
          same name only, and that without the need for a password.
          This option will never delete existing users or remove permissions, especially not when the value of this
          option is changed. This means that users created and permissions assigned once through this option or
          otherwise have to be removed manually.
        '';
        example = literalExpression ''
          [
            {
              name = "nextcloud";
              ensurePermissions = {
                "DATABASE nextcloud" = "ALL PRIVILEGES";
              };
            }
            {
              name = "superuser";
              ensurePermissions = {
                "ALL TABLES IN SCHEMA public" = "ALL PRIVILEGES";
              };
            }
          ]
        '';
      };

      enableTCPIP = mkOption {
        type = types.bool;
        default = false;
        description = ''
          Whether PostgreSQL should listen on all network interfaces.
          If disabled, the database can only be accessed via its Unix
          domain socket or via TCP connections to localhost.
        '';
      };

      logLinePrefix = mkOption {
        type = types.str;
        default = "[%p] ";
        example = "%m [%p] ";
        description = ''
          A printf-style string that is output at the beginning of each log line.
          Upstream default is `'%m [%p] '`, i.e. it includes the timestamp. We do
          not include the timestamp, because journal has it anyway.
        '';
      };

      extraPlugins = mkOption {
        type = types.listOf types.path;
        default = [];
        example = literalExpression "with pkgs.postgresql_11.pkgs; [ postgis pg_repack ]";
        description = ''
          List of PostgreSQL plugins. PostgreSQL version for each plugin should
          match version for `services.postgresql.package` value.
        '';
      };

      settings = mkOption {
        type = with types; attrsOf (oneOf [ bool float int str ]);
        default = {};
        description = ''
          PostgreSQL configuration. Refer to
          <https://www.postgresql.org/docs/11/config-setting.html#CONFIG-SETTING-CONFIGURATION-FILE>
          for an overview of `postgresql.conf`.

          ::: {.note}

          String values will automatically be enclosed in single quotes. Single quotes will be
          escaped with two single quotes as described by the upstream documentation linked above.

          :::
        '';
        example = literalExpression ''
          {
            log_connections = true;
            log_statement = "all";
            logging_collector = true
            log_disconnections = true
            log_destination = lib.mkForce "syslog";
          }
        '';
      };

      recoveryConfig = mkOption {
        type = types.nullOr types.lines;
        default = null;
        description = ''
          Contents of the {file}`recovery.conf` file.
        '';
      };

      superUser = mkOption {
        type = types.str;
        default = "postgres";
        internal = true;
        readOnly = true;
        description = ''
          PostgreSQL superuser account to use for various operations. Internal since changing
          this value would lead to breakage while setting up databases.
        '';
        };
    };

  };

  ###### implementation

  config = mkIf cfg.enable {

    # FIXME: implement. I didn't implement these because they require some
    # sort of postStart facility, which launchd does not provide.
    #
    # one could perhaps trigger another agent by the existing agent, but
    # I couldn't find how to do that.
    warnings = if cfg.initialScript != null
      || cfg.ensureDatabases != []
      || cfg.ensureUsers != []
      then [''
        Currently nix-darwin does not support postgresql initialScript,
        ensureDatabases, or ensureUsers
      '']
      else [];

    services.postgresql.settings =
      {
        hba_file = "${pkgs.writeText "pg_hba.conf" cfg.authentication}";
        ident_file = "${pkgs.writeText "pg_ident.conf" cfg.identMap}";
        log_destination = "stderr";
        log_line_prefix = cfg.logLinePrefix;
        listen_addresses = if cfg.enableTCPIP then "*" else "localhost";
        port = cfg.port;
      };

    services.postgresql.package = let
        mkThrow = ver: throw "postgresql_${ver} was removed, please upgrade your postgresql version.";
    in
      # Note: when changing the default, make it conditional on
      # ‚Äòsystem.stateVersion‚Äô to maintain compatibility with existing
      # systems!
      mkDefault (if config.system.stateVersion >= 4 then pkgs.postgresql_14
            else mkThrow "9_6");

    services.postgresql.dataDir = mkDefault "/var/lib/postgresql/${cfg.package.psqlSchema}";

    services.postgresql.authentication = mkAfter
      ''
        # Generated file; do not edit!
        local all all              peer
        host  all all 127.0.0.1/32 md5
        host  all all ::1/128      md5
      '';

    environment.systemPackages = [ postgresql ];

    environment.pathsToLink = [
     "/share/postgresql"
    ];

    # FIXME: implement system.extraDependencies to do this less sketchily
    # system.extraDependencies = lib.optional (cfg.checkConfig && pkgs.stdenv.hostPlatform == pkgs.stdenv.buildPlatform) configFileCheck;

    launchd.user.agents.postgresql =
      { path = [ postgresql ];
        script = ''
          # FIXME: ${if cfg.checkConfig then configFileCheck else ""}

          if ! test -e ${cfg.dataDir}/PG_VERSION; then
            # Cleanup the data directory.
            ${pkgs.coreutils}/bin/rm -f ${cfg.dataDir}/*.conf

            # Initialise the database.
            ${postgresql}/bin/initdb -U ${cfg.superUser} ${concatStringsSep " " cfg.initdbArgs}

            # See postStart!
            # FIXME: implement postStart
            # touch "${cfg.dataDir}/.first_startup"
          fi

          ${pkgs.coreutils}/bin/ln -sfn ${configFile}/postgresql.conf ${cfg.dataDir}/postgresql.conf
          ${optionalString (cfg.recoveryConfig != null) ''
            ${pkgs.coreutils}/bin/ln -sfn "${pkgs.writeText "recovery.conf" cfg.recoveryConfig}" \
              "${cfg.dataDir}/recovery.conf"
          ''}

          exec ${postgresql}/bin/postgres
        '';

        serviceConfig.KeepAlive = true;
        serviceConfig.RunAtLoad = true;
        serviceConfig.EnvironmentVariables = {
          PGDATA = cfg.dataDir;
        };
        managedBy = "services.postgresql.enable";
      };

  };
}
</file>

<file path="modules/services/privoxy/default.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.services.privoxy;
in
{
  options = {
    services.privoxy.enable = mkOption {
      type = types.bool;
      default = false;
      description = "Whether to enable the privoxy proxy service.";
    };

    services.privoxy.listenAddress = mkOption {
      type = types.str;
      default = "127.0.0.1:8118";
      description = "The address and TCP port on which privoxy will listen.";
    };

    services.privoxy.package = mkOption {
      type = types.package;
      default = pkgs.privoxy;
      example = literalExpression "pkgs.privoxy";
      description = "This option specifies the privoxy package to use.";
    };

    services.privoxy.config = mkOption {
      type = types.lines;
      default = "";
      example = "forward / upstream.proxy:8080";
      description = "Config to use for privoxy";
    };

    services.privoxy.templdir = mkOption {
      type = types.path;
      default = "${pkgs.privoxy}/etc/templates";
      defaultText = "\${pkgs.privoxy}/etc/templates";
      description = "Directory for privoxy template files.";
    };

    services.privoxy.confdir = mkOption {
      type = types.nullOr types.path;
      default = null;
      description = "Directory for privoxy files such as .action and .filter.";
    };
  };

  config = mkIf cfg.enable {
    environment.etc."privoxy-config".text = ''
      ${optionalString (cfg.confdir != null) "confdir ${cfg.confdir}"}
      templdir ${cfg.templdir}
      listen-address ${cfg.listenAddress}
      ${cfg.config}
    '';

    launchd.user.agents.privoxy = {
      path = [ config.environment.systemPath ];
      command = ''
      ${cfg.package}/bin/privoxy /etc/privoxy-config
      '';
      serviceConfig.KeepAlive = true;
      managedBy = "services.privoxy.enable";
    };
  };
}
</file>

<file path="modules/services/redis/default.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.services.redis;
in

{
  options = {
    services.redis.enable = mkOption {
      type = types.bool;
      default = false;
      description = "Whether to enable the redis database service.";
    };

    services.redis.package = mkOption {
      type = types.path;
      default = pkgs.redis;
      defaultText = "pkgs.redis";
      description = "This option specifies the redis package to use";
    };

    services.redis.dataDir = mkOption {
      type = types.nullOr types.path;
      default = "/var/lib/redis";
      description = "Data directory for the redis database.";
    };

    services.redis.port = mkOption {
      type = types.int;
      default = 6379;
      description = "The port for Redis to listen to.";
    };

    services.redis.bind = mkOption {
      type = types.nullOr types.str;
      default = null; # All interfaces
      description = "The IP interface to bind to.";
      example = "127.0.0.1";
    };

    services.redis.unixSocket = mkOption {
      type = types.nullOr types.path;
      default = null;
      description = "The path to the socket to bind to.";
      example = "/var/run/redis.sock";
    };

    services.redis.appendOnly = mkOption {
      type = types.bool;
      default = false;
      description = "By default data is only periodically persisted to disk, enable this option to use an append-only file for improved persistence.";
    };

    services.redis.extraConfig = mkOption {
      type = types.lines;
      default = "";
      description = "Additional text to be appended to {file}`redis.conf`.";
    };
  };

  config = mkIf cfg.enable {

    environment.systemPackages = [ cfg.package ];

    launchd.user.agents.redis = {
      command = "${cfg.package}/bin/redis-server /etc/redis.conf";
      serviceConfig.KeepAlive = true;
      managedBy = "services.redis.enable";
    };

    environment.etc."redis.conf".text = ''
      port ${toString cfg.port}
      ${optionalString (cfg.bind != null) "bind ${cfg.bind}"}
      ${optionalString (cfg.unixSocket != null) "unixsocket ${cfg.unixSocket}"}
      ${optionalString (cfg.dataDir != null) "dir ${cfg.dataDir}"}
      appendOnly ${if cfg.appendOnly then "yes" else "no"}
      ${cfg.extraConfig}
    '';

  };
}
</file>

<file path="modules/services/sketchybar/default.nix">
{ config, lib, pkgs, ... }:

let
  inherit (lib) literalExpression maintainers mkEnableOption mkIf mkPackageOption mkOption optionals types;

  cfg = config.services.sketchybar;

  configFile = pkgs.writeScript "sketchybarrc" cfg.config;
in

{

  meta.maintainers = [
    maintainers.azuwis or "azuwis"
  ];

  options.services.sketchybar = {
    enable = mkEnableOption "sketchybar";

    package = mkPackageOption pkgs "sketchybar" { };

    extraPackages = mkOption {
      type = types.listOf types.package;
      default = [ ];
      example = literalExpression "[ pkgs.jq ]";
      description = ''
        Extra packages to add to PATH.
      '';
    };

    config = mkOption {
      type = types.lines;
      default = "";
      example = ''
        sketchybar --bar height=24
        sketchybar --update
        echo "sketchybar configuration loaded.."
      '';
      description = ''
        Contents of sketchybar's configuration file. If empty (the default), the configuration file won't be managed.

        See [documentation](https://felixkratz.github.io/SketchyBar/)
        and [example](https://github.com/FelixKratz/SketchyBar/blob/master/sketchybarrc).
      '';
    };
  };

  config = mkIf cfg.enable {
    environment.systemPackages = [ cfg.package ];

    launchd.user.agents.sketchybar = {
      path = [ cfg.package ] ++ cfg.extraPackages ++ [ config.environment.systemPath ];
      serviceConfig.ProgramArguments = [ "${cfg.package}/bin/sketchybar" ]
        ++ optionals (cfg.config != "") [ "--config" "${configFile}" ];
      serviceConfig.KeepAlive = true;
      serviceConfig.RunAtLoad = true;
      managedBy = "services.sketchybar.enable";
    };
  };
}
</file>

<file path="modules/services/skhd/default.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.services.skhd;
in

{
  options = {
    services.skhd.enable = mkOption {
      type = types.bool;
      default = false;
      description = "Whether to enable the skhd hotkey daemon.";
    };

    services.skhd.package = mkOption {
      type = types.package;
      default = pkgs.skhd;
      description = "This option specifies the skhd package to use.";
    };

    services.skhd.skhdConfig = mkOption {
      type = types.lines;
      default = "";
      example = "alt + shift - r   :   chunkc quit";
      description = "Config to use for {file}`skhdrc`.";
    };
  };

  config = mkIf cfg.enable {
    environment.systemPackages = [ cfg.package ];

    environment.etc."skhdrc".text = cfg.skhdConfig;

    launchd.user.agents.skhd = {
      path = [ config.environment.systemPath ];

      serviceConfig.ProgramArguments = [ "${cfg.package}/bin/skhd" ]
        ++ optionals (cfg.skhdConfig != "") [ "-c" "/etc/skhdrc" ];
      serviceConfig.KeepAlive = true;
      serviceConfig.ProcessType = "Interactive";

      managedBy = "services.skhd.enable";
    };

  };
}
</file>

<file path="modules/services/spacebar/default.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.services.spacebar;

  toSpacebarConfig = opts:
    concatStringsSep "\n" (mapAttrsToList
      (p: v: "spacebar -m config ${p} ${toString v}") opts);

  configFile = mkIf (cfg.config != {} || cfg.extraConfig != "")
    "${pkgs.writeScript "spacebarrc" (
      (if (cfg.config != {})
       then "${toSpacebarConfig cfg.config}"
       else "")
      + optionalString (cfg.extraConfig != "") cfg.extraConfig)}";
in

{
  options = with types; {
    services.spacebar.enable = mkOption {
      type = bool;
      default = false;
      description = "Whether to enable the spacebar spacebar.";
    };

    services.spacebar.package = mkOption {
      type = path;
      description = "The spacebar package to use.";
    };

    services.spacebar.config = mkOption {
      type = attrs;
      default = {};
      example = literalExpression ''
        {
          clock_format     = "%R";
          background_color = "0xff202020";
          foreground_color = "0xffa8a8a8";
        }
      '';
      description = ''
        Key/Value pairs to pass to spacebar's 'config' domain, via the configuration file.
      '';
    };

    services.spacebar.extraConfig = mkOption {
      type = str;
      default = "";
      example = literalExpression ''
        echo "spacebar config loaded..."
      '';
      description = ''
        Extra arbitrary configuration to append to the configuration file.
      '';
    };
  };

  config = mkIf (cfg.enable) {
    environment.systemPackages = [ cfg.package ];

    launchd.user.agents.spacebar = {
      serviceConfig.ProgramArguments = [ "${cfg.package}/bin/spacebar" ]
                                       ++ optionals (cfg.config != {} || cfg.extraConfig != "") [ "-c" configFile ];

      serviceConfig.KeepAlive = true;
      serviceConfig.RunAtLoad = true;
      serviceConfig.EnvironmentVariables = {
        PATH = "${cfg.package}/bin:${config.environment.systemPath}";
      };

      managedBy = "services.spacebar.enable";
    };
  };
}
</file>

<file path="modules/services/synergy/default.nix">
{ config, lib, pkgs, ... }:

with lib;

let

  cfg = config.services.synergy;

in

{
  options = {

    services.synergy = {
      package = mkOption {
        default = pkgs.synergy;
        defaultText = "pkgs.synergy";
        type = types.package;
        description = "The package used for the synergy client and server.";
      };

      client = {
        enable = mkOption {
          default = false;
          type = types.bool;
          description = ''
            Whether to enable the Synergy client (receive keyboard and mouse events from a Synergy server).
          '';
        };
        screenName = mkOption {
          default = "";
          type = types.str;
          description = ''
            Use the given name instead of the hostname to identify
            ourselves to the server.
          '';
        };
        serverAddress = mkOption {
          type = types.str;
          description = ''
            The server address is of the form: [hostname][:port].  The
            hostname must be the address or hostname of the server.  The
            port overrides the default port, 24800.
          '';
        };
        autoStart = mkOption {
          default = true;
          type = types.bool;
          description = "Whether the Synergy client should be started automatically.";
        };
        tls = {
          enable = mkEnableOption ''
            Whether TLS encryption should be used.

            Using this requires a TLS certificate that can be
            generated by starting the Synergy GUI once and entering
            a valid product key'';
          cert = mkOption {
            type = types.nullOr types.str;
            default = null;
            example = "~/.synergy/SSL/Synergy.pem";
            description = "The TLS certificate to use for encryption.";
          };
        };
      };

      server = {
        enable = mkOption {
          default = false;
          type = types.bool;
          description = ''
            Whether to enable the Synergy server (send keyboard and mouse events).
          '';
        };
        configFile = mkOption {
          default = "/etc/synergy-server.conf";
          type = types.str;
          description = "The Synergy server configuration file.";
        };
        screenName = mkOption {
          default = "";
          type = types.str;
          description = ''
            Use the given name instead of the hostname to identify
            this screen in the configuration.
          '';
        };
        address = mkOption {
          default = "";
          type = types.str;
          description = "Address on which to listen for clients.";
        };
        autoStart = mkOption {
          default = true;
          type = types.bool;
          description = "Whether the Synergy server should be started automatically.";
        };
        tls = {
          enable = mkEnableOption ''
            Whether TLS encryption should be used.

            Using this requires a TLS certificate that can be
            generated by starting the Synergy GUI once and entering
            a valid product key'';
          cert = mkOption {
            type = types.nullOr types.str;
            default = null;
            example = "~/.synergy/SSL/Synergy.pem";
            description = "The TLS certificate to use for encryption.";
          };
        };
      };
    };

  };


  config = mkMerge [
    (mkIf cfg.client.enable {
      launchd.user.agents."synergy-client" = {
        path = [ config.environment.systemPath ];
        serviceConfig.ProgramArguments = [
          "${cfg.package}/bin/synergyc" "-f"
        ] ++ optionals (cfg.client.tls.enable) [ "--enable-crypto" ]
          ++ optionals (cfg.client.tls.cert != null) [ "--tls-cert" cfg.client.tls.cert ]
          ++ optionals (cfg.client.screenName != "") [ "-n" cfg.client.screenName ]
          ++ [
          cfg.client.serverAddress
        ];
        serviceConfig.KeepAlive = true;
        serviceConfig.RunAtLoad = cfg.client.autoStart;
        serviceConfig.ProcessType = "Interactive";
        managedBy = "services.synergy.client.enable";
      };
    })

    (mkIf cfg.server.enable {
      launchd.user.agents."synergy-server" = {
        path = [ config.environment.systemPath ];
        serviceConfig.ProgramArguments = [
          "${cfg.package}/bin/synergys" "-c" "${cfg.server.configFile}" "-f"
        ] ++ optionals (cfg.server.tls.enable) [ "--enable-crypto" ]
          ++ optionals (cfg.server.tls.cert != null) [ "--tls-cert" cfg.server.tls.cert ]
          ++ optionals (cfg.server.screenName != "") [ "-n" cfg.server.screenName ]
          ++ optionals (cfg.server.address != "") [ "-a" cfg.server.address ];
        serviceConfig.KeepAlive = true;
        serviceConfig.RunAtLoad = cfg.server.autoStart;
        serviceConfig.ProcessType = "Interactive";
        managedBy = "services.synergy.server.enable";
      };
    })
  ];
}
</file>

<file path="modules/services/yabai/default.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.services.yabai;

  toYabaiConfig = opts:
    concatStringsSep "\n" (mapAttrsToList
      (p: v: "yabai -m config ${p} ${toString v}")
      opts);

  configFile = mkIf (cfg.config != { } || cfg.extraConfig != "")
    "${pkgs.writeScript "yabairc" (
      (if (cfg.config != {})
       then "${toYabaiConfig cfg.config}"
       else "")
      + optionalString (cfg.extraConfig != "") ("\n" + cfg.extraConfig + "\n"))}";
in

{
  options = with types; {
    services.yabai.enable = mkOption {
      type = bool;
      default = false;
      description = "Whether to enable the yabai window manager.";
    };

    services.yabai.package = mkOption {
      type = path;
      default = pkgs.yabai;
      description = "The yabai package to use.";
    };

    services.yabai.enableScriptingAddition = mkOption {
      type = bool;
      default = false;
      description = ''
        Whether to enable yabai's scripting-addition.
        SIP must be disabled for this to work.
      '';
    };

    services.yabai.config = mkOption {
      type = attrs;
      default = { };
      example = literalExpression ''
        {
          focus_follows_mouse = "autoraise";
          mouse_follows_focus = "off";
          window_placement    = "second_child";
          window_opacity      = "off";
          top_padding         = 36;
          bottom_padding      = 10;
          left_padding        = 10;
          right_padding       = 10;
          window_gap          = 10;
        }
      '';
      description = ''
        Key/Value pairs to pass to yabai's 'config' domain, via the configuration file.
      '';
    };

    services.yabai.extraConfig = mkOption {
      type = lines;
      default = "";
      example = literalExpression ''
        yabai -m rule --add app='System Preferences' manage=off
      '';
      description = "Extra arbitrary configuration to append to the configuration file";
    };
  };

  config = mkMerge [
    (mkIf (cfg.enable) {
      environment.systemPackages = [ cfg.package ];

      launchd.user.agents.yabai = {
        serviceConfig.ProgramArguments = [ "${cfg.package}/bin/yabai" ]
          ++ optionals (cfg.config != { } || cfg.extraConfig != "") [ "-c" configFile ];

        serviceConfig.KeepAlive = true;
        serviceConfig.RunAtLoad = true;
        serviceConfig.EnvironmentVariables = {
          PATH = "${cfg.package}/bin:${config.environment.systemPath}";
        };

        managedBy = "services.yabai.enable";
      };
    })

    # TODO: [@cmacrae] Handle removal of yabai scripting additions
    (mkIf (cfg.enableScriptingAddition) {
      launchd.daemons.yabai-sa = {
        script = "${cfg.package}/bin/yabai --load-sa";
        serviceConfig.RunAtLoad = true;
        serviceConfig.KeepAlive.SuccessfulExit = false;
      };

      environment.etc."sudoers.d/yabai".source = pkgs.runCommand "sudoers-yabai" {} ''
        YABAI_BIN="${cfg.package}/bin/yabai"
        SHASUM=$(sha256sum "$YABAI_BIN" | cut -d' ' -f1)
        cat <<EOF >"$out"
        %admin ALL=(root) NOPASSWD: sha256:$SHASUM $YABAI_BIN --load-sa
        EOF
      '';
    })
  ];
}
</file>

<file path="modules/services/autossh.nix">
{ config, lib, pkgs, ... }:

with lib;

let

  cfg = config.services.autossh;

in

{

  ###### interface

  options = {

    services.autossh = {

      sessions = mkOption {
        type = types.listOf (types.submodule {
          options = {
            name = mkOption {
              type = types.str;
              example = "socks-peer";
              description = "Name of the local AutoSSH session";
            };
            user = mkOption {
              type = types.str;
              example = "bill";
              description = "Name of the user the AutoSSH session should run as";
            };
            monitoringPort = mkOption {
              type = types.int;
              default = 0;
              example = 20000;
              description = ''
                Port to be used by AutoSSH for peer monitoring. Note, that
                AutoSSH also uses mport+1. Value of 0 disables the keep-alive
                style monitoring
              '';
            };
            extraArguments = mkOption {
              type = types.str;
              example = "-N -D4343 bill@socks.example.net";
              description = ''
                Arguments to be passed to AutoSSH and retransmitted to SSH
                process. Some meaningful options include -N (don't run remote
                command), -D (open SOCKS proxy on local port), -R (forward
                remote port), -L (forward local port), -v (Enable debug). Check
                ssh manual for the complete list.
              '';
            };
          };
        });

        default = [];
        description = ''
          List of AutoSSH sessions to start as launchd daemon. Each daemon is
          named 'autossh-{session.name}'.
        '';

        example = [
          {
            name="socks-peer";
            user="bill";
            monitoringPort = 20000;
            extraArguments="-N -D4343 billremote@socks.host.net";
          }
        ];

      };
    };

  };

  ###### implementation

  config = mkIf (cfg.sessions != []) {

    launchd.daemons =
      lib.fold ( s : acc : acc //
        {
          "autossh-${s.name}" =
            let
              mport = if s ? monitoringPort then s.monitoringPort else 0;
            in
            {
              # To be able to start the service with no network connection
              environment.AUTOSSH_GATETIME="0";

              # How often AutoSSH checks the network, in seconds
              environment.AUTOSSH_POLL="30";

              command = "${pkgs.autossh}/bin/autossh -M ${toString mport} ${s.extraArguments}";

              serviceConfig = {
                  KeepAlive = true;
                  UserName = "${s.user}";
              };
            };
        }) {} cfg.sessions;

    environment.systemPackages = [ pkgs.autossh ];

  };
}
</file>

<file path="modules/services/buildkite-agents.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.services.buildkite-agents;
  literalMD = lib.literalMD or (x: lib.literalDocBook "Documentation not rendered. Please upgrade to a newer NixOS with markdown support.");

  mkHookOption = { name, description, example ? null }: {
    inherit name;
    value = mkOption {
      default = null;
      description = description;
      type = types.nullOr types.lines;
    } // (if example == null then {} else { inherit example; });
  };
  mkHookOptions = hooks: listToAttrs (map mkHookOption hooks);

  hooksDir = cfg: let
    mkHookEntry = name: value: ''
      cat > $out/${name} <<'EOF'
      #! ${pkgs.runtimeShell}
      set -e
      ${value}
      EOF
      chmod 755 $out/${name}
    '';
  in pkgs.runCommand "buildkite-agent-hooks" { preferLocalBuild = true; } ''
    mkdir $out
    ${concatStringsSep "\n" (mapAttrsToList mkHookEntry (filterAttrs (n: v: v != null) cfg.hooks))}
  '';

  buildkiteOptions = { name ? "", config, ... }: {
    options = {
      enable = mkOption {
        default = true;
        type = types.bool;
        description = "Whether to enable this buildkite agent";
      };

      package = mkOption {
        default = pkgs.buildkite-agent;
        defaultText = literalExpression "pkgs.buildkite-agent";
        description = "Which buildkite-agent derivation to use";
        type = types.package;
      };

      dataDir = mkOption {
        default = "/var/lib/buildkite-agent-${name}";
        description = "The workdir for the agent";
        type = types.str;
      };

      runtimePackages = mkOption {
        default = [ pkgs.bash pkgs.gnutar pkgs.gzip pkgs.git pkgs.nix ];
        defaultText = literalExpression "[ pkgs.bash pkgs.gnutar pkgs.gzip pkgs.git pkgs.nix ]";
        description = "Add programs to the buildkite-agent environment";
        type = types.listOf (types.either types.package types.path);
      };

      tokenPath = mkOption {
        type = types.path;
        description = ''
          The token from your Buildkite "Agents" page.

          A run-time path to the token file, which is supposed to be provisioned
          outside of Nix store.
        '';
      };

      name = mkOption {
        type = types.str;
        default = "%hostname-${name}-%n";
        description = ''
          The name of the agent as seen in the buildkite dashboard.
        '';
      };

      tags = mkOption {
        type = types.attrsOf (types.either types.str (types.listOf types.str));
        default = {};
        example = { queue = "default"; docker = "true"; ruby2 ="true"; };
        description = ''
          Tags for the agent.
        '';
      };

      extraConfig = mkOption {
        type = types.lines;
        default = "";
        example = "debug=true";
        description = ''
          Extra lines to be added verbatim to the configuration file.
        '';
      };

      preCommands = mkOption {
        type = types.lines;
        default = "";
        description = ''
          Extra commands to run before starting buildkite.
        '';
      };

      privateSshKeyPath = mkOption {
        type = types.nullOr types.path;
        default = null;
        ## maximum care is taken so that secrets (ssh keys and the CI token)
        ## don't end up in the Nix store.
        apply = final: if final == null then null else toString final;

        description = ''
          OpenSSH private key

          A run-time path to the key file, which is supposed to be provisioned
          outside of Nix store.
        '';
      };

      hooks = mkHookOptions [
        { name = "checkout";
          description = ''
            The `checkout` hook script will replace the default checkout routine of the
            bootstrap.sh script. You can use this hook to do your own SCM checkout
            behaviour
          ''; }
        { name = "command";
          description = ''
            The `command` hook script will replace the default implementation of running
            the build command.
          ''; }
        { name = "environment";
          description = ''
            The `environment` hook will run before all other commands, and can be used
            to set up secrets, data, etc. Anything exported in hooks will be available
            to the build script.

            Note: the contents of this file will be copied to the world-readable
            Nix store.
          '';
          example = ''
            export SECRET_VAR=`head -1 /run/keys/secret`
          ''; }
        { name = "post-artifact";
          description = ''
            The `post-artifact` hook will run just after artifacts are uploaded
          ''; }
        { name = "post-checkout";
          description = ''
            The `post-checkout` hook will run after the bootstrap script has checked out
            your projects source code.
          ''; }
        { name = "post-command";
          description = ''
            The `post-command` hook will run after the bootstrap script has run your
            build commands
          ''; }
        { name = "pre-artifact";
          description = ''
            The `pre-artifact` hook will run just before artifacts are uploaded
          ''; }
        { name = "pre-checkout";
          description = ''
            The `pre-checkout` hook will run just before your projects source code is
            checked out from your SCM provider
          ''; }
        { name = "pre-command";
          description = ''
            The `pre-command` hook will run just before your build command runs
          ''; }
        { name = "pre-exit";
          description = ''
            The `pre-exit` hook will run just before your build job finishes
          ''; }
      ];

      hooksPath = mkOption {
        type = types.path;
        default = hooksDir config;
        defaultText = literalMD "generated from {option}`services.buildkite-agents.<name>.hooks`";
        description = ''
          Path to the directory storing the hooks.
          Consider using {option}`services.buildkite-agents.<name>.hooks.<name>`
          instead.
        '';
      };

      shell = mkOption {
        type = types.str;
        default = "${pkgs.bash}/bin/bash -e -c";
        defaultText = literalExpression ''"''${pkgs.bash}/bin/bash -e -c"'';
        description = ''
          Command that buildkite-agent 3 will execute when it spawns a shell.
        '';
      };
    };
  };
  enabledAgents = lib.filterAttrs (n: v: v.enable) cfg;
  mapAgents = function: lib.mkMerge (lib.mapAttrsToList function enabledAgents);
in
{
  options.services.buildkite-agents = mkOption {
    type = types.attrsOf (types.submodule buildkiteOptions);
    default = {};
    description = ''
      Attribute set of buildkite agents.
      The attribute key is combined with the hostname and a unique integer to
      create the final agent name. This can be overridden by setting the `name`
      attribute.
    '';
  };

  config.users.users = mapAgents (name: cfg: {
    "buildkite-agent-${name}" = {
      name = "buildkite-agent-${name}";
      home = cfg.dataDir;
      createHome = true;
      description = "Buildkite agent user";
    };
  });
  config.users.groups = mapAgents (name: cfg: {
    "buildkite-agent-${name}" = {};
  });

  config.launchd.daemons = mapAgents (name: cfg: {
    "buildkite-agent-${name}" =
      { path = cfg.runtimePackages ++ [ cfg.package pkgs.coreutils pkgs.darwin.DarwinTools ];
        environment = {
          HOME = cfg.dataDir;
          NIX_REMOTE = "daemon";
          inherit (config.environment.variables) NIX_SSL_CERT_FILE;
        };

        ## NB: maximum care is taken so that secrets (ssh keys and the CI token)
        ##     don't end up in the Nix store.
        script = let
          sshDir = "${cfg.dataDir}/.ssh";
          tagStr =
            name: value:
            if lib.isList value then
              lib.concatStringsSep "," (builtins.map (v: "${name}=${v}") value)
            else
              "${name}=${value}";
          tagsStr = lib.concatStringsSep "," (lib.mapAttrsToList tagStr cfg.tags);
        in
          optionalString (cfg.privateSshKeyPath != null) ''
            mkdir -m 0700 "${sshDir}"
            install -m600 "${toString cfg.privateSshKeyPath}" "${sshDir}/id_rsa"
          '' + ''
            cat > "${cfg.dataDir}/buildkite-agent.cfg" <<EOF
            token="$(cat ${toString cfg.tokenPath})"
            name="${cfg.name}"
            shell="${cfg.shell}"
            tags="${tagsStr}"
            build-path="${cfg.dataDir}/builds"
            hooks-path="${cfg.hooksPath}"
            ${cfg.extraConfig}
            EOF

            ${cfg.preCommands}

            ${cfg.package}/bin/buildkite-agent start --config ${cfg.dataDir}/buildkite-agent.cfg
          '';

        serviceConfig = {
          ProcessType = "Interactive";
          ThrottleInterval = 30;

          # The combination of KeepAlive.NetworkState and WatchPaths
          # will ensure that buildkite-agent is started on boot, but
          # after networking is available (so the hostname is
          # correct).
          RunAtLoad = true;
          WatchPaths = [
            "/etc/resolv.conf"
            "/Library/Preferences/SystemConfiguration/NetworkInterfaces.plist"
          ];

          GroupName = "buildkite-agent-${name}";
          UserName = "buildkite-agent-${name}";
          WorkingDirectory = config.users.users."buildkite-agent-${name}".home;
          StandardErrorPath = "${cfg.dataDir}/buildkite-agent.log";
          StandardOutPath = "${cfg.dataDir}/buildkite-agent.log";
        };
      };
  });

  config.assertions = mapAgents (name: cfg: [
      { assertion = cfg.hooksPath == (hooksDir cfg)  || all (v: v == null) (attrValues cfg.hooks);
        message = ''
          Options `services.buildkite-agents.${name}.hooksPath' and
          `services.buildkite-agents.${name}.hooks.<name>' are mutually exclusive.
        '';
      }
  ]);

  imports = [
    (mkRemovedOptionModule [ "services" "buildkite-agent"] "services.buildkite-agent has been moved to an attribute set at services.buildkite-agents")
  ];
}
</file>

<file path="modules/services/cachix-agent.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.services.cachix-agent;
in {
  options.services.cachix-agent = {
    enable = mkOption {
      type = types.bool;
      default = false;
      description = ''
        Enable to run Cachix Agent as a system service.
        
        Read [Cachix Deploy](https://docs.cachix.org/deploy/) documentation for more information.
      '';
    };

    name = mkOption {
      type = types.str;
      default = config.networking.hostName;
      description = ''
        Agent name, usually the same as the hostname.
      '';
    };

    package = mkOption {
      description = ''
        Package containing cachix executable.
      '';
      type = types.package;
      default = pkgs.cachix;
      defaultText = literalExpression "pkgs.cachix";
    };

    credentialsFile = mkOption {
      type = types.path;
      default = "/etc/cachix-agent.token";
      description = ''
        Required file that needs to contain:
       
          export CACHIX_AGENT_TOKEN=...
      '';
    };

    logFile = mkOption {
      type = types.nullOr types.path;
      default = "/var/log/cachix-agent.log";
      description = "Absolute path to log all stderr and stdout";
    };
  };

  config = mkIf cfg.enable {
    # TODO: Upstream this to NixOS.
    assertions = [
      {
        assertion = config.nix.enable;
        message = ''`services.cachix-agent.enable` requires `nix.enable`'';
      }
    ];

    launchd.daemons.cachix-agent = {
      script = ''
        . ${cfg.credentialsFile}

        exec ${cfg.package}/bin/cachix deploy agent ${cfg.name}
      '';

      path = [ config.nix.package pkgs.coreutils config.environment.systemPath ];

      environment = {
        NIX_SSL_CERT_FILE = "${pkgs.cacert}/etc/ssl/certs/ca-bundle.crt";
        USER = "root";
      };

      serviceConfig.KeepAlive = true;
      serviceConfig.RunAtLoad = true;
      serviceConfig.ProcessType = "Interactive";
      serviceConfig.StandardErrorPath = cfg.logFile;
      serviceConfig.StandardOutPath = cfg.logFile;
      serviceConfig.WatchPaths = [
        cfg.credentialsFile
      ];
    };
  };
}
</file>

<file path="modules/services/chunkwm.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.services.chunkwm;
  plugins = [ "border" "ffm" "tiling" ];
in

{
  options = {
    services.chunkwm.enable = mkOption {
      type = types.bool;
      default = false;
      description = "Whether to enable the chunkwm window manager.";
    };

    services.chunkwm.package = mkOption {
      type = types.package;
      example = literalExpression "pkgs.chunkwm";
      description = "This option specifies the chunkwm package to use.";
    };

    services.chunkwm.hotload = mkOption {
      type = types.bool;
      default = true;
      description = "Whether to enable hotload.";
    };

    services.chunkwm.extraConfig = mkOption {
      type = types.lines;
      default = "";
      example = ''chunkc tiling::rule --owner Emacs --state tile'';
      description = "Additional commands for {file}`chunkwmrc`.";
    };

    services.chunkwm.plugins.dir = mkOption {
      type = types.path;
      default = "/run/current-system/sw/lib/chunkwm/plugins";
      description = "Chunkwm Plugins directory.";
    };

    services.chunkwm.plugins.list = mkOption {
      type = types.listOf (types.enum plugins);
      default = plugins;
      example = ["tiling"];
      description = "Chunkwm Plugins to enable.";
    };

    services.chunkwm.plugins."border".config = mkOption {
      type = types.lines;
      default = ''chunkc set focused_border_color   0xffc0b18b'';
      description = "Optional border plugin configuration.";
    };

    services.chunkwm.plugins."tiling".config = mkOption {
      type = types.lines;
      example = ''chunkc set global_desktop_mode   bsp'';
      description = "Optional tiling plugin configuration.";
    };
  };

  config = mkIf cfg.enable {

    services.chunkwm.plugins."border".config = mkDefault ''
      chunkc set focused_border_color          0xffc0b18b
      chunkc set focused_border_width          4
      chunkc set focused_border_radius         0
      chunkc set focused_border_skip_floating  0
    '';

    services.chunkwm.plugins."tiling".config = mkDefault ''
      chunkc set global_desktop_mode           bsp
      chunkc set 2_desktop_mode                monocle
      chunkc set 5_desktop_mode                float

      chunkc set 1_desktop_tree                ~/.chunkwm_layouts/dev_1

      chunkc set global_desktop_offset_top     25
      chunkc set global_desktop_offset_bottom  15
      chunkc set global_desktop_offset_left    15
      chunkc set global_desktop_offset_right   15
      chunkc set global_desktop_offset_gap     15

      chunkc set 1_desktop_offset_top          25
      chunkc set 1_desktop_offset_bottom       15
      chunkc set 1_desktop_offset_left         15
      chunkc set 1_desktop_offset_right        15
      chunkc set 1_desktop_offset_gap          15

      chunkc set 3_desktop_offset_top          15
      chunkc set 3_desktop_offset_bottom       15
      chunkc set 3_desktop_offset_left         15
      chunkc set 3_desktop_offset_right        15

      chunkc set desktop_padding_step_size     10.0
      chunkc set desktop_gap_step_size         5.0

      chunkc set bsp_spawn_left                1
      chunkc set bsp_optimal_ratio             1.618
      chunkc set bsp_split_mode                optimal
      chunkc set bsp_split_ratio               0.66

      chunkc set window_focus_cycle            monitor
      chunkc set mouse_follows_focus           1
      chunkc set window_float_next             0
      chunkc set window_float_center           1
      chunkc set window_region_locked          1
    '';

    environment.etc."chunkwmrc".source = pkgs.writeScript "etc-chunkwmrc" (
      ''
        #!/bin/bash
        chunkc core::plugin_dir ${toString cfg.plugins.dir}
        chunkc core::hotload ${if cfg.hotload then "1" else "0"}
      ''
        + concatMapStringsSep "\n" (p: "# Config for chunkwm-${p} plugin\n"+cfg.plugins.${p}.config or "# Nothing to configure") cfg.plugins.list
        + concatMapStringsSep "\n" (p: "chunkc core::load "+p+".so") cfg.plugins.list
        + "\n" + cfg.extraConfig
    );

    launchd.user.agents.chunkwm = {
      path = [ cfg.package config.environment.systemPath ];
      serviceConfig.ProgramArguments = [ "${getOutput "out" cfg.package}/bin/chunkwm" ]
        ++ [ "-c" "/etc/chunkwmrc" ];
      serviceConfig.RunAtLoad = true;
      serviceConfig.KeepAlive = true;
      serviceConfig.ProcessType = "Interactive";
      managedBy = "services.chunkwm.enable";
    };

  };
}
</file>

<file path="modules/services/dnscrypt-proxy.nix">
{
  config,
  lib,
  pkgs,
  ...
}:

let

  cfg = config.services.dnscrypt-proxy;

  format = pkgs.formats.toml { };

  configFile = format.generate "dnscrypt-proxy.toml" cfg.settings;

in

{
  options.services.dnscrypt-proxy = {

    enable = lib.mkEnableOption "the dnscrypt-proxy service.";

    package = lib.mkPackageOption pkgs "dnscrypt-proxy" { };

    settings = lib.mkOption {
      description = ''
        Attrset that is converted and passed as TOML config file.
        For available params, see: <https://github.com/DNSCrypt/dnscrypt-proxy/blob/${pkgs.dnscrypt-proxy.version}/dnscrypt-proxy/example-dnscrypt-proxy.toml>
      '';
      example = lib.literalExpression ''
        {
          sources.public-resolvers = {
            urls = [ "https://download.dnscrypt.info/resolvers-list/v2/public-resolvers.md" ];
            cache_file = "public-resolvers.md";
            minisign_key = "RWQf6LRCGA9i53mlYecO4IzT51TGPpvWucNSCh1CBM0QTaLn73Y7GFO3";
            refresh_delay = 72;
          };
        }
      '';
      type = format.type;
      default = { };
    };
  };

  config = lib.mkIf cfg.enable {
    users.users._dnscrypt-proxy = {
      uid = config.ids.uids._dnscrypt-proxy;
      gid = config.ids.gids._dnscrypt-proxy;
      home = "/var/lib/dnscrypt-proxy";
      createHome = true;
      shell = "/usr/bin/false";
      description = "System user for dnscrypt-proxy";
    };

    users.groups._dnscrypt-proxy = {
      gid = config.ids.gids._dnscrypt-proxy;
      description = "System group for dnscrypt-proxy";
    };

    users.knownUsers = [ "_dnscrypt-proxy" ];
    users.knownGroups = [ "_dnscrypt-proxy" ];

    launchd.daemons.dnscrypt-proxy = {
      script = ''
        ${lib.getExe' cfg.package "dnscrypt-proxy"} -config ${configFile}
      '';
      serviceConfig =
        let
          logPath = config.users.users._dnscrypt-proxy.home + "/dnscrypt-proxy.log";
        in
        {
          RunAtLoad = true;
          KeepAlive = true;
          StandardOutPath = logPath;
          StandardErrorPath = logPath;
          GroupName = "_dnscrypt-proxy";
          UserName = "_dnscrypt-proxy";
        };
    };
  };
}
</file>

<file path="modules/services/dnsmasq.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.services.dnsmasq;
  mapA = f: attrs: with builtins; attrValues (mapAttrs f attrs);
in

{
  options = {
    services.dnsmasq.enable = mkOption {
      type = types.bool;
      default = false;
      description = "Whether to enable DNSmasq.";
    };

    services.dnsmasq.package = mkOption {
      type = types.path;
      default = pkgs.dnsmasq;
      defaultText = "pkgs.dnsmasq";
      description = "This option specifies the dnsmasq package to use.";
    };

    services.dnsmasq.bind = mkOption {
      type = types.str;
      default = "127.0.0.1";
      description = "This option specifies the interface on which DNSmasq will listen.";
    };

    services.dnsmasq.port = mkOption {
      type = types.int;
      default = 53;
      description = "This option specifies port on which DNSmasq will listen.";
    };

    services.dnsmasq.addresses = mkOption {
      type = types.attrs;
      default = {};
      description = "List of domains that will be redirected by the DNSmasq.";
      example = literalExpression ''
        { localhost = "127.0.0.1"; }
        '';
    };

    services.dnsmasq.servers = mkOption {
      type = types.listOf types.str;
      default = [];
      description = ''
        List of upstream DNS servers to forward queries to.
        If empty, dnsmasq will use the servers from /etc/resolv.conf.
        Each entry can be:
        - An IP address (e.g., "1.2.3.4")
        - A domain-specific server (e.g., "/example.com/1.2.3.4")
        - A server with port (e.g., "1.2.3.4#5353")
        See dnsmasq(8) man page for --server option for full syntax.
      '';
      example = literalExpression ''
        [
          "8.8.8.8"
          "8.8.4.4"
          "/internal.example.com/192.168.1.1"
        ]
      '';
    };
  };

  config = mkIf cfg.enable {
    environment.systemPackages = [ cfg.package ];

    launchd.daemons.dnsmasq = {
      serviceConfig.ProgramArguments = [
        "${cfg.package}/bin/dnsmasq"
        "--listen-address=${cfg.bind}"
        "--port=${toString cfg.port}"
        "--keep-in-foreground"
      ] ++ (mapA (domain: addr: "--address=/${domain}/${addr}") cfg.addresses)
        ++ (map (server: "--server=${server}") cfg.servers);

      serviceConfig.KeepAlive = true;
      serviceConfig.RunAtLoad = true;
    };

    environment.etc = builtins.listToAttrs (builtins.map (domain: {
      name = "resolver/${domain}";
      value = {
        enable = true;
        text = ''
          port ${toString cfg.port}
          nameserver ${cfg.bind}
          '';
      };
    }) (builtins.attrNames cfg.addresses));
  };
}
</file>

<file path="modules/services/emacs.nix">
{ config, lib, pkgs, ... }:

with lib;

let

  cfg = config.services.emacs;

in {
  options = {
    services.emacs = {
      enable = mkOption {
        type = types.bool;
        default = false;
        description = "Whether to enable the Emacs Daemon.";
      };

      package = mkOption {
        type = types.path;
        default = pkgs.emacs;
        description = "This option specifies the emacs package to use.";
      };

      additionalPath = mkOption {
        type = types.listOf types.str;
        default = [ ];
        example = [ "/Users/my_user_name" ];
        description = ''
          This option specifies additional PATH that the emacs daemon would have.
          Typically if you have binaries in your home directory that is what you would add your home path here.
          One caveat is that there won't be shell variable expansion, so you can't use $HOME for example
        '';
      };

      exec = mkOption {
        type = types.str;
        default = "emacs";
        description = "Emacs command/binary to execute.";
      };
    };
  };

  config = mkIf cfg.enable {

    launchd.user.agents.emacs = {
      path = cfg.additionalPath ++ [ config.environment.systemPath ];
      serviceConfig = {
        ProgramArguments = [ "${cfg.package}/bin/${cfg.exec}" "--fg-daemon" ];
        RunAtLoad = true;
        KeepAlive = true;
      };
      managedBy = "services.emacs.enable";
    };

  };
}
</file>

<file path="modules/services/eternal-terminal.nix">
{ config, lib, pkgs, ... }:

with lib;

let cfg = config.services.eternal-terminal;
in {
  options = {
    services.eternal-terminal = {

      enable = mkEnableOption "Eternal Terminal server";

      package = mkOption {
        type = types.path;
        default = pkgs.eternal-terminal;
        defaultText = "pkgs.eternal-terminal";
        description =
          "This option specifies the eternal-terminal package to use.";
      };

      port = mkOption {
        default = 2022;
        type = types.port;
        description = ''
          The port the server should listen on. Will use the server's default (2022) if not specified.

          Make sure to open this port in the firewall if necessary.
        '';
      };

      verbosity = mkOption {
        default = 0;
        type = types.enum (lib.range 0 9);
        description = ''
          The verbosity level (0-9).
        '';
      };

      silent = mkOption {
        default = false;
        type = types.bool;
        description = ''
          If enabled, disables all logging.
        '';
      };

      logSize = mkOption {
        default = 20971520;
        type = types.int;
        description = ''
          The maximum log size.
        '';
      };
    };
  };

  config = mkIf cfg.enable {

    # We need to ensure the et package is fully installed because
    # the (remote) et client runs the `etterminal` binary when it
    # connects.
    environment.systemPackages = [ cfg.package ];

    launchd.daemons.eternal-terminal = {
      path = [ cfg.package ];
      serviceConfig = {
        ProgramArguments = [
          "${cfg.package}/bin/etserver"
          "--cfgfile=${
            pkgs.writeText "et.cfg" ''
              ; et.cfg : Config file for Eternal Terminal
              ;

              [Networking]
              port = ${toString cfg.port}

              [Debug]
              verbose = ${toString cfg.verbosity}
              silent = ${if cfg.silent then "1" else "0"}
              logsize = ${toString cfg.logSize}
            ''
          }"
        ];
        KeepAlive = true;
        RunAtLoad = true;
        HardResourceLimits.NumberOfFiles = 4096;
        SoftResourceLimits.NumberOfFiles = 4096;
      };
    };
  };
  meta.maintainers = [ lib.maintainers.ryane or "ryane" ];
}
</file>

<file path="modules/services/gitlab-runner.nix">
{ config, lib, pkgs, ... }:
with builtins;
with lib;
let
  cfg = config.services.gitlab-runner;
  hasDocker = config.virtualisation.docker.enable;
  hashedServices = mapAttrs'
    (name: service: nameValuePair
      "${name}_${config.networking.hostName}_${
        substring 0 12
        (hashString "md5" (unsafeDiscardStringContext (toJSON service)))}"
      service)
    cfg.services;
  configPath = "$HOME/.gitlab-runner/config.toml";
  configureScript = pkgs.writeShellScriptBin "gitlab-runner-configure" (
    if (cfg.configFile != null) then ''
      mkdir -p $(dirname ${configPath})
      cp ${cfg.configFile} ${configPath}
      # make config file readable by service
      chown -R --reference=$HOME $(dirname ${configPath})
    '' else ''
      set -e
      export CONFIG_FILE=${configPath}

      mkdir -p $(dirname ${configPath})

      # remove no longer existing services
      gitlab-runner verify --delete

      # current and desired state
      NEEDED_SERVICES=$(echo ${concatStringsSep " " (attrNames hashedServices)} | tr " " "\n")
      REGISTERED_SERVICES=$(gitlab-runner list 2>&1 | grep 'Executor' | awk '{ print $1 }')

      # difference between current and desired state
      NEW_SERVICES=$(grep -vxF -f <(echo "$REGISTERED_SERVICES") <(echo "$NEEDED_SERVICES") || true)
      OLD_SERVICES=$(grep -vxF -f <(echo "$NEEDED_SERVICES") <(echo "$REGISTERED_SERVICES") || true)

      # register new services
      ${concatStringsSep "\n" (mapAttrsToList (name: service: ''
        if echo "$NEW_SERVICES" | grep -xq ${name}; then
          bash -c ${escapeShellArg (concatStringsSep " \\\n " ([
            "set -a && source ${service.registrationConfigFile} &&"
            "gitlab-runner register"
            "--non-interactive"
            "--name ${name}"
            "--executor ${service.executor}"
            "--limit ${toString service.limit}"
            "--request-concurrency ${toString service.requestConcurrency}"
            "--maximum-timeout ${toString service.maximumTimeout}"
          ] ++ service.registrationFlags
            ++ optional (service.buildsDir != null)
            "--builds-dir ${service.buildsDir}"
            ++ optional (service.cloneUrl != null)
            "--clone-url ${service.cloneUrl}"
            ++ optional (service.preCloneScript != null)
            "--pre-clone-script ${service.preCloneScript}"
            ++ optional (service.preBuildScript != null)
            "--pre-build-script ${service.preBuildScript}"
            ++ optional (service.postBuildScript != null)
            "--post-build-script ${service.postBuildScript}"
            ++ optional (service.tagList != [ ])
            "--tag-list ${concatStringsSep "," service.tagList}"
            ++ optional service.runUntagged
            "--run-untagged"
            ++ optional service.protected
            "--access-level ref_protected"
            ++ optional service.debugTraceDisabled
            "--debug-trace-disabled"
            ++ map (e: "--env ${escapeShellArg e}") (mapAttrsToList (name: value: "${name}=${value}") service.environmentVariables)
            ++ optionals (hasPrefix "docker" service.executor) (
              assert (
                assertMsg (service.dockerImage != null)
                  "dockerImage option is required for ${service.executor} executor (${name})");
              [ "--docker-image ${service.dockerImage}" ]
              ++ optional service.dockerDisableCache
              "--docker-disable-cache"
              ++ optional service.dockerPrivileged
              "--docker-privileged"
              ++ map (v: "--docker-volumes ${escapeShellArg v}") service.dockerVolumes
              ++ map (v: "--docker-extra-hosts ${escapeShellArg v}") service.dockerExtraHosts
              ++ map (v: "--docker-allowed-images ${escapeShellArg v}") service.dockerAllowedImages
              ++ map (v: "--docker-allowed-services ${escapeShellArg v}") service.dockerAllowedServices
            )
          ))} && sleep 1 || exit 1
        fi
      '') hashedServices)}

      # unregister old services
      for NAME in $(echo "$OLD_SERVICES")
      do
        [ ! -z "$NAME" ] && gitlab-runner unregister \
          --name "$NAME" && sleep 1
      done

      # update global options
      tomlq -t \
         ${escapeShellArg (concatStringsSep " | " [
            ".check_interval = ${toJSON cfg.checkInterval}"
            ".concurrent = ${toJSON cfg.concurrent}"
            ".sentry_dsn = ${toJSON cfg.sentryDSN}"
            ".listen_address = ${toJSON cfg.prometheusListenAddress}"
            ".session_server.listen_address = ${toJSON cfg.sessionServer.listenAddress}"
            ".session_server.advertise_address = ${toJSON cfg.sessionServer.advertiseAddress}"
            ".session_server.session_timeout = ${toJSON cfg.sessionServer.sessionTimeout}"
            "del(.[] | nulls)"
            "del(.session_server[] | nulls)"
         ])} ${configPath} \
        > config.toml.new
      mv config.toml.new ${configPath}

      # make config file readable by service
      chown -R --reference=$HOME $(dirname ${configPath})
    '');
  startScript = pkgs.writeShellScriptBin "gitlab-runner-start" ''
    export CONFIG_FILE=${configPath}
    exec gitlab-runner run --working-directory $HOME
  '';
in
{
  options.services.gitlab-runner = {
    enable = mkEnableOption "Gitlab Runner";
    configFile = mkOption {
      type = types.nullOr types.path;
      default = null;
      description = ''
        Configuration file for gitlab-runner.

        {option}`configFile` takes precedence over {option}`services`.
        {option}`checkInterval` and {option}`concurrent` will be ignored too.

        This option is deprecated, please use {option}`services` instead.
        You can use {option}`registrationConfigFile` and
        {option}`registrationFlags`
        for settings not covered by this module.
      '';
    };
    checkInterval = mkOption {
      type = types.int;
      default = 0;
      example = literalExpression "with lib; (length (attrNames config.services.gitlab-runner.services)) * 3";
      description = ''
        Defines the interval length, in seconds, between new jobs check.
        The default value is 3;
        if set to 0 or lower, the default value will be used.
        See [runner documentation](https://docs.gitlab.com/runner/configuration/advanced-configuration.html#how-check_interval-works) for more information.
      '';
    };
    concurrent = mkOption {
      type = types.int;
      default = 1;
      example = literalExpression "config.nix.maxJobs";
      description = ''
        Limits how many jobs globally can be run concurrently.
        The most upper limit of jobs using all defined runners.
        0 does not mean unlimited.
      '';
    };
    sentryDSN = mkOption {
      type = types.nullOr types.str;
      default = null;
      example = "https://public:private@host:port/1";
      description = ''
        Data Source Name for tracking of all system level errors to Sentry.
      '';
    };
    prometheusListenAddress = mkOption {
      type = types.nullOr types.str;
      default = null;
      example = "localhost:8080";
      description = ''
        Address (&lt;host&gt;:&lt;port&gt;) on which the Prometheus metrics HTTP server
        should be listening.
      '';
    };
    sessionServer = mkOption {
      type = types.submodule {
        options = {
          listenAddress = mkOption {
            type = types.nullOr types.str;
            default = null;
            example = "0.0.0.0:8093";
            description = ''
              An internal URL to be used for the session server.
            '';
          };
          advertiseAddress = mkOption {
            type = types.nullOr types.str;
            default = null;
            example = "runner-host-name.tld:8093";
            description = ''
              The URL that the Runner will expose to GitLab to be used
              to access the session server.
              Fallbacks to {option}`listenAddress` if not defined.
            '';
          };
          sessionTimeout = mkOption {
            type = types.int;
            default = 1800;
            description = ''
              How long in seconds the session can stay active after
              the job completes (which will block the job from finishing).
            '';
          };
        };
      };
      default = { };
      example = literalExpression ''
        {
          listenAddress = "0.0.0.0:8093";
        }
      '';
      description = ''
        The session server allows the user to interact with jobs
        that the Runner is responsible for. A good example of this is the
        [interactive web terminal](https://docs.gitlab.com/ee/ci/interactive_web_terminal/index.html).
      '';
    };
    gracefulTermination = mkOption {
      type = types.bool;
      default = false;
      description = ''
        Finish all remaining jobs before stopping.
        If not set gitlab-runner will stop immediatly without waiting
        for jobs to finish, which will lead to failed builds.
      '';
    };
    gracefulTimeout = mkOption {
      type = types.str;
      default = "infinity";
      example = "5min 20s";
      description = ''
        Time to wait until a graceful shutdown is turned into a forceful one.
      '';
    };
    package = mkOption {
      type = types.package;
      default = pkgs.gitlab-runner;
      defaultText = "pkgs.gitlab-runner";
      example = literalExpression "pkgs.gitlab-runner_1_11";
      description = "Gitlab Runner package to use.";
    };
    extraPackages = mkOption {
      type = types.listOf types.package;
      default = [ ];
      description = ''
        Extra packages to add to PATH for the gitlab-runner process.
      '';
    };
    services = mkOption {
      description = "GitLab Runner services.";
      default = { };
      example = literalExpression ''
        {
          # runner for building in docker via host's nix-daemon
          # nix store will be readable in runner, might be insecure
          nix = {
            # File should contain at least these two variables:
            # `CI_SERVER_URL`
            # `REGISTRATION_TOKEN`
            registrationConfigFile = "/run/secrets/gitlab-runner-registration";
            dockerImage = "alpine";
            dockerVolumes = [
              "/nix/store:/nix/store:ro"
              "/nix/var/nix/db:/nix/var/nix/db:ro"
              "/nix/var/nix/daemon-socket:/nix/var/nix/daemon-socket:ro"
            ];
            dockerDisableCache = true;
            preBuildScript = pkgs.writeScript "setup-container" '''
              mkdir -p -m 0755 /nix/var/log/nix/drvs
              mkdir -p -m 0755 /nix/var/nix/gcroots
              mkdir -p -m 0755 /nix/var/nix/profiles
              mkdir -p -m 0755 /nix/var/nix/temproots
              mkdir -p -m 0755 /nix/var/nix/userpool
              mkdir -p -m 1777 /nix/var/nix/gcroots/per-user
              mkdir -p -m 1777 /nix/var/nix/profiles/per-user
              mkdir -p -m 0755 /nix/var/nix/profiles/per-user/root
              mkdir -p -m 0700 "$HOME/.nix-defexpr"

              . ''${pkgs.nix}/etc/profile.d/nix.sh

              ''${pkgs.nix}/bin/nix-env -i ''${concatStringsSep " " (with pkgs; [ nix cacert git openssh ])}

              ''${pkgs.nix}/bin/nix-channel --add https://nixos.org/channels/nixpkgs-unstable
              ''${pkgs.nix}/bin/nix-channel --update nixpkgs
            ''';
            environmentVariables = {
              ENV = "/etc/profile";
              USER = "root";
              NIX_REMOTE = "daemon";
              PATH = "/nix/var/nix/profiles/default/bin:/nix/var/nix/profiles/default/sbin:/bin:/sbin:/usr/bin:/usr/sbin";
              NIX_SSL_CERT_FILE = "/nix/var/nix/profiles/default/etc/ssl/certs/ca-bundle.crt";
            };
            tagList = [ "nix" ];
          };
          # runner for building docker images
          docker-images = {
            # File should contain at least these two variables:
            # `CI_SERVER_URL`
            # `REGISTRATION_TOKEN`
            registrationConfigFile = "/run/secrets/gitlab-runner-registration";
            dockerImage = "docker:stable";
            dockerVolumes = [
              "/var/run/docker.sock:/var/run/docker.sock"
            ];
            tagList = [ "docker-images" ];
          };
          # runner for executing stuff on host system (very insecure!)
          # make sure to add required packages (including git!)
          # to `environment.systemPackages`
          shell = {
            # File should contain at least these two variables:
            # `CI_SERVER_URL`
            # `REGISTRATION_TOKEN`
            registrationConfigFile = "/run/secrets/gitlab-runner-registration";
            executor = "shell";
            tagList = [ "shell" ];
          };
          # runner for everything else
          default = {
            # File should contain at least these two variables:
            # `CI_SERVER_URL`
            # `REGISTRATION_TOKEN`
            registrationConfigFile = "/run/secrets/gitlab-runner-registration";
            dockerImage = "debian:stable";
          };
        }
      '';
      type = types.attrsOf (types.submodule {
        options = {
          registrationConfigFile = mkOption {
            type = types.path;
            description = ''
              Absolute path to a file with environment variables
              used for gitlab-runner registration.
              A list of all supported environment variables can be found in
              `gitlab-runner register --help`.

              Ones that you probably want to set is

              `CI_SERVER_URL=<CI server URL>`

              `REGISTRATION_TOKEN=<registration secret>`
            '';
          };
          registrationFlags = mkOption {
            type = types.listOf types.str;
            default = [ ];
            example = [ "--docker-helper-image my/gitlab-runner-helper" ];
            description = ''
              Extra command-line flags passed to
              `gitlab-runner register`.
              Execute `gitlab-runner register --help`
              for a list of supported flags.
            '';
          };
          environmentVariables = mkOption {
            type = types.attrsOf types.str;
            default = { };
            example = { NAME = "value"; };
            description = ''
              Custom environment variables injected to build environment.
              For secrets you can use {option}`registrationConfigFile`
              with `RUNNER_ENV` variable set.
            '';
          };
          executor = mkOption {
            type = types.str;
            default = "docker";
            description = ''
              Select executor, eg. shell, docker, etc.
              See [runner documentation](https://docs.gitlab.com/runner/executors/README.html) for more information.
            '';
          };
          buildsDir = mkOption {
            type = types.nullOr types.path;
            default = null;
            example = "/var/lib/gitlab-runner/builds";
            description = ''
              Absolute path to a directory where builds will be stored
              in context of selected executor (Locally, Docker, SSH).
            '';
          };
          cloneUrl = mkOption {
            type = types.nullOr types.str;
            default = null;
            example = "http://gitlab.example.local";
            description = ''
              Overwrite the URL for the GitLab instance. Used if the Runner can‚Äôt connect to GitLab on the URL GitLab exposes itself.
            '';
          };
          dockerImage = mkOption {
            type = types.nullOr types.str;
            default = null;
            description = ''
              Docker image to be used.
            '';
          };
          dockerVolumes = mkOption {
            type = types.listOf types.str;
            default = [ ];
            example = [ "/var/run/docker.sock:/var/run/docker.sock" ];
            description = ''
              Bind-mount a volume and create it
              if it doesn't exist prior to mounting.
            '';
          };
          dockerDisableCache = mkOption {
            type = types.bool;
            default = false;
            description = ''
              Disable all container caching.
            '';
          };
          dockerPrivileged = mkOption {
            type = types.bool;
            default = false;
            description = ''
              Give extended privileges to container.
            '';
          };
          dockerExtraHosts = mkOption {
            type = types.listOf types.str;
            default = [ ];
            example = [ "other-host:127.0.0.1" ];
            description = ''
              Add a custom host-to-IP mapping.
            '';
          };
          dockerAllowedImages = mkOption {
            type = types.listOf types.str;
            default = [ ];
            example = [ "ruby:*" "python:*" "php:*" "my.registry.tld:5000/*:*" ];
            description = ''
              Whitelist allowed images.
            '';
          };
          dockerAllowedServices = mkOption {
            type = types.listOf types.str;
            default = [ ];
            example = [ "postgres:9" "redis:*" "mysql:*" ];
            description = ''
              Whitelist allowed services.
            '';
          };
          preCloneScript = mkOption {
            type = types.nullOr types.path;
            default = null;
            description = ''
              Runner-specific command script executed before code is pulled.
            '';
          };
          preBuildScript = mkOption {
            type = types.nullOr types.path;
            default = null;
            description = ''
              Runner-specific command script executed after code is pulled,
              just before build executes.
            '';
          };
          postBuildScript = mkOption {
            type = types.nullOr types.path;
            default = null;
            description = ''
              Runner-specific command script executed after code is pulled
              and just after build executes.
            '';
          };
          tagList = mkOption {
            type = types.listOf types.str;
            default = [ ];
            description = ''
              Tag list.
            '';
          };
          runUntagged = mkOption {
            type = types.bool;
            default = false;
            description = ''
              Register to run untagged builds; defaults to
              `true` when {option}`tagList` is empty.
            '';
          };
          limit = mkOption {
            type = types.int;
            default = 0;
            description = ''
              Limit how many jobs can be handled concurrently by this service.
              0 (default) simply means don't limit.
            '';
          };
          requestConcurrency = mkOption {
            type = types.int;
            default = 0;
            description = ''
              Limit number of concurrent requests for new jobs from GitLab.
            '';
          };
          maximumTimeout = mkOption {
            type = types.int;
            default = 0;
            description = ''
              What is the maximum timeout (in seconds) that will be set for
              job when using this Runner. 0 (default) simply means don't limit.
            '';
          };
          protected = mkOption {
            type = types.bool;
            default = false;
            description = ''
              When set to true Runner will only run on pipelines
              triggered on protected branches.
            '';
          };
          debugTraceDisabled = mkOption {
            type = types.bool;
            default = false;
            description = ''
              When set to true Runner will disable the possibility of
              using the `CI_DEBUG_TRACE` feature.
            '';
          };
        };
      });
    };
  };
  config = mkIf cfg.enable {

    users.users.gitlab-runner =
      { name = "gitlab-runner";
        uid = mkDefault 532;
        # gid = mkDefault config.users.groups.gitlab-runner.gid;
        home = mkDefault "/var/lib/gitlab-runner";
        shell = "/bin/bash";
        description = "Gitlab agent user";
      };
    users.groups.gitlab-runner =
      { name = "gitlab-runner";
        gid = mkDefault 532;
        description = "Gitlab agent user group";
      };


    # system.activationScripts.preActivation.text = let user = config.users.users.gitlab-runner; in ''
    #  mkdir -p '${user.home}'
    #  chown ${toString user.uid}:${toString user.gid} '${user.home}'
    #'';


    warnings = optional (cfg.configFile != null) "services.gitlab-runner.`configFile` is deprecated, please use services.gitlab-runner.`services`.";
    environment.systemPackages = [ cfg.package ];

    launchd.daemons.gitlab-runner = {
      environment = { #config.networking.proxy.envVars // {
        HOME = "${config.users.users.gitlab-runner.home}";
        NIX_REMOTE = "daemon";
        NIX_SSL_CERT_FILE = "${pkgs.cacert}/etc/ssl/certs/ca-bundle.crt";
      };
      path = with pkgs; [
        bash
        gawk
        jq
        moreutils
        yq
        # util-linux
        cfg.package
        coreutils
        gnugrep
        gnused
      ] ++ cfg.extraPackages;

        script = ''
            ${configureScript}/bin/gitlab-runner-configure && ${startScript}/bin/gitlab-runner-start
        '';

        serviceConfig = {
            ProcessType = "Interactive";
            ThrottleInterval = 30;

          # StandardOutPath = "/var/lib/gitlab-runner/out.log";
          # StandardErrorPath = "/var/lib/gitlab-runner/err.log";
          # The combination of KeepAlive.NetworkState and WatchPaths
          # will ensure that buildkite-agent is started on boot, but
          # after networking is available (so the hostname is
          # correct).
          RunAtLoad = true;
        #   KeepAlive.NetworkState = true;
          WatchPaths = [
            "/etc/resolv.conf"
            "/Library/Preferences/SystemConfiguration/NetworkInterfaces.plist"
          ];

          GroupName = "gitlab-runner";
          UserName  = "gitlab-runner";
          WorkingDirectory = config.users.users.gitlab-runner.home;
        };

    };
    # systemd.services.gitlab-runner = {
    #   description = "Gitlab Runner";
    #   documentation = [ "https://docs.gitlab.com/runner/" ];
    #   after = [ "network.target" ]
    #     ++ optional hasDocker "docker.service";
    #   requires = optional hasDocker "docker.service";
    #   wantedBy = [ "multi-user.target" ];
    #   environment = config.networking.proxy.envVars // {
    #     HOME = "/var/lib/gitlab-runner";
    #   };
    #   path = with pkgs; [
    #     bash
    #     gawk
    #     jq
    #     moreutils
    #     remarshal
    #     util-linux
    #     cfg.package
    #   ] ++ cfg.extraPackages;
    #   reloadIfChanged = true;
    #   serviceConfig = {
    #     # Set `DynamicUser` under `systemd.services.gitlab-runner.serviceConfig`
    #     # to `lib.mkForce false` in your configuration to run this service as root.
    #     # You can also set `User` and `Group` options to run this service as desired user.
    #     # Make sure to restart service or changes won't apply.
    #     DynamicUser = true;
    #     StateDirectory = "gitlab-runner";
    #     SupplementaryGroups = optional hasDocker "docker";
    #     ExecStartPre = "!${configureScript}/bin/gitlab-runner-configure";
    #     ExecStart = "${startScript}/bin/gitlab-runner-start";
    #     ExecReload = "!${configureScript}/bin/gitlab-runner-configure";
    #   } // optionalAttrs (cfg.gracefulTermination) {
    #     TimeoutStopSec = "${cfg.gracefulTimeout}";
    #     KillSignal = "SIGQUIT";
    #     KillMode = "process";
    #   };
    # };
    # # Enable docker if `docker` executor is used in any service
    # virtualisation.docker.enable = mkIf (
    #   any (s: s.executor == "docker") (attrValues cfg.services)
    # ) (mkDefault true);
  };
  imports = [
    (mkRenamedOptionModule [ "services" "gitlab-runner" "packages" ] [ "services" "gitlab-runner" "extraPackages" ] )
    (mkRemovedOptionModule [ "services" "gitlab-runner" "configOptions" ] "Use services.gitlab-runner.services option instead" )
    (mkRemovedOptionModule [ "services" "gitlab-runner" "workDir" ] "You should move contents of workDir (if any) to /var/lib/gitlab-runner" )
  ];
}
</file>

<file path="modules/services/ipfs.nix">
{ config, lib, pkgs, ... }:

with lib;

let

  cfg = config.services.ipfs;

in
{
  meta.maintainers = [ "jmmaloney4" ];

  options.services.ipfs = {
      enable = mkOption {
        type = types.bool;
        default = false;
        description = "Whether to enable the ipfs daemon.";
      };

      package = mkOption {
        type = types.package;
        default = pkgs.kubo;
        # defaultText = "pkgs.kubo";
        description = ''
          The ipfs package to use.
        '';
      };

      logFile = mkOption {
        type = types.nullOr types.path;
        default = null;
        example =  "/var/tmp/ipfs.log";
        description = ''
          The logfile to use for the ipfs service. Alternatively
          {command}`sudo launchctl debug system/org.nixos.ipfs --stderr`
          can be used to stream the logs to a shell after restarting the service with
          {command}`sudo launchctl kickstart -k system/org.nixos.ipfs`.
        '';
      };

      ipfsPath = mkOption {
        type = types.nullOr types.path;
        default = null;
        description = "Set the IPFS_PATH environment variable.";
      };

      enableGarbageCollection = mkOption {
        type = types.bool;
        default = false;
        description = "Passes --enable-gc flag to ipfs daemon.";
      };
  };

  config = mkIf cfg.enable {
    environment.systemPackages = [ cfg.package ];
    launchd.user.agents.ipfs = {
      serviceConfig = {
        ProgramArguments = [ "${cfg.package}/bin/ipfs" "daemon" ]
          ++ optionals (cfg.enableGarbageCollection) [ "--enable-gc" ];
        KeepAlive = true;
        RunAtLoad = true;
        ProcessType = "Background";
        StandardOutPath = cfg.logFile;
        StandardErrorPath = cfg.logFile;
        EnvironmentVariables = {} // (optionalAttrs (cfg.ipfsPath != null) { IPFS_PATH = cfg.ipfsPath; });
      };
      managedBy = "services.ipfs.enable";
    };
  };
}
</file>

<file path="modules/services/lorri.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.services.lorri;
in
{
  options =  {
    services.lorri = {
      enable = mkOption {
        type = types.bool;
        default = false;
        description = "Whether to enable the lorri service.";
      };
      
      logFile = mkOption {
        type = types.nullOr types.path;
        default = null;
        example =  "/var/tmp/lorri.log";
        description = ''
          The logfile to use for the lorri service. Alternatively
          {command}`sudo launchctl debug system/org.nixos.lorri --stderr`
          can be used to stream the logs to a shell after restarting the service with
          {command}`sudo launchctl kickstart -k system/org.nixos.lorri`.
        '';
      };
    };
  };

  config = mkIf cfg.enable {
    # TODO: Upstream this to NixOS.
    assertions = [
      {
        assertion = config.nix.enable;
        message = ''`services.lorri.enable` requires `nix.enable`'';
      }
    ];

    environment.systemPackages = [ pkgs.lorri ];

    launchd.user.agents.lorri = {
      command = with pkgs; "${lorri}/bin/lorri daemon";
      path = with pkgs; [ config.nix.package git gnutar gzip ];
      serviceConfig = {
        KeepAlive = true;
        RunAtLoad = true;
        ProcessType = "Background";
        StandardOutPath = cfg.logFile;
        StandardErrorPath = cfg.logFile;
        EnvironmentVariables = { NIX_PATH = "nixpkgs=" + toString pkgs.path; };
      };
      managedBy = "services.lorri.enable";
    };
  };
}
</file>

<file path="modules/services/mopidy.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.services.mopidy;
in

{
  options = {
    services.mopidy.enable = mkOption {
      type = types.bool;
      default = false;
      description = "Whether to enable the Mopidy Daemon.";
    };

    services.mopidy.package = mkOption {
      type = types.path;
      default = pkgs.mopidy;
      defaultText = "pkgs.mopidy";
      description = "This option specifies the mopidy package to use.";
    };

    services.mopidy.mediakeys.enable = mkOption {
      type = types.bool;
      default = false;
      description = "Whether to enable the Mopidy OSX Media Keys support daemon.";
    };

    services.mopidy.mediakeys.package = mkOption {
      type = types.path;
      default = pkgs.pythonPackages.osxmpdkeys;
      defaultText = "pkgs.pythonPackages.osxmpdkeys";
      description = "This option specifies the mediakeys package to use.";
    };
  };

  config = mkMerge [
    (mkIf cfg.enable {
      launchd.user.agents.mopidy = {
        serviceConfig.Program = "${cfg.package}/bin/mopidy";
        serviceConfig.RunAtLoad = true;
        serviceConfig.KeepAlive = true;
        managedBy = "services.mopidy.enable";
      };
    })
    (mkIf cfg.mediakeys.enable {
      launchd.user.agents.mopidymediakeys = {
        serviceConfig.Program = "${cfg.package}/bin/mpdkeys";
        serviceConfig.RunAtLoad = true;
        serviceConfig.KeepAlive = true;
        managedBy = "services.mopidy.mediakeys.enable";
      };
    })
  ];
}
</file>

<file path="modules/services/netbird.nix">
{ config, lib, pkgs, ... }:
with lib;
let
  cfg = config.services.netbird;
in
{
  options.services.netbird = {
    enable = mkEnableOption "Netbird daemon";
    package = mkOption {
      type = types.package;
      default = pkgs.netbird;
      defaultText = literalExpression "pkgs.netbird";
      description = "The package to use for netbird";
    };
  };
  config = mkIf cfg.enable {
    environment.systemPackages = [ cfg.package ];
    launchd.daemons.netbird = {
      script = ''
        mkdir -p /var/run/netbird /var/lib/netbird
        exec ${cfg.package}/bin/netbird service run
      '';
      serviceConfig = {
        EnvironmentVariables = {
          NB_CONFIG = "/var/lib/netbird/config.json";
          NB_LOG_FILE = "console";
        };
        KeepAlive = true;
        RunAtLoad = true;
        StandardOutPath = "/var/log/netbird.out.log";
        StandardErrorPath = "/var/log/netbird.err.log";
      };
    };
  };
}
</file>

<file path="modules/services/nix-daemon.nix">
{ config, lib, ... }:

let
  cfg = config.services.nix-daemon;

  inherit (lib) mkRemovedOptionModule mkDefault mkIf mkMerge mkOption types;
in

{
  imports = [
    (mkRemovedOptionModule [ "services" "nix-daemon" "enable" ] ''
      nix-darwin now manages nix-daemon unconditionally when
      `nix.enable` is on.
    '')
  ];

  options = {
    services.nix-daemon.enableSocketListener = mkOption {
      type = types.bool;
      default = false;
      description = "Whether to make the nix-daemon service socket activated.";
    };

    services.nix-daemon.logFile = mkOption {
      type = types.nullOr types.path;
      default = null;
      example = "/var/log/nix-daemon.log";
      description = ''
        The logfile to use for the nix-daemon service. Alternatively
        {command}`sudo launchctl debug system/org.nixos.nix-daemon --stderr`
        can be used to stream the logs to a shell after restarting the service with
        {command}`sudo launchctl kickstart -k system/org.nixos.nix-daemon`.
      '';
    };

    services.nix-daemon.tempDir = mkOption {
      type = types.nullOr types.path;
      default = null;
      description = "The TMPDIR to use for nix-daemon.";
    };
  };

  config = mkIf config.nix.enable {

    launchd.daemons.nix-daemon = {
      command = lib.getExe' config.nix.package "nix-daemon";
      serviceConfig.ProcessType = config.nix.daemonProcessType;
      serviceConfig.LowPriorityIO = config.nix.daemonIOLowPriority;
      serviceConfig.Label = "org.nixos.nix-daemon"; # must match daemon installed by Nix regardless of the launchd label Prefix
      serviceConfig.SoftResourceLimits.NumberOfFiles = mkDefault 1048576;
      serviceConfig.StandardErrorPath = cfg.logFile;

      serviceConfig.KeepAlive = mkIf (!cfg.enableSocketListener) true;

      serviceConfig.Sockets = mkIf cfg.enableSocketListener
        { Listeners.SockType = "stream";
          Listeners.SockPathName = "/nix/var/nix/daemon-socket/socket";
        };

      serviceConfig.EnvironmentVariables = mkMerge [
        config.nix.envVars
        {
          NIX_SSL_CERT_FILE = mkIf
            (config.environment.variables ? NIX_SSL_CERT_FILE)
            (mkDefault config.environment.variables.NIX_SSL_CERT_FILE);
          TMPDIR = mkIf (cfg.tempDir != null) cfg.tempDir;
          # FIXME: workaround for https://github.com/NixOS/nix/issues/2523
          OBJC_DISABLE_INITIALIZE_FORK_SAFETY = mkDefault "YES";
        }
      ];
    };

  };
}
</file>

<file path="modules/services/openssh.nix">
{ config, lib, ... }:

let
  cfg = config.services.openssh;
in
{
  options = {
    services.openssh = {
      enable = lib.mkOption {
        type = lib.types.nullOr lib.types.bool;
        default = null;
        description = ''
          Whether to enable Apple's built-in OpenSSH server.

          The default is null which means let macOS manage the OpenSSH server.
        '';
      };

      extraConfig = lib.mkOption {
        type = lib.types.lines;
        default = "";
        description = ''
          Extra configuration text loaded in {file}`sshd_config`.
          See {manpage}`sshd_config(5)` for help.
        '';
      };
    };
  };

  config = {
    # We don't use `systemsetup -setremotelogin` as it requires Full Disk Access
    system.activationScripts.launchd.text = lib.mkIf (cfg.enable != null) (if cfg.enable then ''
      if [[ "$(systemsetup -getremotelogin | sed 's/Remote Login: //')" == "Off" ]]; then
        launchctl enable system/com.openssh.sshd
        launchctl bootstrap system /System/Library/LaunchDaemons/ssh.plist
      fi
    '' else ''
      if [[ "$(systemsetup -getremotelogin | sed 's/Remote Login: //')" == "On" ]]; then
        launchctl bootout system/com.openssh.sshd
        launchctl disable system/com.openssh.sshd
      fi
    '');

    environment.etc."ssh/sshd_config.d/100-nix-darwin.conf".text = cfg.extraConfig;
  };
}
</file>

<file path="modules/services/spotifyd.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.services.spotifyd;

  format = pkgs.formats.toml { };
  configFile = format.generate "spotifyd.conf" {
    global = {
      backend = "portaudio";
    };
    spotifyd = cfg.settings;
  };
in
{
  options = {
    services.spotifyd = {
      enable = mkOption {
        type = types.bool;
        default = false;
        description = ''
          Whether to enable the spotifyd service.
        '';
      };

      package = mkOption {
        type = types.path;
        default = pkgs.spotifyd;
        defaultText = "pkgs.spotifyd";
        description = ''
          The spotifyd package to use.
        '';
      };

      settings = mkOption {
        type = types.nullOr format.type;
        default = null;
        example = {
          bitrate = 160;
          volume_normalisation = true;
        };
        description = ''
          Configuration for spotifyd, see <https://spotifyd.github.io/spotifyd/config/File.html>
          for supported values.
        '';
      };
    };
  };

  config = mkIf cfg.enable {
    environment.systemPackages = [ cfg.package ];
    launchd.user.agents.spotifyd = {
      serviceConfig.ProgramArguments = [ "${cfg.package}/bin/spotifyd" "--no-daemon" ]
        ++ optionals (cfg.settings != null) [ "--config-path=${configFile}" ];
      serviceConfig = {
        KeepAlive = true;
        RunAtLoad = true;
        ThrottleInterval = 30;
      };
      managedBy = "services.spotifyd.enable";
    };
  };
}
</file>

<file path="modules/services/synapse-bt.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.services.synapse-bt;
  configOptions = recursiveUpdate {
    port = cfg.port;
    disk = {
      directory = cfg.downloadDir;
    };
  } cfg.extraConfig;

  configFile = pkgs.runCommand "config.toml" {
    buildInputs = [ pkgs.remarshal ];
  } ''
    remarshal -if json -of toml \
      < ${pkgs.writeText "config.json" (builtins.toJSON configOptions)} \
      > $out
  '';
in

{
  options = {
    services.synapse-bt = {
      enable = mkOption {
        type = types.bool;
        default = false;
        description = "Whether to run Synapse BitTorrent Daemon.";
      };

      package = mkOption {
        type = types.package;
        default = pkgs.synapse-bt;
        defaultText = "pkgs.synapse-bt";
        description = "Synapse BitTorrent package to use.";
      };

      port = mkOption {
        type = types.int;
        default = 16384;
        description = "The port on which Synapse BitTorrent listens.";
      };

      downloadDir = mkOption {
        type = types.path;
        default = "/var/lib/synapse-bt";
        example = "/var/lib/synapse-bt/downloads";
        description = "Download directory for Synapse BitTorrent.";
      };

      extraConfig = mkOption {
        default = {};
        description = "Extra configuration options for Synapse BitTorrent.";
        type = types.attrs;
      };
    };
  };

  config = mkIf cfg.enable {

    environment.systemPackages = [ cfg.package ];

    launchd.user.agents.synapse-bt =
      { path = [ cfg.package ];
        command = "${cfg.package}/bin/synapse --config ${configFile}";
        serviceConfig.KeepAlive = true;
        serviceConfig.RunAtLoad = true;
        managedBy = "services.synapse-bt.enable";
      };

  };
}
</file>

<file path="modules/services/tailscale.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.services.tailscale;

in
{
  imports = [
    (mkRemovedOptionModule [ "services" "tailscale" "domain" ] "Tailscale no longer requires setting the search domain manually.")
    (mkRemovedOptionModule [ "services" "tailscale" "magicDNS" ] "MagicDNS no longer requires overriding the DNS servers, if this is necessary you can use `services.tailscale.overrideLocalDns`.")
  ];

  options.services.tailscale = {
    enable = mkEnableOption "Tailscale client daemon";

    package = mkOption {
      type = types.package;
      default = pkgs.tailscale;
      defaultText = literalExpression "pkgs.tailscale";
      description = "The package to use for tailscale";
    };

    overrideLocalDns = mkOption {
      type = types.bool;
      default = false;
      example = true;
      description = ''
        This option implements `Override local DNS` as it is not yet implemented in Tailscaled-on-macOS.

        To use this option, in the Tailscale control panel:
          1. at least one DNS server is added
          2. `Override local DNS` is enabled

        As this option sets 100.100.100.100 as your sole DNS server, if the requirements above are not met,
        all non-MagicDNS queries WILL fail.
      '';
    };
  };

  config = mkIf cfg.enable {
    assertions = [{
      assertion = !cfg.overrideLocalDns || config.networking.dns == [ "100.100.100.100" ];
      message = ''
        DNS servers should be configured on the Tailscale control panel when `services.tailscale.overrideLocalDns` is enabled.

        A race condition can occur when DNS servers are set locally, leading to MagicDNS to not work.
      '';
    }];

    environment.systemPackages = [ cfg.package ];

    launchd.daemons.tailscaled = {
      # derived from
      # https://github.com/tailscale/tailscale/blob/main/cmd/tailscaled/install_darwin.go#L30
      command = lib.getExe' cfg.package "tailscaled";
      serviceConfig = {
        Label = "com.tailscale.tailscaled";
        RunAtLoad = true;
      };
    };

    networking.dns = mkIf cfg.overrideLocalDns [ "100.100.100.100" ];

    # Ensures Tailscale MagicDNS always works even without adding 100.100.100.100 to DNS servers
    environment.etc."resolver/ts.net".text = "nameserver 100.100.100.100";

    # This file gets created by tailscaled when `Override local DNS` is turned off
    environment.etc."resolver/ts.net".knownSha256Hashes = [
      "2c28f4fe3b4a958cd86b120e7eb799eee6976daa35b228c885f0630c55ef626c"
    ];

    # Cleaning up the .before-nix-darwin file is necessary as any files in /etc/resolver will be used.
    system.activationScripts.etc.text = mkAfter ''
      if [ -e /etc/resolver/ts.net.before-nix-darwin ]; then
        rm /etc/resolver/ts.net.before-nix-darwin
      fi
    '';
  };
}
</file>

<file path="modules/services/trezord.nix">
{ config, lib, pkgs, ... }:

with lib;
let
  cfg = config.services.trezord;
in {
  # Options copied from:
  # https://github.com/NixOS/nixpkgs/blob/9d6e454b857fb472fa35fc8b098fa5ac307a0d7d/nixos/modules/services/hardware/trezord.nix#L16
  options = {
    services.trezord = {
      enable = mkOption {
        type = types.bool;
        default = false;
        description = ''
          Enable Trezor bridge daemon, for use with Trezor hardware wallets.
        '';
      };

      emulator.enable = mkOption {
        type = types.bool;
        default = false;
        description = ''
          Enable Trezor emulator support.
        '';
       };

      emulator.port = mkOption {
        type = types.port;
        default = 21324;
        description = ''
          Listening port for the Trezor emulator.
        '';
      };
    };
  };

  config = mkIf cfg.enable {
    launchd.user.agents.trezord = {
      serviceConfig = {
        ProgramArguments = [ "${pkgs.trezord}/bin/trezord-go" ]
          ++ optionals cfg.emulator.enable [ "-e" (builtins.toString cfg.emulator.port) ];
        KeepAlive = true;
        RunAtLoad = true;
      };
      managedBy = "services.trezord.enable";
    };
  };
}
</file>

<file path="modules/services/wg-quick.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.networking.wg-quick;

  peerOpts = { ... }: {
    options = {
      allowedIPs = mkOption {
        type = types.listOf types.str;
        default = [ ];
        description = "List of IP addresses associated with this peer.";
      };

      endpoint = mkOption {
        type = types.nullOr types.str;
        default = null;
        description = "IP and port to connect to this peer at.";
      };

      persistentKeepalive = mkOption {
        type = types.nullOr types.int;
        default = null;
        description = "Interval in seconds to send keepalive packets";
      };

      presharedKeyFile = mkOption {
        type = types.nullOr types.str;
        default = null;
        description =
          "Optional, path to file containing the pre-shared key for this peer.";
      };

      publicKey = mkOption {
        default = null;
        type = types.str;
        description = "The public key for this peer.";
      };
    };
  };

  interfaceOpts = { ... }: {
    options = {
      address = mkOption {
        type = types.nullOr (types.listOf types.str);
        default = [ ];
        description = "List of IP addresses for this interface.";
      };

      autostart = mkOption {
        type = types.bool;
        default = true;
        description =
          "Whether to bring up this interface automatically during boot.";
      };

      dns = mkOption {
        type = types.listOf types.str;
        default = [ ];
        description = "List of DNS servers for this interface.";
      };

      listenPort = mkOption {
        type = types.nullOr types.int;
        default = null;
        description = "Port to listen on, randomly selected if not specified.";
      };

      mtu = mkOption {
        type = types.nullOr types.int;
        default = null;
        description =
          "MTU to set for this interface, automatically set if not specified";
      };

      peers = mkOption {
        type = types.listOf (types.submodule peerOpts);
        default = [ ];
        description = "List of peers associated with this interface.";
      };

      preDown = mkOption {
        type = with types; coercedTo (listOf str) (concatStringsSep "\n") lines;
        default = "";
        description = "List of commadns to run before interface shutdown.";
      };

      preUp = mkOption {
        type = with types; coercedTo (listOf str) (concatStringsSep "\n") lines;
        default = "";
        description = "List of commands to run before interface setup.";
      };

      postDown = mkOption {
        type = with types; coercedTo (listOf str) (concatStringsSep "\n") lines;
        default = "";
        description = "List of commands to run after interface shutdown";
      };

      postUp = mkOption {
        type = with types; coercedTo (listOf str) (concatStringsSep "\n") lines;
        default = "";
        description = "List of commands to run after interface setup.";
      };

      privateKeyFile = mkOption {
        type = types.str;
        default = null;
        description = "Path to file containing this interface's private key.";
      };

      table = mkOption {
        type = types.nullOr types.str;
        default = null;
        description = ''
          Controls the routing table to which routes are added. There are two
          special values: `off` disables the creation of routes altogether,
          and `auto` (the default) adds routes to the default table and
          enables special handling of default routes.
        '';
      };
    };
  };

  generateInterfaceScript = name: text:
    ((pkgs.writeShellScriptBin name text) + "/bin/${name}");

  generatePostUpPSKText = name: interfaceOpt:
    map (peer:
      optionalString (peer.presharedKeyFile != null) ''
        wg set $(cat /var/run/wireguard/${name}.name) peer ${peer.publicKey} preshared-key ${peer.presharedKeyFile}
      '') interfaceOpt.peers;

  generatePostUpText = name: interfaceOpt:
    (optionalString (interfaceOpt.privateKeyFile != null) ''
      wg set $(cat /var/run/wireguard/${name}.name) private-key ${interfaceOpt.privateKeyFile}
    '') + (concatStrings (generatePostUpPSKText name interfaceOpt))
    + interfaceOpt.postUp;

  generateInterfacePostUp = name: interfaceOpt:
    generateInterfaceScript "postUp.sh" (generatePostUpText name interfaceOpt);

  generateInterfaceConfig = name: interfaceOpt:
    ''
      [Interface]
    '' + optionalString (interfaceOpt.address != [ ]) (''
      Address = ${concatStringsSep "," interfaceOpt.address}
    '') + optionalString (interfaceOpt.dns != [ ]) ''
      DNS = ${concatStringsSep "," interfaceOpt.dns}
    '' + optionalString (interfaceOpt.listenPort != null) ''
      ListenPort = ${toString interfaceOpt.listenPort}
    '' + optionalString (interfaceOpt.mtu != null) ''
      MTU = ${toString interfaceOpt.mtu}
    '' + optionalString (interfaceOpt.preUp != "") ''
      PreUp = ${generateInterfaceScript "preUp.sh" interfaceOpt.preUp}
    '' + optionalString (interfaceOpt.preDown != "") ''
      PreDown = ${generateInterfaceScript "preDown.sh" interfaceOpt.preDown}
    '' + optionalString
    (interfaceOpt.privateKeyFile != null || interfaceOpt.postUp != "") ''
      PostUp = ${generateInterfacePostUp name interfaceOpt}
    '' + optionalString (interfaceOpt.postDown != "") ''
      PostDown = ${generateInterfaceScript "postDown.sh" interfaceOpt.postDown}
    '' + optionalString (interfaceOpt.table != null) ''
      Table = ${interfaceOpt.table}
    '' + optionalString (interfaceOpt.peers != [ ]) "\n"
    + concatStringsSep "\n" (map generatePeerConfig interfaceOpt.peers);

  generatePeerConfig = peerOpt:
    ''
      [Peer]
      PublicKey = ${peerOpt.publicKey}
    '' + optionalString (peerOpt.allowedIPs != [ ]) ''
      AllowedIPs = ${concatStringsSep "," peerOpt.allowedIPs}
    '' + optionalString (peerOpt.endpoint != null) ''
      Endpoint = ${peerOpt.endpoint}
    '' + optionalString (peerOpt.persistentKeepalive != null) ''
      PersistentKeepalive = ${toString peerOpt.persistentKeepalive}
    '';

  generateInterfaceAttrs = name: interfaceOpt:
    nameValuePair "wireguard/${name}.conf" {
      enable = true;
      text = generateInterfaceConfig name interfaceOpt;
    };

  generateLaunchDaemonAttrs = name: interfaceOpt:
    nameValuePair "wg-quick-${name}" {
      serviceConfig = {
        EnvironmentVariables = {
          PATH =
            "${pkgs.wireguard-tools}/bin:${pkgs.wireguard-go}/bin:${config.environment.systemPath}";
        };
        KeepAlive = {
          NetworkState = true;
          SuccessfulExit = true;
        };
        ProgramArguments =
          [ "${pkgs.wireguard-tools}/bin/wg-quick" "up" "${name}" ];
        RunAtLoad = true;
        StandardErrorPath = "${cfg.logDir}/wg-quick-${name}.log";
        StandardOutPath = "${cfg.logDir}/wg-quick-${name}.log";
      };
    };
in {
  options = {
    networking.wg-quick = {
      interfaces = mkOption {
        type = types.attrsOf (types.submodule interfaceOpts);
        default = { };
        description = "Set of wg-quick interfaces.";
      };

      logDir = mkOption {
        type = types.str;
        default = "/var/log";
        description = "Directory to save wg-quick logs to.";
      };
    };
  };

  config = mkIf (cfg.interfaces != { }) {
    launchd.daemons = mapAttrs' generateLaunchDaemonAttrs
      (filterAttrs (name: interfaceOpt: interfaceOpt.autostart)
        config.networking.wg-quick.interfaces);

    environment.etc =
      mapAttrs' generateInterfaceAttrs config.networking.wg-quick.interfaces;

    environment.systemPackages = [ pkgs.wireguard-go pkgs.wireguard-tools ];
  };
}
</file>

<file path="modules/system/defaults/ActivityMonitor.nix">
{ config, lib, ... }:

with lib;

{
  options = {

    system.defaults.ActivityMonitor.ShowCategory = mkOption {
      type = types.nullOr (types.enum [100 101 102 103 104 105 106 107]);
      default = null;
      description = ''
          Change which processes to show.
          * 100: All Processes
          * 101: All Processes, Hierarchally
          * 102: My Processes
          * 103: System Processes
          * 104: Other User Processes
          * 105: Active Processes
          * 106: Inactive Processes
          * 107: Windowed Processes
          Default is 100.
        '';
    };

    system.defaults.ActivityMonitor.IconType = mkOption {
      type = types.nullOr types.int;
      default = null;
      description = ''
          Change the icon in the dock when running.
          * 0: Application Icon
          * 2: Network Usage
          * 3: Disk Activity
          * 5: CPU Usage
          * 6: CPU History
          Default is null.
        '';
    };

    system.defaults.ActivityMonitor.SortColumn = mkOption {
      type = types.nullOr types.str;
      default = null;
      description = ''
          Which column to sort the main activity page (such as "CPUUsage"). Default is null.
        '';
    };

    system.defaults.ActivityMonitor.SortDirection = mkOption {
      type = types.nullOr types.int;
      default = null;
      description = ''
          The sort direction of the sort column (0 is decending). Default is null.
        '';
    };

    system.defaults.ActivityMonitor.OpenMainWindow = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
          Open the main window when opening Activity Monitor. Default is true.
        '';
    };
  };
}
</file>

<file path="modules/system/defaults/alf.nix">
{ lib, ... }:

let
  path = [
    "system"
    "defaults"
    "alf"
  ];
in
{
  imports = [
    (lib.mkRemovedOptionModule (path ++ [ "globalstate" ])
      "Use `networking.applicationFirewall.enable' and `networking.applicationFirewall.blockAllIncoming' instead."
    )
    (lib.mkRemovedOptionModule (
      path ++ [ "allowsignedenabled" ]
    ) "Use `networking.applicationFirewall.allowSigned' instead.")
    (lib.mkRemovedOptionModule (
      path ++ [ "allowdownloadsignedenabled" ]
    ) "Use `networking.applicationFirewall.allowSignedApp' instead.")
    (lib.mkRemovedOptionModule (path ++ [ "loggingenabled" ]) "It's no longer necessary.")
    (lib.mkRemovedOptionModule (
      path ++ [ "stealthenabled" ]
    ) "Use `networking.applicationFirewall.enableStealthMode' instead.")
  ];
}
</file>

<file path="modules/system/defaults/clock.nix">
{ config, lib, ... }:

with lib;

{
  options = {

    system.defaults.menuExtraClock.FlashDateSeparators = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        When enabled, the clock indicator (which by default is the colon) will flash on and off each second. Default is null.
      '';
    };

    system.defaults.menuExtraClock.IsAnalog = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Show an analog clock instead of a digital one. Default is null.
      '';
    };

    system.defaults.menuExtraClock.Show24Hour = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Show a 24-hour clock, instead of a 12-hour clock. Default is null.
      '';
    };

    system.defaults.menuExtraClock.ShowAMPM = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Show the AM/PM label. Useful if Show24Hour is false. Default is null.
      '';
    };

    system.defaults.menuExtraClock.ShowDayOfMonth = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Show the day of the month. Default is null.
      '';
    };

    system.defaults.menuExtraClock.ShowDayOfWeek = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Show the day of the week. Default is null.
      '';
    };

    system.defaults.menuExtraClock.ShowDate = mkOption {
      type = types.nullOr (types.enum [ 0 1 2 ]);
      default = null;
      description = ''
        Show the full date. Default is null.

        0 = When space allows
        1 = Always
        2 = Never
      '';
    };

    system.defaults.menuExtraClock.ShowSeconds = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Show the clock with second precision, instead of minutes. Default is null.
      '';
    };

  };
}
</file>

<file path="modules/system/defaults/controlcenter.nix">
{ config, lib, ... }:

{
  options = {

    system.defaults.controlcenter.BatteryShowPercentage = lib.mkOption {
        type = lib.types.nullOr lib.types.bool;
        default = null; 
        description = ''
            Apple menu > System Preferences > Control Center > Battery

            Show a battery percentage in menu bar. Default is null.
        '';
    };

    system.defaults.controlcenter.Sound = lib.mkOption {
        type = lib.types.nullOr lib.types.bool;
        apply = v: if v == null then null else if v == true then 18 else 24;
        default = null; 
        description = ''
            Apple menu > System Preferences > Control Center > Sound

            Show a sound control in menu bar . Default is null.

            18 = Display icon in menu bar
            24 = Hide icon in menu bar
        '';
    };

    system.defaults.controlcenter.Bluetooth = lib.mkOption {
        type = lib.types.nullOr lib.types.bool;
        apply = v: if v == null then null else if v == true then 18 else 24;
        default = null; 
        description = ''
            Apple menu > System Preferences > Control Center > Bluetooth

            Show a bluetooth control in menu bar. Default is null.

            18 = Display icon in menu bar
            24 = Hide icon in menu bar
        '';
    };

    system.defaults.controlcenter.AirDrop = lib.mkOption {
        type = lib.types.nullOr lib.types.bool;
        apply = v: if v == null then null else if v == true then 18 else 24;
        default = null; 
        description = ''
            Apple menu > System Preferences > Control Center > AirDrop

            Show a AirDrop control in menu bar. Default is null.

            18 = Display icon in menu bar
            24 = Hide icon in menu bar
        '';
    };

    system.defaults.controlcenter.Display = lib.mkOption {
        type = lib.types.nullOr lib.types.bool;
        apply = v: if v == null then null else if v == true then 18 else 24;
        default = null; 
        description = ''
            Apple menu > System Preferences > Control Center > Display

            Show a Screen Brightness control in menu bar. Default is null.

            18 = Display icon in menu bar
            24 = Hide icon in menu bar
        '';
    };

    system.defaults.controlcenter.FocusModes = lib.mkOption {
        type = lib.types.nullOr lib.types.bool;
        apply = v: if v == null then null else if v == true then 18 else 24;
        default = null; 
        description = ''
            Apple menu > System Preferences > Control Center > Focus

            Show a Focus control in menu bar. Default is null.

            18 = Display icon in menu bar
            24 = Hide icon in menu bar
        '';
    };

    system.defaults.controlcenter.NowPlaying = lib.mkOption {
        type = lib.types.nullOr lib.types.bool;
        apply = v: if v == null then null else if v == true then 18 else 24;
        default = null; 
        description = ''
            Apple menu > System Preferences > Control Center > Now Playing

            Show a Now Playing control in menu bar. Default is null.

            18 = Display icon in menu bar
            24 = Hide icon in menu bar
        '';
    };
  };
}
</file>

<file path="modules/system/defaults/CustomPreferences.nix">
{ config, lib, ... }:

with lib;

let
  valueType = with lib.types; nullOr (oneOf [
    bool
    int
    float
    str
    path
    (attrsOf valueType)
    (listOf valueType)
  ]) // {
    description = "plist value";
  };
  defaultsType = types.submodule {
    freeformType = valueType;
  };
in {
  options = {
    system.defaults.CustomUserPreferences = mkOption {
      type = defaultsType;
      default = { };
      example = {
        "NSGlobalDomain" = { "TISRomanSwitchState" = 1; };
        "com.apple.Safari" = {
          "com.apple.Safari.ContentPageGroupIdentifier.WebKit2DeveloperExtrasEnabled" =
            true;
        };
      };
      description = ''
        Sets custom user preferences
      '';
    };

    system.defaults.CustomSystemPreferences = mkOption {
      type = defaultsType;
      default = { };
      example = {
        "NSGlobalDomain" = { "TISRomanSwitchState" = 1; };
        "com.apple.Safari" = {
          "com.apple.Safari.ContentPageGroupIdentifier.WebKit2DeveloperExtrasEnabled" =
            true;
        };
      };
      description = ''
        Sets custom system preferences
      '';
    };

  };
}
</file>

<file path="modules/system/defaults/dock.nix">
{ config, lib, ... }:

with lib;

let
  # Should only be used with options that previously used floats defined as strings.
  inherit (config.lib.defaults.types) floatWithDeprecationError;
in {
  imports = [
    (mkRenamedOptionModule [ "system" "defaults" "dock" "expose-group-by-app" ] [ "system" "defaults" "dock" "expose-group-apps" ])
  ];

  options = {

    system.defaults.dock.appswitcher-all-displays = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to display the appswitcher on all displays or only the main one. The default is false.
      '';
    };

    system.defaults.dock.autohide = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to automatically hide and show the dock. The default is false.
      '';
    };

    system.defaults.dock.autohide-delay = mkOption {
      type = types.nullOr floatWithDeprecationError;
      default = null;
      example = 0.24;
      description = ''
        Sets the speed of the autohide delay. The default is given in the example.
      '';
    };

    system.defaults.dock.autohide-time-modifier = mkOption {
      type = types.nullOr floatWithDeprecationError;
      default = null;
      example = 1.0;
      description = ''
        Sets the speed of the animation when hiding/showing the Dock. The default is given in the example.
      '';
    };

    system.defaults.dock.dashboard-in-overlay = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to hide Dashboard as a Space. The default is false.
      '';
    };

    system.defaults.dock.enable-spring-load-actions-on-all-items = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Enable spring loading for all Dock items. The default is false.
      '';
    };

    system.defaults.dock.expose-animation-duration = mkOption {
      type = types.nullOr floatWithDeprecationError;
      default = null;
      example = 1.0;
      description = ''
        Sets the speed of the Mission Control animations. The default is given in the example.
      '';
    };

    system.defaults.dock.expose-group-apps = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to group windows by application in Mission Control's Expos√©. The default is false.
      '';
    };

    system.defaults.dock.launchanim = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Animate opening applications from the Dock. The default is true.
      '';
    };

    system.defaults.dock.mineffect = mkOption {
      type = types.nullOr (types.enum [ "genie" "suck" "scale" ]);
      default = null;
      description = ''
        Set the minimize/maximize window effect. The default is genie.
      '';
    };

    system.defaults.dock.minimize-to-application = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to minimize windows into their application icon.  The default is false.
      '';
    };

    system.defaults.dock.mouse-over-hilite-stack = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Enable highlight hover effect for the grid view of a stack in the Dock.
      '';
    };

    system.defaults.dock.mru-spaces = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to automatically rearrange spaces based on most recent use.  The default is true.
      '';
    };

    system.defaults.dock.orientation = mkOption {
      type = types.nullOr (types.enum [ "bottom" "left" "right" ]);
      default = null;
      description = ''
        Position of the dock on screen.  The default is "bottom".
      '';
    };

    system.defaults.dock.persistent-apps = mkOption {
      type = let
        taggedType = types.attrTag {
              app = mkOption {
                description = "An application to be added to the dock.";
                type = types.str;
              };
              file = mkOption {
                description = "A file to be added to the dock.";
                type = types.str;
              };
              folder = mkOption {
                description = "A folder to be added to the dock.";
                type = types.str;
              };
              spacer = mkOption {
                description = "A spacer to be added to the dock. Can be small or regular size.";
                type = types.submodule {
                  options.small = mkOption {
                    description = "Whether the spacer is small.";
                    type = types.bool;
                    default = false;
                  };
                };
              };
            };

        simpleType = types.either types.str types.path;
        toTagged = path: { app = path; };
        in
      types.nullOr (types.listOf (types.coercedTo simpleType toTagged taggedType));
      default = null;
      example = [
        { app = "/Applications/Safari.app"; }
        { spacer = { small = false; }; }
        { spacer = { small = true; }; }
        { folder = "/System/Applications/Utilities"; }
        { file = "/User/example/Downloads/test.csv"; }
      ];
      description = ''
        Persistent applications, spacers, files, and folders in the dock.
      '';
      apply =
      let
        toTile = item: if item ? app then {
        tile-data.file-data = {
          _CFURLString = item.app;
          _CFURLStringType = 0;
        };
        } else if item ? spacer then {
          tile-data = { };
          tile-type = if item.spacer.small then "small-spacer-tile" else "spacer-tile";
        } else if item ? folder then {
          tile-data.file-data = {
            _CFURLString = "file://" + item.folder;
            _CFURLStringType = 15;
          };
          tile-type = "directory-tile";
        } else if item ? file then {
          tile-data.file-data = {
            _CFURLString = "file://" + item.file;
            _CFURLStringType = 15;
          };
          tile-type = "file-tile";
        } else item;
      in
      value: if value == null then null else map toTile value;
    };

    system.defaults.dock.persistent-others = mkOption {
      type = types.nullOr (types.listOf (types.either types.path types.str));
      default = null;
      example = [ "~/Documents" "~/Downloads" ];
      description = ''
        Persistent folders in the dock.
      '';
      apply = value:
        if !(isList value)
        then value
        else map (folder: { tile-data = { file-data = { _CFURLString = "file://" + folder; _CFURLStringType = 15; }; }; tile-type = if strings.hasInfix "." (last (splitString "/" folder)) then "file-tile" else "directory-tile"; }) value;
    };

    system.defaults.dock.scroll-to-open = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Scroll up on a Dock icon to show all Space's opened windows for an app, or open stack. The default is false.
      '';
    };

    system.defaults.dock.show-process-indicators = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Show indicator lights for open applications in the Dock. The default is true.
      '';
    };

    system.defaults.dock.showhidden = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to make icons of hidden applications tranclucent.  The default is false.
      '';
    };

    system.defaults.dock.show-recents = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Show recent applications in the dock. The default is true.
      '';
    };

    system.defaults.dock.slow-motion-allowed = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Allow for slow-motion minimize effect while holding Shift key. The default is false.
      '';
    };

    system.defaults.dock.static-only = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Show only open applications in the Dock. The default is false.
      '';
    };

    system.defaults.dock.tilesize = mkOption {
      type = types.nullOr types.int;
      default = null;
      description = ''
        Size of the icons in the dock.  The default is 64.
      '';
    };

    system.defaults.dock.magnification = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Magnify icon on hover. The default is false.
      '';
    };

    system.defaults.dock.largesize = mkOption {
      type = types.nullOr (types.ints.between 16 128);
      default = null;
      description = ''
        Magnified icon size on hover. The default is 16.
      '';
    };

    system.defaults.dock.wvous-tl-corner = mkOption {
      type = types.nullOr types.ints.positive;
      default = null;
      description = ''
        Hot corner action for top left corner. Valid values include:

        * `1`: Disabled
        * `2`: Mission Control
        * `3`: Application Windows
        * `4`: Desktop
        * `5`: Start Screen Saver
        * `6`: Disable Screen Saver
        * `7`: Dashboard
        * `10`: Put Display to Sleep
        * `11`: Launchpad
        * `12`: Notification Center
        * `13`: Lock Screen
        * `14`: Quick Note
      '';
    };

    system.defaults.dock.wvous-bl-corner = mkOption {
      type = types.nullOr types.ints.positive;
      default = null;
      description = ''
        Hot corner action for bottom left corner. Valid values include:

        * `1`: Disabled
        * `2`: Mission Control
        * `3`: Application Windows
        * `4`: Desktop
        * `5`: Start Screen Saver
        * `6`: Disable Screen Saver
        * `7`: Dashboard
        * `10`: Put Display to Sleep
        * `11`: Launchpad
        * `12`: Notification Center
        * `13`: Lock Screen
        * `14`: Quick Note
      '';
    };

    system.defaults.dock.wvous-tr-corner = mkOption {
      type = types.nullOr types.ints.positive;
      default = null;
      description = ''
        Hot corner action for top right corner. Valid values include:

        * `1`: Disabled
        * `2`: Mission Control
        * `3`: Application Windows
        * `4`: Desktop
        * `5`: Start Screen Saver
        * `6`: Disable Screen Saver
        * `7`: Dashboard
        * `10`: Put Display to Sleep
        * `11`: Launchpad
        * `12`: Notification Center
        * `13`: Lock Screen
        * `14`: Quick Note
      '';
    };

    system.defaults.dock.wvous-br-corner = mkOption {
      type = types.nullOr types.ints.positive;
      default = null;
      description = ''
        Hot corner action for bottom right corner. Valid values include:

        * `1`: Disabled
        * `2`: Mission Control
        * `3`: Application Windows
        * `4`: Desktop
        * `5`: Start Screen Saver
        * `6`: Disable Screen Saver
        * `7`: Dashboard
        * `10`: Put Display to Sleep
        * `11`: Launchpad
        * `12`: Notification Center
        * `13`: Lock Screen
        * `14`: Quick Note
      '';
    };

    };
}
</file>

<file path="modules/system/defaults/finder.nix">
{ config, lib, ... }:

let
  inherit (lib) mkOption types;

  cfg = config.system.defaults.finder;
in
{
  options = {

    system.defaults.finder.AppleShowAllFiles = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to always show hidden files. The default is false.
      '';
    };

    system.defaults.finder.ShowStatusBar = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Show status bar at bottom of finder windows with item/disk space stats. The default is false.
      '';
    };

    system.defaults.finder.ShowPathbar = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Show path breadcrumbs in finder windows. The default is false.
      '';
    };

    system.defaults.finder.FXDefaultSearchScope = mkOption {
      type = types.nullOr types.str;
      default = null;
      description = ''
        Change the default search scope. Use "SCcf" to default to current folder.
        The default is unset ("This Mac").
      '';
    };

    system.defaults.finder.FXRemoveOldTrashItems = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Remove items in the trash after 30 days.
        The default is false.
      '';
    };

    system.defaults.finder.FXPreferredViewStyle = mkOption {
      type = types.nullOr types.str;
      default = null;
      description = ''
        Change the default finder view.
        "icnv" = Icon view, "Nlsv" = List view, "clmv" = Column View, "Flwv" = Gallery View
        The default is icnv.
      '';
    };

    system.defaults.finder.AppleShowAllExtensions = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to always show file extensions. The default is false.
      '';
    };

    system.defaults.finder.CreateDesktop = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to show icons on the desktop or not. The default is true.
      '';
    };

    system.defaults.finder.QuitMenuItem = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to allow quitting of the Finder. The default is false.
      '';
    };

    system.defaults.finder.ShowExternalHardDrivesOnDesktop = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to show external disks on desktop. The default is true.
      '';
    };

    system.defaults.finder.ShowHardDrivesOnDesktop = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to show hard disks on desktop. The default is false.
      '';
    };

    system.defaults.finder.ShowMountedServersOnDesktop = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to show connected servers on desktop. The default is false.
      '';
    };

    system.defaults.finder.ShowRemovableMediaOnDesktop = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to show removable media (CDs, DVDs and iPods) on desktop. The default is true.
      '';
    };

    system.defaults.finder._FXShowPosixPathInTitle = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to show the full POSIX filepath in the window title. The default is false.
      '';
    };

    system.defaults.finder._FXSortFoldersFirst = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Keep folders on top when sorting by name. The default is false.
      '';
    };

    system.defaults.finder._FXSortFoldersFirstOnDesktop = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Keep folders on top when sorting by name on the desktop. The default is false.
      '';
    };

    system.defaults.finder.FXEnableExtensionChangeWarning = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to show warnings when change the file extension of files. The default is true.
      '';
    };

    system.defaults.finder.NewWindowTarget = mkOption {
      type = types.nullOr (types.enum [
        "Computer"
        "OS volume"
        "Home"
        "Desktop"
        "Documents"
        "Recents"
        "iCloud Drive"
        "Other"
      ]);
      apply = key: if key == null then null else {
        "Computer" = "PfCm";
        "OS volume" = "PfVo";
        "Home" = "PfHm";
        "Desktop" = "PfDe";
        "Documents" = "PfDo";
        "Recents" = "PfAF";
        "iCloud Drive" = "PfID";
        "Other" = "PfLo";
      }.${key};
      default = null;
      description = ''
        Change the default folder shown in Finder windows. "Other" corresponds to the value of
        NewWindowTargetPath. The default is unset ("Recents").
      '';
    };

    system.defaults.finder.NewWindowTargetPath = mkOption {
      type = types.nullOr types.str;
      default = null;
      description = ''
        Sets the URI to open when NewWindowTarget is "Other". Spaces and similar characters must be
        escaped. If the value is invalid, Finder will open your home directory.
        Example: "file:///Users/foo/long%20cat%20pics".
        The default is unset.
      '';
    };
  };

  config = {
    assertions = [{
      assertion = cfg.NewWindowTargetPath != null -> cfg.NewWindowTarget == "PfLo";
      message = "`system.defaults.finder.NewWindowTarget` should be set to `Other` when `NewWindowTargetPath` is non-null.";
    }
    {
      assertion = cfg.NewWindowTarget == "PfLo" -> cfg.NewWindowTargetPath != null;
      message = "`system.defaults.finder.NewWindowTargetPath` should be non-null when `NewWindowTarget` is set to `Other`.";
    }];
  };
}
</file>

<file path="modules/system/defaults/GlobalPreferences.nix">
{ config, lib, ... }:

with lib;

let
  inherit (config.lib.defaults.types) floatWithDeprecationError;
in {
  options = {

    system.defaults.".GlobalPreferences"."com.apple.sound.beep.sound" =
      mkOption {
        type = types.nullOr (types.path);
        default = null;
        description = ''
          Sets the system-wide alert sound. Found under "Sound Effects" in the
          "Sound" section of "System Preferences". Look in
          "/System/Library/Sounds" for possible candidates.
        '';
      };

    system.defaults.".GlobalPreferences"."com.apple.mouse.scaling" =
      mkOption {
        type = types.nullOr floatWithDeprecationError;
        default = null;
        example = -1.0;
        description = ''
          Sets the mouse tracking speed. Found in the "Mouse" section of
          "System Preferences". Set to -1.0 to disable mouse acceleration.
        '';
      };
  };
}
</file>

<file path="modules/system/defaults/hitoolbox.nix">
{ lib, ... }:

{
  options = {

    system.defaults.hitoolbox.AppleFnUsageType = lib.mkOption {
      type = lib.types.nullOr (lib.types.enum [
        "Do Nothing"
        "Change Input Source"
        "Show Emoji & Symbols"
        "Start Dictation"
      ]);
      apply = key: if key == null then null else {
        "Do Nothing" = 0;
        "Change Input Source" = 1;
        "Show Emoji & Symbols" = 2;
        "Start Dictation" = 3;
      }.${key};
      default = null;
      description = ''
        Chooses what happens when you press the Fn key on the keyboard. A restart is required for
        this setting to take effect.

        The default is unset ("Show Emoji & Symbols").
      '';
    };

  };
}
</file>

<file path="modules/system/defaults/iCal.nix">
{ lib, ... }:

{
  options = {
    system.defaults.iCal."first day of week" = lib.mkOption {
      type = lib.types.nullOr (lib.types.enum [
        "System Setting"
        "Sunday"
        "Monday"
        "Tuesday"
        "Wednesday"
        "Thursday"
        "Friday"
        "Saturday"
      ]);
      apply = key: if key == null then null else {
        "System Setting" = 0;
        "Sunday" = 1;
        "Monday" = 2;
        "Tuesday" = 3;
        "Wednesday" = 4;
        "Thursday" = 5;
        "Friday" = 6;
        "Saturday" = 7;
      }.${key};
      default = null;
      description = ''
        Set the day to start week on in the Calendar. The default is "System Setting".

        System Setting means inherit the value from Language & Region.
      '';
    };

    system.defaults.iCal.CalendarSidebarShown = lib.mkOption {
      type = lib.types.nullOr lib.types.bool;
      default = null;
      description = ''
        Show calendar list. The default is false.

        This requires restarting `Calendar.app` to show.
      '';
    };

    system.defaults.iCal."TimeZone support enabled" = lib.mkOption {
      type = lib.types.nullOr lib.types.bool;
      default = null;
      description = ''
        Turn on time zone support. The default is false.
      '';
    };
  };
}
</file>

<file path="modules/system/defaults/LaunchServices.nix">
{ config, lib, ... }:

with lib;

{
  options = {

    system.defaults.LaunchServices.LSQuarantine = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to enable quarantine for downloaded applications.  The default is true.
      '';
    };

  };
}
</file>

<file path="modules/system/defaults/loginwindow.nix">
{ config, lib, ... }:

with lib;

{
  options = {
    system.defaults.loginwindow.SHOWFULLNAME = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Apple menu > System Preferences > Users and Groups > Login Options

        Displays login window as a name and password field instead of a list of users.
        Default is false.
      '';
    };

    system.defaults.loginwindow.autoLoginUser = mkOption {
      type = types.nullOr types.str;
      default = null;
      description = ''
        Apple menu > System Preferences > Users and Groups > Login Options

        Auto login the supplied user on boot. Default is Off.
      '';
    };

    system.defaults.loginwindow.GuestEnabled = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Apple menu > System Preferences > Users and Groups > Login Options

        Allow users to login to the machine as guests using the Guest account. Default is true.
      '';
    };

    system.defaults.loginwindow.LoginwindowText = mkOption {
      type = types.nullOr types.str;
      default = null;
      description = ''
        Text to be shown on the login window. Default is "\\\\U03bb".
      '';
    };

    system.defaults.loginwindow.ShutDownDisabled = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Apple menu > System Preferences > Users and Groups > Login Options

        Hides the Shut Down button on the login screen. Default is false.
      '';
    };

    system.defaults.loginwindow.SleepDisabled = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Apple menu > System Preferences > Users and Groups > Login Options

        Hides the Sleep button on the login screen. Default is false.
      '';
    };

    system.defaults.loginwindow.RestartDisabled = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Apple menu > System Preferences > Users and Groups > Login Options

        Hides the Restart button on the login screen. Default is false.
      '';
    };

    system.defaults.loginwindow.ShutDownDisabledWhileLoggedIn = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Apple menu > System Preferences > Users and Groups > Login Options

        Disables the "Shutdown" option when users are logged in. Default is false.
      '';
    };

    system.defaults.loginwindow.PowerOffDisabledWhileLoggedIn = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Apple menu > System Preferences > Users and Groups > Login Options

        If set to true, the Power Off menu item will be disabled when the user is logged in. Default is false.
      '';
    };

    system.defaults.loginwindow.RestartDisabledWhileLoggedIn = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Apple menu > System Preferences > Users and Groups > Login Options

        Disables the ‚ÄúRestart‚Äù option when users are logged in. Default is false.
      '';
    };

    system.defaults.loginwindow.DisableConsoleAccess = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Disables the ability for a user to access the console by typing ‚Äú>console‚Äù
        for a username at the login window. Default is false.
      '';
    };
  };
}
</file>

<file path="modules/system/defaults/magicmouse.nix">
{ config, lib, ... }:

with lib;

{
  options = {

    system.defaults.magicmouse.MouseButtonMode = mkOption {
      type = types.nullOr (types.enum [
        "OneButton"
        "TwoButton"
      ]);
      default = null;
      description = ''
        "OneButton": any tap is a left click.  "TwoButton": allow left-
        and right-clicking.
      '';
    };

  };
}
</file>

<file path="modules/system/defaults/NSGlobalDomain.nix">
{ config, lib, ... }:

with lib;

let
  # Should only be used with options that previously used floats defined as strings.
  inherit (config.lib.defaults.types) floatWithDeprecationError;
in {
  options = {
    system.defaults.NSGlobalDomain.AppleShowAllFiles = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to always show hidden files. The default is false.
      '';
    };

    system.defaults.NSGlobalDomain.AppleEnableMouseSwipeNavigateWithScrolls = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Enables swiping left or right with two fingers to navigate backward or forward. The default is true.
      '';
    };

    system.defaults.NSGlobalDomain.AppleEnableSwipeNavigateWithScrolls = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Enables swiping left or right with two fingers to navigate backward or forward. The default is true.
      '';
    };

    system.defaults.NSGlobalDomain.AppleFontSmoothing = mkOption {
      type = types.nullOr (types.enum [ 0 1 2 ]);
      default = null;
      description = ''
        Sets the level of font smoothing (sub-pixel font rendering).
      '';
    };

    system.defaults.NSGlobalDomain.AppleInterfaceStyle = mkOption {
      type = types.nullOr (types.enum [ "Dark" ]);
      default = null;
      description = ''
        Set to 'Dark' to enable dark mode.

        To set to light mode, set this to `null` and you'll need to manually run
        {command}`defaults delete -g AppleInterfaceStyle`.

        This option requires logging out and logging back in to apply.
      '';
    };

    system.defaults.NSGlobalDomain.AppleIconAppearanceTheme = mkOption {
      type = types.nullOr (types.enum [ "RegularDark" "RegularAutomatic" "ClearLight" "ClearDark" "ClearAutomatic" "TintedLight" "TintedDark" "TintedAutomatic" ]);
      default = null;
      description = ''
        Set icon and widget style

        To set to default mode, set this to `null` and you'll need to manually run
        {command}`defaults delete -g AppleIconAppearanceTheme`.

        This option requires logging out and logging back in to apply.
      '';
    };

    system.defaults.NSGlobalDomain.AppleInterfaceStyleSwitchesAutomatically = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to automatically switch between light and dark mode. The default is false.
      '';
    };

    system.defaults.NSGlobalDomain.AppleKeyboardUIMode = mkOption {
      type = types.nullOr (types.enum [ 0 2 3 ]);
      default = null;
      description = ''
        Configures the keyboard control behavior. The default is 0.

        0 = Disabled
        2 = Enabled on Sonoma or later
        3 = Enabled on older macOS versions
      '';
    };

    system.defaults.NSGlobalDomain.ApplePressAndHoldEnabled = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to enable the press-and-hold feature. The default is true.
      '';
    };

    system.defaults.NSGlobalDomain.AppleShowAllExtensions = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to show all file extensions in Finder. The default is false.
      '';
    };

    system.defaults.NSGlobalDomain.AppleShowScrollBars = mkOption {
      type = types.nullOr (types.enum [ "WhenScrolling" "Automatic" "Always" ]);
      default = null;
      description = ''
        When to show the scrollbars. Options are 'WhenScrolling', 'Automatic' and 'Always'.
      '';
    };

    system.defaults.NSGlobalDomain.AppleScrollerPagingBehavior = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Jump to the spot that's clicked on the scroll bar. The default is false.
      '';
    };

    system.defaults.NSGlobalDomain.AppleSpacesSwitchOnActivate = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether or not to switch to a workspace that has a window of the application open, that is switched to. The default is true.
      '';
    };

    system.defaults.NSGlobalDomain.NSAutomaticCapitalizationEnabled = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to enable automatic capitalization. The default is true.
      '';
    };

    system.defaults.NSGlobalDomain.NSAutomaticInlinePredictionEnabled = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to enable inline predictive text. The default is true.
      '';
    };

    system.defaults.NSGlobalDomain.NSAutomaticDashSubstitutionEnabled = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to enable smart dash substitution. The default is true.
      '';
    };

    system.defaults.NSGlobalDomain.NSAutomaticPeriodSubstitutionEnabled = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to enable smart period substitution. The default is true.
      '';
    };

    system.defaults.NSGlobalDomain.NSAutomaticQuoteSubstitutionEnabled = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to enable smart quote substitution. The default is true.
      '';
    };

    system.defaults.NSGlobalDomain.NSAutomaticSpellingCorrectionEnabled = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to enable automatic spelling correction. The default is true.
      '';
    };

    system.defaults.NSGlobalDomain.NSAutomaticWindowAnimationsEnabled = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to animate opening and closing of windows and popovers. The default is true.
      '';
    };

    system.defaults.NSGlobalDomain.NSDisableAutomaticTermination = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to disable the automatic termination of inactive apps.
      '';
    };

    system.defaults.NSGlobalDomain.NSDocumentSaveNewDocumentsToCloud = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to save new documents to iCloud by default. The default is true.
      '';
    };

    system.defaults.NSGlobalDomain.AppleWindowTabbingMode = mkOption {
      type = types.nullOr (types.enum [ "manual" "always" "fullscreen" ]);
      default = null;
      description = ''
        Sets the window tabbing when opening a new document: 'manual', 'always', or 'fullscreen'. The default is 'fullscreen'.
      '';
    };

    system.defaults.NSGlobalDomain.NSNavPanelExpandedStateForSaveMode = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to use expanded save panel by default. The default is false.
      '';
    };

    system.defaults.NSGlobalDomain.NSNavPanelExpandedStateForSaveMode2 = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to use expanded save panel by default. The default is false.
      '';
    };

    system.defaults.NSGlobalDomain.NSTableViewDefaultSizeMode = mkOption {
      type = types.nullOr (types.enum [ 1 2 3 ]);
      default = null;
      description = ''
        Sets the size of the finder sidebar icons: 1 (small), 2 (medium) or 3 (large). The default is 3.
      '';
    };

    system.defaults.NSGlobalDomain.NSTextShowsControlCharacters = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to display ASCII control characters using caret notation in standard text views. The default is false.
      '';
    };

    system.defaults.NSGlobalDomain.NSUseAnimatedFocusRing = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to enable the focus ring animation. The default is true.
      '';
    };

    system.defaults.NSGlobalDomain.NSScrollAnimationEnabled = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to enable smooth scrolling. The default is true.
      '';
    };

    system.defaults.NSGlobalDomain.NSWindowResizeTime = mkOption {
      type = types.nullOr floatWithDeprecationError;
      default = null;
      example = 0.20;
      description = ''
        Sets the speed speed of window resizing. The default is given in the example.
      '';
    };

    system.defaults.NSGlobalDomain.NSWindowShouldDragOnGesture = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to enable moving window by holding anywhere on it like on Linux. The default is false.
      '';
    };

    system.defaults.NSGlobalDomain.NSStatusItemSpacing = mkOption {
      type = types.nullOr types.int;
      default = null;
      example = 12;
      description = ''
        Sets the spacing between status icons in the menu bar.
      '';
    };

    system.defaults.NSGlobalDomain.NSStatusItemSelectionPadding = mkOption {
      type = types.nullOr types.int;
      default = null;
      example = 6;
      description = ''
        Sets the padding around status icons in the menu bar.
      '';
    };

    system.defaults.NSGlobalDomain.InitialKeyRepeat = mkOption {
      type = types.nullOr types.int;
      default = null;
      description = ''
        Apple menu > System Preferences > Keyboard

        If you press and hold certain keyboard keys when in a text area, the key‚Äôs character begins to repeat.
        For example, the Delete key continues to remove text for as long as you hold it down.

        This sets how long you must hold down the key before it starts repeating.
      '';
    };

    system.defaults.NSGlobalDomain.KeyRepeat = mkOption {
      type = types.nullOr types.int;
      default = null;
      description = ''
        Apple menu > System Preferences > Keyboard

        If you press and hold certain keyboard keys when in a text area, the key‚Äôs character begins to repeat.
        For example, the Delete key continues to remove text for as long as you hold it down.

        This sets how fast it repeats once it starts.
      '';
    };

    system.defaults.NSGlobalDomain.PMPrintingExpandedStateForPrint = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to use the expanded print panel by default. The default is false.
      '';
    };

    system.defaults.NSGlobalDomain.PMPrintingExpandedStateForPrint2 = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to use the expanded print panel by default. The default is false.
      '';
    };

    system.defaults.NSGlobalDomain."com.apple.keyboard.fnState" = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Use F1, F2, etc. keys as standard function keys.
      '';
    };

    system.defaults.NSGlobalDomain."com.apple.mouse.tapBehavior" = mkOption {
      type = types.nullOr (types.enum [ 1 ]);
      default = null;
      description = ''
        Configures the trackpad tap behavior. Mode 1 enables tap to click.
      '';
    };

    system.defaults.NSGlobalDomain."com.apple.sound.beep.volume" = mkOption {
      type = types.nullOr floatWithDeprecationError;
      default = null;
      description = ''
        Apple menu > System Preferences > Sound

        Sets the beep/alert volume level from 0.000 (muted) to 1.000 (100% volume).

        75% = 0.7788008

        50% = 0.6065307

        25% = 0.4723665
      '';
    };

    system.defaults.NSGlobalDomain."com.apple.sound.beep.feedback" = mkOption {
      type = types.nullOr types.int;
      default = null;
      description = ''
        Apple menu > System Preferences > Sound

        Make a feedback sound when the system volume changed. This setting accepts
        the integers 0 or 1. Defaults to 1.
      '';
    };

    system.defaults.NSGlobalDomain."com.apple.trackpad.enableSecondaryClick" = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to enable trackpad secondary click. The default is true.
      '';
    };

    system.defaults.NSGlobalDomain."com.apple.trackpad.trackpadCornerClickBehavior" = mkOption {
      type = types.nullOr (types.enum [ 1 ]);
      default = null;
      description = ''
        Configures the trackpad corner click behavior. Mode 1 enables right click.
      '';
    };

    system.defaults.NSGlobalDomain."com.apple.trackpad.scaling" = mkOption {
      type = types.nullOr floatWithDeprecationError;
      default = null;
      description = ''
        Configures the trackpad tracking speed (0 to 3). The default is "1".
      '';
    };

    system.defaults.NSGlobalDomain."com.apple.trackpad.forceClick" = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to enable trackpad force click.
      '';
    };

    system.defaults.NSGlobalDomain."com.apple.springing.enabled" = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to enable spring loading (expose) for directories.
      '';
    };

    system.defaults.NSGlobalDomain."com.apple.springing.delay" = mkOption {
      type = types.nullOr floatWithDeprecationError;
      default = null;
      example = 1.0;
      description = ''
        Set the spring loading delay for directories. The default is given in the example.
      '';
    };

    system.defaults.NSGlobalDomain."com.apple.swipescrolldirection" = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to enable "Natural" scrolling direction. The default is true.
      '';
    };

    system.defaults.NSGlobalDomain.AppleMeasurementUnits = mkOption {
      type = types.nullOr (types.enum [ "Centimeters" "Inches" ]);
      default = null;
      description = ''
        Whether to use centimeters (metric) or inches (US, UK) as the measurement unit. The default is based on region settings.
      '';
    };

    system.defaults.NSGlobalDomain.AppleMetricUnits = mkOption {
      type = types.nullOr (types.enum [ 0 1 ]);
      default = null;
      description = ''
        Whether to use the metric system. The default is based on region settings.
      '';
    };

    system.defaults.NSGlobalDomain.AppleTemperatureUnit = mkOption {
      type = types.nullOr (types.enum [ "Celsius" "Fahrenheit" ]);
      default = null;
      description = ''
        Whether to use Celsius or Fahrenheit. The default is based on region settings.
      '';
    };

    system.defaults.NSGlobalDomain.AppleICUForce24HourTime = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to use 24-hour or 12-hour time. The default is based on region settings.
      '';
    };

    system.defaults.NSGlobalDomain._HIHideMenuBar = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to autohide the menu bar. The default is false.
      '';
    };

  };

}
</file>

<file path="modules/system/defaults/screencapture.nix">
{ lib, ... }:

with lib;

{
  options = {

    system.defaults.screencapture.location = mkOption {
      type = types.nullOr types.str;
      default = null;
      description = ''
          The filesystem path to which screencaptures should be written.
        '';
    };

    system.defaults.screencapture.type = mkOption {
      type = types.nullOr types.str;
      default = null;
      description = ''
          The image format to use, such as "jpg".
        '';
    };

    system.defaults.screencapture.disable-shadow = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
          Disable drop shadow border around screencaptures. The default is false.
        '';
    };

    system.defaults.screencapture.include-date = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Include date and time in screenshot filenames. The default is true.
        Screenshot 2024-01-09 at 13.27.20.png would be an example for true.
        
        Screenshot.png
        Screenshot 1.png would be an example for false.
      '';
    };

    system.defaults.screencapture.show-thumbnail = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Show thumbnail after screencapture before writing to file. The default is true.
      '';
    };

    system.defaults.screencapture.target = mkOption {
      type = types.nullOr (types.enum [ "file" "clipboard" "preview" "mail" "messages" ]);
      default = null;
      description = ''
        Target to which screencapture should save screenshot to. The default is "file".
        Valid values include:

        * `file`: Saves as a file in location specified by `system.defaults.screencapture.location`
        * `clipboard`: Saves screenshot to clipboard
        * `preview`: Opens screenshot in Preview app
        * `mail`
        * `messages`
      '';
    };
  };
}
</file>

<file path="modules/system/defaults/screensaver.nix">
{ config, lib, ... }:

with lib;

{
  options = {

    system.defaults.screensaver.askForPassword = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
          If true, the user is prompted for a password when the screen saver is unlocked or stopped. The default is false.
        '';
    };

    system.defaults.screensaver.askForPasswordDelay = mkOption {
      type = types.nullOr types.int;
      default = null;
      description = ''
          The number of seconds to delay before the password will be required to unlock or stop the screen saver (the grace period).
        '';
    };
  };
}
</file>

<file path="modules/system/defaults/smb.nix">
{ config, lib, ... }:

with lib;

{
  options = {
    system.defaults.smb.NetBIOSName = mkOption {
      type = types.nullOr types.str;
      default = null;
      description = "Hostname to use for NetBIOS.";
    };

    system.defaults.smb.ServerDescription = mkOption {
      type = types.nullOr types.str;
      default = null;
      description = "Hostname to use for sharing services.";
    };
  };
}
</file>

<file path="modules/system/defaults/SoftwareUpdate.nix">
{ config, lib, ... }:

with lib;

{
  options = {
    system.defaults.SoftwareUpdate.AutomaticallyInstallMacOSUpdates = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Automatically install Mac OS software updates. Defaults to false.
      '';
    };
  };
}
</file>

<file path="modules/system/defaults/spaces.nix">
{ config, lib, ... }:

with lib;

{
  options = {
    system.defaults.spaces.spans-displays = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Apple menu > System Preferences > Mission Control

        Displays have separate Spaces (note a logout is required before
        this setting will take effect).

        false = each physical display has a separate space (Mac default)
        true = one space spans across all physical displays
      '';
    };
  };
}
</file>

<file path="modules/system/defaults/trackpad.nix">
{ config, lib, ... }:

with lib;

{
  options = {

    system.defaults.trackpad.Clicking = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to enable trackpad tap to click.  The default is false.
      '';
    };

    system.defaults.trackpad.Dragging = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to enable tap-to-drag. The default is false.
      '';
    };

    system.defaults.trackpad.TrackpadRightClick = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to enable trackpad right click.  The default is false.
      '';
    };

    system.defaults.trackpad.TrackpadThreeFingerDrag = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Whether to enable three finger drag.  The default is false.
      '';
    };

    system.defaults.trackpad.ActuationStrength = mkOption {
      type = types.nullOr (types.enum [ 0 1 ]);
      default = null;
      description = ''
        0 to enable Silent Clicking, 1 to disable.  The default is 1.
      '';
    };

    system.defaults.trackpad.FirstClickThreshold = mkOption {
      type = types.nullOr (types.enum [ 0 1 2 ]);
      default = null;
      description = ''
        For normal click: 0 for light clicking, 1 for medium, 2 for firm.
        The default is 1.
      '';
    };

    system.defaults.trackpad.SecondClickThreshold = mkOption {
      type = types.nullOr (types.enum [ 0 1 2 ]);
      default = null;
      description = ''
        For force touch: 0 for light clicking, 1 for medium, 2 for firm.
        The default is 1.
      '';
    };

    system.defaults.trackpad.TrackpadThreeFingerTapGesture = mkOption {
      type = types.nullOr (types.enum [ 0 2 ]);
      default = null;
      description = ''
        0 to disable three finger tap, 2 to trigger Look up & data detectors.
        The default is 2.
      '';
    };

  };
}
</file>

<file path="modules/system/defaults/universalaccess.nix">
{ config, lib, ... }:

with lib;

{
  options = {

    system.defaults.universalaccess.mouseDriverCursorSize = mkOption {
      type = types.nullOr types.float;
      default = null;
      example = 1.5;
      description = ''
        Set the size of cursor. 1 for normal, 4 for maximum.
        The default is 1.
      '';
    };

    system.defaults.universalaccess.reduceMotion = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Disable animation when switching screens or opening apps
      '';
    };

    system.defaults.universalaccess.reduceTransparency = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Disable transparency in the menu bar and elsewhere.
        The default is false.
      '';
    };

    system.defaults.universalaccess.closeViewScrollWheelToggle = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Use scroll gesture with the Ctrl (^) modifier key to zoom.
        The default is false.
      '';
    };

    system.defaults.universalaccess.closeViewZoomFollowsFocus = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Follow the keyboard focus while zoomed in.
        Without setting `closeViewScrollWheelToggle` this has no effect.
        The default is false.
      '';
    };

  };
}
</file>

<file path="modules/system/defaults/WindowManager.nix">
{ config, lib, ... }:

with lib;
{
  options = {
    system.defaults.WindowManager.GloballyEnabled = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Enable Stage Manager
        Stage Manager arranges your recent windows into a single strip for reduced clutter and quick access. Default is false.
      '';
    };

    system.defaults.WindowManager.EnableStandardClickToShowDesktop = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Click wallpaper to reveal desktop
        Clicking your wallpaper will move all windows out of the way to allow access to your desktop items and widgets. Default is true.
        false means "Only in Stage Manager"
        true means "Always"
      '';
    };

    system.defaults.WindowManager.AutoHide = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Auto hide stage strip showing recent apps. Default is false.
      '';
    };

    system.defaults.WindowManager.AppWindowGroupingBehavior = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Grouping strategy when showing windows from an application.
        false means "One at a time"
        true means "All at once"
      '';
    };

    system.defaults.WindowManager.StandardHideDesktopIcons = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Hide items on desktop.
        '';
    };

    system.defaults.WindowManager.HideDesktop = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Hide items in Stage Manager.
      '';
    };

    system.defaults.WindowManager.EnableTilingByEdgeDrag = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Enable dragging windows to screen edges to tile them. The default is true.
      '';
    };

    system.defaults.WindowManager.EnableTopTilingByEdgeDrag = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Enable dragging windows to the menu bar to fill the screen. The default is true.
      '';
    };

    system.defaults.WindowManager.EnableTilingOptionAccelerator = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Enable holding alt to tile windows. The default is true.
      '';
    };

    system.defaults.WindowManager.EnableTiledWindowMargins = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Enable window margins when tiling windows. The default is true.
      '';
    };

    system.defaults.WindowManager.StandardHideWidgets = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
          Hide widgets on desktop.
        '';
    };

    system.defaults.WindowManager.StageManagerHideWidgets = mkOption {
      type = types.nullOr types.bool;
      default = null;
      description = ''
        Hide widgets in Stage Manager.
      '';
    };
  };
}
</file>

<file path="modules/system/activation-scripts.nix">
{ config, lib, pkgs, ... }:

with lib;

let

  inherit (pkgs) stdenv;

  cfg = config.system;

  script = import ../lib/write-text.nix {
    inherit lib;
    mkTextDerivation = name: text: pkgs.writeScript "activate-${name}" text;
  };

  activationPath =
    lib.makeBinPath (
      [
        pkgs.gnugrep
        pkgs.coreutils
      ] ++ lib.optionals config.nix.enable [ config.nix.package ]
    )
    + lib.optionalString (!config.nix.enable) ''
      $(
        # If `nix.enable` is off, there might be an unmanaged Nix
        # installation (say in `/nix/var/nix/profiles/default`) that
        # activation scripts (such as Home Manager) want to find on the
        # `$PATH`. Search for it directly to avoid polluting the
        # activation script environment with everything on the
        # `environment.systemPath`.
        if nixEnvPath=$(
          PATH="${config.environment.systemPath}" command -v nix-env
        ); then
          printf ':'
          ${lib.getExe' pkgs.coreutils "dirname"} -- "$(
            ${lib.getExe' pkgs.coreutils "readlink"} \
              --canonicalize-missing \
              -- "$nixEnvPath"
          )"
        fi
      )''
    + ":/usr/bin:/bin:/usr/sbin:/sbin";
in

{
  options = {

    system.activationScripts = mkOption {
      internal = true;
      type = types.attrsOf (types.submodule script);
      default = {};
      description = ''
        A set of shell script fragments that are executed when a NixOS
        system configuration is activated.  Examples are updating
        /etc, creating accounts, and so on.  Since these are executed
        every time you boot the system or run
        {command}`nixos-rebuild`, it's important that they are
        idempotent and fast.
      '';
    };

  };

  config = {

    assertions =
      map
        (userActivationOption: {
          assertion = !config.system.activationScripts ? ${userActivationOption};
          message = ''
            The `system.activationScripts.${userActivationOption}` option has
            been removed, as all activation now takes place as `root`. Please
            restructure your custom activation scripts appropriately,
            potentially using `sudo` if you need to run commands as a user.
          '';
        })
        [
          "extraUserActivation"
          "preUserActivation"
          "postUserActivation"
        ];

    system.activationScripts.script.text = ''
      #!/usr/bin/env -i ${stdenv.shell}
      # shellcheck shell=bash
      # shellcheck disable=SC2096

      set -e
      set -o pipefail

      PATH="${activationPath}"

      export PATH
      export USER=root
      export LOGNAME=root
      export HOME=~root
      export MAIL=/var/mail/root
      export SHELL=$BASH
      export LANG=C
      export LC_CTYPE=UTF-8

      systemConfig=@out@

      # Ensure a consistent umask.
      umask 0022

      cd /

      if [[ $(id -u) -ne 0 ]]; then
        printf >&2 '\e[1;31merror: `activate` must be run as root\e[0m\n'
        exit 2
      fi

      ${cfg.activationScripts.preActivation.text}

      ${cfg.activationScripts.checks.text}
      ${cfg.activationScripts.createRun.text}
      ${cfg.activationScripts.extraActivation.text}
      ${cfg.activationScripts.groups.text}
      ${cfg.activationScripts.users.text}
      ${cfg.activationScripts.applications.text}
      ${cfg.activationScripts.pam.text}
      ${cfg.activationScripts.patches.text}
      ${cfg.activationScripts.etc.text}
      ${cfg.activationScripts.defaults.text}
      ${cfg.activationScripts.userDefaults.text}
      ${cfg.activationScripts.launchd.text}
      ${cfg.activationScripts.userLaunchd.text}
      ${cfg.activationScripts.nix-daemon.text}
      ${cfg.activationScripts.time.text}
      ${cfg.activationScripts.networking.text}
      ${cfg.activationScripts.power.text}
      ${cfg.activationScripts.keyboard.text}
      ${cfg.activationScripts.fonts.text}
      ${cfg.activationScripts.nvram.text}
      ${cfg.activationScripts.homebrew.text}

      ${cfg.activationScripts.postActivation.text}

      # Make this configuration the current configuration.
      # The readlink is there to ensure that when $systemConfig = /system
      # (which is a symlink to the store), /run/current-system is still
      # used as a garbage collection root.
      ln -sfn "$(readlink -f "$systemConfig")" /run/current-system

      # Prevent the current configuration from being garbage-collected.
      if [[ -d /nix/var/nix/gcroots ]]; then
        ln -sfn /run/current-system /nix/var/nix/gcroots/current-system
      fi
    '';

    # Extra activation scripts, that can be customized by users
    # don't use this unless you know what you are doing.
    system.activationScripts.extraActivation.text = mkDefault "";
    system.activationScripts.preActivation.text = mkDefault "";
    system.activationScripts.postActivation.text = mkDefault "";

  };
}
</file>

<file path="modules/system/applications.nix">
{
  config,
  lib,
  pkgs,
  ...
}:

{
  config = {
    system.checks.text = lib.mkAfter ''
      ensureAppManagement() {
        for appBundle in /Applications/Nix\ Apps/*.app; do
          if [[ -d "$appBundle" ]]; then
            if ! touch "$appBundle/.DS_Store" &> /dev/null; then
              return 1
            fi
          fi
        done

        return 0
      }

      if ! ensureAppManagement; then
        if [[ "$(launchctl managername)" != Aqua ]]; then
          # It is possible to grant the App Management permission to `sshd-keygen-wrapper`, however
          # there are many pitfalls like requiring the primary user to grant the permission and to
          # be logged in when `darwin-rebuild` is run over SSH and it will still fail sometimes...
          printf >&2 '\e[1;31merror: permission denied when trying to update apps over SSH, aborting activation\e[0m\n'
          printf >&2 'Apps could not be updated as `darwin-rebuild` requires Full Disk Access to work over SSH.\n'
          printf >&2 'You can either:\n'
          printf >&2 '\n'
          printf >&2 '  grant Full Disk Access to all programs run over SSH\n'
          printf >&2 '\n'
          printf >&2 'or\n'
          printf >&2 '\n'
          printf >&2 '  run `darwin-rebuild` in a graphical session.\n'
          printf >&2 '\n'
          printf >&2 'The option "Allow full disk access for remote users" can be found by\n'
          printf >&2 'navigating to System Settings > General > Sharing > Remote Login\n'
          printf >&2 'and then pressing on the i icon next to the switch.\n'
          exit 1
        else
          # The TCC service required to modify notarised app bundles is `kTCCServiceSystemPolicyAppBundles`
          # and we can reset it to ensure the user gets another prompt
          tccutil reset SystemPolicyAppBundles > /dev/null

          if ! ensureAppManagement; then
            printf >&2 '\e[1;31merror: permission denied when trying to update apps, aborting activation\e[0m\n'
            printf >&2 '`darwin-rebuild` requires permission to update your apps, please accept the notification\n'
            printf >&2 'and grant the permission for your terminal emulator in System Settings.\n'
            printf >&2 '\n'
            printf >&2 'If you did not get a notification, you can navigate to System Settings > Privacy & Security > App Management.\n'
            exit 1
          fi
        fi
      fi
    '';

    system.build.applications = pkgs.buildEnv {
      name = "system-applications";
      paths = config.environment.systemPackages;
      pathsToLink = "/Applications";
    };

    system.activationScripts.applications.text = ''
      # Set up applications.
      echo "setting up /Applications/Nix Apps..." >&2

      ourLink () {
        local link
        link=$(readlink "$1")
        [ -L "$1" ] && [ "''${link#*-}" = 'system-applications/Applications' ]
      }

      ${lib.optionalString (config.system.primaryUser != null) ''
        # Clean up for links created at the old location in HOME
        # TODO: Remove this in 25.11.
        if ourLink ~${config.system.primaryUser}/Applications; then
          rm ~${config.system.primaryUser}/Applications
        elif ourLink ~${config.system.primaryUser}/Applications/'Nix Apps'; then
          rm ~${config.system.primaryUser}/Applications/'Nix Apps'
        fi
      ''}

      targetFolder='/Applications/Nix Apps'

      # Clean up old style symlink to nix store
      if [ -e "$targetFolder" ] && ourLink "$targetFolder"; then
        rm "$targetFolder"
      fi

      mkdir -p "$targetFolder"

      rsyncFlags=(
        # mtime is standardized in the nix store, which would leave only file size to distinguish files.
        # Thus we need checksums, despite the speed penalty.
        --checksum
        # Converts all symlinks pointing outside of the copied tree (thus unsafe) into real files and directories.
        # This neatly converts all the symlinks pointing to application bundles in the nix store into
        # real directories, without breaking any relative symlinks inside of application bundles.
        # This is good enough, because the make-symlinks-relative.sh setup hook converts all $out internal
        # symlinks to relative ones.
        --copy-unsafe-links
        --archive
        --delete
        --chmod=-w
        --no-group
        --no-owner
      )

      ${lib.getExe pkgs.rsync} "''${rsyncFlags[@]}" ${config.system.build.applications}/Applications/ "$targetFolder"
    '';
  };
}
</file>

<file path="modules/system/defaults-write.nix">
{ config, lib, ... }:

with lib;

let
  cfg = config.system.defaults;

  writeDefault = domain: key: value:
    "defaults write ${domain} ${escapeShellArg key} ${escapeShellArg (generators.toPlist { escape = true; } value)}";

  defaultsToList = domain: attrs: mapAttrsToList (writeDefault domain) (filterAttrs (n: v: v != null) attrs);
  userDefaultsToList = domain: attrs: let
    user = escapeShellArg config.system.primaryUser;
  in map
    (cmd: ''launchctl asuser "$(id -u -- ${user})" sudo --user=${user} -- ${cmd}'')
    (defaultsToList domain attrs);

  # Filter out options to not pass through
  # dock has alias options that we need to ignore
  dockFiltered = (builtins.removeAttrs cfg.dock ["expose-group-by-app"]);

  # defaults
  loginwindow = defaultsToList "/Library/Preferences/com.apple.loginwindow" cfg.loginwindow;
  smb = defaultsToList "/Library/Preferences/SystemConfiguration/com.apple.smb.server" cfg.smb;
  SoftwareUpdate = defaultsToList "/Library/Preferences/com.apple.SoftwareUpdate" cfg.SoftwareUpdate;
  CustomSystemPreferences = flatten (mapAttrsToList (name: value: defaultsToList name value) cfg.CustomSystemPreferences);

  # userDefaults
  GlobalPreferences = userDefaultsToList ".GlobalPreferences" cfg.".GlobalPreferences";
  LaunchServices = userDefaultsToList "com.apple.LaunchServices" cfg.LaunchServices;
  NSGlobalDomain = userDefaultsToList "-g" cfg.NSGlobalDomain;
  menuExtraClock = userDefaultsToList "com.apple.menuextra.clock" cfg.menuExtraClock;
  dock = userDefaultsToList "com.apple.dock" dockFiltered;
  finder = userDefaultsToList "com.apple.finder" cfg.finder;
  hitoolbox = userDefaultsToList "com.apple.HIToolbox" cfg.hitoolbox;
  iCal = userDefaultsToList "com.apple.iCal" cfg.iCal;
  magicmouse = userDefaultsToList "com.apple.AppleMultitouchMouse" cfg.magicmouse;
  magicmouseBluetooth = userDefaultsToList "com.apple.driver.AppleMultitouchMouse.mouse" cfg.magicmouse;
  screencapture = userDefaultsToList "com.apple.screencapture" cfg.screencapture;
  screensaver = userDefaultsToList "com.apple.screensaver" cfg.screensaver;
  spaces = userDefaultsToList "com.apple.spaces" cfg.spaces;
  trackpad = userDefaultsToList "com.apple.AppleMultitouchTrackpad" cfg.trackpad;
  trackpadBluetooth = userDefaultsToList "com.apple.driver.AppleBluetoothMultitouch.trackpad" cfg.trackpad;
  universalaccess = userDefaultsToList "com.apple.universalaccess" cfg.universalaccess;
  ActivityMonitor = userDefaultsToList "com.apple.ActivityMonitor" cfg.ActivityMonitor;
  WindowManager = userDefaultsToList "com.apple.WindowManager" cfg.WindowManager;
  controlcenter = userDefaultsToList "~${config.system.primaryUser}/Library/Preferences/ByHost/com.apple.controlcenter" cfg.controlcenter;
  CustomUserPreferences = flatten (mapAttrsToList (name: value: userDefaultsToList name value) cfg.CustomUserPreferences);


  mkIfLists = list: mkIf (any (attrs: attrs != [ ]) list);
in

{
  config = {

    # Type used for `system.defaults.<domain>.*` options that previously accepted float values as a
    # string.
    lib.defaults.types.floatWithDeprecationError = types.float // {
      check = x:
        if isString x && builtins.match "^[+-]?([0-9]*[.])?[0-9]+$" x != null
        then throw "Using strings for `system.defaults.<domain>.*' options of type float is no longer permitted, use native float values instead."
        else types.float.check x;
    };

    system.requiresPrimaryUser = concatMap
      (scope: mapAttrsToList
        (name: value: mkIf (value != null) (showOption [ "system" "defaults" scope name ]))
        (if scope == "dock" then dockFiltered else cfg.${scope}))
      [
        "CustomUserPreferences"
        ".GlobalPreferences"
        "LaunchServices"
        "NSGlobalDomain"
        "menuExtraClock"
        "dock"
        "finder"
        "hitoolbox"
        "magicmouse"
        "screencapture"
        "screensaver"
        "spaces"
        "trackpad"
        "universalaccess"
        "ActivityMonitor"
        "WindowManager"
        "controlcenter"
      ];

    system.activationScripts.defaults.text = mkIfLists [
      loginwindow
      smb
      SoftwareUpdate
      CustomSystemPreferences
    ]
      ''
        # Set defaults
        echo >&2 "system defaults..."
        ${concatStringsSep "\n" loginwindow}
        ${concatStringsSep "\n" smb}
        ${concatStringsSep "\n" SoftwareUpdate}
        ${concatStringsSep "\n" CustomSystemPreferences}
      '';

    system.activationScripts.userDefaults.text = mkIfLists
      [
        GlobalPreferences
        LaunchServices
        NSGlobalDomain
        menuExtraClock
        dock
        finder
        hitoolbox
        iCal
        magicmouse
        magicmouseBluetooth
        screencapture
        screensaver
        spaces
        trackpad
        trackpadBluetooth
        universalaccess
        ActivityMonitor
        CustomUserPreferences
        WindowManager
        controlcenter
      ]
      ''
        # Set defaults
        echo >&2 "user defaults..."

        ${concatStringsSep "\n" NSGlobalDomain}

        ${concatStringsSep "\n" GlobalPreferences}
        ${concatStringsSep "\n" LaunchServices}
        ${concatStringsSep "\n" menuExtraClock}
        ${concatStringsSep "\n" dock}
        ${concatStringsSep "\n" finder}
        ${concatStringsSep "\n" hitoolbox}
        ${concatStringsSep "\n" iCal}
        ${concatStringsSep "\n" magicmouse}
        ${concatStringsSep "\n" magicmouseBluetooth}
        ${concatStringsSep "\n" screencapture}
        ${concatStringsSep "\n" screensaver}
        ${concatStringsSep "\n" spaces}
        ${concatStringsSep "\n" trackpad}
        ${concatStringsSep "\n" trackpadBluetooth}
        ${concatStringsSep "\n" universalaccess}
        ${concatStringsSep "\n" ActivityMonitor}
        ${concatStringsSep "\n" CustomUserPreferences}
        ${concatStringsSep "\n" WindowManager}
        ${concatStringsSep "\n" controlcenter}

        ${optionalString (length dock > 0) ''
          echo >&2 "restarting Dock..."
          killall -qu ${escapeShellArg config.system.primaryUser} Dock || true
        ''}
      '';

  };
}
</file>

<file path="modules/system/etc.nix">
{ config, lib, pkgs, ... }:

with lib;

let

  text = import ../lib/write-text.nix {
    inherit lib;
    mkTextDerivation = name: text: pkgs.writeText "etc-${name}" text;
  };

  etc = filter (f: f.enable) (attrValues config.environment.etc);

in

{
  options = {

    environment.etc = mkOption {
      type = types.attrsOf (types.submodule text);
      default = { };
      description = ''
        Set of files that have to be linked in {file}`/etc`.
      '';
    };

  };

  config = {

    system.build.etc = pkgs.runCommand "etc"
      { preferLocalBuild = true; }
      ''
        mkdir -p $out/etc
        cd $out/etc
        ${concatMapStringsSep "\n" (attr: ''
          mkdir -p "$(dirname ${escapeShellArg attr.target})"
          ln -s ${escapeShellArgs [ attr.source attr.target ]}
        '') etc}
      '';

    system.activationScripts.checks.text = mkAfter ''
      declare -A etcSha256Hashes=(
        ${concatMapStringsSep "\n  "
          (attr:
            "[${escapeShellArg attr.target}]=" +
            escapeShellArg (concatStringsSep " " attr.knownSha256Hashes))
          etc}
      )

      declare -a etcProblems=()

      while IFS= read -r -d "" configFile; do
        subPath=''${configFile#"$systemConfig"/etc/}
        etcStaticFile=/etc/static/$subPath
        etcFile=/etc/$subPath

        # We need to check files that exist and aren't already links to
        # $etcStaticFile for known hashes.
        if [[
          -e $etcFile
          && $(readlink "$etcFile") != "$etcStaticFile"
        ]]; then
          # Only check hashes of paths that resolve to regular files;
          # everything else (e.g. directories) we complain about
          # unconditionally.
          if [[ -f $(readlink -f "$etcFile") ]]; then
            etcFileSha256Output=$(shasum -a 256 "$etcFile")
            etcFileSha256Hash=''${etcFileSha256Output%% *}
            for knownSha256Hash in ''${etcSha256Hashes[$subPath]}; do
              if [[ $etcFileSha256Hash == "$knownSha256Hash" ]]; then
                # Hash matches, OK to overwrite; go to the next file.
                continue 2
              fi
            done
          fi
          etcProblems+=("$etcFile")
        fi
      done < <(find -H "$systemConfig/etc" -type l -print0)

      if (( ''${#etcProblems[@]} )); then
        printf >&2 '\x1B[1;31merror: Unexpected files in /etc, aborting '
        printf >&2 'activation\x1B[0m\n'
        printf >&2 'The following files have unrecognized content and would be '
        printf >&2 'overwritten:\n\n'
        printf >&2 '  %s\n' "''${etcProblems[@]}"
        printf >&2 '\nPlease check there is nothing critical in these files, '
        printf >&2 'rename them by adding .before-nix-darwin to the end, and '
        printf >&2 'then try again.\n'
        exit 2
      fi
    '';

    system.activationScripts.etc.text = ''
      # Set up the statically computed bits of /etc.
      printf >&2 'setting up /etc...\n'

      ln -sfn "$(readlink -f "$systemConfig/etc")" /etc/static

      while IFS= read -r -d "" etcStaticFile; do
        etcFile=/etc/''${etcStaticFile#/etc/static/}
        etcDir=''${etcFile%/*}

        if [[ ! -d $etcDir ]]; then
          mkdir -p "$etcDir"
        fi

        if [[ -e $etcFile ]]; then
          if [[ $(readlink -- "$etcFile") == "$etcStaticFile" ]]; then
            continue
          else
            mv "$etcFile" "$etcFile.before-nix-darwin"
          fi
        fi

        ln -s "$etcStaticFile" "$etcFile"
      done < <(find -H /etc/static -type l -print0)

      while IFS= read -r -d "" etcFile; do
        etcStaticFile=/etc/static/''${etcFile#/etc/}

        # Delete stale links into /etc/static.
        if [[
          $(readlink -- "$etcFile") == "$etcStaticFile"
          && ! -e $etcStaticFile
        ]]; then
          rm "$etcFile"
        fi
      done < <(find -H /etc -type l -print0)
    '';

  };
}
</file>

<file path="modules/system/keyboard.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.system.keyboard;
in

{
  options = {
    system.keyboard.enableKeyMapping = mkOption {
      type = types.bool;
      default = false;
      description = "Whether to enable keyboard mappings.";
    };

    system.keyboard.remapCapsLockToControl = mkOption {
      type = types.bool;
      default = false;
      description = "Whether to remap the Caps Lock key to Control.";
    };

    system.keyboard.remapCapsLockToEscape = mkOption {
      type = types.bool;
      default = false;
      description = "Whether to remap the Caps Lock key to Escape.";
    };

    system.keyboard.nonUS.remapTilde = mkOption {
      type = types.bool;
      default = false;
      description = "Whether to remap the Tilde key on non-us keyboards.";
    };

    system.keyboard.swapLeftCommandAndLeftAlt = mkOption {
      type = types.bool;
      default = false;
      description = "Whether to swap the left Command key and left Alt key.";
    };

    system.keyboard.swapLeftCtrlAndFn = mkOption {
      type = types.bool;
      default = false;
      description = "Whether to swap the left Control key and Fn (Globe) key.";
    };

    system.keyboard.userKeyMapping = mkOption {
      internal = true;
      type = types.listOf (types.attrsOf types.int);
      default = [];
      description = ''
        List of keyboard mappings to apply, for more information see
        <https://developer.apple.com/library/content/technotes/tn2450/_index.html>.
      '';
    };
  };

  config = {

    warnings = mkIf (!cfg.enableKeyMapping && cfg.userKeyMapping != [])
      [ "system.keyboard.enableKeyMapping is not enabled, keyboard mappings will not be configured." ];

    system.keyboard.userKeyMapping = [
      (mkIf cfg.remapCapsLockToControl { HIDKeyboardModifierMappingSrc = 30064771129; HIDKeyboardModifierMappingDst = 30064771296; })
      (mkIf cfg.remapCapsLockToEscape { HIDKeyboardModifierMappingSrc = 30064771129; HIDKeyboardModifierMappingDst = 30064771113; })
      (mkIf cfg.nonUS.remapTilde { HIDKeyboardModifierMappingSrc = 30064771172; HIDKeyboardModifierMappingDst = 30064771125; })
      (mkIf cfg.swapLeftCommandAndLeftAlt {
        HIDKeyboardModifierMappingSrc = 30064771299;
        HIDKeyboardModifierMappingDst = 30064771298;
      })
      (mkIf cfg.swapLeftCommandAndLeftAlt {
        HIDKeyboardModifierMappingSrc = 30064771298;
        HIDKeyboardModifierMappingDst = 30064771299;
      })
      (mkIf cfg.swapLeftCtrlAndFn {
        HIDKeyboardModifierMappingSrc = 30064771296;
        HIDKeyboardModifierMappingDst = 1095216660483;
      })
      (mkIf cfg.swapLeftCtrlAndFn {
        HIDKeyboardModifierMappingSrc = 1095216660483;
        HIDKeyboardModifierMappingDst = 30064771296;
      })
    ];

    system.activationScripts.keyboard.text = optionalString cfg.enableKeyMapping ''
      # Configuring keyboard
      echo "configuring keyboard..." >&2
      hidutil property --set '{"UserKeyMapping":${builtins.toJSON cfg.userKeyMapping}}' > /dev/null
    '';

  };
}
</file>

<file path="modules/system/launchd.nix">
{ config, lib, pkgs, ... }:

with lib;

let

  cfg = config.system;

  text = import ../lib/write-text.nix {
    inherit lib;
    mkTextDerivation = pkgs.writeText;
  };

  launchdVariables = prefix: mapAttrsToList (name: value: ''
    ${prefix} launchctl setenv ${name} '${value}'
  '');

  launchdActivation = basedir: target: ''
    if ! diff '${cfg.build.launchd}/Library/${basedir}/${target}' '/Library/${basedir}/${target}' &> /dev/null; then
      if test -f '/Library/${basedir}/${target}'; then
        echo "reloading service $(basename ${target} .plist)" >&2
        launchctl unload '/Library/${basedir}/${target}' || true
      else
        echo "creating service $(basename ${target} .plist)" >&2
      fi
      if test -L '/Library/${basedir}/${target}'; then
        rm '/Library/${basedir}/${target}'
      fi
      cp -f '${cfg.build.launchd}/Library/${basedir}/${target}' '/Library/${basedir}/${target}'
      launchctl load -w '/Library/${basedir}/${target}'
    fi
  '';

  userLaunchdActivation = target: let
    user = lib.escapeShellArg config.system.primaryUser;
  in ''
    if ! diff ${cfg.build.launchd}/user/Library/LaunchAgents/${target} ~${user}/Library/LaunchAgents/${target} &> /dev/null; then
      if test -f ~${user}/Library/LaunchAgents/${target}; then
        echo "reloading user service $(basename ${target} .plist)" >&2
        launchctl asuser "$(id -u -- ${user})" sudo --user=${user} -- launchctl unload ~${user}/Library/LaunchAgents/${target} || true
      else
        echo "creating user service $(basename ${target} .plist)" >&2
      fi
      if test -L ~${user}/Library/LaunchAgents/${target}; then
        sudo --user=${user} -- rm ~${user}/Library/LaunchAgents/${target}
      fi
      sudo --user=${user} -- cp -f '${cfg.build.launchd}/user/Library/LaunchAgents/${target}' ~${user}/Library/LaunchAgents/${target}
      launchctl asuser "$(id -u -- ${user})" sudo --user=${user} -- launchctl load -w ~${user}/Library/LaunchAgents/${target}
    fi
  '';

  launchAgents = filter (f: f.enable) (attrValues config.environment.launchAgents);
  launchDaemons = filter (f: f.enable) (attrValues config.environment.launchDaemons);
  userLaunchAgents = filter (f: f.enable) (attrValues config.environment.userLaunchAgents);

in

{
  options = {

    environment.launchAgents = mkOption {
      type = types.attrsOf (types.submodule text);
      default = { };
      description = ''
        Set of files that have to be linked in {file}`/Library/LaunchAgents`.
      '';
    };

    environment.launchDaemons = mkOption {
      type = types.attrsOf (types.submodule text);
      default = { };
      description = ''
        Set of files that have to be linked in {file}`/Library/LaunchDaemons`.
      '';
    };

    environment.userLaunchAgents = mkOption {
      type = types.attrsOf (types.submodule text);
      default = { };
      description = ''
        Set of files that have to be linked in {file}`~/Library/LaunchAgents`.
      '';
    };

  };

  config = {

    system.build.launchd = pkgs.runCommand "launchd"
      { preferLocalBuild = true; }
      ''
        mkdir -p $out/Library/LaunchAgents $out/Library/LaunchDaemons $out/user/Library/LaunchAgents
        cd $out/Library/LaunchAgents
        ${concatMapStringsSep "\n" (attr: "ln -s '${attr.source}' '${attr.target}'") launchAgents}
        cd $out/Library/LaunchDaemons
        ${concatMapStringsSep "\n" (attr: "ln -s '${attr.source}' '${attr.target}'") launchDaemons}
        cd $out/user/Library/LaunchAgents
        ${concatMapStringsSep "\n" (attr: "ln -s '${attr.source}' '${attr.target}'") userLaunchAgents}
      '';

    system.activationScripts.launchd.text = ''
      # Set up launchd services in /Library/LaunchAgents and /Library/LaunchDaemons
      echo "setting up launchd services..." >&2

      ${concatStringsSep "\n" (launchdVariables "" config.launchd.envVariables)}

      ${concatMapStringsSep "\n" (attr: launchdActivation "LaunchAgents" attr.target) launchAgents}
      ${concatMapStringsSep "\n" (attr: launchdActivation "LaunchDaemons" attr.target) launchDaemons}

      for f in /run/current-system/Library/LaunchAgents/*; do
        [[ -e "$f" ]] || break  # handle when directory is empty
        f=''${f#/run/current-system/Library/LaunchAgents/}

        if [[ ! -e "${cfg.build.launchd}/Library/LaunchAgents/$f" ]]; then
          echo "removing service $(basename "$f" .plist)" >&2
          launchctl unload "/Library/LaunchAgents/$f" || true
          if [[ -e "/Library/LaunchAgents/$f" ]]; then
            rm -f "/Library/LaunchAgents/$f"
          fi
        fi
      done

      for f in /run/current-system/Library/LaunchDaemons/*; do
        [[ -e "$f" ]] || break  # handle when directory is empty
        f=''${f#/run/current-system/Library/LaunchDaemons/}

        if [[ ! -e "${cfg.build.launchd}/Library/LaunchDaemons/$f" ]]; then
          echo "removing service $(basename "$f" .plist)" >&2
          launchctl unload "/Library/LaunchDaemons/$f" || true
          if [[ -e "/Library/LaunchDaemons/$f" ]]; then
            rm -f "/Library/LaunchDaemons/$f"
          fi
        fi
      done
    '';

    system.activationScripts.userLaunchd.text = let
      user = lib.escapeShellArg config.system.primaryUser;
    in mkIf (config.launchd.user.envVariables != { } || userLaunchAgents != [ ]) ''
      # Set up user launchd services in ~/Library/LaunchAgents
      echo "setting up user launchd services..."

      ${concatStringsSep "\n" (launchdVariables "sudo --user=${user} --" config.launchd.user.envVariables)}

      ${optionalString (builtins.length userLaunchAgents > 0) ''
      sudo --user=${user} -- mkdir -p ~${user}/Library/LaunchAgents
      ''}
      ${concatMapStringsSep "\n" (attr: userLaunchdActivation attr.target) userLaunchAgents}

      for f in /run/current-system/user/Library/LaunchAgents/*; do
        [[ -e "$f" ]] || break  # handle when directory is empty
        f=''${f#/run/current-system/user/Library/LaunchAgents/}

        if [[ ! -e "${cfg.build.launchd}/user/Library/LaunchAgents/$f" ]]; then
          echo "removing user service $(basename "$f" .plist)" >&2
          sudo --user=${user} -- launchctl unload ~${user}/Library/LaunchAgents/"$f" || true
          if [[ -e ~${user}/Library/LaunchAgents/"$f" ]]; then
            sudo --user=${user} -- rm -f ~${user}/Library/LaunchAgents/"$f"
          fi
        fi
      done
    '';

  };
}
</file>

<file path="modules/system/nvram.nix">
{ config, lib, pkgs, ... }:

let
  cfg = config.system;

  mkNvramVariables =
    lib.attrsets.mapAttrsToList
      (name: value: "nvram ${lib.escapeShellArg name}=${lib.escapeShellArg value}")
      cfg.nvram.variables;
in

{
  meta.maintainers = [
    lib.maintainers.samasaur or "samasaur"
  ];

  options = {
    system.nvram.variables = lib.mkOption {
      type = with lib.types; attrsOf str;
      default = {};
      internal = true;
      example = {
        "StartupMute" = "%01";
      };
      description = ''
        Non-volatile RAM variables to set. Removing a key-value pair from this
        list will **not** return the variable to its previous value, but will
        no longer set its value on system configuration activations.
      '';
    };
  };

  config = {
    system.activationScripts.nvram.text = ''
      echo "setting nvram variables..." >&2

      ${builtins.concatStringsSep "\n" mkNvramVariables}
    '';
  };
}
</file>

<file path="modules/system/patches.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.system;
in

{
  options = {

    system.patches = mkOption {
      type = types.listOf types.path;
      default = [ ];
      example = literalExpression ''
        [
          (pkgs.writeText "bashrc.patch" ''''
            --- a/etc/bashrc
            +++ b/etc/bashrc
            @@ -8,3 +8,5 @@
             shopt -s checkwinsize

             [ -r "/etc/bashrc_$TERM_PROGRAM" ] && . "/etc/bashrc_$TERM_PROGRAM"
            +
            +if test -e /etc/static/bashrc; then . /etc/static/bashrc; fi
          '''')
        ]
      '';
      description = ''
        Set of patches to apply to {file}`/`.

        ::: {.warning}

        This can modify everything so use with caution.

        :::

        Useful for safely changing system files.  Unlike the etc module this
        won't remove or modify files with unexpected content.
      '';
    };

  };

  config = {

    system.build.patches = pkgs.runCommand "patches"
      { preferLocalBuild = true; }
      ''
        mkdir -p $out/patches
        cd $out/patches
        ${concatMapStringsSep "\n" (f: "ln -s '${f}' $(basename '${f}')") cfg.patches}
      '';

    system.activationScripts.patches.text = ''
      # Applying patches to /.
      echo "applying patches..." >&2

      for f in /run/current-system/patches/*; do
        [[ -e "$f" ]] || break  # handle when directory is empty
        f=''${f#/run/current-system/patches/}

        if [[ ! -e "${config.system.build.patches}/patches/$f" ]]; then
          patch --force --reverse --backup -d / -p1 < "/run/current-system/patches/$f" || true
        fi
      done

      ${concatMapStringsSep "\n" (f: ''
        f="$(basename ${f})"
        if ! patch --force --reverse --dry-run -d / -p1 < '${f}' &> /dev/null; then
            patch --forward --backup -d / -p1 < '${f}' || true
        fi
      '') cfg.patches}
    '';

  };
}
</file>

<file path="modules/system/primary-user.nix">
{
  lib,
  config,
  ...
}:

{
  options = {
    system.primaryUser = lib.mkOption {
      type = lib.types.nullOr lib.types.str;
      default = null;
      description = ''
        The user used for options that previously applied to the user
        running `darwin-rebuild`.

        This is a transition mechanism as nix-darwin reorganizes its
        options and will eventually be unnecessary and removed.
      '';
    };

    system.primaryUserHome = lib.mkOption {
      internal = true;
      type = lib.types.str;
      default =
        config.users.users.${config.system.primaryUser}.home or "/Users/${config.system.primaryUser}";
    };

    system.requiresPrimaryUser = lib.mkOption {
      internal = true;
      type = lib.types.listOf lib.types.str;
      default = [ ];
    };
  };

  config = {
    assertions = [
      {
        assertion = config.system.primaryUser == null -> config.system.requiresPrimaryUser == [ ];
        message = ''
          Previously, some nix-darwin options applied to the user running
          `darwin-rebuild`. As part of a long‚Äêterm migration to make
          nix-darwin focus on system‚Äêwide activation and support first‚Äêclass
          multi‚Äêuser setups, all system activation now runs as `root`, and
          these options instead apply to the `system.primaryUser` user.

          You currently have the following primary‚Äêuser‚Äêrequiring options set:

          ${lib.concatMapStringsSep "\n" (name: "* `${name}`") (
            lib.sort (name1: name2: name1 < name2) config.system.requiresPrimaryUser
          )}

          To continue using these options, set `system.primaryUser` to the name
          of the user you have been using to run `darwin-rebuild`.

          If you run into any unexpected issues with the migration, please
          open an issue at <https://github.com/nix-darwin/nix-darwin/issues/new>
          and include as much information as possible.
        '';
      }
    ];
  };
}
</file>

<file path="modules/system/shells.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.environment;
in

{
  options = {
    environment.shells = mkOption {
      type = types.listOf (types.either types.shellPackage types.path);
      default = [];
      example = literalExpression "[ pkgs.bashInteractive pkgs.zsh ]";
      description = ''
        A list of permissible login shells for user accounts.

        The default macOS shells will be automatically included:
          - /bin/bash
          - /bin/csh
          - /bin/dash
          - /bin/ksh
          - /bin/sh
          - /bin/tcsh
          - /bin/zsh
      '';
      apply = map (v: if types.shellPackage.check v then "/run/current-system/sw${v.shellPath}" else v);
    };
  };

  config = mkIf (cfg.shells != []) {

    environment.etc."shells".text = ''
      # List of acceptable shells for chpass(1).
      # Ftpd will not allow users to connect who are not using
      # one of these shells.

      /bin/bash
      /bin/csh
      /bin/dash
      /bin/ksh
      /bin/sh
      /bin/tcsh
      /bin/zsh

      # List of shells managed by nix.
      ${concatStringsSep "\n" cfg.shells}
    '';

    environment.etc."shells".knownSha256Hashes = [
      "9d5aa72f807091b481820d12e693093293ba33c73854909ad7b0fb192c2db193"  # macOS
    ];

  };
}
</file>

<file path="modules/system/startup.nix">
{ config, lib, pkgs, ... }:

let
  cfg = config.system.startup;
in

{
  meta.maintainers = [
    lib.maintainers.samasaur or "samasaur"
  ];

  options = {
    system.startup.chime = lib.mkOption {
      type = with lib.types; nullOr bool;
      default = null;
      example = false;
      description = ''
        Whether to enable the startup chime.

        By default, this option does not affect your system configuration in any way.
        However, this means that after it has been set once, unsetting it will not
        return to the old behavior. It will allow the setting to be controlled in
        System Settings, though.
      '';
    };
  };

  config = {
    system.nvram.variables."StartupMute" = lib.mkIf (cfg.chime != null) (if cfg.chime then "%00" else "%01");
  };
}
</file>

<file path="modules/system/version.nix">
{ options, config, lib, ... }:

with lib;

let
  cfg = config.system;

  # Based on `lib.trivial.revisionWithDefault` from nixpkgs.
  gitRevision = path:
    if pathIsGitRepo "${path}/.git"
    then commitIdFromGitRepo "${path}/.git"
    else if pathExists "${path}/.git-revision"
    then fileContents "${path}/.git-revision"
    else null;

  nixpkgsSrc = config.nixpkgs.source;

  # If `nixpkgs.constructedByUs` is true, then Nixpkgs was imported from
  # `nixpkgs.source` and we can use revision information (flake input,
  # `builtins.fetchGit`, etc.) from it. Otherwise `pkgs` could be
  # anything and we can't reliably determine exact version information,
  # but if the configuration explicitly sets `nixpkgs.source` we
  # trust it.
  useSourceRevision =
    (config.nixpkgs.constructedByUs
      || options.nixpkgs.source.highestPrio < (lib.mkDefault {}).priority)
    && isAttrs nixpkgsSrc
    && (nixpkgsSrc._type or null == "flake"
      || isString (nixpkgsSrc.rev or null));
in

{
  options = {
    system.stateVersion = mkOption {
      type = types.ints.between 1 config.system.maxStateVersion;
      # TODO: Remove this default and the assertion below.
      default = config.system.maxStateVersion;
      description = ''
        Every once in a while, a new nix-darwin release may change
        configuration defaults in a way incompatible with stateful
        data. For instance, if the default version of PostgreSQL
        changes, the new version will probably be unable to read your
        existing databases. To prevent such breakage, you can set the
        value of this option to the nix-darwin release with which you want
        to be compatible. The effect is that nix-darwin will option
        defaults corresponding to the specified release (such as using
        an older version of PostgreSQL).
      '';
    };

    system.maxStateVersion = mkOption {
      internal = true;
      type = types.int;
      default = 6;
    };

    system.darwinLabel = mkOption {
      type = types.str;
      description = "Label to be used in the names of generated outputs.";
    };

    system.darwinRelease = mkOption {
      readOnly = true;
      type = types.str;
      default = (lib.importJSON ../../version.json).release;
      description = "The nix-darwin release (e.g. `24.11`).";
    };

    system.darwinVersion = mkOption {
      internal = true;
      type = types.str;
      default = cfg.darwinRelease + cfg.darwinVersionSuffix;
      description = "The full nix-darwin version (e.g. `24.11.2abdb5a`).";
    };

    system.darwinVersionSuffix = mkOption {
      internal = true;
      type = types.str;
      default = if cfg.darwinRevision != null
        then ".${substring 0 7 cfg.darwinRevision}"
        else "";
      description = "The short nix-darwin version suffix (e.g. `.2abdb5a`).";
    };

    system.darwinRevision = mkOption {
      internal = true;
      type = types.nullOr types.str;
      default = gitRevision (toString ../..);
      description = "The darwin git revision from which this configuration was built.";
    };

    system.nixpkgsRelease = mkOption {
      readOnly = true;
      type = types.str;
      default = lib.trivial.release;
      description = "The nixpkgs release (e.g. `24.11`).";
    };

    # TODO: Shouldn‚Äôt mismatch the Darwin release, rethink all this‚Ä¶
    system.nixpkgsVersion = mkOption {
      internal = true;
      type = types.str;
      default = cfg.nixpkgsRelease + cfg.nixpkgsVersionSuffix;
      description = "The full nixpkgs version (e.g. `24.11.1160.f2d4ee1`).";
    };

    system.nixpkgsVersionSuffix = mkOption {
      internal = true;
      type = types.str;
      default = if useSourceRevision
        then ".${lib.substring 0 8 (nixpkgsSrc.lastModifiedDate or nixpkgsSrc.lastModified or "19700101")}.${nixpkgsSrc.shortRev or "dirty"}"
        else lib.trivial.versionSuffix;
      description = "The short nixpkgs version suffix (e.g. `.1160.f2d4ee1`).";
    };

    system.nixpkgsRevision = mkOption {
      internal = true;
      type = types.nullOr types.str;
      default = if useSourceRevision && nixpkgsSrc ? rev
        then nixpkgsSrc.rev
        else lib.trivial.revisionWithDefault null;
      description = "The nixpkgs git revision from which this configuration was built.";
    };

    system.configurationRevision = mkOption {
      type = types.nullOr types.str;
      default = null;
      description = "The Git revision of the top-level flake from which this configuration was built.";
    };
  };

  config = {
    # This default is set here rather than up there so that the options
    # documentation is not reprocessed on every commit
    system.darwinLabel = mkDefault cfg.darwinVersion;

    assertions = [
      {
        assertion = options.system.stateVersion.highestPrio != (lib.mkOptionDefault { }).priority;
        message = ''
          The `system.stateVersion` option is not defined in your
          nix-darwin configuration. The value is used to conditionalize
          backwards‚Äêincompatible changes in default settings. You should
          usually set this once when installing nix-darwin on a new system
          and then never change it (at least without reading all the relevant
          entries in the changelog using `darwin-rebuild changelog`).

          You can use the current value for new installations as follows:

              system.stateVersion = ${toString config.system.maxStateVersion};
        '';
      }
    ];
  };
}
</file>

<file path="modules/time/default.nix">
{ config, lib, pkgs, ... }:

with lib;

let

  cfg = config.time;

  timeZone = optionalString (cfg.timeZone != null) ''
    if ! systemsetup -listtimezones | grep -q "^ ${cfg.timeZone}$"; then
      echo "${cfg.timeZone} is not a valid timezone. The command 'listtimezones' will show a list of valid time zones." >&2
      false
    fi
    systemsetup -settimezone "${cfg.timeZone}" 2>/dev/null 1>&2
  '';

in

{
  options = {

    time.timeZone = mkOption {
      type = types.nullOr types.str;
      default = null;
      example = "America/New_York";
      description = ''
        The time zone used when displaying times and dates. See <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones>
        or run {command}`sudo systemsetup -listtimezones`
        for a comprehensive list of possible values for this setting.
      '';
    };

  };

  config = {

    system.activationScripts.time.text = mkIf (cfg.timeZone != null) ''
      # Set defaults
      echo "configuring time..." >&2

      ${timeZone}
    '';

  };
}
</file>

<file path="modules/users/group.nix">
{ name, lib, ... }:

{
  options = let
    inherit (lib) mkOption types;
  in {
    name = mkOption {
      type = types.str;
      default = name;
      description = ''
        The group's name. If undefined, the name of the attribute set
        will be used.
      '';
    };

    gid = mkOption {
      type = types.int;
      description = "The group's GID.";
    };

    members = mkOption {
      type = types.listOf types.str;
      default = [];
      description = "The group's members.";
    };

    description = mkOption {
      type = types.str;
      default = "";
      description = "The group's description.";
    };
  };
}
</file>

<file path="modules/users/user.nix">
{ name, lib, ... }:

{
  options = let
    inherit (lib) literalExpression mkOption types;
  in {
    name = mkOption {
      type = types.nonEmptyStr;
      default = name;
      description = ''
        The name of the user account. If undefined, the name of the
        attribute set will be used.
      '';
    };

    description = mkOption {
      type = types.nullOr types.nonEmptyStr;
      default = null;
      example = "Alice Q. User";
      description = ''
        A short description of the user account, typically the
        user's full name.

        This defaults to `null` which means, on creation, `sysadminctl`
        will pick the description which is usually always {option}`name`.

        Using an empty name is not supported and breaks macOS like
        making the user not appear in Directory Utility.
      '';
    };

    uid = mkOption {
      type = types.int;
      description = "The user's UID.";
    };

    gid = mkOption {
      type = types.int;
      default = 20;
      description = "The user's primary group.";
    };

    isHidden = mkOption {
      type = types.bool;
      default = true;
      description = "Whether to make the user account hidden.";
    };

    # extraGroups = mkOption {
    #   type = types.listOf types.str;
    #   default = [];
    #   description = "The user's auxiliary groups.";
    # };

    home = mkOption {
      type = types.nullOr types.path;
      default = null;
      description = ''
        The user's home directory. This defaults to `null`.

        When this is set to `null`, if the user has not been created yet,
        they will be created with the home directory `/var/empty` to match
        the old default.
      '';
    };

    createHome = mkOption {
      type = types.bool;
      default = false;
      description = "Create the home directory when creating the user.";
    };

    shell = mkOption {
      type = types.nullOr (types.either types.shellPackage types.path);
      default = null;
      example = literalExpression "pkgs.bashInteractive";
      description = ''
        The user's shell. This defaults to `null`.

        When this is set to `null`, if the user has not been created yet,
        they will be created with the shell `/usr/bin/false` to prevent
        interactive login. If the user already exists, the value is
        considered managed by macOS and `nix-darwin` will not change it.
      '';
    };

    ignoreShellProgramCheck = mkOption {
      type = types.bool;
      default = false;
      description = ''
        By default, nix-darwin will check that programs.SHELL.enable is set to
        true if the user has a custom shell specified. If that behavior isn't
        required and there are custom overrides in place to make sure that the
        shell is functional, set this to true.
      '';
    };

    packages = mkOption {
      type = types.listOf types.package;
      default = [];
      example = literalExpression "[ pkgs.firefox pkgs.thunderbird ]";
      description = ''
        The set of packages that should be made availabe to the user.
        This is in contrast to {option}`environment.systemPackages`,
        which adds packages to all users.
      '';
    };
  };
}
</file>

<file path="modules/alias.nix">
{ config, lib, pkgs, ... }:

with lib;

let

in

{
  options = {

    networking.networkservices = mkOption { internal = true; default = null; };
    security.enableAccessibilityAccess = mkOption { internal = true; default = null; };
    security.accessibilityPrograms = mkOption { internal = true; default = null; };

  };

  config = {

    assertions =
      [ { assertion = config.security.enableAccessibilityAccess == null; message = "security.enableAccessibilityAccess was removed, it's broken since 10.12 because of SIP"; }
        { assertion = config.system.activationScripts.extraPostActivation.text == ""; message = "system.activationScripts.extraPostActivation was renamed to system.activationScripts.postActivation"; }
        { assertion = config.system.activationScripts.extraUserPostActivation.text == ""; message = "system.activationScripts.extraUserPostActivation was renamed to system.activationScripts.postUserActivation"; }
      ];

    warnings = mkIf (config.networking.networkservices != null) [
      "networking.networkservices was renamed to networking.knownNetworkServices"
    ];

    networking.knownNetworkServices = mkIf (config.networking.networkservices != null) config.networking.networkservices;

    system.activationScripts.extraPostActivation.text = mkDefault "";
    system.activationScripts.extraUserPostActivation.text = mkDefault "";

  };
}
</file>

<file path="modules/homebrew.nix">
# Created by: https://github.com/malob
{ config, lib, options, pkgs, ... }:

with lib;

let
  cfg = config.homebrew;

  brewfileFile = pkgs.writeText "Brewfile" cfg.brewfile;

  # Brewfile creation helper functions -------------------------------------------------------------

  mkBrewfileSectionString = heading: entries: optionalString (entries != [ ]) ''
    # ${heading}
    ${concatMapStringsSep "\n" (v: v.brewfileLine or v) entries}

  '';

  mkBrewfileLineValueString = v:
    if isInt v then toString v
    else if isFloat v then strings.floatToString v
    else if isBool v then boolToString v
    else if isString v then ''"${v}"''
    else if isAttrs v then "{ ${concatStringsSep ", " (mapAttrsToList (n: v': "${n}: ${mkBrewfileLineValueString v'}") v)} }"
    else if isList v then "[${concatMapStringsSep ", " mkBrewfileLineValueString v}]"
    else abort "The value: ${generators.toPretty v} is not a valid Brewfile value.";

  mkBrewfileLineOptionsListString = attrs:
    concatStringsSep ", " (mapAttrsToList (n: v: "${n}: ${v}") attrs);


  # Option and submodule helper functions ----------------------------------------------------------

  mkNullOrBoolOption = args: mkOption (args // {
    type = types.nullOr types.bool;
    default = null;
  });

  mkNullOrStrOption = args: mkOption (args // {
    type = types.nullOr types.str;
    default = null;
  });

  mkInternalOption = args: mkOption (args // {
    visible = false;
    internal = true;
    readOnly = true;
  });

  mkProcessedSubmodConfig = attrs: mapAttrs (_: mkBrewfileLineValueString)
    (filterAttrsRecursive (n: v: n != "_module" && n != "brewfileLine" && v != null) attrs);


  # Submodules -------------------------------------------------------------------------------------
  # Option values and descriptions of Brewfile entries are sourced/derived from:
  #   * `brew` manpage: https://docs.brew.sh/Manpage
  #   * `brew bundle` source files (at https://github.com/Homebrew/brew/tree/master/Library/Homebrew/bundle):
  #     * dsl.rb
  #     * {brew,cask,tap}_installer.rb
  #     * ../test/bundle/{brew,cask,tap}_installer_spec.rb

  onActivationOptions = { config, ... }: {
    options = {
      cleanup = mkOption {
        type = types.enum [ "none" "uninstall" "zap" ];
        default = "none";
        example = "uninstall";
        description = ''
          This option manages what happens to formulae installed by Homebrew, that aren't present in
          the Brewfile generated by this module, during {command}`nix-darwin` system
          activation.

          When set to `"none"` (the default), formulae not present in the generated
          Brewfile are left installed.

          When set to `"uninstall"`, {command}`nix-darwin` invokes
          {command}`brew bundle [install]` with the {command}`--cleanup` flag. This
          uninstalls all formulae not listed in generated Brewfile, i.e.,
          {command}`brew uninstall` is run for those formulae.

          When set to `"zap"`, {command}`nix-darwin` invokes
          {command}`brew bundle [install]` with the {command}`--cleanup --zap`
          flags. This uninstalls all formulae not listed in the generated Brewfile, and if the
          formula is a cask, removes all files associated with that cask. In other words,
          {command}`brew uninstall --zap` is run for all those formulae.

          If you plan on exclusively using {command}`nix-darwin` to manage formulae
          installed by Homebrew, you probably want to set this option to
          `"uninstall"` or `"zap"`.
        '';
      };
      autoUpdate = mkOption {
        type = types.bool;
        default = false;
        description = ''
          Whether to enable Homebrew to auto-update itself and all formulae during
          {command}`nix-darwin` system activation. The default is `false`
          so that repeated invocations of {command}`darwin-rebuild switch` are idempotent.

          Note that Homebrew auto-updates when it's been more then 5 minutes since it last updated.

          Although auto-updating is disabled by default during system activation, note that Homebrew
          will auto-update when you manually invoke certain Homebrew commands. To modify this
          behavior see [](#opt-homebrew.global.autoUpdate).

          Implementation note: when disabled, this option sets the `HOMEBREW_NO_AUTO_UPDATE`
          environment variable when {command}`nix-darwin` invokes {command}`brew bundle [install]`
          during system activation.
        '';
      };
      upgrade = mkOption {
        type = types.bool;
        default = false;
        description = ''
          Whether to enable Homebrew to upgrade outdated formulae and Mac App Store apps during
          {command}`nix-darwin` system activation. The default is `false`
          so that repeated invocations of {command}`darwin-rebuild switch` are idempotent.

          Implementation note: when disabled, {command}`nix-darwin` invokes
          {command}`brew bundle [install]` with the {command}`--no-upgrade` flag during system
          activation.
        '';
      };
      extraFlags = mkOption {
        type = types.listOf types.str;
        default = [ ];
        example = [ "--verbose" ];
        description = ''
          Extra flags to pass to {command}`brew bundle [install]` during {command}`nix-darwin`
          system activation.
        '';
      };

      brewBundleCmd = mkInternalOption { type = types.str; };
    };

    config = {
      brewBundleCmd = concatStringsSep " " (
        optional (!config.autoUpdate) "HOMEBREW_NO_AUTO_UPDATE=1"
        ++ [ "brew bundle --file='${brewfileFile}'" ]
        ++ optional (!config.upgrade) "--no-upgrade"
        ++ optional (config.cleanup == "uninstall") "--cleanup"
        ++ optional (config.cleanup == "zap") "--cleanup --zap"
        ++ config.extraFlags
      );
    };
  };

  globalOptions = { config, ... }: {
    options = {
      brewfile = mkOption {
        type = types.bool;
        default = false;
        description = ''
          Whether to enable Homebrew to automatically use the Brewfile that this module generates in
          the Nix store, when you manually invoke {command}`brew bundle`.

          Enabling this option will change the default value of
          [](#opt-homebrew.global.lockfiles) to `false` since, with
          this option enabled, {command}`brew bundle [install]` will default to using the
          Brewfile that this module generates in the Nix store, unless you explicitly point it at
          another Brewfile using the `--file` flag. As a result, it will try to
          write the lockfile in the Nix store, and complain that it can't (though the command will
          run successfully regardless).

          Implementation note: when enabled, this option sets the
          `HOMEBREW_BUNDLE_FILE` environment variable to the path of the Brewfile
          that this module generates in the Nix store, by adding it to
          [](#opt-environment.variables).
        '';
      };
      autoUpdate = mkOption {
        type = types.bool;
        default = true;
        description = ''
          Whether to enable Homebrew to auto-update itself and all formulae when you manually invoke
          commands like {command}`brew install`, {command}`brew upgrade`,
          {command}`brew tap`, and {command}`brew bundle [install]`.

          Note that Homebrew auto-updates when you manually invoke commands like the ones mentioned
          above if it's been more then 5 minutes since it last updated.

          You may want to consider disabling this option if you have
          [](#opt-homebrew.onActivation.upgrade) enabled, and
          [](#opt-homebrew.onActivation.autoUpdate) disabled, if you want to ensure that
          your installed formulae will only be upgraded during {command}`nix-darwin` system
          activation, after you've explicitly run {command}`brew update`.

          Implementation note: when disabled, this option sets the
          `HOMEBREW_NO_AUTO_UPDATE` environment variable, by adding it to
          [](#opt-environment.variables).
        '';
      };
      lockfiles = mkOption {
        type = types.bool;
        default = !config.brewfile;
        defaultText = literalExpression "!config.homebrew.global.brewfile";
        description = ''
          Whether to enable Homebrew to generate lockfiles when you manually invoke
          {command}`brew bundle [install]`.

          This option will default to `false` if
          [](#opt-homebrew.global.brewfile) is enabled since, with that option enabled,
          {command}`brew bundle [install]` will default to using the Brewfile that this
          module generates in the Nix store, unless you explicitly point it at another Brewfile
          using the `--file` flag. As a result, it will try to write the
          lockfile in the Nix store, and complain that it can't (though the command will run
          successfully regardless).

          Implementation note: when disabled, this option sets the
          `HOMEBREW_BUNDLE_NO_LOCK` environment variable, by adding it to
          [](#opt-environment.variables).
        '';
      };

      # The `noLock` option was replaced by `lockfiles`. Due to `homebrew.global` being a submodule,
      # we can't use `mkRemovedOptionModule`, so we leave this option definition here, and trigger
      # and error message with an assertion below if it's set by the user.
      noLock = mkOption { visible = false; default = null; };

      homebrewEnvironmentVariables = mkInternalOption { type = types.attrs; };
    };

    config = {
      homebrewEnvironmentVariables = {
        HOMEBREW_BUNDLE_FILE = mkIf config.brewfile "${brewfileFile}";
        HOMEBREW_NO_AUTO_UPDATE = mkIf (!config.autoUpdate) "1";
        HOMEBREW_BUNDLE_NO_LOCK = mkIf (!config.lockfiles) "1";
      };
    };
  };

  tapOptions = { config, ... }: {
    options = {
      name = mkOption {
        type = types.str;
        example = "apple/apple";
        description = ''
          When {option}`clone_target` is unspecified, this is the name of a formula
          repository to tap from GitHub using HTTPS. For example, `"user/repo"`
          will tap https://github.com/user/homebrew-repo.
        '';
      };
      clone_target = mkNullOrStrOption {
        description = ''
          Use this option to tap a formula repository from anywhere, using any transport protocol
          that {command}`git` handles. When {option}`clone_target` is specified, taps
          can be cloned from places other than GitHub and using protocols other than HTTPS, e.g.,
          SSH, git, HTTP, FTP(S), rsync.
        '';
      };
      force_auto_update = mkNullOrBoolOption {
        description = ''
          Whether to auto-update the tap even if it is not hosted on GitHub. By default, only taps
          hosted on GitHub are auto-updated (for performance reasons).
        '';
      };

      brewfileLine = mkInternalOption { type = types.nullOr types.str; };
    };

    config =
      let
        sCfg = mkProcessedSubmodConfig config;
      in
      {
        brewfileLine =
          "tap ${sCfg.name}"
          + optionalString (sCfg ? clone_target) ", ${sCfg.clone_target}"
          + optionalString (sCfg ? force_auto_update)
            ", force_auto_update: ${sCfg.force_auto_update}";
      };
  };

  # Sourced from https://docs.brew.sh/Manpage#global-cask-options
  # and valid values for `HOMEBREW_CASK_OPTS`.
  caskArgsOptions = { config, ... }: {
    options = {
      appdir = mkNullOrStrOption {
        description = ''
          Target location for Applications.

          Homebrew's default is {file}`/Applications`.
        '';
      };
      colorpickerdir = mkNullOrStrOption {
        description = ''
          Target location for Color Pickers.

          Homebrew's default is {file}`~/Library/ColorPickers`.
        '';
      };
      prefpanedir = mkNullOrStrOption {
        description = ''
          Target location for Preference Panes.

          Homebrew's default is {file}`~/Library/PreferencePanes`.
        '';
      };
      qlplugindir = mkNullOrStrOption {
        description = ''
          Target location for QuickLook Plugins.

          Homebrew's default is {file}`~/Library/QuickLook`.
        '';
      };
      mdimporterdir = mkNullOrStrOption {
        description = ''
          Target location for Spotlight Plugins.

          Homebrew's default is {file}`~/Library/Spotlight`.
        '';
      };
      dictionarydir = mkNullOrStrOption {
        description = ''
          Target location for Dictionaries.

          Homebrew's default is {file}`~/Library/Dictionaries`.
        '';
      };
      fontdir = mkNullOrStrOption {
        description = ''
          Target location for Fonts.

          Homebrew's default is {file}`~/Library/Fonts`.
        '';
      };
      servicedir = mkNullOrStrOption {
        description = ''
          Target location for Services.

          Homebrew's default is {file}`~/Library/Services`.
        '';
      };
      input_methoddir = mkNullOrStrOption {
        description = ''
          Target location for Input Methods.

          Homebrew's default is {file}`~/Library/Input Methods`.
        '';
      };
      internet_plugindir = mkNullOrStrOption {
        description = ''
          Target location for Internet Plugins.

          Homebrew's default is {file}`~/Library/Internet Plug-Ins`.
        '';
      };
      audio_unit_plugindir = mkNullOrStrOption {
        description = ''
          Target location for Audio Unit Plugins.

          Homebrew's default is
          {file}`~/Library/Audio/Plug-Ins/Components`.
        '';
      };
      vst_plugindir = mkNullOrStrOption {
        description = ''
          Target location for VST Plugins.

          Homebrew's default is {file}`~/Library/Audio/Plug-Ins/VST`.
        '';
      };
      vst3_plugindir = mkNullOrStrOption {
        description = ''
          Target location for VST3 Plugins.

          Homebrew's default is {file}`~/Library/Audio/Plug-Ins/VST3`.
        '';
      };
      screen_saverdir = mkNullOrStrOption {
        description = ''
          Target location for Screen Savers.

          Homebrew's default is {file}`~/Library/Screen Savers`.
        '';
      };
      language = mkNullOrStrOption {
        description = ''
          Comma-separated list of language codes to prefer for cask installation. The first matching
          language is used, otherwise it reverts to the cask‚Äôs default language. The default value
          is the language of your system.
        '';
        example = "zh-TW";
      };
      require_sha = mkNullOrBoolOption {
        description = ''
          Whether to require cask(s) to have a checksum.

          Homebrew's default is `false`.
        '';
      };
      no_quarantine = mkNullOrBoolOption {
        description = "Whether to disable quarantining of downloads.";
      };
      no_binaries = mkNullOrBoolOption {
        description = "Whether to disable linking of helper executables.";
      };
      ignore_dependencies = mkNullOrBoolOption {
        description = "Ignore casks dependencies in case you manage them extrenally";
      };

      brewfileLine = mkInternalOption { type = types.nullOr types.str; };
    };

    config =
      let
        sCfg = mkProcessedSubmodConfig config;
      in
      {
        brewfileLine =
          if sCfg == { } then null
          else "cask_args ${mkBrewfileLineOptionsListString sCfg}";
      };
  };

  brewOptions = { config, ... }: {
    options = {
      name = mkOption {
        type = types.str;
        description = "The name of the formula to install.";
      };
      args = mkOption {
        type = with types; nullOr (listOf str);
        default = null;
        description = ''
          Arguments flags to pass to {command}`brew install`. Values should not include the
          leading `"--"`.
        '';
      };
      conflicts_with = mkOption {
        type = with types; nullOr (listOf str);
        default = null;
        description = ''
          List of formulae that should be unlinked and their services stopped (if they are
          installed).
        '';
      };
      restart_service = mkOption {
        type = with types; nullOr (either bool (enum [ "changed" ]));
        default = null;
        description = ''
          Whether to run {command}`brew services restart` for the formula and register it to
          launch at login (or boot). If set to `"changed"`, the service will only
          be restarted on version changes.

          Homebrew's default is `false`.
        '';
      };
      start_service = mkNullOrBoolOption {
        description = ''
          Whether to run {command}`brew services start` for the formula and register it to
          launch at login (or boot).

          Homebrew's default is `false`.
        '';
      };
      link = mkNullOrBoolOption {
        description = ''
          Whether to link the formula to the Homebrew prefix. When this option is
          `null`, Homebrew will use it's default behavior which is to link the
          formula if it's currently unlinked and not keg-only, and to unlink the formula if it's
          currently linked and keg-only.
        '';
      };

      brewfileLine = mkInternalOption { type = types.nullOr types.str; };
    };

    config =
      let
        sCfg = mkProcessedSubmodConfig config;
        sCfgSubset = removeAttrs sCfg [ "name" "restart_service" ];
      in
      {
        brewfileLine =
          "brew ${sCfg.name}"
          + optionalString (sCfgSubset != { }) ", ${mkBrewfileLineOptionsListString sCfgSubset}"
          # We need to handle the `restart_service` option seperately since it can be either a bool
          # or `:changed` in the Brewfile.
          + optionalString (sCfg ? restart_service) (
            ", restart_service: " + (
              if isBool config.restart_service then sCfg.restart_service
              else ":${config.restart_service}"
            )
          );
      };
  };

  caskOptions = { config, ... }: {
    options = {
      name = mkOption {
        type = types.str;
        description = "The name of the cask to install.";
      };
      args = mkOption {
        type = types.nullOr (types.submodule caskArgsOptions);
        default = null;
        visible = "shallow"; # so that options from `homebrew.caskArgs` aren't repeated.
        description = ''
          Arguments passed to {command}`brew install --cask` when installing this cask. See
          [](#opt-homebrew.caskArgs) for the available options.
        '';
      };
      greedy = mkOption {
        type = types.nullOr types.bool;
        default = cfg.greedyCasks;
        description = ''
          Whether to always upgrade this cask regardless of whether it's unversioned or it updates
          itself.
        '';
      };

      brewfileLine = mkInternalOption { type = types.nullOr types.str; };
    };

    config =
      let
        sCfg = mkProcessedSubmodConfig config;
        sCfgSubset = removeAttrs sCfg [ "name" ];
      in
      {
        brewfileLine =
          "cask ${sCfg.name}"
          + optionalString (sCfgSubset != { }) ", ${mkBrewfileLineOptionsListString sCfgSubset}";
      };
  };
in

{
  # Interface --------------------------------------------------------------------------------------

  imports = [
    (mkRenamedOptionModule [ "homebrew" "autoUpdate" ] [ "homebrew" "onActivation" "autoUpdate" ])
    (mkRenamedOptionModule [ "homebrew" "cleanup" ] [ "homebrew" "onActivation" "cleanup" ])
  ];

  options.homebrew = {
    enable = mkEnableOption ''
      {command}`nix-darwin` to manage installing/updating/upgrading Homebrew taps, formulae,
      and casks, as well as Mac App Store apps and Docker containers, using Homebrew Bundle.

      Note that enabling this option does not install Homebrew, see the Homebrew
      [website](https://brew.sh) for installation instructions.

      Use the [](#opt-homebrew.brews), [](#opt-homebrew.casks),
      [](#opt-homebrew.masApps), and [](#opt-homebrew.whalebrews) options
      to list the Homebrew formulae, casks, Mac App Store apps, and Docker containers you'd like to
      install. Use the [](#opt-homebrew.taps) option, to make additional formula
      repositories available to Homebrew. This module uses those options (along with the
      [](#opt-homebrew.caskArgs) options) to generate a Brewfile that
      {command}`nix-darwin` passes to the {command}`brew bundle` command during
      system activation.

      The default configuration of this module prevents Homebrew Bundle from auto-updating Homebrew
      and all formulae, as well as upgrading anything that's already installed, so that repeated
      invocations of {command}`darwin-rebuild switch` (without any change to the
      configuration) are idempotent. You can modify this behavior using the options under
      [](#opt-homebrew.onActivation).

      This module also provides a few options for modifying how Homebrew commands behave when
      you manually invoke them, under [](#opt-homebrew.global)'';

    user = mkOption {
      type = types.str;
      default = config.system.primaryUser;
      defaultText = literalExpression "config.system.primaryUser";
      description = ''
        The user that owns the Homebrew installation. In most cases
        this should be the normal user account that you installed
        Homebrew as.
      '';
    };

    brewPrefix = mkOption {
      type = types.str;
      default = if pkgs.stdenv.hostPlatform.isAarch64 then "/opt/homebrew/bin" else "/usr/local/bin";
      defaultText = literalExpression ''
        if pkgs.stdenv.hostPlatform.isAarch64 then "/opt/homebrew/bin"
        else "/usr/local/bin"
      '';
      description = ''
        The path prefix where the {command}`brew` executable is located. This will be set to
        the correct value based on your system's platform, and should only need to be changed if you
        manually installed Homebrew in a non-standard location.
      '';
    };

    onActivation = mkOption {
      type = types.submodule onActivationOptions;
      default = { };
      description = ''
        Options for configuring the behavior of the {command}`brew bundle` command that
        {command}`nix-darwin` runs during system activation.
      '';
    };

    global = mkOption {
      type = types.submodule globalOptions;
      default = { };
      description = ''
        Options for configuring the behavior of Homebrew commands when you manually invoke them.
      '';
    };

    taps = mkOption {
      type = with types; listOf (coercedTo str (name: { inherit name; }) (submodule tapOptions));
      default = [ ];
      example = literalExpression ''
        # Adapted from https://docs.brew.sh/Brew-Bundle-and-Brewfile
        [
          # `brew tap`
          "apple/apple"

          # `brew tap` with custom Git URL and arguments
          {
            name = "user/tap-repo";
            clone_target = "https://user@bitbucket.org/user/homebrew-tap-repo.git";
            force_auto_update = true;
          }
        ]
      '';
      description = ''
        List of Homebrew formula repositories to tap.

        Taps defined as strings, e.g., `"user/repo"`, are a shorthand for:

        `{ name = "user/repo"; }`
      '';
    };

    caskArgs = mkOption {
      type = types.submodule caskArgsOptions;
      default = { };
      example = literalExpression ''
        {
          appdir = "~/Applications";
          require_sha = true;
        }
      '';
      description = ''
        Arguments passed to {command}`brew install --cask` for all casks listed in
        [](#opt-homebrew.casks).
      '';
    };

    greedyCasks = mkNullOrBoolOption {
      description = ''
        Whether to always upgrade casks listed in [](#opt-homebrew.casks) regardless
        of whether it's unversioned or it updates itself.
      '';
    };

    brews = mkOption {
      type = with types; listOf (coercedTo str (name: { inherit name; }) (submodule brewOptions));
      default = [ ];
      example = literalExpression ''
        # Adapted from https://docs.brew.sh/Brew-Bundle-and-Brewfile
        [
          # `brew install`
          "imagemagick"

          # `brew install --with-rmtp`, `brew services restart` on version changes
          {
            name = "denji/nginx/nginx-full";
            args = [ "with-rmtp" ];
            restart_service = "changed";
          }

          # `brew install`, always `brew services restart`, `brew link`, `brew unlink mysql` (if it is installed)
          {
            name = "mysql@5.6";
            restart_service = true;
            link = true;
            conflicts_with = [ "mysql" ];
          }
        ]
      '';
      description = ''
        List of Homebrew formulae to install.

        Formulae defined as strings, e.g., `"imagemagick"`, are a shorthand for:

        `{ name = "imagemagick"; }`
      '';
    };

    casks = mkOption {
      type = with types; listOf (coercedTo str (name: { inherit name; }) (submodule caskOptions));
      default = [ ];
      example = literalExpression ''
        # Adapted from https://docs.brew.sh/Brew-Bundle-and-Brewfile
        [
          # `brew install --cask`
          "google-chrome"

          # `brew install --cask --appdir=~/my-apps/Applications`
          {
            name = "firefox";
            args = { appdir = "~/my-apps/Applications"; };
          }

          # always upgrade auto-updated or unversioned cask to latest version even if already installed
          {
            name = "opera";
            greedy = true;
          }
        ]
      '';
      description = ''
        List of Homebrew casks to install.

        Casks defined as strings, e.g., `"google-chrome"`, are a shorthand for:

        `{ name = "google-chrome"; }`
      '';
    };

    masApps = mkOption {
      type = types.attrsOf types.ints.positive;
      default = { };
      example = literalExpression ''
        {
          "1Password for Safari" = 1569813296;
          Xcode = 497799835;
        }
      '';
      description = ''
        Applications to install from Mac App Store using {command}`mas`.

        Note that you need to be signed into the Mac App Store for {command}`mas` to
        successfully install and upgrade applications, and that unfortunately apps removed from this
        option will not be uninstalled automatically even if
        [](#opt-homebrew.onActivation.cleanup) is set to `"uninstall"`
        or `"zap"` (this is currently a limitation of Homebrew Bundle).

        For more information on {command}`mas` see:
        [github.com/mas-cli/mas](https://github.com/mas-cli/mas).
      '';
    };

    whalebrews = mkOption {
      type = with types; listOf str;
      default = [ ];
      example = [ "whalebrew/wget" ];
      description = ''
        List of Docker images to install using {command}`whalebrew`.

        When this option is used, `"whalebrew"` is automatically added to
        [](#opt-homebrew.brews).

        For more information on {command}`whalebrew` see:
        [github.com/whalebrew/whalebrew](https://github.com/whalebrew/whalebrew).
      '';
    };

    extraConfig = mkOption {
      type = types.lines;
      default = "";
      example = ''
        # 'brew cask install' only if '/usr/libexec/java_home --failfast' fails
        cask "java" unless system "/usr/libexec/java_home --failfast"
      '';
      description = "Extra lines to be added verbatim to the bottom of the generated Brewfile.";
    };

    brewfile = mkInternalOption {
      type = types.str;
      description = "String reprensentation of the generated Brewfile useful for debugging.";
    };
  };


  # Implementation ---------------------------------------------------------------------------------

  config = {

    assertions = [
      # See comment above `homebrew.global.noLock` option declaration for why this is required.
      { assertion = cfg.global.noLock == null; message = "The option `homebrew.global.noLock' was removed, use `homebrew.global.lockfiles' in it's place."; }
    ];

    warnings = [
      (mkIf (options.homebrew.autoUpdate.isDefined || options.homebrew.cleanup.isDefined) "The `homebrew' module no longer upgrades outdated formulae and apps by default during `nix-darwin' system activation. To enable upgrading, set `homebrew.onActivation.upgrade = true'.")
    ];

    system.requiresPrimaryUser = mkIf (cfg.enable && options.homebrew.user.highestPrio == (mkOptionDefault {}).priority) [
      "homebrew.enable"
    ];

    homebrew.brews =
      optional (cfg.whalebrews != [ ]) "whalebrew";

    homebrew.brewfile =
      "# Created by `nix-darwin`'s `homebrew` module\n\n"
      + mkBrewfileSectionString "Taps" cfg.taps
      + mkBrewfileSectionString "Arguments for all casks"
        (optional (cfg.caskArgs.brewfileLine != null) cfg.caskArgs)
      + mkBrewfileSectionString "Brews" cfg.brews
      + mkBrewfileSectionString "Casks" cfg.casks
      + mkBrewfileSectionString "Mac App Store apps"
        (mapAttrsToList (n: id: ''mas "${n}", id: ${toString id}'') cfg.masApps)
      + mkBrewfileSectionString "Docker containers" (map (v: ''whalebrew "${v}"'') cfg.whalebrews)
      + optionalString (cfg.extraConfig != "") ("# Extra config\n" + cfg.extraConfig);

    environment.variables = mkIf cfg.enable cfg.global.homebrewEnvironmentVariables;

    system.activationScripts.homebrew.text = mkIf cfg.enable ''
      # Homebrew Bundle
      echo >&2 "Homebrew bundle..."
      if [ -f "${cfg.brewPrefix}/brew" ]; then
        PATH="${cfg.brewPrefix}:${lib.makeBinPath [ pkgs.mas ]}:$PATH" \
        sudo \
          --preserve-env=PATH \
          --user=${escapeShellArg cfg.user} \
          --set-home \
          env \
          ${cfg.onActivation.brewBundleCmd}
      else
        echo -e "\e[1;31merror: Homebrew is not installed, skipping...\e[0m" >&2
      fi
    '';
  };
}
</file>

<file path="modules/meta.nix">
# This module was derived from
# https://github.com/NixOS/nixpkgs/blob/000387627d26f245a6d9a0a7a60b7feddecaeec0/nixos/modules/misc/meta.nix
{ lib, ... }:

with lib;

let
  maintainer = mkOptionType {
    name = "maintainer";
    check = email: elem email (attrValues lib.maintainers);
    merge = loc: defs: listToAttrs (singleton (nameValuePair (last defs).file (last defs).value));
  };

  listOfMaintainers = types.listOf maintainer // {
    # Returns list of
    #   { "module-file" = [
    #        "maintainer1 <first@nixos.org>"
    #        "maintainer2 <second@nixos.org>" ];
    #   }
    merge = loc: defs:
      zipAttrs
        (flatten (imap1 (n: def: imap1 (m: def':
          maintainer.merge (loc ++ ["[${toString n}-${toString m}]"])
            [{ inherit (def) file; value = def'; }]) def.value) defs));
  };

in

{
  options = {
    meta = {

      maintainers = mkOption {
        type = listOfMaintainers;
        internal = true;
        default = [];
        example = [ lib.maintainers.lnl7 ];
        description = ''
          List of maintainers of each module.  This option should be defined at
          most once per module.

          NOTE: `lib` comes from Nixpkgs, which can go out of
          sync with nix-darwin. For this reason, use definitions like
          `maintainers.alice or "alice"`.
        '';
      };

    };
  };

  meta.maintainers = [
    maintainers.roberth or "roberth"
  ];
}
</file>

<file path="modules/module-list.nix">
[
  ./alias.nix
  ./config/system-path.nix
  ./config/terminfo.nix
  ./documentation
  ./meta.nix
  ./misc/ids.nix
  ./misc/lib.nix
  ./security/pam.nix
  ./security/pki
  ./security/sandbox
  ./security/sudo.nix
  ./system
  ./system/base.nix
  ./system/primary-user.nix
  ./system/checks.nix
  ./system/activation-scripts.nix
  ./system/applications.nix
  ./system/defaults-write.nix
  ./system/defaults/controlcenter.nix
  ./system/defaults/LaunchServices.nix
  ./system/defaults/NSGlobalDomain.nix
  ./system/defaults/GlobalPreferences.nix
  ./system/defaults/CustomPreferences.nix
  ./system/defaults/clock.nix
  ./system/defaults/dock.nix
  ./system/defaults/finder.nix
  ./system/defaults/hitoolbox.nix
  ./system/defaults/iCal.nix
  ./system/defaults/screencapture.nix
  ./system/defaults/screensaver.nix
  ./system/defaults/alf.nix
  ./system/defaults/loginwindow.nix
  ./system/defaults/magicmouse.nix
  ./system/defaults/smb.nix
  ./system/defaults/SoftwareUpdate.nix
  ./system/defaults/spaces.nix
  ./system/defaults/trackpad.nix
  ./system/defaults/universalaccess.nix
  ./system/defaults/ActivityMonitor.nix
  ./system/defaults/WindowManager.nix
  ./system/etc.nix
  ./system/keyboard.nix
  ./system/launchd.nix
  ./system/nvram.nix
  ./system/patches.nix
  ./system/shells.nix
  ./system/startup.nix
  ./system/version.nix
  ./time
  ./networking
  ./networking/applicationFirewall.nix
  ./nix
  ./nix/linux-builder.nix
  ./nix/nix-darwin.nix
  ./nix/nixpkgs.nix
  ./nix/nixpkgs-flake.nix
  ./environment
  ./fonts
  ./launchd
  ./power
  ./power/sleep.nix
  ./services/activate-system
  ./services/aerospace
  ./services/autossh.nix
  ./services/buildkite-agents.nix
  ./services/chunkwm.nix
  ./services/cachix-agent.nix
  ./services/dnsmasq.nix
  ./services/dnscrypt-proxy.nix
  ./services/emacs.nix
  ./services/eternal-terminal.nix
  ./services/github-runner
  ./services/gitlab-runner.nix
  ./services/hercules-ci-agent
  ./services/ipfs.nix
  ./services/karabiner-elements
  ./services/khd
  ./services/kwm
  ./services/lorri.nix
  ./services/mail/offlineimap.nix
  ./services/mopidy.nix
  ./services/monitoring/telegraf.nix
  ./services/monitoring/netdata.nix
  ./services/monitoring/prometheus-node-exporter.nix
  ./services/netbird.nix
  ./services/nix-daemon.nix
  ./services/nix-gc
  ./services/nix-optimise
  ./services/ofborg
  ./services/openssh.nix
  ./services/postgresql
  ./services/privoxy
  ./services/redis
  ./services/sketchybar
  ./services/skhd
  ./services/spacebar
  ./services/spotifyd.nix
  ./services/synapse-bt.nix
  ./services/synergy
  ./services/tailscale.nix
  ./services/trezord.nix
  ./services/wg-quick.nix
  ./services/yabai
  ./services/nextdns
  ./services/jankyborders
  ./programs/_1password.nix
  ./programs/_1password-gui.nix
  ./programs/arqbackup.nix
  ./programs/bash
  ./programs/direnv.nix
  ./programs/fish.nix
  ./programs/gnupg.nix
  ./programs/man.nix
  ./programs/info
  ./programs/nix-index
  ./programs/ssh.nix
  ./programs/tmux.nix
  ./programs/vim.nix
  ./programs/zsh
  ./homebrew.nix
  ./users
]
</file>

<file path="pkgs/darwin-uninstaller/configuration.nix">
{ lib, config, pkgs, ... }:

with lib;

{
  # We are uninstalling, disable sanity checks.
  assertions = mkForce [];
  system.activationScripts.checks.text = mkForce "";

  environment.etc = mkForce {};
  launchd.agents = mkForce {};
  launchd.daemons = mkForce {};
  launchd.user.agents = mkForce {};

  # Restore any unmanaged `nix-daemon`.
  nix.enable = false;

  system.activationScripts.postActivation.text = mkAfter ''
    nix-channel --remove darwin || true

    ${lib.optionalString (config.system.primaryUser != null) ''
      sudo \
        --user=${lib.escapeShellArg config.system.primaryUser} \
        --set-home \
        -- nix-channel --remove darwin \
      || true
    ''}

    if [[ -L /Applications/Nix\ Apps ]]; then
        rm /Applications/Nix\ Apps
    fi

    if [[ -L /etc/static ]]; then
        rm /etc/static
    fi

    # grep will return 1 when no lines matched which makes this line fail with `set -eo pipefail`
    dscl . -list /Users UserShell | { grep "\s/run/" || true; } | awk '{print $1}' | while read -r user; do
      shell=$(dscl . -read /Users/"$user" UserShell)
      if [[ "$shell" != */bin/zsh ]]; then
        echo >&2 "warning: changing $user's shell from $shell to /bin/zsh"
      fi

      dscl . -create /Users/"$user" UserShell /bin/zsh
    done

    while IFS= read -r -d "" file; do
      mv "$file" "''${file%.*}"
    done < <(find /etc -name '*.before-nix-darwin' -follow -print0)
  '';
}
</file>

<file path="pkgs/darwin-uninstaller/default.nix">
{ lib, path, stdenv, writeShellApplication }:

let
  uninstallSystem = import ../../eval-config.nix {
    inherit lib;
    modules = [
      ./configuration.nix
      {
        nixpkgs.source = path;
        nixpkgs.hostPlatform = stdenv.hostPlatform.system;
        system.tools.darwin-uninstaller.enable = false;
      }
    ];
  };
in writeShellApplication {
  name = "darwin-uninstaller";
  text = ''
    while [ "$#" -gt 0 ]; do
      i="$1"; shift 1
      case "$i" in
        --help)
          echo "darwin-uninstaller: [--help]"
          exit
          ;;
      esac
    done

    echo >&2
    echo >&2 "Uninstalling nix-darwin, this will:"
    echo >&2
    echo >&2 "    - remove /Applications/Nix Apps symlink"
    echo >&2 "    - cleanup static /etc files"
    echo >&2 "    - disable and remove all launchd services managed by nix-darwin"
    if [[
      -e /run/current-system/Library/LaunchDaemons/org.nixos.nix-daemon.plist
      && -e /nix/var/nix/profiles/default/Library/LaunchDaemons/org.nixos.nix-daemon.plist
    ]]; then
      echo >&2 "    - restore nix-daemon service from the Nix installer"
    fi
    echo >&2

    if [[ -t 0 ]]; then
      read -r -p "Proceed? [y/n] " i
      case "$i" in
        y|Y)
          ;;
        *)
          exit 3
          ;;
      esac
    fi

    ${uninstallSystem.system}/sw/bin/darwin-rebuild activate

    if [[ -L /run/current-system ]]; then
      rm /run/current-system
    fi

    if [[ -L /run ]]; then
      if [[ -e /etc/synthetic.conf ]]; then
        sed -i -E '/^run[[:space:]]/d' /etc/synthetic.conf
        /System/Library/Filesystems/apfs.fs/Contents/Resources/apfs.util -t &>/dev/null || true
        echo >&2 "NOTE: the /run symlink will be removed on reboot"
      else
        rm /run
      fi
    fi

    echo >&2
    echo >&2 "NOTE: The /nix/var/nix/profiles/system* profiles still exist and won't be garbage collected."
    echo >&2
    echo >&2 "Done!"
    echo >&2
  '';

  derivationArgs.passthru.tests.uninstaller = writeShellApplication {
    name = "post-uninstall-test";
    text = ''
      echo >&2 "running uninstaller tests..."
      echo >&2

      echo >&2 "checking darwin channel"
      nix-instantiate --find-file darwin && exit 1
      echo >&2 "checking /etc"
      test -e /etc/static && exit 1
      echo >&2 "checking /run/current-system"
      test -e /run/current-system && exit 1
      if [[ $(stat -f '%Su' /nix/store) == "root" ]]; then
        echo >&2 "checking nix-daemon service"
        launchctl print system/org.nixos.nix-daemon
        pgrep -l nix-daemon
        test -e /Library/LaunchDaemons/org.nixos.nix-daemon.plist
        [[ "$(shasum -a 256 /Library/LaunchDaemons/org.nixos.nix-daemon.plist | awk '{print $1}')" == "$(shasum -a 256 /nix/var/nix/profiles/default/Library/LaunchDaemons/org.nixos.nix-daemon.plist | awk '{print $1}')" ]]
        nix-store --store daemon -q --hash ${stdenv.shell}
      fi
      echo >&2 ok
    '';
  };
}
</file>

<file path="pkgs/nix-tools/darwin-option.sh">
#! @shell@
set -e
set -o pipefail

export PATH=@path@
export NIX_PATH=${NIX_PATH:-@nixPath@}

evalNix() {
  nix-instantiate --eval --strict "${extraEvalFlags[@]}" -E "with import <darwin> {}; $*" 2>/dev/null
}

evalOpt() {
  evalNix "options.$option.$*"
}

evalOptAttrs() {
  evalNix "builtins.concatStringsSep \"\\n\" (builtins.attrNames $*)" | jq -r .
}

evalOptText() {
  evalNix "options.$option.$*" | jq -r .
}

showSyntax() {
  echo "$0: [-I path] <option>" >&2
  evalOptAttrs "options"
  exit 1
}

# Parse the command line.
origArgs=("$@")
extraEvalFlags=()
option=

while [ "$#" -gt 0 ]; do
  i="$1"; shift 1
  case "$i" in
    --help)
      showSyntax
      ;;
    -I)
      if [ -z "$1" ]; then
        echo "$0: ‚Äò$i‚Äô requires an argument"
        exit 1
      fi
      j="$1"; shift 1
      extraEvalFlags+=("$i" "$j")
      ;;
    *)
      option="$i"
      ;;
  esac
done

if [ -z "$option" ]; then showSyntax; fi

if [ "$(evalOpt "_type")" = '"option"' ]; then
  echo "Value:"
  evalOpt "value" || echo "no value"
  echo
  echo "Default:"
  evalOpt "default" || evalOptText "defaultText" || echo "no default"
  echo
  echo "Example:"
  if [ "$(evalOpt "example._type")" = '"literalExpression"' ]; then
    evalOptText "example.text" || echo "no example"
  else
    evalOpt "example" || echo "no example"
  fi
  echo
  echo "Description:"
  evalOptText "description.text" || echo "no description"
  echo
else
  evalOptAttrs "options.$option"
fi
</file>

<file path="pkgs/nix-tools/darwin-rebuild.sh">
#! @shell@
set -e
set -o pipefail

if [[ $(id -u) -eq 0 ]]; then
  # On macOS, `sudo(8)` preserves `$HOME` by default, which causes Nix
  # to output warnings.
  HOME=~root
fi

export PATH=@path@
export NIX_PATH=${NIX_PATH:-@nixPath@}

# Use the daemon even as `root` so that resource limits, TLS and proxy
# configuration, etc. work as expected.
export NIX_REMOTE=${NIX_REMOTE:-daemon}

showSyntax() {
  echo "darwin-rebuild [--help] {edit | switch | activate | build | check | changelog}" >&2
  echo "               [--list-generations] [{--profile-name | -p} name] [--rollback]" >&2
  echo "               [{--switch-generation | -G} generation] [--verbose...] [-v...]" >&2
  echo "               [-Q] [{--max-jobs | -j} number] [--cores number] [--dry-run]" >&2
  echo "               [--keep-going | -k] [--keep-failed | -K] [--fallback] [--show-trace]" >&2
  echo "               [--print-build-logs | -L] [--impure] [-I path]" >&2
  echo "               [--option name value] [--arg name value] [--argstr name value]" >&2
  echo "               [--no-flake | [--flake flake]" >&2
  echo "                             [--commit-lock-file] [--recreate-lock-file]" >&2
  echo "                             [--no-update-lock-file] [--no-write-lock-file]" >&2
  echo "                             [--override-input input flake] [--update-input input]" >&2
  echo "                             [--no-registries] [--offline] [--refresh]]" >&2
  echo "               [--substituters substituters-list] ..." >&2
  exit 1
}

# Parse the command line.
origArgs=("$@")
extraMetadataFlags=()
extraBuildFlags=()
extraLockFlags=()
extraProfileFlags=()
profile=@profile@
action=
flake=
noFlake=

while [ $# -gt 0 ]; do
  i=$1; shift 1
  case $i in
    --help)
      showSyntax
      ;;
    edit|switch|activate|build|check|changelog)
      action=$i
      ;;
    --show-trace|--keep-going|--keep-failed|--verbose|-v|-vv|-vvv|-vvvv|-vvvvv|--fallback|--offline)
      extraMetadataFlags+=("$i")
      extraBuildFlags+=("$i")
      ;;
    --no-build-hook|--dry-run|-k|-K|-Q)
      extraBuildFlags+=("$i")
      ;;
    -j[0-9]*)
      extraBuildFlags+=("$i")
      ;;
    --max-jobs|-j|--cores|-I)
      if [ $# -lt 1 ]; then
        echo "$0: '$i' requires an argument"
        exit 1
      fi
      j=$1; shift 1
      extraBuildFlags+=("$i" "$j")
      ;;
    --arg|--argstr|--option)
      if [ $# -lt 2 ]; then
        echo "$0: '$i' requires two arguments"
        exit 1
      fi
      j=$1
      k=$2
      shift 2
      extraMetadataFlags+=("$i" "$j" "$k")
      extraBuildFlags+=("$i" "$j" "$k")
      ;;
    --flake)
      flake=$1
      shift 1
      ;;
    --no-flake)
      noFlake=1
      ;;
    -L|-vL|--print-build-logs|--impure|--recreate-lock-file|--no-update-lock-file|--no-write-lock-file|--no-registries|--commit-lock-file|--refresh)
      extraLockFlags+=("$i")
      ;;
    --update-input)
      j="$1"; shift 1
      extraLockFlags+=("$i" "$j")
      ;;
    --override-input)
      j="$1"; shift 1
      k="$1"; shift 1
      extraLockFlags+=("$i" "$j" "$k")
      ;;
    --list-generations)
      action="list"
      extraProfileFlags=("$i")
      ;;
    --rollback)
      action="rollback"
      extraProfileFlags=("$i")
      ;;
    --switch-generation|-G)
      action="rollback"
      if [ $# -lt 1 ]; then
        echo "$0: '$i' requires an argument"
        exit 1
      fi
      j=$1; shift 1
      extraProfileFlags=("$i" "$j")
      ;;
    --profile-name|-p)
      if [ -z "$1" ]; then
        echo "$0: '$i' requires an argument"
        exit 1
      fi
      if [ "$1" != system ]; then
        profile="/nix/var/nix/profiles/system-profiles/$1"
        mkdir -p -m 0755 "$(dirname "$profile")"
      fi
      shift 1
      ;;
    --substituters)
      if [ -z "$1" ]; then
        echo "$0: '$i' requires an argument"
        exit 1
      fi
      j=$1; shift 1
      extraMetadataFlags+=("$i" "$j")
      extraBuildFlags+=("$i" "$j")
      ;;
    *)
      echo "$0: unknown option '$i'"
      exit 1
      ;;
  esac
done

if [ -z "$action" ]; then showSyntax; fi

if [[ $action =~ ^switch|activate|rollback|check$ && $(id -u) -ne 0 ]]; then
  printf >&2 '%s: system activation must now be run as root\n' "$0"
  exit 1
fi

flakeFlags=(--extra-experimental-features 'nix-command flakes')

# Use /etc/nix-darwin/flake.nix if it exists. It can be a symlink to the
# actual flake.
if [[ -z $flake && -e /etc/nix-darwin/flake.nix && -z $noFlake ]]; then
  flake="$(dirname "$(readlink -f /etc/nix-darwin/flake.nix)")"
fi

# For convenience, use the hostname as the default configuration to
# build from the flake.
if [[ -n "$flake" ]]; then
    if [[ $flake =~ ^(.*)\#([^\#\"]*)$ ]]; then
       flake="${BASH_REMATCH[1]}"
       flakeAttr="${BASH_REMATCH[2]}"
    fi
    if [[ -z "$flakeAttr" ]]; then
      flakeAttr=$(scutil --get LocalHostName)
    fi
    flakeAttr=darwinConfigurations.${flakeAttr}
fi

if [ "$action" != build ]; then
  if [ -n "$flake" ]; then
    extraBuildFlags+=("--no-link")
  else
    extraBuildFlags+=("--no-out-link")
  fi
fi

if [ "$action" = edit ]; then
  if [ -z "$flake" ]; then
    darwinConfig=$(nix-instantiate "${extraBuildFlags[@]}" --find-file darwin-config)
    exec "${EDITOR:-vi}" "$darwinConfig"
  else
    exec nix "${flakeFlags[@]}" edit "${extraLockFlags[@]}" -- "$flake#$flakeAttr"
  fi
fi

if [ "$action" = switch ] || [ "$action" = build ] || [ "$action" = check ] || [ "$action" = changelog ]; then
  echo "building the system configuration..." >&2
  if [ -z "$flake" ]; then
    systemConfig="$(nix-build '<darwin>' "${extraBuildFlags[@]}" -A system)"
  else
    systemConfig=$(nix "${flakeFlags[@]}" build --json \
      "${extraBuildFlags[@]}" "${extraLockFlags[@]}" \
      -- "$flake#$flakeAttr.system" \
      | jq -r '.[0].outputs.out')
  fi
fi

if [ "$action" = list ] || [ "$action" = rollback ]; then
  nix-env -p "$profile" "${extraProfileFlags[@]}"
fi

if [ "$action" = rollback ]; then
  systemConfig="$(cat $profile/systemConfig)"
fi

if [ "$action" = activate ]; then
  systemConfig=$(readlink -f "${0%*/sw/bin/darwin-rebuild}")
fi

if [ -z "$systemConfig" ]; then exit 0; fi

# TODO: Remove this backwards‚Äêcompatibility hack in 25.11.

if
  [[ -x $systemConfig/activate-user ]] \
  && ! grep -q '^# nix-darwin: deprecated$' "$systemConfig/activate-user"
then
  hasActivateUser=1
else
  hasActivateUser=
fi

runActivateUser() {
  if [[ -n $SUDO_USER ]]; then
    sudo --user="$SUDO_USER" --set-home -- "$systemConfig/activate-user"
  else
    printf >&2 \
      '%s: $SUDO_USER not set, can‚Äôt run legacy `activate-user` script\n' \
      "$0"
    exit 1
  fi
}

if [ "$action" = switch ]; then
  nix-env -p "$profile" --set "$systemConfig"
fi

if [ "$action" = switch ] || [ "$action" = activate ] || [ "$action" = rollback ]; then
  if [[ -n $hasActivateUser ]]; then
    runActivateUser
  fi
  "$systemConfig/activate"
fi

if [ "$action" = changelog ]; then
  ${PAGER:-less} -- "$systemConfig/darwin-changes"
fi

if [ "$action" = check ]; then
  export checkActivation=1
  if [[ -n $hasActivateUser ]]; then
    runActivateUser
  else
    "$systemConfig/activate"
  fi
fi
</file>

<file path="pkgs/nix-tools/darwin-rebuild.zsh-completions">
#compdef darwin-rebuild
#autoload

_nix-common-options

local -a _1st_arguments
_1st_arguments=(
  'edit:Open nix-darwin config in $EDITOR'\
  'switch:Build, activate, and update the current generation'\
  'activate:Activate an already built store path and update the current generation'\
  'build:Build without activating or updating the current generation'\
  'check:Build and run the activation sanity checks'\
  'changelog:Show most recent entries in the changelog'\
)

_arguments \
  $__nix_search_path_args\
  '(--verbose -v)*'{--verbose,-v}'[Increase verbosity of diagnostic messages]'\
  '(--max-jobs -j)'{--max-jobs,-j}'[max number of build jobs in parallel]:jobs:'\
  '--cores[threads per job (e.g. -j argument to make)]:cores:'\
  '(--keep-going -k)'{--keep-going,-k}"[keep going until all builds are finished]"\
  '(--keep-failed -K)'{--keep-failed,-K}'[keep failed builds (usually in /tmp)]'\
  '--fallback[If binary download fails, fall back on building from source]'\
  '--show-trace[Print stack trace of evaluation errors]'\
  '*--option[set Nix configuration option]:options:_nix_options:value:_nix_options_value'\
  '*--arg[argument to pass to the Nix function]:Name:_nix_complete_function_arg:Value: '\
  '*--argstr[pass a string]:Name:_nix_complete_function_arg:String: '\
  '--list-generations[Print a list of all generations in the active profile]'\
  '--rollback[Roll back to the previous configuration]'\
  {--switch-generation,-G}'[Activate specified generation]'\
  '(--profile-name -p)'{--profile-name,-p}'[Profile to use to track current and previous system configurations]:Profile:_nix_profiles'\
  '1:: :->subcmds' && return 0

case $state in
  subcmds)
    _describe -t commands 'darwin-rebuild subcommands' _1st_arguments
  ;;
esac
</file>

<file path="pkgs/nix-tools/darwin-version.sh">
#! @shell@
set -e
set -o pipefail
export PATH=@path@:$PATH

showSyntax() {
  echo "darwin-version [--help|--darwin-revision|--nixpkgs-revision|--configuration-revision|--json]" >&2
}

case "$1" in
  --help)
    showSyntax
    ;;
  --darwin-revision)
    revision="$(jq --raw-output '.darwinRevision // "null"' < /run/current-system/darwin-version.json)"
    if [[ "$revision" == "null" ]]; then
      echo "$0: nix-darwin commit hash is unknown" >&2
      exit 1
    fi
    echo "$revision"
    ;;
  --nixpkgs-revision)
    revision="$(jq --raw-output '.nixpkgsRevision // "null"' < /run/current-system/darwin-version.json)"
    if [[ "$revision" == "null" ]]; then
      echo "$0: Nixpkgs commit hash is unknown" >&2
      exit 1
    fi
    echo "$revision"
    ;;
  --configuration-revision)
    revision="$(jq --raw-output '.configurationRevision // "null"' < /run/current-system/darwin-version.json)"
    if [[ "$revision" == "null" ]]; then
      echo "$0: configuration commit hash is unknown" >&2
      exit 1
    fi
    echo "$revision"
    ;;
  --json)
    cat /run/current-system/darwin-version.json
    ;;
  *)
    label="$(jq --raw-output '.darwinLabel // "null"' < /run/current-system/darwin-version.json)"
    if [[ "$label" == "null" ]]; then
      showSyntax
      exit 1
    fi
    echo "$label"
    ;;
esac
</file>

<file path="pkgs/nix-tools/default.nix">
{ lib
, coreutils
, jq
, git
, replaceVarsWith
, stdenv
, profile ? "/nix/var/nix/profiles/system"
, # This should be kept in sync with the default
  # `environment.systemPath`. We err on side of including conditional
  # things like the profile directories, since they‚Äôre more likely to
  # help than hurt, and this default is mostly used for fresh
  # installations anyway.
  systemPath ? lib.concatStringsSep ":" [
  "$HOME/.nix-profile/bin"
  "/etc/profiles/per-user/$USER/bin"
  "/run/current-system/sw/bin"
  "/nix/var/nix/profiles/default/bin"
  "/usr/local/bin"
  "/usr/bin"
  "/bin"
  "/usr/sbin"
  "/sbin"
]
, nixPackage ? null
, # This should be kept in sync with the default `nix.nixPath`.
  nixPath ? lib.concatStringsSep ":" [
  "darwin-config=/etc/nix-darwin/configuration.nix"
  "/nix/var/nix/profiles/per-user/root/channels"
]
}:

let
  extraPath = lib.makeBinPath [ coreutils jq git nixPackage ];
  
  writeProgram =
    attrs:
    replaceVarsWith (
      attrs
      // {
        dir = "bin";
        isExecutable = true;
        meta.mainProgram = attrs.name;
      }
    );

  path = "${extraPath}:${systemPath}";
in
{
  darwin-option = writeProgram {
    name = "darwin-option";
    src = ./darwin-option.sh;

    replacements = {
      inherit path nixPath;
      inherit (stdenv) shell;
    };
  };

  darwin-rebuild = writeProgram {
    name = "darwin-rebuild";
    src = ./darwin-rebuild.sh;

    replacements = {
      inherit path nixPath profile;
      inherit (stdenv) shell;
    };

    postInstall = ''
      mkdir -p $out/share/zsh/site-functions
      cp ${./darwin-rebuild.zsh-completions} $out/share/zsh/site-functions/_darwin-rebuild
    '';
  };

  darwin-version = writeProgram {
    name = "darwin-version";
    src = ./darwin-version.sh;

    replacements = {
      inherit (stdenv) shell;
      path = lib.makeBinPath [ jq ];
    };
  };
}
</file>

<file path="tests/fixtures/system-defaults-write/system.txt">
defaults write /Library/Preferences/SystemConfiguration/com.apple.smb.server NetBIOSName '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<string>IMAC-000000</string>
</plist>'
defaults write /Library/Preferences/SystemConfiguration/com.apple.smb.server ServerDescription '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<string>Darwin\\U2019&apos;s iMac</string>
</plist>'
</file>

<file path="tests/fixtures/system-defaults-write/user.txt">
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g AppleEnableMouseSwipeNavigateWithScrolls '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<false/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g AppleEnableSwipeNavigateWithScrolls '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<false/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g AppleFontSmoothing '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<integer>1</integer>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g AppleICUForce24HourTime '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g AppleIconAppearanceTheme '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<string>RegularDark</string>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g AppleKeyboardUIMode '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<integer>3</integer>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g ApplePressAndHoldEnabled '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g AppleScrollerPagingBehavior '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g AppleShowAllExtensions '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g AppleShowAllFiles '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g AppleShowScrollBars '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<string>Always</string>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g AppleSpacesSwitchOnActivate '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<false/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g AppleWindowTabbingMode '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<string>always</string>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g InitialKeyRepeat '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<integer>10</integer>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g KeyRepeat '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<integer>1</integer>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g NSAutomaticCapitalizationEnabled '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<false/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g NSAutomaticDashSubstitutionEnabled '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<false/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g NSAutomaticInlinePredictionEnabled '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<false/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g NSAutomaticPeriodSubstitutionEnabled '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<false/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g NSAutomaticQuoteSubstitutionEnabled '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<false/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g NSAutomaticSpellingCorrectionEnabled '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<false/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g NSAutomaticWindowAnimationsEnabled '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<false/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g NSDisableAutomaticTermination '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g NSDocumentSaveNewDocumentsToCloud '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<false/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g NSNavPanelExpandedStateForSaveMode '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g NSNavPanelExpandedStateForSaveMode2 '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g NSScrollAnimationEnabled '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g NSTableViewDefaultSizeMode '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<integer>2</integer>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g NSTextShowsControlCharacters '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g NSUseAnimatedFocusRing '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<false/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g NSWindowResizeTime '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<real>0.010000</real>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g NSWindowShouldDragOnGesture '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g PMPrintingExpandedStateForPrint '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g PMPrintingExpandedStateForPrint2 '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g com.apple.keyboard.fnState '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g com.apple.mouse.tapBehavior '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<integer>1</integer>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g com.apple.springing.delay '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<real>0.000000</real>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g com.apple.springing.enabled '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g com.apple.swipescrolldirection '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g com.apple.trackpad.enableSecondaryClick '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write -g com.apple.trackpad.trackpadCornerClickBehavior '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<integer>1</integer>
</plist>'

launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write .GlobalPreferences com.apple.sound.beep.sound '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<string>/System/Library/Sounds/Funk.aiff</string>
</plist>'

launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.menuextra.clock FlashDateSeparators '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<false/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.menuextra.clock Show24Hour '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<false/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.menuextra.clock ShowDate '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<integer>2</integer>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.menuextra.clock ShowDayOfWeek '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.dock appswitcher-all-displays '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<false/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.dock autohide-delay '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<real>0.240000</real>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.dock expose-group-apps '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.dock orientation '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<string>left</string>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.dock persistent-apps '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<array>
	<dict>
		<key>tile-data</key>
		<dict>
			<key>file-data</key>
			<dict>
				<key>_CFURLString</key>
				<string>/Applications/MyApp.app</string>
				<key>_CFURLStringType</key>
				<integer>0</integer>
			</dict>
		</dict>
	</dict>
	<dict>
		<key>tile-data</key>
		<dict>
			<key>file-data</key>
			<dict>
				<key>_CFURLString</key>
				<string>/Applications/Cool.app</string>
				<key>_CFURLStringType</key>
				<integer>0</integer>
			</dict>
		</dict>
	</dict>
	<dict>
		<key>tile-data</key>
		<dict>

		</dict>
		<key>tile-type</key>
		<string>small-spacer-tile</string>
	</dict>
	<dict>
		<key>tile-data</key>
		<dict>

		</dict>
		<key>tile-type</key>
		<string>spacer-tile</string>
	</dict>
	<dict>
		<key>tile-data</key>
		<dict>
			<key>file-data</key>
			<dict>
				<key>_CFURLString</key>
				<string>file:///Applications/Utilities</string>
				<key>_CFURLStringType</key>
				<integer>15</integer>
			</dict>
		</dict>
		<key>tile-type</key>
		<string>directory-tile</string>
	</dict>
	<dict>
		<key>tile-data</key>
		<dict>
			<key>file-data</key>
			<dict>
				<key>_CFURLString</key>
				<string>file:///Users/example/Downloads/test.csv</string>
				<key>_CFURLStringType</key>
				<integer>15</integer>
			</dict>
		</dict>
		<key>tile-type</key>
		<string>file-tile</string>
	</dict>
</array>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.dock persistent-others '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<array>
	<dict>
		<key>tile-data</key>
		<dict>
			<key>file-data</key>
			<dict>
				<key>_CFURLString</key>
				<string>file://~/Documents</string>
				<key>_CFURLStringType</key>
				<integer>15</integer>
			</dict>
		</dict>
		<key>tile-type</key>
		<string>directory-tile</string>
	</dict>
	<dict>
		<key>tile-data</key>
		<dict>
			<key>file-data</key>
			<dict>
				<key>_CFURLString</key>
				<string>file://~/Downloads/file.txt</string>
				<key>_CFURLStringType</key>
				<integer>15</integer>
			</dict>
		</dict>
		<key>tile-type</key>
		<string>file-tile</string>
	</dict>
</array>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.dock scroll-to-open '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<false/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.finder AppleShowAllExtensions '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.finder AppleShowAllFiles '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.finder CreateDesktop '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<false/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.finder FXDefaultSearchScope '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<string>SCcf</string>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.finder FXEnableExtensionChangeWarning '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<false/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.finder FXPreferredViewStyle '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<string>Flwv</string>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.finder FXRemoveOldTrashItems '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<false/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.finder NewWindowTarget '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<string>PfLo</string>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.finder NewWindowTargetPath '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<string>file:///Library/Apple</string>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.finder QuitMenuItem '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.finder ShowExternalHardDrivesOnDesktop '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<false/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.finder ShowHardDrivesOnDesktop '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<false/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.finder ShowMountedServersOnDesktop '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<false/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.finder ShowPathbar '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.finder ShowRemovableMediaOnDesktop '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<false/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.finder ShowStatusBar '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.finder _FXShowPosixPathInTitle '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.finder _FXSortFoldersFirst '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.finder _FXSortFoldersFirstOnDesktop '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<false/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.HIToolbox AppleFnUsageType '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<integer>2</integer>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.iCal CalendarSidebarShown '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.iCal 'TimeZone support enabled' '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.iCal 'first day of week' '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<integer>4</integer>
</plist>'


launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.screencapture include-date '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.screencapture location '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<string>/tmp</string>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.screencapture target '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<string>file</string>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.screensaver askForPassword '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.screensaver askForPasswordDelay '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<integer>5</integer>
</plist>'



launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.universalaccess closeViewScrollWheelToggle '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.universalaccess closeViewZoomFollowsFocus '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.universalaccess mouseDriverCursorSize '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<real>1.500000</real>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.universalaccess reduceMotion '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.universalaccess reduceTransparency '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.ActivityMonitor IconType '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<integer>3</integer>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.ActivityMonitor OpenMainWindow '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.ActivityMonitor ShowCategory '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<integer>103</integer>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.ActivityMonitor SortColumn '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<string>CPUUsage</string>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.ActivityMonitor SortDirection '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<integer>0</integer>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write NSGlobalDomain TISRomanSwitchState '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<integer>1</integer>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.Safari NSUserKeyEquivalents '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>Quit Safari</key>
	<string>@^q</string>
</dict>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.Safari com.apple.Safari.ContentPageGroupIdentifier.WebKit2DeveloperExtrasEnabled '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.WindowManager AppWindowGroupingBehavior '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.WindowManager AutoHide '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<false/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.WindowManager EnableStandardClickToShowDesktop '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<false/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.WindowManager EnableTiledWindowMargins '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.WindowManager EnableTilingByEdgeDrag '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.WindowManager EnableTilingOptionAccelerator '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.WindowManager EnableTopTilingByEdgeDrag '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.WindowManager GloballyEnabled '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<false/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.WindowManager HideDesktop '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<false/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.WindowManager StageManagerHideWidgets '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.WindowManager StandardHideDesktopIcons '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<false/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write com.apple.WindowManager StandardHideWidgets '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write ~test-defaults-user/Library/Preferences/ByHost/com.apple.controlcenter AirDrop '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<integer>18</integer>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write ~test-defaults-user/Library/Preferences/ByHost/com.apple.controlcenter BatteryShowPercentage '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<true/>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write ~test-defaults-user/Library/Preferences/ByHost/com.apple.controlcenter Bluetooth '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<integer>18</integer>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write ~test-defaults-user/Library/Preferences/ByHost/com.apple.controlcenter Display '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<integer>24</integer>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write ~test-defaults-user/Library/Preferences/ByHost/com.apple.controlcenter FocusModes '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<integer>24</integer>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write ~test-defaults-user/Library/Preferences/ByHost/com.apple.controlcenter NowPlaying '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<integer>18</integer>
</plist>'
launchctl asuser "$(id -u -- test-defaults-user)" sudo --user=test-defaults-user -- defaults write ~test-defaults-user/Library/Preferences/ByHost/com.apple.controlcenter Sound '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<integer>24</integer>
</plist>'
</file>

<file path="tests/activation-scripts.nix">
{ config, pkgs, ... }:

{
  system.activationScripts.preActivation.text = "echo hook preActivation";
  system.activationScripts.extraActivation.text = "echo hook extraActivation";
  system.activationScripts.postActivation.text = "echo hook postActivation";

  test = ''
    countHooks() {
      awk '/echo hook / {i++ ; print i " => " $0}' "$2" | grep "$1"
    }

    echo checking activation hooks in /activate >&2
    countHooks "1 => echo hook preActivation" ${config.out}/activate
    countHooks "2 => echo hook extraActivation" ${config.out}/activate
    countHooks "3 => echo hook postActivation" ${config.out}/activate
  '';
}
</file>

<file path="tests/autossh.nix">
{ config, pkgs, ... }:

{
  services.autossh.sessions = [
    {
      name = "foo";
      user = "jfelice";
      extraArguments = "-i /some/key -T -N bar.eraserhead.net";
    }
  ];

  test = ''
    plist=${config.out}/Library/LaunchDaemons/org.nixos.autossh-foo.plist
    test -f $plist
    grep '<string>/bin/wait4path /nix/store &amp;&amp; exec /nix/store/.*/bin/autossh ' $plist
    grep '<string>/bin/wait4path /nix/store &amp;&amp; exec.*-i /some/key ' $plist
    tr -d '\n\t ' <$plist |grep '<key>KeepAlive</key><true */>'
  '';
}
</file>

<file path="tests/environment-path.nix">
{ config, lib, pkgs, ... }:

with lib;

{
  environment.systemPath = mkMerge [
    (mkBefore [ "beforePath" ])
    [ "myPath" ]
    (mkAfter [ "afterPath" ])
  ];

  environment.profiles = mkMerge [
    (mkBefore [ "beforeProfile" ])
    [ "myProfile" ]
    (mkAfter [ "afterProfile" ])
  ];

  test = ''
    echo 'checking PATH' >&2
    env_path=$(bash -c 'source ${config.system.build.setEnvironment}; echo $PATH')

    test "$env_path" = "${builtins.concatStringsSep ":" [
      "beforePath"
      "myPath"
      "beforeProfile/bin"
      "/homeless-shelter/.nix-profile/bin"
      "myProfile/bin"
      "/run/current-system/sw/bin"
      "/nix/var/nix/profiles/default/bin"
      "afterProfile/bin"
      "/usr/local/bin"
      "/usr/bin"
      "/bin"
      "/usr/sbin"
      "/sbin"
      "afterPath"
    ]}"
  '';
}
</file>

<file path="tests/environment-terminfo.nix">
{ config, ... }:

{
  environment.enableAllTerminfo = true;

  test = ''
    set -v

    echo checking /usr/share/terminfo in environment >&2
    grep 'export TERMINFO_DIRS=.*:/usr/share/terminfo' ${config.system.build.setEnvironment}

    # https://serverfault.com/a/225827
    echo checking /etc/terminfo contains lots of terminfos >&2
    find -L ${config.system.path} -name alacritty | grep .
    find -L ${config.system.path} -name xterm-kitty | grep .
    find -L ${config.system.path} -name wezterm | grep .
  '';
}
</file>

<file path="tests/fonts.nix">
{ config, pkgs, ... }:

let
  font = pkgs.runCommand "font-0.0.0" {} ''
    mkdir -p $out
    touch $out/Font.ttf
  '';
in

{
  fonts.packages = [ font ];

  test = ''
    echo "checking fonts in /Library/Fonts/Nix Fonts" >&2
    test -e "${config.out}/Library/Fonts/Nix Fonts"/*/Font.ttf

    echo "checking activation of fonts in /activate" >&2
    grep '/Library/Fonts/Nix Fonts' ${config.out}/activate
  '';
}
</file>

<file path="tests/homebrew.nix">
{ config, lib, ... }:

let
  mkTest = filter: result: ''
    if ! echo "$bf" | grep -F '${filter}' | grep -F '${result}' > /dev/null; then
      echo Expected:
      echo '${result}'
      echo Actual:
      echo "$bf" | grep -F '${filter}'
      exit 1
    fi
  '';
in

{
  homebrew.enable = true;

  homebrew.user = "test-homebrew-user";

  # Examples taken from https://github.com/Homebrew/homebrew-bundle
  homebrew.taps = [
    "homebrew/cask"
    {
      name = "user/tap-repo1";
      clone_target = "https://user@bitbucket.org/user/homebrew-tap-repo1.git";
    }
    {
      name = "user/tap-repo2";
      clone_target = "https://user@bitbucket.org/user/homebrew-tap-repo2.git";
      force_auto_update = true;
    }
  ];

  homebrew.caskArgs = {
    appdir = "~/Applications";
    require_sha = true;
  };

  homebrew.brews = [
    "imagemagick"
    {
      name = "denji/nginx/nginx-full";
      args = [ "with-rmtp" ];
      restart_service = "changed";
    }
    {
      name = "mysql@5.6";
      restart_service = true;
      link = true;
      conflicts_with = [ "mysql" ];
    }
  ];

  homebrew.casks = [
    "google-chrome"
    {
      name = "firefox";
      args = { appdir = "~/my-apps/Applications"; };
    }
    {
      name = "opera";
      greedy = true;
    }
  ];

  homebrew.masApps = {
    "1Password for Safari" = 1569813296;
    Xcode = 497799835;
  };

  homebrew.whalebrews = [
    "whalebrew/wget"
  ];

  test = ''
    bf=${lib.escapeShellArg config.homebrew.brewfile}

    echo "checking tap entries in Brewfile" >&2
    ${mkTest "homebrew/cask" ''tap "homebrew/cask"''}
    ${mkTest "user/tap-repo1" ''tap "user/tap-repo1", "https://user@bitbucket.org/user/homebrew-tap-repo1.git"''}
    ${mkTest "user/tap-repo2" ''tap "user/tap-repo2", "https://user@bitbucket.org/user/homebrew-tap-repo2.git", force_auto_update: true''}

    echo "checking cask_args entry in Brewfile" >&2
    ${mkTest "cask_args" ''cask_args appdir: "~/Applications", require_sha: true''}

    echo "checking brew entries in Brewfile" >&2
    ${mkTest "imagemagick" ''brew "imagemagick"''}
    ${mkTest "denji/nginx/nginx-full" ''brew "denji/nginx/nginx-full", args: ["with-rmtp"], restart_service: :changed''}
    ${mkTest "mysql@5.6" ''brew "mysql@5.6", conflicts_with: ["mysql"], link: true, restart_service: true''}

    echo "checking cask entries in Brewfile" >&2
    ${mkTest "google-chrome" ''cask "google-chrome"''}
    ${mkTest "firefox" ''cask "firefox", args: { appdir: "~/my-apps/Applications" }''}
    ${mkTest "opera" ''cask "opera", greedy: true''}

    echo "checking mas entries in Brewfile" >&2
    ${mkTest "1Password for Safari" ''mas "1Password for Safari", id: 1569813296''}
    ${mkTest "Xcode" ''mas "Xcode", id: 497799835''}

    echo "checking whalebrew entries in Brewfile" >&2
    ${mkTest "whalebrew/wget" ''whalebrew "whalebrew/wget"''}
  '';
}
</file>

<file path="tests/launchd-daemons.nix">
{ config, pkgs, ... }:

{
  system.primaryUser = "test-launchd-user";

  launchd.daemons.foo.command = "foo";
  launchd.agents.bar.command = "bar";
  launchd.user.agents.baz.command = "baz";

  test = ''
    echo "checking launchd load in /activate" >&2
    grep "launchctl load .* '/Library/LaunchDaemons/org.nixos.foo.plist" ${config.out}/activate
    grep "launchctl load .* '/Library/LaunchAgents/org.nixos.bar.plist" ${config.out}/activate
    echo "checking launchd user agent load in /activate" >&2
    grep "sudo --user=test-launchd-user -- launchctl load .* ~test-launchd-user/Library/LaunchAgents/org.nixos.baz.plist" ${config.out}/activate
    echo "checking LaunchAgents creation /activate" >&2
    grep "sudo --user=test-launchd-user -- mkdir -p ~test-launchd-user/Library/LaunchAgents" ${config.out}/activate
  '';
}
</file>

<file path="tests/launchd-setenv.nix">
{ config, pkgs, ... }:

{
  launchd.envVariables.FOO = "42";

  test = ''
    echo checking launchd setenv in /activate >&2
    grep "launchctl setenv FOO '42'" ${config.out}/activate
  '';
}
</file>

<file path="tests/networking-hostname.nix">
{ lib, config, ... }:

{
  networking.hostName = "EVE";
  networking.computerName = "EVE‚Äôs MacBook Pro";

  test = ''
    echo checking hostname in /activate >&2
    grep "scutil --set ComputerName 'EVE‚Äôs MacBook Pro'" ${config.out}/activate
    grep "scutil --set LocalHostName ${lib.escapeShellArg "EVE"}" ${config.out}/activate
    grep "scutil --set HostName ${lib.escapeShellArg "EVE"}" ${config.out}/activate
  '';
}
</file>

<file path="tests/networking-networkservices.nix">
{ config, lib, ... }:

{
  networking.knownNetworkServices = [ "Wi-Fi" "Thunderbolt Ethernet" ];
  networking.dns = [ "8.8.8.8" "8.8.4.4" ];

  test = ''
    echo checking dns settings in /activate >&2
    grep "networksetup -setdnsservers ${lib.escapeShellArgs [ "Wi-Fi" "8.8.8.8" "8.8.4.4" ]}" ${config.out}/activate
    grep "networksetup -setdnsservers ${lib.escapeShellArgs [ "Thunderbolt Ethernet" "8.8.8.8" "8.8.4.4" ]}" ${config.out}/activate
    echo checking empty searchdomain settings in /activate >&2
    grep "networksetup -setsearchdomains ${lib.escapeShellArgs [ "Wi-Fi" "empty" ]}" ${config.out}/activate
    grep "networksetup -setsearchdomains ${lib.escapeShellArgs [ "Thunderbolt Ethernet" "empty" ]}" ${config.out}/activate
  '';
}
</file>

<file path="tests/networking-shell-escape.nix">
{ config, pkgs, ... }:

{
  networking.computerName = "\"Quotey McQuote's Macbook Pro\"";
  networking.hostName = "\"Quotey-McQuote's-Macbook-Pro\"";

  test = ''
    echo checking hostname in /activate >&2
    grep "scutil --set ComputerName '"\""Quotey McQuote's Macbook Pro"\""'" ${config.out}/activate
    grep "scutil --set LocalHostName '"\""Quotey-McQuote's-Macbook-Pro"\""'" ${config.out}/activate
    grep "scutil --set HostName "'"\""Quotey-McQuote's-Macbook-Pro"\""'"  ${config.out}/activate
  '';
}
</file>

<file path="tests/networking-wakeonlan.nix">
{ config, pkgs, ... }:

{
  networking.wakeOnLan.enable = true;

  test = ''
    echo checking wake on network access settings in /activate >&2
    grep "systemsetup -setWakeOnNetworkAccess 'on'" ${config.out}/activate
  '';
}
</file>

<file path="tests/nix-enable.nix">
{ config, ... }:

{
  nix.enable = false;

  test = ''
    printf >&2 'checking for unexpected Nix binary in /sw/bin\n'
    [[ -e ${config.out}/sw/bin/nix-env ]] && exit 1

    printf >&2 'checking for unexpected nix-daemon plist in /Library/LaunchDaemons\n'
    [[ -e ${config.out}/Library/LaunchDaemons/org.nixos.nix-daemon.plist ]] && exit 1

    printf >&2 'checking for late‚Äêbound Nix lookup in /activate\n'
    grep nixEnvPath= ${config.out}/activate

    printf >&2 'checking for late‚Äêbound Nix lookup in activation service\n'
    script=$(cat ${config.out}/Library/LaunchDaemons/org.nixos.activate-system.plist | awk -F'[< ]' '$6 ~ "^/nix/store/.*" {print $6}')
    grep nixEnvPath= "$script"
  '';
}
</file>

<file path="tests/nixpkgs-overlays.nix">
{ config, pkgs, ... }:

{
  nixpkgs.overlays = [
    (self: super:
    {
      hello = super.runCommand "hello" {} "mkdir $out";
    })
  ];

  test = ''
    echo checking /bin/hello >&2
    (! ${pkgs.hello}/bin/hello)
  '';
}
</file>

<file path="tests/power-restart.nix">
{ config, pkgs, ... }:

{
  power.restartAfterPowerFailure = true;
  power.restartAfterFreeze = true;

  test = ''
    echo checking restart power settings in /activate >&2
    grep "systemsetup -setRestartPowerFailure 'on'" ${config.out}/activate
    grep "systemsetup -setRestartFreeze 'on'" ${config.out}/activate
  '';
}
</file>

<file path="tests/power-sleep.nix">
{ config, pkgs, ... }:

{
  power.sleep.computer = "never";
  power.sleep.display = 15;
  power.sleep.harddisk = 5;
  power.sleep.allowSleepByPowerButton = false;

  test = ''
    echo checking power sleep settings in /activate >&2
    grep "systemsetup -setComputerSleep 'never'" ${config.out}/activate
    grep "systemsetup -setDisplaySleep '15'" ${config.out}/activate
    grep "systemsetup -setHardDiskSleep '5'" ${config.out}/activate
    grep "systemsetup -setAllowPowerButtonToSleepComputer 'off'" ${config.out}/activate
  '';
}
</file>

<file path="tests/programs-ssh-empty-known-hosts.nix">
{ config, pkgs, ... }:

{
  test = ''
    echo >&2 "checking existance of /etc/ssh/ssh_known_hosts"
    if test -e ${config.out}/etc/ssh/ssh_known_hosts; then
      echo >&2 "/etc/ssh/ssh_known_hosts exists but it shouldn't!"
      exit 1
    fi
  '';
}
</file>

<file path="tests/programs-ssh.nix">
{ config, pkgs, ... }:

{
  programs.ssh.knownHosts = {
    "github.com" = {
      publicKey = "ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAq2A7hRGmdnm9tUDbO9IDSwBK6TbQa+PXYPCPy6rbTrTtw7PHkccKrpp0yVhp5HdEIcKr6pLlVDBfOLX9QUsyCOV0wzfjIJNlGEYsdlLJizHhbn2mUjvSAHQqZETYP81eFzLQNnPHt4EVVUh7VfDESU84KezmD5QlWpXLmvU31/yMf+Se8xhHTvKSCZIFImWwoG6mbUoWf9nzpIoaSjB+weqqUUmpaaasXVal72J+UX2B+2RPW3RcT0eOzQgqlJL3RKrTJvdsjE3JEAvGq3lGHSZXy28G3skua2SmVi/w4yCE6gbODqnTWlg7+wC604ydGXA8VJiS5ap43JXiUFFAaQ==";
    };
  };
  users.users.foo.openssh.authorizedKeys.keys = [ "ssh-ed25519 AAAA..." ];

  test = ''
    echo >&2 "checking for github.com in /etc/ssh/ssh_known_hosts"
    grep 'github.com ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAq2A7hRGmdnm9tUDbO9IDSwBK6TbQa+PXYPCPy6rbTrTtw7PHkccKrpp0yVhp5HdEIcKr6pLlVDBfOLX9QUsyCOV0wzfjIJNlGEYsdlLJizHhbn2mUjvSAHQqZETYP81eFzLQNnPHt4EVVUh7VfDESU84KezmD5QlWpXLmvU31/yMf+Se8xhHTvKSCZIFImWwoG6mbUoWf9nzpIoaSjB+weqqUUmpaaasXVal72J+UX2B+2RPW3RcT0eOzQgqlJL3RKrTJvdsjE3JEAvGq3lGHSZXy28G3skua2SmVi/w4yCE6gbODqnTWlg7+wC604ydGXA8VJiS5ap43JXiUFFAaQ==' ${config.out}/etc/ssh/ssh_known_hosts

    echo >&2 "checking for authorized keys for foo in /etc/ssh/nix_authorized_keys.d/foo"
    grep 'ssh-ed25519 AAAA...' ${config.out}/etc/ssh/nix_authorized_keys.d/foo
    echo >&2 "checking for authorized keys command in /etc/ssh/sshd_config.d/101-authorized-keys.conf"
    grep 'AuthorizedKeysCommand /bin/cat /etc/ssh/nix_authorized_keys.d/%u' ${config.out}/etc/ssh/sshd_config.d/101-authorized-keys.conf
  '';
}
</file>

<file path="tests/programs-tmux.nix">
{ config, pkgs, ... }:

{
  programs.tmux.enable = true;
  programs.tmux.enableVim = true;

  test = ''
    echo "checking for tmux in /sw/bin" >&2
    test -x ${config.out}/sw/bin/tmux
    grep "__ETC_ZSHRC_SOURCED=${"''"}" ${config.out}/sw/bin/tmux
    grep "__NIX_DARWIN_SET_ENVIRONMENT_DONE=${"''"}" ${config.out}/sw/bin/tmux

    echo "checking for tmux.conf in /etc" >&2
    test -e ${config.out}/etc/tmux.conf
    grep "setw -g mode-keys vi" ${config.out}/etc/tmux.conf
  '';
}
</file>

<file path="tests/programs-zsh.nix">
{ config, pkgs, ... }:

{
   environment.systemPath = [ pkgs.hello ];
   environment.shellAliases.ls = "ls -G";
   environment.interactiveShellInit = "source /etc/environment.d/*.conf";

   programs.zsh.enable = true;
   programs.zsh.enableCompletion = true;
   programs.zsh.enableBashCompletion = false;
   programs.zsh.enableAutosuggestions = true;

   programs.zsh.shellInit = "source /etc/zshenv.d/*.conf";
   programs.zsh.interactiveShellInit = "source /etc/zshrc.d/*.conf";
   programs.zsh.loginShellInit = "source /etc/zprofile.d/*.conf";
   programs.zsh.promptInit = "autoload -U promptinit && promptinit && prompt off";

   programs.zsh.variables.FOO = "42";

   test = ''
     echo >&2 "checking for share/zsh in /sw"
     test -e ${config.out}/sw/share/zsh

     echo >&2 "checking setEnvironment in /etc/zshenv"
     fgrep '. ${config.system.build.setEnvironment}' ${config.out}/etc/zshenv
     echo >&2 "checking zshenv.d in /etc/zshenv"
     grep 'source /etc/zshenv.d/\*.conf' ${config.out}/etc/zshenv

     echo >&2 "checking environment.d in /etc/zshrc"
     grep 'source /etc/environment.d/\*.conf' ${config.out}/etc/zshrc
     echo >&2 "checking zshrc.d in /etc/zshrc"
     grep 'source /etc/zshrc.d/\*.conf' ${config.out}/etc/zshrc
     echo >&2 "checking prompt off in /etc/zshrc"
     grep 'prompt off' ${config.out}/etc/zshrc
     echo >&2 "checking compinit in /etc/zshrc"
     grep 'autoload -U compinit && compinit' ${config.out}/etc/zshrc
     echo >&2 "checking bashcompinit in /etc/zshrc"
     (! grep 'bashcompinit' ${config.out}/etc/zshrc)
     echo >&2 "checking zsh-autosuggestions in /etc/zshrc"
     grep 'source ${pkgs.zsh-autosuggestions}/share/zsh-autosuggestions/zsh-autosuggestions.zsh' ${config.out}/etc/zshrc

     echo >&2 "checking zprofile.d in /etc/zprofile"
     grep 'source /etc/zprofile.d/\*.conf' ${config.out}/etc/zprofile
     echo >&2 "checking zsh variables in /etc/zprofile"
     grep 'FOO="42"' ${config.out}/etc/zprofile
     echo >&2 "checking shell aliases in /etc/zprofile"
     grep "alias ls='ls -G'" ${config.out}/etc/zprofile
   '';
}
</file>

<file path="tests/security-pki.nix">
{ config, pkgs, ... }:

{
  security.pki.certificates = [
    ''
      Fake Root CA
      ------------
    ''
  ];

  test = ''
    echo "checking for ca-certificates.crt in /etc" >&2
    test -e ${config.out}/etc/ssl/certs/ca-certificates.crt

    echo "checking NIX_SSL_CERT_FILE in set-environment" >&2
    grep 'NIX_SSL_CERT_FILE="/etc/ssl/certs/ca-certificates.crt"' ${config.system.build.setEnvironment}

    echo "checking for certificates in ca-certificates.crt" >&2
    grep -q 'BEGIN CERTIFICATE' ${config.out}/etc/ssl/certs/ca-certificates.crt

    echo "checking for extra certificate in ca-certificates.crt" >&2
    grep 'Fake Root CA' ${config.out}/etc/ssl/certs/ca-certificates.crt
  '';
}
</file>

<file path="tests/services-activate-system-changed-label-prefix.nix">
{ config, pkgs, ... }:

{
  launchd.labelPrefix = "org.nix-darwin";

  test = ''
    echo checking activation service in /Library/LaunchDaemons >&2
    grep "org.nix-darwin.activate-system" ${config.out}/Library/LaunchDaemons/org.nix-darwin.activate-system.plist

    echo checking activation of /run/current-system >&2
    script=$(cat ${config.out}/Library/LaunchDaemons/org.nix-darwin.activate-system.plist | awk -F'[< ]' '$6 ~ "^/nix/store/.*" {print $6}')
    grep "ln -sfn .* /run/current-system" "$script"
  '';
}
</file>

<file path="tests/services-activate-system.nix">
{ config, pkgs, ... }:

{
  test = ''
    echo checking activation service in /Library/LaunchDaemons >&2
    grep "org.nixos.activate-system" ${config.out}/Library/LaunchDaemons/org.nixos.activate-system.plist

    echo checking activation of /run/current-system >&2
    script=$(cat ${config.out}/Library/LaunchDaemons/org.nixos.activate-system.plist | awk -F'[< ]' '$6 ~ "^/nix/store/.*" {print $6}')
    grep "ln -sfn .* /run/current-system" "$script"
  '';
}
</file>

<file path="tests/services-aerospace.nix">
{ config, pkgs, ... }:

let
  aerospace = pkgs.runCommand "aerospace-0.0.0" { } "mkdir $out";
in

{
  system.primaryUser = "test-aerospace-user";

  services.aerospace.enable = true;
  services.aerospace.package = aerospace;
  services.aerospace.settings = {
    after-startup-command = [ "layout tiles" ];
    gaps = {
      outer.left = 8;
      outer.bottom = 8;
      outer.top = 8;
      outer.right = 8;
    };
    mode.main.binding = {
      alt-h = "focus left";
      alt-j = "focus down";
      alt-k = "focus up";
      alt-l = "focus right";
    };
    on-window-detected = [
      {
        "if" = {
          app-id = "Another.Cool.App";
          during-aerospace-startup = false;
        };
        check-further-callbacks = false;
        run = "move-node-to-workspace m";
      }
      {
        "if".app-name-regex-substring = "finder|calendar";
        run = "layout floating";
      }
      {
        "if".workspace = "1";
        run = "layout h_accordion";
      }
    ];
    workspace-to-monitor-force-assignment = {
        "1" = 1;
        "2" = "main";
        "3" = "secondary";
        "4" = "built-in";
        "5" = "^built-in retina display$";
        "6" = [ "secondary" "dell" ];
    };
  };

  test = ''
    echo >&2 "checking aerospace service in ~/Library/LaunchAgents"
    grep "org.nixos.aerospace" ${config.out}/user/Library/LaunchAgents/org.nixos.aerospace.plist
    grep "${aerospace}/Applications/AeroSpace.app/Contents/MacOS/AeroSpace" ${config.out}/user/Library/LaunchAgents/org.nixos.aerospace.plist

    conf=`sed -En 's/^[[:space:]]*<string>.*--config-path (.*)<\/string>$/\1/p' \
      ${config.out}/user/Library/LaunchAgents/org.nixos.aerospace.plist`

    echo >&2 "checking config in $conf"
    grep 'after-startup-command = \["layout tiles"\]' $conf

    grep 'bottom = 8' $conf
    grep 'left = 8' $conf
    grep 'right = 8' $conf
    grep 'top = 8' $conf

    grep 'alt-h = "focus left"' $conf
    grep 'alt-j = "focus down"' $conf
    grep 'alt-k = "focus up"' $conf
    grep 'alt-l = "focus right"' $conf

    grep 'check-further-callbacks = false' $conf
    grep 'run = "move-node-to-workspace m"' $conf
    grep 'app-id = "Another.Cool.App"' $conf
    grep 'during-aerospace-startup = false' $conf

    grep 'run = "layout floating"' $conf
    grep 'app-name-regex-substring = "finder|calendar"' $conf
    (! grep 'window-title-regex-substring' $conf)
    
    grep 'workspace = "1"' $conf
    grep 'run = "layout h_accordion"' $conf

    grep '1 = 1' $conf
    grep '2 = "main"' $conf
    grep '3 = "secondary"' $conf
    grep '4 = "built-in"' $conf
    grep '5 = "^built-in retina display$"' $conf
    grep '6 = \["secondary", "dell"\]' $conf
  '';
}
</file>

<file path="tests/services-buildkite-agent.nix">
{ config, pkgs, ... }:

let
  buildkite-agent = pkgs.runCommand "buildkite-agent-0.0.0" { } "mkdir $out";
  tokenPath = pkgs.writeText "buildkite_token" "TEST_TOKEN";
in

{
  services.buildkite-agents.test = {
    enable = true;
    package = buildkite-agent;
    extraConfig = "yolo=1";
    privateSshKeyPath = "/dev/null";
    hooks.command = "echo test hook";
    inherit tokenPath;
  };

  test = ''
    echo "checking buildkite-agent-test service in /Library/LaunchDaemons" >&2
    grep "org.nixos.buildkite-agent-test" ${config.out}/Library/LaunchDaemons/org.nixos.buildkite-agent-test.plist

    echo "checking creation of buildkite-agent service config" >&2
    script=$(cat ${config.out}/Library/LaunchDaemons/org.nixos.buildkite-agent-test.plist | awk -F'[< ]' '$6 ~ "^/nix/store/.*" {print $6}')
    grep "yolo=1" "$script"
    grep "${tokenPath}" "$script"

    echo "checking that a buildkite-agent hook works" >&2
    hooks_path=$(cat $script | awk -F'"' '/^hooks-path/ {print $2;}')
    $hooks_path/command | grep test
  '';
}
</file>

<file path="tests/services-dnscrypt-proxy.nix">
{
  config,
  pkgs,
  ...
}:

let
  dnscrypt-proxy = pkgs.runCommand "dnscrypt-proxy-0.0.0" { } "mkdir $out";
in
{
  services.dnscrypt-proxy.enable = true;
  services.dnscrypt-proxy.package = dnscrypt-proxy;

  test = ''

    echo >&2 "checking dnscrypt-proxy service in /Library/LaunchDaemons"
    grep -q "org.nixos.dnscrypt-proxy" --  ${config.out}/Library/LaunchDaemons/org.nixos.dnscrypt-proxy.plist
    grep -q "dnscrypt-proxy-start" -- ${config.out}/Library/LaunchDaemons/org.nixos.dnscrypt-proxy.plist

    echo >&2 "checking dnscrypt-proxy system user in /Library/LaunchDaemons"
    grep -q "_dnscrypt-proxy" -- ${config.out}/Library/LaunchDaemons/org.nixos.dnscrypt-proxy.plist
  '';
}
</file>

<file path="tests/services-dnsmasq.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  dnsmasq = pkgs.runCommand "dnsmasq-0.0.0" {} "mkdir $out";
in

{
  services.dnsmasq.enable = true;
  services.dnsmasq.package = dnsmasq;
  services.dnsmasq.addresses = {
    localhost = "127.0.0.1";
  };
  services.dnsmasq.servers = [
    "8.8.8.8"
    "/example.com/192.168.1.1"
  ];

  test = ''
    echo >&2 "checking dnsmasq service in /Library/LaunchDaemons"
    grep "org.nixos.dnsmasq" ${config.out}/Library/LaunchDaemons/org.nixos.dnsmasq.plist
    grep "${dnsmasq}/bin/dnsmasq" ${config.out}/Library/LaunchDaemons/org.nixos.dnsmasq.plist
    grep -F -- "--address=/localhost/127.0.0.1" ${config.out}/Library/LaunchDaemons/org.nixos.dnsmasq.plist

    echo >&2 "checking server options"
    grep -F -- "--server=8.8.8.8" ${config.out}/Library/LaunchDaemons/org.nixos.dnsmasq.plist
    grep -F -- "--server=/example.com/192.168.1.1" ${config.out}/Library/LaunchDaemons/org.nixos.dnsmasq.plist

    echo >&2 "checking resolver config"
    grep -F "port 53" ${config.out}/etc/resolver/localhost
    grep -F "nameserver 127.0.0.1" ${config.out}/etc/resolver/localhost
  '';
}
</file>

<file path="tests/services-eternal-terminal.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  eternal-terminal = pkgs.runCommand "eternal-terminal-0.0.0" { } "mkdir $out";

in {
  services.eternal-terminal.enable = true;
  services.eternal-terminal.package = eternal-terminal;
  services.eternal-terminal.port = 2222;
  services.eternal-terminal.silent = true;

  test = ''
    echo >&2 "checking eternal-terminal service in /Library/LaunchDaemons"
    grep "org.nixos.eternal-terminal" ${config.out}/Library/LaunchDaemons/org.nixos.eternal-terminal.plist
    grep "${eternal-terminal}/bin/etserver" ${config.out}/Library/LaunchDaemons/org.nixos.eternal-terminal.plist
  '';
}
</file>

<file path="tests/services-github-runners.nix">
{ config, pkgs, ... }:
{
  services.github-runners."a-runner" = {
    enable = true;
    url = "https://github.com/nixos/nixpkgs";
    tokenFile = "/secret/path/to/a/github/token";
  };

  test = ''
    echo >&2 "checking github-runner service in /Library/LaunchDaemons"
    grep "org.nixos.github-runner-a-runner" ${config.out}/Library/LaunchDaemons/org.nixos.github-runner-a-runner.plist
    grep "<string>_github-runner</string>" ${config.out}/Library/LaunchDaemons/org.nixos.github-runner-a-runner.plist

    echo >&2 "checking for user in /activate"
    grep "GitHub Runner service user" ${config.out}/activate
  '';
}
</file>

<file path="tests/services-jankyborders.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  jankyborders = pkgs.runCommand "borders-0.0.0" {} "mkdir $out";
in

{
  system.primaryUser = "test-jankyborders-user";

  services.jankyborders.enable = true;
  services.jankyborders.package = jankyborders;
  services.jankyborders.width = 5.0;
  services.jankyborders.hidpi = true;
  services.jankyborders.active_color = "0xFFFFFFFF";
  services.jankyborders.order = "below";

  test = ''
    echo >&2 "checking jankyborders service in ~/Library/LaunchAgents"
    grep "org.nixos.jankyborders" ${config.out}/user/Library/LaunchAgents/org.nixos.jankyborders.plist
    grep "${jankyborders}/bin/borders" ${config.out}/user/Library/LaunchAgents/org.nixos.jankyborders.plist

    echo >&2 "checking jankyborders config arguments"
    grep "width=5.000000" ${config.out}/user/Library/LaunchAgents/org.nixos.jankyborders.plist
    grep "hidpi=on" ${config.out}/user/Library/LaunchAgents/org.nixos.jankyborders.plist
    grep "active_color=0xFFFFFFFF" ${config.out}/user/Library/LaunchAgents/org.nixos.jankyborders.plist
    grep "order=below" ${config.out}/user/Library/LaunchAgents/org.nixos.jankyborders.plist
  '';
}
</file>

<file path="tests/services-lorri.nix">
{
  config,
  pkgs,
  lib,
  ...
}:

let
  plistPath = "${config.out}/user/Library/LaunchAgents/org.nixos.lorri.plist";
  expectedPath = "${lib.makeBinPath [
    config.nix.package
    pkgs.git
    pkgs.gnutar
    pkgs.gzip
  ]}";
  expectedNixPath = "${"nixpkgs=" + toString pkgs.path}";
in
{
  system.primaryUser = "test-lorri-user";

  services.lorri.enable = true;
  test = ''
    PATH=${
      lib.makeBinPath [
        pkgs.xcbuild
        pkgs.jq
      ]
    }:$PATH

    plutil -lint ${plistPath}
    plutil -convert json -o service.json ${plistPath}

    <service.json jq -e ".EnvironmentVariables.PATH     == \"${expectedPath}\""
    <service.json jq -e ".EnvironmentVariables.NIX_PATH == \"${expectedNixPath}\""
    <service.json jq -e ".KeepAlive                     == true"
    <service.json jq -e ".Label                         == \"org.nixos.lorri\""
    <service.json jq -e ".ProcessType                   == \"Background\""
    <service.json jq -e ".ProgramArguments|length       == 3"
    <service.json jq -e ".ProgramArguments[0]           == \"/bin/sh\""
    <service.json jq -e ".ProgramArguments[1]           == \"-c\""
    <service.json jq -e ".ProgramArguments[2]           == \"/bin/wait4path /nix/store && exec ${pkgs.lorri}/bin/lorri daemon\""
    <service.json jq -e ".RunAtLoad                     == true"
  '';
}
</file>

<file path="tests/services-netdata.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  netdata = pkgs.runCommand "netdata-0.0.0" {} "mkdir $out";
in
{
  services.netdata = {
    enable = true;
    package = netdata;
  };

  test = ''
    echo >&2 "checking netdata service in launchd daemons"
    grep "netdata" ${config.out}/Library/LaunchDaemons/netdata.plist
    grep "${netdata}/bin/netdata" ${config.out}/Library/LaunchDaemons/netdata.plist
  '';
}
</file>

<file path="tests/services-nextdns.nix">
{ config, lib, pkgs, ... }:

with lib;

let nextdns = pkgs.runCommand "nextdns-0.0.0" { } "mkdir $out";

in {
  services.nextdns.enable = true;
  services.nextdns.arguments = [ "-config" "10.0.3.0/24=abcdef" ];

  test = ''
    echo >&2 "checking nextdns service in ~/Library/LaunchDaemons"
    grep "org.nixos.nextdns" ${config.out}/Library/LaunchDaemons/org.nixos.nextdns.plist
    grep "/bin/nextdns" ${config.out}/Library/LaunchDaemons/org.nixos.nextdns.plist
    grep -- "-config" ${config.out}/Library/LaunchDaemons/org.nixos.nextdns.plist
    grep "10.0.3.0/24=abcdef" ${config.out}/Library/LaunchDaemons/org.nixos.nextdns.plist
  '';
}
</file>

<file path="tests/services-nix-daemon.nix">
{ config, pkgs, ... }:

let
  cacert = pkgs.runCommand "cacert-0.0.0" {} "mkdir -p $out";
  nix = pkgs.runCommand "nix-2.2" {} "mkdir -p $out";
in

{
  nix.package = nix;
  launchd.labelPrefix = "org.nix-darwin"; # should not have an effect on nix-daemon

  environment.variables.NIX_SSL_CERT_FILE = "${cacert}/etc/ssl/certs/ca-certificates.crt";

  test = ''
    echo checking nix-daemon service in /Library/LaunchDaemons >&2
    grep "<string>org.nixos.nix-daemon</string>" ${config.out}/Library/LaunchDaemons/org.nixos.nix-daemon.plist
    grep "<string>/bin/wait4path" ${config.out}/Library/LaunchDaemons/org.nixos.nix-daemon.plist
    grep "&amp;&amp;" ${config.out}/Library/LaunchDaemons/org.nixos.nix-daemon.plist
    grep "exec ${nix}/bin/nix-daemon</string>" ${config.out}/Library/LaunchDaemons/org.nixos.nix-daemon.plist
    grep "<key>KeepAlive</key>" ${config.out}/Library/LaunchDaemons/org.nixos.nix-daemon.plist
    (! grep "<key>Sockets</key>" ${config.out}/Library/LaunchDaemons/org.nixos.nix-daemon.plist)

    echo checking NIX_SSL_CERT_FILE in nix-daemon service >&2
    grep "<key>NIX_SSL_CERT_FILE</key>" ${config.out}/Library/LaunchDaemons/org.nixos.nix-daemon.plist
    grep "<string>${cacert}/etc/ssl/certs/ca-certificates.crt</string>" ${config.out}/Library/LaunchDaemons/org.nixos.nix-daemon.plist

    echo checking nix-daemon reload in /activate >&2
    grep "launchctl kill HUP system/org.nixos.nix-daemon" ${config.out}/activate
  '';
}
</file>

<file path="tests/services-nix-gc.nix">
{ config, pkgs, ... }:

let
  nix = pkgs.runCommand "nix-2.2" { } "mkdir -p $out";
in

{
  nix.gc.automatic = true;
  nix.gc.options = "--delete-older-than 30d";
  nix.package = nix;

  test = ''
    echo checking nix-gc service in /Library/LaunchDaemons >&2
    grep "<string>org.nixos.nix-gc</string>" ${config.out}/Library/LaunchDaemons/org.nixos.nix-gc.plist
    grep "<string>/bin/wait4path /nix/store &amp;&amp; exec ${nix}/bin/nix-collect-garbage --delete-older-than 30d</string>" ${config.out}/Library/LaunchDaemons/org.nixos.nix-gc.plist

    (! grep "<key>KeepAlive</key>" ${config.out}/Library/LaunchDaemons/org.nixos.nix-gc.plist)
  '';
}
</file>

<file path="tests/services-nix-optimise.nix">
{ config, pkgs, ... }:

let
  nix = pkgs.runCommand "nix-2.2" { } "mkdir -p $out";
in

{
  nix.optimise.automatic = true;
  nix.package = nix;

  test = ''
    echo checking nix-optimise service in /Library/LaunchDaemons >&2
    grep "<string>org.nixos.nix-optimise</string>" \
      ${config.out}/Library/LaunchDaemons/org.nixos.nix-optimise.plist
    grep "<string>/bin/wait4path /nix/store &amp;&amp; exec ${nix}/bin/nix-store --optimise</string>" \
      ${config.out}/Library/LaunchDaemons/org.nixos.nix-optimise.plist
    (! grep "<key>KeepAlive</key>" ${config.out}/Library/LaunchDaemons/org.nixos.nix-optimise.plist)
  '';
}
</file>

<file path="tests/services-ofborg.nix">
{ config, pkgs, ... }:

let
  ofborg = pkgs.runCommand "ofborg-0.0.0" {} "mkdir $out";
in

{
  services.ofborg.enable = true;
  services.ofborg.package = ofborg;

  users.knownGroups = [ "ofborg" ];
  users.knownUsers = [ "ofborg" ];

  test = ''
    echo >&2 "checking ofborg service in /Library/LaunchDaemons"
    grep "org.nixos.ofborg" ${config.out}/Library/LaunchDaemons/org.nixos.ofborg.plist
    grep "<string>ofborg</string>" ${config.out}/Library/LaunchDaemons/org.nixos.ofborg.plist

    echo >&2 "checking for user in /activate"
    grep "OfBorg service user" ${config.out}/activate

    echo >&2 "checking for logfile permissions in /activate"
    grep "touch '/var/log/ofborg.log'" ${config.out}/activate
    grep "chown .* '/var/log/ofborg.log'" ${config.out}/activate

    echo >&2 "checking config.json permissions in /activate"
    grep "chmod 600 '/var/lib/ofborg/config.json'" ${config.out}/activate
    grep "chown .* '/var/lib/ofborg/config.json'" ${config.out}/activate
  '';
}
</file>

<file path="tests/services-offlineimap.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  offlineimap = pkgs.runCommand "offlineimap-0.0.0" {} "mkdir -p $out";
in

{
  system.primaryUser = "test-offlineimap-user";

  services.offlineimap.enable = true;
  services.offlineimap.package = offlineimap;
  services.offlineimap.runQuick = true;
  services.offlineimap.extraConfig = ''
    [general]
    accounts = test
    ui = quiet

    [Account test]
    localrepository = testLocal
    remoterepository = testRemote
    autorefresh = 2
    maxage = 2017-07-01

    [Repository testLocal]
    type = GmailMaildir

    [Repository testRemote]
    type = Gmail
    ssl = yes
    starttls = no
    expunge = yes
  '';

  test = ''
    echo >&2 "checking offlineimap service in ~/Library/LaunchAgents"
    grep "org.nixos.offlineimap" ${config.out}/user/Library/LaunchAgents/org.nixos.offlineimap.plist
    grep "bin/offlineimap" ${config.out}/user/Library/LaunchAgents/org.nixos.offlineimap.plist
    grep "\-q" ${config.out}/user/Library/LaunchAgents/org.nixos.offlineimap.plist

    echo >&2 "checking config in /etc/offlineimaprc"
    grep "accounts\ \=\ test" ${config.out}/etc/offlineimaprc
  '';
}
</file>

<file path="tests/services-openssh.nix">
{ config, pkgs, ... }:

{
  services.openssh.extraConfig = ''
    StreamLocalBindUnlink yes
  '';

  test = ''
    echo >&2 "checking for StreamLocalBindUnlink in /etc/ssh/ssh_known_hosts"
    grep 'StreamLocalBindUnlink yes' ${config.out}/etc/ssh/sshd_config.d/100-nix-darwin.conf
  '';
}
</file>

<file path="tests/services-privoxy.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  privoxy = pkgs.runCommand "privoxy-0.0.0" {} "mkdir $out";
in

{
  system.primaryUser = "test-privoxy-user";

  services.privoxy.enable = true;
  services.privoxy.package = privoxy;
  services.privoxy.config = "forward / .";

  test = ''
    echo >&2 "checking privoxy service in ~/Library/LaunchAgents"
    grep "org.nixos.privoxy" ${config.out}/user/Library/LaunchAgents/org.nixos.privoxy.plist
    echo grep "${privoxy}/bin/privoxy" ${config.out}/user/Library/LaunchAgents/org.nixos.privoxy.plist
    grep "${privoxy}/bin/privoxy" ${config.out}/user/Library/LaunchAgents/org.nixos.privoxy.plist

    echo >&2 "checking config in /etc/privoxy-config"
    grep "forward / ." ${config.out}/etc/privoxy-config
  '';
}
</file>

<file path="tests/services-redis.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  redis = pkgs.runCommand "redis-0.0.0" {} "mkdir $out";
in

{
  system.primaryUser = "test-redis-user";

  services.redis.enable = true;
  services.redis.package = redis;
  services.redis.extraConfig = ''
    maxmemory-policy allkeys-lru
    stop-writes-on-bgsave-error no
  '';

  test = ''
    echo >&2 "checking redis service in ~/Library/LaunchAgents"
    grep "org.nixos.redis" ${config.out}/user/Library/LaunchAgents/org.nixos.redis.plist
    grep "${redis}/bin/redis-server /etc/redis.conf" ${config.out}/user/Library/LaunchAgents/org.nixos.redis.plist

    echo >&2 "checking config in /etc/redis.conf"
    grep "maxmemory-policy allkeys-lru" ${config.out}/etc/redis.conf
    grep "stop-writes-on-bgsave-error no" ${config.out}/etc/redis.conf
  '';
}
</file>

<file path="tests/services-skhd.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  skhd = pkgs.runCommand "skhd-0.0.0" {} "mkdir $out";
in

{
  system.primaryUser = "test-skhd-user";

  services.skhd.enable = true;
  services.skhd.package = skhd;
  services.skhd.skhdConfig = "alt + shift - r  :  chunkc quit";

  test = ''
    echo >&2 "checking skhd service in ~/Library/LaunchAgents"
    grep "org.nixos.skhd" ${config.out}/user/Library/LaunchAgents/org.nixos.skhd.plist
    grep "${skhd}/bin/skhd" ${config.out}/user/Library/LaunchAgents/org.nixos.skhd.plist

    echo >&2 "checking config in /etc/skhdrc"
    grep "alt + shift - r  :  chunkc quit" ${config.out}/etc/skhdrc
  '';
}
</file>

<file path="tests/services-spacebar.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  spacebar = pkgs.runCommand "spacebar-0.0.0" {} "mkdir $out";
in

{
  system.primaryUser = "test-spacebar-user";

  services.spacebar.enable = true;
  services.spacebar.package = spacebar;
  services.spacebar.config = { background_color = "0xff202020"; };
  services.spacebar.extraConfig = ''echo "spacebar config loaded..."'';

  test = ''
    echo >&2 "checking spacebar service in ~/Library/LaunchAgents"
    grep "org.nixos.spacebar" ${config.out}/user/Library/LaunchAgents/org.nixos.spacebar.plist
    grep "${spacebar}/bin/spacebar" ${config.out}/user/Library/LaunchAgents/org.nixos.spacebar.plist

    conf=`sed -En '/<string>-c<\/string>/{n; s/\s+?<\/?string>//g; p;}' \
      ${config.out}/user/Library/LaunchAgents/org.nixos.spacebar.plist`

    echo >&2 "checking config in $conf"
    grep "spacebar -m config background_color 0xff202020" $conf
    grep "spacebar config loaded..." $conf
  '';
}
</file>

<file path="tests/services-spotifyd.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  spotifyd = pkgs.runCommand "spotifyd-0.0.0" {} "mkdir $out";
in

{
  system.primaryUser = "test-spotify-user";

  services.spotifyd.enable = true;
  services.spotifyd.package = spotifyd;

  test = ''
    echo >&2 "checking spotifyd service in ~/Library/LaunchAgents"
    grep "org.nixos.spotifyd" ${config.out}/user/Library/LaunchAgents/org.nixos.spotifyd.plist
    grep "${spotifyd}/bin/spotifyd" ${config.out}/user/Library/LaunchAgents/org.nixos.spotifyd.plist
  '';
}
</file>

<file path="tests/services-synapse-bt.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  synapse-bt = pkgs.runCommand "synapse-bt-0.0.0" {} "mkdir $out";
in

{
  system.primaryUser = "test-synapse-bt-user";

  services.synapse-bt.enable = true;
  services.synapse-bt.package = synapse-bt;

  test = ''
    echo >&2 "checking synapse-bt service in ~/Library/LaunchAgents"
    grep "org.nixos.synapse-bt" ${config.out}/user/Library/LaunchAgents/org.nixos.synapse-bt.plist
    grep "${synapse-bt}/bin/synapse" ${config.out}/user/Library/LaunchAgents/org.nixos.synapse-bt.plist
  '';
}
</file>

<file path="tests/services-synergy.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  synergy = pkgs.runCommand "synergy-0.0.0" {} "mkdir $out";
in

{
  system.primaryUser = "test-synergy-user";

  services.synergy.package = synergy;

  services.synergy.client.enable = true;
  services.synergy.client.screenName = "client_screenName";
  services.synergy.client.serverAddress = "123.123.123.123:123";

  services.synergy.server.enable = true;
  services.synergy.server.configFile = "/tmp/synergy.conf";
  services.synergy.server.screenName = "server_screenName";
  services.synergy.server.address = "0.0.0.0:123";

  test = ''
    echo >&2 "checking synergy-client service in ~/Library/LaunchAgents"
    grep "org.nixos.synergy-client" ${config.out}/user/Library/LaunchAgents/org.nixos.synergy-client.plist
    grep "${synergy}/bin/synergyc" ${config.out}/user/Library/LaunchAgents/org.nixos.synergy-client.plist
    grep "${config.services.synergy.client.screenName}" ${config.out}/user/Library/LaunchAgents/org.nixos.synergy-client.plist
    grep "${config.services.synergy.client.serverAddress}" ${config.out}/user/Library/LaunchAgents/org.nixos.synergy-client.plist

    echo >&2 "checking synergy-server service in ~/Library/LaunchAgents"
    grep "org.nixos.synergy-server" ${config.out}/user/Library/LaunchAgents/org.nixos.synergy-server.plist
    grep "${synergy}/bin/synergys" ${config.out}/user/Library/LaunchAgents/org.nixos.synergy-server.plist
    grep "${config.services.synergy.server.configFile}" ${config.out}/user/Library/LaunchAgents/org.nixos.synergy-server.plist
    grep "${config.services.synergy.server.screenName}" ${config.out}/user/Library/LaunchAgents/org.nixos.synergy-server.plist
    grep "${config.services.synergy.server.address}" ${config.out}/user/Library/LaunchAgents/org.nixos.synergy-server.plist
  '';
}
</file>

<file path="tests/services-yabai.nix">
{ config, lib, pkgs, ... }:

with lib;

let
  yabai = pkgs.runCommand "yabai-0.0.0" {} "mkdir $out";
in

{
  system.primaryUser = "test-yabai-user";

  services.yabai.enable = true;
  services.yabai.package = yabai;
  services.yabai.config = { focus_follows_mouse = "autoraise"; };
  services.yabai.extraConfig = "yabai -m rule --add app='System Preferences' manage=off";

  test = ''
    echo >&2 "checking yabai service in ~/Library/LaunchAgents"
    grep "org.nixos.yabai" ${config.out}/user/Library/LaunchAgents/org.nixos.yabai.plist
    grep "${yabai}/bin/yabai" ${config.out}/user/Library/LaunchAgents/org.nixos.yabai.plist

    conf=`sed -En '/<string>-c<\/string>/{n; s/\s+?<\/?string>//g; p;}' \
      ${config.out}/user/Library/LaunchAgents/org.nixos.yabai.plist`

    echo >&2 "checking config in $conf"
    grep "yabai -m config focus_follows_mouse autoraise" $conf
    grep "yabai -m rule --add app='System Preferences' manage=off" $conf
    if [ `cat $conf | wc -l` -eq "2" ]; then echo "yabairc correctly contains 2 lines"; else return 1; fi
  '';
}
</file>

<file path="tests/sockets-nix-daemon.nix">
{ config, pkgs, ... }:

let
  nix = pkgs.runCommand "nix-2.2" {} "mkdir -p $out";
in

{
  services.nix-daemon.enableSocketListener = true;
  nix.package = nix;
  launchd.labelPrefix = "org.nix-darwin"; # should not have an effect on nix-daemon

  test = ''
    echo checking nix-daemon service in /Library/LaunchDaemons >&2
    grep "<string>org.nixos.nix-daemon</string>" ${config.out}/Library/LaunchDaemons/org.nixos.nix-daemon.plist
    grep "<string>/bin/wait4path" ${config.out}/Library/LaunchDaemons/org.nixos.nix-daemon.plist
    grep "&amp;&amp;" ${config.out}/Library/LaunchDaemons/org.nixos.nix-daemon.plist
    grep "exec ${nix}/bin/nix-daemon</string>" ${config.out}/Library/LaunchDaemons/org.nixos.nix-daemon.plist
    (! grep "<key>KeepAlive</key>" ${config.out}/Library/LaunchDaemons/org.nixos.nix-daemon.plist)
    grep "<key>Sockets</key>" ${config.out}/Library/LaunchDaemons/org.nixos.nix-daemon.plist
    grep "/nix/var/nix/daemon-socket/socket" ${config.out}/Library/LaunchDaemons/org.nixos.nix-daemon.plist
  '';
}
</file>

<file path="tests/system-defaults-write.nix">
{ config, pkgs, lib, ... }:

{
  system.primaryUser = "test-defaults-user";

  imports = [
    {
      system.defaults.CustomUserPreferences = {
        "NSGlobalDomain" = { "TISRomanSwitchState" = 1; };
        "com.apple.Safari" = {
          "com.apple.Safari.ContentPageGroupIdentifier.WebKit2DeveloperExtrasEnabled" =
            true;
        };
      };
    }
    {
      system.defaults.CustomUserPreferences = {
        "com.apple.Safari" = {
          "NSUserKeyEquivalents"."Quit Safari" = "@^q"; # Option-Cmd-Q
        };
      };
    }
  ];

  system.defaults.NSGlobalDomain.AppleShowAllFiles = true;
  system.defaults.NSGlobalDomain.AppleEnableMouseSwipeNavigateWithScrolls = false;
  system.defaults.NSGlobalDomain.AppleEnableSwipeNavigateWithScrolls = false;
  system.defaults.NSGlobalDomain.AppleFontSmoothing = 1;
  system.defaults.NSGlobalDomain.AppleIconAppearanceTheme = "RegularDark";
  system.defaults.NSGlobalDomain.AppleICUForce24HourTime = true;
  system.defaults.NSGlobalDomain.AppleKeyboardUIMode = 3;
  system.defaults.NSGlobalDomain.ApplePressAndHoldEnabled = true;
  system.defaults.NSGlobalDomain.AppleShowAllExtensions = true;
  system.defaults.NSGlobalDomain.AppleShowScrollBars = "Always";
  system.defaults.NSGlobalDomain.AppleScrollerPagingBehavior = true;
  system.defaults.NSGlobalDomain.AppleSpacesSwitchOnActivate = false;
  system.defaults.NSGlobalDomain.NSAutomaticCapitalizationEnabled = false;
  system.defaults.NSGlobalDomain.NSAutomaticInlinePredictionEnabled = false;
  system.defaults.NSGlobalDomain.NSAutomaticDashSubstitutionEnabled = false;
  system.defaults.NSGlobalDomain.NSAutomaticPeriodSubstitutionEnabled = false;
  system.defaults.NSGlobalDomain.NSAutomaticQuoteSubstitutionEnabled = false;
  system.defaults.NSGlobalDomain.NSAutomaticSpellingCorrectionEnabled = false;
  system.defaults.NSGlobalDomain.NSAutomaticWindowAnimationsEnabled = false;
  system.defaults.NSGlobalDomain.NSDisableAutomaticTermination = true;
  system.defaults.NSGlobalDomain.NSDocumentSaveNewDocumentsToCloud = false;
  system.defaults.NSGlobalDomain.AppleWindowTabbingMode = "always";
  system.defaults.NSGlobalDomain.NSNavPanelExpandedStateForSaveMode = true;
  system.defaults.NSGlobalDomain.NSNavPanelExpandedStateForSaveMode2 = true;
  system.defaults.NSGlobalDomain.NSTableViewDefaultSizeMode = 2;
  system.defaults.NSGlobalDomain.NSTextShowsControlCharacters = true;
  system.defaults.NSGlobalDomain.NSUseAnimatedFocusRing = false;
  system.defaults.NSGlobalDomain.NSScrollAnimationEnabled = true;
  system.defaults.NSGlobalDomain.NSWindowResizeTime = 0.01;
  system.defaults.NSGlobalDomain.NSWindowShouldDragOnGesture = true;
  system.defaults.NSGlobalDomain.InitialKeyRepeat = 10;
  system.defaults.NSGlobalDomain.KeyRepeat = 1;
  system.defaults.NSGlobalDomain.PMPrintingExpandedStateForPrint = true;
  system.defaults.NSGlobalDomain.PMPrintingExpandedStateForPrint2 = true;
  system.defaults.NSGlobalDomain."com.apple.keyboard.fnState" = true;
  system.defaults.NSGlobalDomain."com.apple.mouse.tapBehavior" = 1;
  system.defaults.NSGlobalDomain."com.apple.trackpad.enableSecondaryClick" = true;
  system.defaults.NSGlobalDomain."com.apple.trackpad.trackpadCornerClickBehavior" = 1;
  system.defaults.NSGlobalDomain."com.apple.springing.enabled" = true;
  system.defaults.NSGlobalDomain."com.apple.springing.delay" = 0.0;
  system.defaults.NSGlobalDomain."com.apple.swipescrolldirection" = true;
  system.defaults.".GlobalPreferences"."com.apple.sound.beep.sound" = "/System/Library/Sounds/Funk.aiff";
  system.defaults.menuExtraClock.FlashDateSeparators = false;
  system.defaults.menuExtraClock.Show24Hour = false;
  system.defaults.menuExtraClock.ShowDayOfWeek = true;
  system.defaults.menuExtraClock.ShowDate = 2;
  system.defaults.dock.expose-group-apps = true;
  system.defaults.dock.appswitcher-all-displays = false;
  system.defaults.dock.autohide-delay = 0.24;
  system.defaults.dock.orientation = "left";
  system.defaults.dock.persistent-apps = [
    "/Applications/MyApp.app"
    { app = "/Applications/Cool.app"; }
    { spacer = { small = true; }; }
    { spacer = { small = false; }; }
    { folder = "/Applications/Utilities"; }
    { file = "/Users/example/Downloads/test.csv"; }
  ];
  system.defaults.dock.persistent-others = ["~/Documents" "~/Downloads/file.txt"];
  system.defaults.dock.scroll-to-open = false;
  system.defaults.finder.AppleShowAllFiles = true;
  system.defaults.finder.ShowStatusBar = true;
  system.defaults.finder.ShowPathbar = true;
  system.defaults.finder.FXDefaultSearchScope = "SCcf";
  system.defaults.finder.FXPreferredViewStyle = "Flwv";
  system.defaults.finder.FXRemoveOldTrashItems = false;
  system.defaults.finder.AppleShowAllExtensions = true;
  system.defaults.finder.CreateDesktop = false;
  system.defaults.finder.NewWindowTarget = "Other";
  system.defaults.finder.NewWindowTargetPath = "file:///Library/Apple";
  system.defaults.finder.QuitMenuItem = true;
  system.defaults.finder._FXShowPosixPathInTitle = true;
  system.defaults.finder._FXSortFoldersFirst = true;
  system.defaults.finder._FXSortFoldersFirstOnDesktop = false;
  system.defaults.finder.FXEnableExtensionChangeWarning = false;
  system.defaults.finder.ShowExternalHardDrivesOnDesktop = false;
  system.defaults.finder.ShowHardDrivesOnDesktop = false;
  system.defaults.finder.ShowMountedServersOnDesktop = false;
  system.defaults.finder.ShowRemovableMediaOnDesktop = false;
  system.defaults.hitoolbox.AppleFnUsageType = "Show Emoji & Symbols";
  system.defaults.iCal."first day of week" = "Wednesday";
  system.defaults.iCal.CalendarSidebarShown = true;
  system.defaults.iCal."TimeZone support enabled" = true;
  system.defaults.screencapture.location = "/tmp";
  system.defaults.screencapture.target = "file";
  system.defaults.screencapture.include-date = true;
  system.defaults.screensaver.askForPassword = true;
  system.defaults.screensaver.askForPasswordDelay = 5;
  system.defaults.smb.NetBIOSName = "IMAC-000000";
  system.defaults.smb.ServerDescription = ''Darwin\\U2019's iMac'';
  system.defaults.universalaccess.mouseDriverCursorSize = 1.5;
  system.defaults.universalaccess.reduceMotion = true;
  system.defaults.universalaccess.reduceTransparency = true;
  system.defaults.universalaccess.closeViewScrollWheelToggle = true;
  system.defaults.universalaccess.closeViewZoomFollowsFocus = true;
  system.defaults.ActivityMonitor.ShowCategory = 103;
  system.defaults.ActivityMonitor.IconType = 3;
  system.defaults.ActivityMonitor.SortColumn = "CPUUsage";
  system.defaults.ActivityMonitor.SortDirection = 0;
  system.defaults.ActivityMonitor.OpenMainWindow = true;
  system.defaults.WindowManager.GloballyEnabled = false;
  system.defaults.WindowManager.EnableStandardClickToShowDesktop = false;
  system.defaults.WindowManager.AutoHide = false;
  system.defaults.WindowManager.AppWindowGroupingBehavior = true;
  system.defaults.WindowManager.StandardHideDesktopIcons = false;
  system.defaults.WindowManager.HideDesktop = false;
  system.defaults.WindowManager.EnableTilingByEdgeDrag = true;
  system.defaults.WindowManager.EnableTopTilingByEdgeDrag = true;
  system.defaults.WindowManager.EnableTilingOptionAccelerator = true;
  system.defaults.WindowManager.EnableTiledWindowMargins = true;
  system.defaults.WindowManager.StandardHideWidgets = true;
  system.defaults.WindowManager.StageManagerHideWidgets = true;
  system.defaults.controlcenter.BatteryShowPercentage = true;
  system.defaults.controlcenter.Sound = false;
  system.defaults.controlcenter.Bluetooth = true;
  system.defaults.controlcenter.AirDrop = true;
  system.defaults.controlcenter.Display = false;
  system.defaults.controlcenter.FocusModes = false;
  system.defaults.controlcenter.NowPlaying = true;
  test = lib.strings.concatMapStringsSep "\n"
    (x: ''
      echo >&2 "checking ${x} defaults write in /activate"
      ${pkgs.python3}/bin/python3 <<EOL
      import sys
      from pathlib import Path
      fixture = '${./fixtures/system-defaults-write}/${x}.txt'
      out = '${config.out}/activate'
      if Path(fixture).read_text() not in Path(out).read_text():
        print("Did not find content from %s in %s" % (fixture, out), file=sys.stderr)
        sys.exit(1)
      EOL
    '') [
    "system"
    "user"
  ];
}
</file>

<file path="tests/system-environment.nix">
{ config, pkgs, ... }:

{
   programs.bash.enable = true;
   programs.fish.enable = true;
   programs.zsh.enable = true;

   test = ''
     echo checking setEnvironment in /etc/bashrc >&2
     fgrep '. ${config.system.build.setEnvironment}' ${config.out}/etc/bashrc

     echo checking setEnvironment in /etc/fish/nixos-env-preinit.fish >&2
     grep 'fenv source ${config.system.build.setEnvironment}' ${config.out}/etc/fish/nixos-env-preinit.fish

     echo checking setEnvironment in /etc/zshenv >&2
     fgrep '. ${config.system.build.setEnvironment}' ${config.out}/etc/zshenv
   '';
}
</file>

<file path="tests/system-keyboard-mapping.nix">
{ config, pkgs, ... }:

{
  system.keyboard.enableKeyMapping = true;
  system.keyboard.remapCapsLockToControl = true;
  system.keyboard.remapCapsLockToEscape = true;
  system.keyboard.nonUS.remapTilde = true;
  system.keyboard.swapLeftCommandAndLeftAlt = true;
  system.keyboard.swapLeftCtrlAndFn = true;

  test = ''
    echo checking keyboard mappings in /activate >&2
    grep "hidutil property --set '{\"UserKeyMapping\":.*}'" ${config.out}/activate
    grep "\"HIDKeyboardModifierMappingSrc\":30064771129" ${config.out}/activate
    grep "\"HIDKeyboardModifierMappingSrc\":30064771172" ${config.out}/activate
    grep "\"HIDKeyboardModifierMappingDst\":30064771113" ${config.out}/activate
    grep "\"HIDKeyboardModifierMappingDst\":30064771125" ${config.out}/activate
    grep "\"HIDKeyboardModifierMappingDst\":30064771296" ${config.out}/activate
    grep "\"HIDKeyboardModifierMappingDst\":30064771298" ${config.out}/activate
    grep "\"HIDKeyboardModifierMappingDst\":30064771299" ${config.out}/activate
    grep "\"HIDKeyboardModifierMappingDst\":30064771296" ${config.out}/activate
    grep "\"HIDKeyboardModifierMappingDst\":1095216660483" ${config.out}/activate
  '';
}
</file>

<file path="tests/system-packages.nix">
{ config, pkgs, ... }:

let
  hello = pkgs.runCommand "hello-0.0.0" {} ''
    mkdir -p $out/bin $out/lib
    touch $out/bin/hello $out/lib/libhello.dylib
  '';
in

{
   environment.systemPackages = [ hello ];

   test = ''
     echo checking hello binary in /sw/bin >&2
     test -e ${config.out}/sw/bin/hello
     test "$(readlink -f ${config.out}/sw/bin/hello)" = "${hello}/bin/hello"

     echo checking for unexpected paths in /sw/bin >&2
     test -e ${config.out}/sw/lib/libhello.dylib && return
   '';
}
</file>

<file path="tests/system-path.nix">
{ config, pkgs, ... }:

{
   environment.systemPath = [ pkgs.hello ];

   test = ''
     echo checking systemPath in setEnvironment >&2
     grep 'export PATH=${pkgs.hello}/bin' ${config.system.build.setEnvironment}
   '';
}
</file>

<file path="tests/system-shells.nix">
{ config, pkgs, ... }:

{
   environment.shells = [ pkgs.zsh ];

   test = ''
     echo checking zsh in /etc/shells >&2
     grep '/run/current-system/sw/bin/zsh' ${config.out}/etc/shells
   '';
}
</file>

<file path="tests/users-groups.nix">
{ lib, config, pkgs, ... }:

{
  users.knownGroups = [ "foo" "created.group" "deleted.group" ];
  users.groups.foo.gid = 42000;
  users.groups.foo.description = "Foo group";
  users.groups.foo.members = [ "admin" "foo" ];

  users.groups."created.group".gid = 42001;
  users.groups."unknown.group".gid = 42002;

  users.knownUsers = [ "foo" "created.user" "deleted.user" ];
  users.users.foo.uid = 42000;
  users.users.foo.gid = 42000;
  users.users.foo.description = "Foo user";
  users.users.foo.isHidden = false;
  users.users.foo.home = "/Users/foo";
  users.users.foo.createHome = true;
  users.users.foo.shell = pkgs.bashInteractive;

  users.users."created.user".uid = 42001;
  users.users."created.user".description = null;
  users.users."created.user".home = null;
  users.users."created.user".shell = null;

  users.users."unknown.user".uid = 42002;

  test = ''
    set -v

    # checking group creation in /activate
    grep "dscl . -create ${lib.escapeShellArg "/Groups/foo"} PrimaryGroupID 42000" ${config.out}/activate
    grep "dscl . -create ${lib.escapeShellArg "/Groups/foo"} RealName ${lib.escapeShellArg "Foo group"}" ${config.out}/activate
    grep "dscl . -create ${lib.escapeShellArg "/Groups/created.group"} PrimaryGroupID 42001" ${config.out}/activate
    (! grep "dscl . -delete ${lib.escapeShellArg "/Groups/created.group"}" ${config.out}/activate)

    # checking group deletion in /activate
    grep "dscl . -delete ${lib.escapeShellArg "/Groups/deleted.group"}" ${config.out}/activate
    (! grep "dscl . -create ${lib.escapeShellArg "/Groups/deleted.group"}" ${config.out}/activate)

    echo "checking group membership in /activate" >&2
    grep "dscl . -create ${lib.escapeShellArg "/Groups/foo"} GroupMembership ${lib.escapeShellArgs [ "admin" "foo" ]}" ${config.out}/activate
    grep "dscl . -create ${lib.escapeShellArg "/Groups/created.group"} GroupMembership" ${config.out}/activate

    # checking unknown group in /activate
    # checking groups not in knownGroups don't appear in /activate
    (! grep "dscl . -create ${lib.escapeShellArg "/Groups/unknown.group"}" ${config.out}/activate)
    (! grep "dscl . -delete ${lib.escapeShellArg "/Groups/unknown.group"}" ${config.out}/activate)

    # checking user creation in /activate
    grep "sysadminctl -addUser ${lib.escapeShellArgs [ "foo" "-UID" 42000 "-GID" 42000 "-fullName" "Foo user" "-home" "/Users/foo" "-shell" "/run/current-system/sw/bin/bash" ]}" ${config.out}/activate
    grep "createhomedir -cu ${lib.escapeShellArg "foo"}" ${config.out}/activate
    grep "sysadminctl -addUser ${lib.escapeShellArgs [ "created.user" "-UID" 42001 ]} .* ${lib.escapeShellArgs [ "-shell" "/usr/bin/false" ] }" ${config.out}/activate
    grep "sysadminctl -addUser ${lib.escapeShellArg "created.user"} .* ${lib.escapeShellArgs [ "-home" "/var/empty" ]}" ${config.out}/activate
    (! grep "dscl . -delete ${lib.escapeShellArg "/Users/created.user"}" ${config.out}/activate)
    (! grep "dscl . -delete ${lib.escapeShellArg "/Groups/created.user"}" ${config.out}/activate)

    # checking user properties always get updated in /activate
    grep "dscl . -create ${lib.escapeShellArg "/Users/foo"} PrimaryGroupID 42000" ${config.out}/activate
    grep "dscl . -create ${lib.escapeShellArg "/Users/foo"} RealName ${lib.escapeShellArg "Foo user"}" ${config.out}/activate
    grep "createhomedir -cu ${lib.escapeShellArg "foo"}" ${config.out}/activate
    grep "dscl . -create ${lib.escapeShellArg "/Users/foo"} UserShell ${lib.escapeShellArg "/run/current-system/sw/bin/bash"}" ${config.out}/activate
    grep "dscl . -create ${lib.escapeShellArg "/Users/foo"} IsHidden 0" ${config.out}/activate

    # checking user properties that are null don't get updated in /activate
    (! grep "dscl . -create ${lib.escapeShellArg "/Users/created.user"} RealName" ${config.out}/activate)
    (! grep "dscl . -create ${lib.escapeShellArg "/Users/created.user"} UserShell" ${config.out}/activate)

    # checking user deletion in /activate
    grep "dscl . -delete ${lib.escapeShellArg "/Users/deleted.user"}" ${config.out}/activate
    (! grep "sysadminctl -addUser ${lib.escapeShellArg "deleted.user"}" ${config.out}/activate)

    # checking that users not specified in knownUsers doesn't get changed in /activate
    (! grep "sysadminctl -addUser ${lib.escapeShellArg "unknown.user"}" ${config.out}/activate)
    (! grep "dscl . -delete ${lib.escapeShellArg "/Users/unknown.user"}" ${config.out}/activate)
    (! grep "dscl . -create ${lib.escapeShellArg "/Users/unknown.user"}" ${config.out}/activate)

    set +v
  '';
}
</file>

<file path="tests/users-packages.nix">
{ config, pkgs, ... }:

let
  hello = pkgs.runCommand "hello-0.0.0" {} ''
    mkdir -p $out/bin $out/lib
    touch $out/bin/hello $out/lib/libhello.dylib
  '';
in

{
  users.knownUsers = [ "foo" ];
  users.users.foo.uid = 42000;
  users.users.foo.gid = 42000;
  users.users.foo.description = "Foo user";
  users.users.foo.isHidden = false;
  users.users.foo.home = "/Users/foo";
  users.users.foo.shell = "/run/current-system/sw/bin/bash";
  users.users.foo.packages = [ hello ];

  test = ''
    echo checking hello binary in /etc/profiles/per-user/foo/bin >&2
    test -e ${config.out}/etc/profiles/per-user/foo/bin/hello
    test "$(readlink -f ${config.out}/etc/profiles/per-user/foo/bin/hello)" = "${hello}/bin/hello"

    echo checking for unexpected paths in /etc/profiles/per-user/foo/bin >&2
    test -e ${config.out}/etc/profiles/per-user/foo/lib/libhello.dylib && return

    echo "checking /etc/profiles/per-user/foo/bin in environment" >&2
    grep 'export PATH=.*:/etc/profiles/per-user/$USER/bin' ${config.system.build.setEnvironment}
  '';
}
</file>

<file path=".git-blame-ignore-revs">
# nixpkgs: format with `nixfmt`
dc1c716ded39758062ed7e6bc410ad274119de9f
</file>

<file path=".gitignore">
*.swp
result*
</file>

<file path="CHANGELOG">
2025-01-30
- Previously, some nix-darwin options applied to the user running
  `darwin-rebuild`. As part of a long‚Äêterm migration to make
  nix-darwin focus on system‚Äêwide activation and support first‚Äêclass
  multi‚Äêuser setups, all system activation now runs as `root`, and
  these options instead apply to the `system.primaryUser` user.

  You will get an evaluation error if you are using any options to
  which this applies.

  To continue using these options, set `system.primaryUser` to the name
  of the user you have been using to run `darwin-rebuild`. In the long
  run, this setting will be deprecated and removed after all the
  functionality it is relevant for has been adjusted to allow
  specifying the relevant user separately, moved under the
  `users.users.*` namespace, or migrated to Home Manager.

  Accordingly, `darwin-rebuild` must now be run as root, the
  `system.activationScripts.{extraUserActivation,preUserActivation,
  postUserActivation}` settings have been removed, and all activation
  scripts are now executed as `root` ‚Äì be careful if you override any
  of them.

  If you run into any unexpected issues with the migration, please
  open an issue at <https://github.com/nix-darwin/nix-darwin/issues/new>
  and include as much information as possible.

2025-01-29
- There is now a `nix.enable` toggle to disable management of the Nix
  installation. Nix installation management has been made more
  opinionated as a consequence; nix-darwin now only supports managing a
  multi‚Äêuser daemon installation of Nix, and unconditionally takes
  ownership of the nix-daemon launchd daemon and the `_nixbld*` build
  users when Nix installation management is enabled.

  If the new constraints do not work with your setup, you can disable
  the `nix.enable` option to opt out of Nix installation management
  entirely; see the option documentation for caveats.

2025-01-18
- The default configuration path for all new installations
  is `/etc/nix-darwin`. This was already the undocumented
  default for `darwin-rebuild switch` when using flakes. This
  is implemented by setting `environment.darwinConfig` to
  `"/etc/nix-darwin/configuration.nix"` by default when
  `system.stateVersion` ‚â• 6.

2024-09-10
- The default Nix build user group ID is now set to 350 when
  `system.stateVersion` ‚â• 5, to reflect the default for new Nix
  installations. This only affects installations that enable
  `nix.configureBuildUsers`, and any divergence will be detected on
  system activation. To use `nix.configureBuildUsers` with a higher
  `system.stateVersion` on installations using the old group ID, set:

      ids.gids.nixbld = 30000;

  We do not recommend trying to change the group ID with macOS user
  management tools without a complete uninstallation and reinstallation
  of Nix.

2024-06-15
- SECURITY NOTICE: The previous implementation of the
  `users.users.<name>.openssh.authorizedKeys.*` options would not delete
  authorized keys files when the setting for a given user was removed.

  This means that if you previously stopped managing a user's authorized
  SSH keys with nix-darwin, or intended to revoke their access by
  removing the option, the previous set of keys could still be used to
  log in as that user.

  You can check the /etc/ssh/authorized_keys.d directory to see which
  keys were permitted; afterwards, please remove the directory and
  re-run activation. The options continue to be supported and will now
  correctly permit only the keys in your current system configuration.

2022-08-24
- Major changes to `homebrew` module
  `homebrew.cleanup` was renamed to `homebrew.onActivation.cleanup`.

  `homebrew.autoUpdate` was renamed to `homebrew.onActivation.autoUpdate`.

  `homebrew.onActivation.upgrade` was added, and the default behavior of the
  module was changed to not upgrade installed formulae and apps.

  `homebrew.global.autoUpdate` was added.

  `homebrew.global.noLock` was replaced with `hombrew.global.lockfiles`.

  `homebrew.caskArgs` submodule was added for configuring arguments to be used
  for all casks.

  `homebrew.{taps,brews,casks}` were reimplemented as lists of submodules,
  instead of lists of strings, with well documented options for all available
  arguments for these Brewfile entry types, while preserving backwards
  compatibility with the previous implementation.

2022-08-14
- nix module updated to bring it back in sync with it's NixOS counterpart
  It should now be much more fiesable to share code for this module between
  `nix-darwin` and NixOS configs.

  `nix-darwin` now requires Nix >= 2.2.

  `nix.package` can no longer be a path to a profile.

  `nix.version` option has been removed. Use `nix.package.version` if you want
  to reference the version Nix installed/used by your config.

  Many options moved/renamed from `nix.*` to `nix.settings.*`. For example
  `nix.binaryCaches` is now `nix.settings.substituters`.

  You can use `nix.settings` to set any option in `nix.conf`.

  `users.nix.*` options moved to `nix.*`.

  `nix.daemonIONice` was renamed to `nix.daemonIOLowPriority`, and
  `nix.daemonNiceLevel` was removed in favor a new option
  `nix.nix.daemonProcessType`.

2021-01-16
- Added `homebrew` module, to manage formulas installed by Homebrew via `brew bundle`.

2020-10-25
- The option environment.variables.SHELL is no longer set automatically when,
  eg. programs.zsh.enable is configured.

2020-09-12
- Options using the deprecated loaOf where removed, see https://github.com/NixOS/nixpkgs/pull/96042

    The following options no longer accept lists:
    environment.etc, environment.launchAgents.*, environment.launchDaemons.*,
    users.users, programs.ssh.knownHosts

2019-05-04
- A configuration.nix manpage is now included by default, run
  `man 5 configuration.nix` or `darwin-help`. The documentation option can be
  disabled to exclude the manual and it's extra build dependencies.

    documentation.enable = false;

2019-05-01
- nix.nixPath entries are now merged by default
  system.stateVersion > 3

    For the original behaviour, override the option using a higher priority.

    nix.nixPath = lib.mkForce [ "darwin-config=/configuration.nix" ... ];

  This option also supports specifying named NIX_PATH entries using an
  attribute set now.

    nix.nixPath = [{ darwin = "/src/darwin"; }];

2019-02-23
- The users module now supports declarative per-user packages similar to nixos.
  eg.

    users.users.<name>.packages = [ pkgs.hello ];

2019-01-02
- The NIX_PATH validation can be disabled now, this is particularly useful if
  the darwin configuration is deployed from another machine in which case it
  often doesn't matter that darwin-rebuild won't work on the host itself.

    system.checks.verifyNixPath = false;

2018-03-29
- default nix.package no longer uses the default profile.
  system.stateVersion > 2

    For the original behaviour configure nix.package

    nix.package = "/nix/var/nix/profiles/default";

2018-03-06
- added ssh.knownHosts, to manage global known_hosts.

2018-01-16
- fixed issue for single-user installs, be careful when rolling back to a
  revision after 9792b08fdf049524742143f4f788e3eb61a769fda.

    If you run into trouble try NIX_REMOTE= darwin-rebuild switch.

2018-01-13
- added users.users and users.groups to manage user accounts.
  Changes will not be applied to existing users or groups.

2018-01-08
- added networking.networkservices, to manage dns servers and searchdomains.
  This will clear existing values when enabled.

2018-01-06
- added nixpkgs.overlays, there is a chapter on overlays in the nixpkgs manual
  https://nixos.org/nixpkgs/manual/#chap-overlays with more information.

2018-01-04
- the nix.useDaemon/services.nix-daemon.enable options now automatically
  reload the daemon for you when nix.conf changes.

2017-11-29
- the security.enableAccessibilityAccess option was removed since it
  no longer works on macOS 10.12 and later.

2017-11-06
- the programs.fish module was rewritten based on improvements from
  NixOS. This might have some incompatible changes compared to the
  previous implementation.

2017-10-06
- loeOf was removed from nixpkgs in 10881bbe11b2f66ebfa880795e5bc01a04158da4

    Using single items instead of a list no longer works for
    environment.systemPath and launchd.<serviceType>.<name>.path

2017-10-01
- added system.stateVersion option, add this to your configuration to
  avoid breaking changes.  This changelog and the activation checks
  will show instructions on what to do to safely increment this value.

2017-07-06
- added user channels to the default nix.nixPath

    Using a user channel now works without any custom configuration.
    See https://github.com/NixOS/nix/issues/1548 if you are running into
    issues when updating your channel.

2017-07-28
- added support for command-not-found, using nix-index

    programs.nix-index.enable = true;

2017-07-23
- darwin entry in the default nix.nixPath was removed for
  system.stateVersion > 1

    Use a channel for nix-darwin or configure nix.nixPath

    sudo nix-channel --add https://github.com/nix-darwin/nix-darwin/archive/master.tar.gz darwin
    sudo nix-channel --update

    nix.nixPath =
      [ "darwin=$HOME/.nix-defexpr/darwin"
        "darwin-config=$HOME/.nixpkgs/darwin-configuration.nix"
        "/nix/var/nix/profiles/per-user/root/channels"
      ];

2017-01-09
- nix.profile was renamed to nix.package
</file>

<file path="default.nix">
{ nixpkgs ? <nixpkgs>
, configuration ? <darwin-config>
, system ? builtins.currentSystem
, pkgs ? import nixpkgs { inherit system; }
, lib ? pkgs.lib
}:

let
  eval = import ./eval-config.nix {
    inherit lib;
    modules = [
      configuration
      { nixpkgs.source = lib.mkDefault nixpkgs; }
    ] ++ lib.optional (system != null) {
      nixpkgs.system = lib.mkDefault system;
    };
  };
in
eval // {
  darwin-uninstaller = pkgs.callPackage ./pkgs/darwin-uninstaller { };

  inherit (pkgs.callPackage ./pkgs/nix-tools { }) darwin-option darwin-rebuild darwin-version;
}
</file>

<file path="eval-config.nix">
let
  nixDarwinVersion = builtins.fromJSON (builtins.readFile ./version.json);

  checkRelease = lib:
    # Avoid breaking configurations when the unstable Nixpkgs version
    # rolls over.
    #
    # TODO: Something more refined than this would be ideal, as this
    # still means you could be using unstable nix-darwin 25.05 with
    # Nixpkgs 26.05, which would be unfortunate.
    if nixDarwinVersion.isReleaseBranch then
      lib.trivial.release == nixDarwinVersion.release
    else
      lib.versionAtLeast lib.trivial.release nixDarwinVersion.release;
in

{ lib
, modules
, baseModules ? import ./modules/module-list.nix
, specialArgs ? { }
, check ? true
, enableNixpkgsReleaseCheck ? true
}@args:

assert enableNixpkgsReleaseCheck -> checkRelease lib || throw ''

  nix-darwin now uses release branches that correspond to Nixpkgs releases.
  The nix-darwin and Nixpkgs branches in use must match, but you are currently
  using nix-darwin ${nixDarwinVersion.release} with Nixpkgs ${lib.trivial.release}.

  On macOS, you should use either the `nixpkgs-unstable` or
  `nixpkgs-YY.MM-darwin` branches of Nixpkgs. These correspond to the
  `master` and `nix-darwin-YY.MM` branches of nix-darwin, respectively. Check
  <https://status.nixos.org/> for the currently supported Nixpkgs releases.

  If you‚Äôre using flakes, make sure your inputs look like this:

      inputs = {
        nixpkgs.url = "github:NixOS/nixpkgs/NIXPKGS-BRANCH";
        nix-darwin.url = "github:nix-darwin/nix-darwin/NIX-DARWIN-BRANCH";
        nix-darwin.inputs.nixpkgs.follows = "nixpkgs";
        # ‚Ä¶
      };

  If you‚Äôre using channels, you can check your current channels with:

      $ sudo nix-channel --list
      nixpkgs https://nixos.org/channels/NIXPKGS-BRANCH
      darwin https://github.com/nix-darwin/nix-darwin/archive/NIX-DARWIN-BRANCH.tar.gz
      ‚Ä¶
      $ nix-channel --list
      ‚Ä¶

  If `darwin` or `nixpkgs` are present in `nix-channel --list` (without
  `sudo`), you should delete them with `nix-channel --remove NAME`. These can
  contribute to version mismatch problems.

  You can then fix your channels like this:

      $ sudo nix-channel --add https://nixos.org/channels/NIXPKGS-BRANCH nixpkgs
      $ sudo nix-channel --add https://github.com/nix-darwin/nix-darwin/archive/NIX-DARWIN-BRANCH.tar.gz darwin
      $ sudo nix-channel --update

  After that, activating your system again should work correctly. If it
  doesn‚Äôt, please open an issue at
  <https://github.com/nix-darwin/nix-darwin/issues/new> and include as much
  information as possible.
'';

let
  argsModule = {
    _file = ./eval-config.nix;
    config = {
      _module.args = {
        inherit baseModules modules;
      };
    };
  };

  eval = lib.evalModules (builtins.removeAttrs args [ "lib" "enableNixpkgsReleaseCheck" ] // {
    class = "darwin";
    modules = modules ++ [ argsModule ] ++ baseModules;
    specialArgs = { modulesPath = builtins.toString ./modules; } // specialArgs;
  });
  
  withExtraAttrs = configuration: configuration // {
    inherit (configuration._module.args) pkgs;
    system = configuration.config.system.build.toplevel;
    extendModules = args: withExtraAttrs (configuration.extendModules args);
  };
in withExtraAttrs eval
</file>

<file path="flake.lock">
{
  "nodes": {
    "nixpkgs": {
      "locked": {
        "lastModified": 1747728033,
        "narHash": "sha256-NnXFQu7g4LnvPIPfJmBuZF7LFy/fey2g2+LCzjQhTUk=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "2f9173bde1d3fbf1ad26ff6d52f952f9e9da52ea",
        "type": "github"
      },
      "original": {
        "owner": "NixOS",
        "ref": "nixpkgs-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "nixpkgs": "nixpkgs"
      }
    }
  },
  "root": "root",
  "version": 7
}
</file>

<file path="flake.nix">
{
  description = "A collection of darwin modules";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";
  };

  outputs = { self, nixpkgs }: let
    forAllSystems = nixpkgs.lib.genAttrs [ "aarch64-darwin" "x86_64-darwin" "aarch64-linux" "x86_64-linux" ];
    forDarwinSystems = nixpkgs.lib.genAttrs [ "aarch64-darwin" "x86_64-darwin" ];

    jobs = forAllSystems (system: import ./release.nix {
      inherit nixpkgs system;

      nix-darwin = self;
    });
  in {
    lib = {
      evalConfig = import ./eval-config.nix;

      darwinSystem = args@{ modules, ... }: self.lib.evalConfig (
        { inherit (nixpkgs) lib; }
        // nixpkgs.lib.optionalAttrs (args ? pkgs) { inherit (args.pkgs) lib; }
        // builtins.removeAttrs args [ "system" "pkgs" "inputs" ]
        // {
          modules = modules
            ++ nixpkgs.lib.optional (args ? pkgs) ({ lib, ... }: {
              _module.args.pkgs = lib.mkForce args.pkgs;
            })
            # Backwards compatibility shim; TODO: warn?
            ++ nixpkgs.lib.optional (args ? system) ({ lib, ... }: {
              nixpkgs.system = lib.mkDefault args.system;
            })
            # Backwards compatibility shim; TODO: warn?
            ++ nixpkgs.lib.optional (args ? inputs) {
              _module.args.inputs = args.inputs;
            }
            ++ [ ({ lib, ... }: {
              nixpkgs.source = lib.mkDefault nixpkgs;
              nixpkgs.flake.source = lib.mkDefault nixpkgs.outPath;

              system.checks.verifyNixPath = lib.mkDefault false;

              system.darwinVersionSuffix = ".${self.shortRev or self.dirtyShortRev or "dirty"}";
              system.darwinRevision = let
                rev = self.rev or self.dirtyRev or null;
              in
                lib.mkIf (rev != null) rev;
            }) ];
          });
    };

    overlays.default = final: prev: {
      inherit (prev.callPackage ./pkgs/nix-tools { }) darwin-rebuild darwin-option darwin-version;

      darwin-uninstaller = prev.callPackage ./pkgs/darwin-uninstaller { };
    };

    darwinModules.hydra = ./modules/examples/hydra.nix;
    darwinModules.lnl = ./modules/examples/lnl.nix;
    darwinModules.simple = ./modules/examples/simple.nix;

    templates.default = {
      path = ./modules/examples/flake;
      description = "nix flake init -t nix-darwin";
    };

    checks = forDarwinSystems (system: jobs.${system}.tests // jobs.${system}.examples);

    packages = forAllSystems (system: {
      inherit (jobs.${system}.docs) manualHTML manpages optionsJSON;
    } // (nixpkgs.lib.optionalAttrs (nixpkgs.lib.hasSuffix "darwin" system) (let
      pkgs = import nixpkgs {
        inherit system;
        overlays = [ self.overlays.default ];
      };
    in {
      default = self.packages.${system}.darwin-rebuild;

      inherit (pkgs) darwin-option darwin-rebuild darwin-version darwin-uninstaller;

      # TODO: Include manuals for active release branches in the website.
      # (This may involve moving it to a separate repository.)
      website = pkgs.linkFarm "nix-darwin-website" {
        "index.html" = ./doc/website/index.html;
        manual = "${self.packages.${system}.manualHTML}/share/doc/darwin";
      };
    })));
  };
}
</file>

<file path="LICENSE">
Copyright 2017 <Daiderd Jordan>

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</file>

<file path="README.md">
[<img src="https://github.com/user-attachments/assets/0e1a77ac-6739-4153-bd24-abd3a5e143f5" width="200px" alt="logo" />](https://github.com/nix-darwin/nix-darwin)

# nix-darwin

[![Test](https://github.com/nix-darwin/nix-darwin/actions/workflows/test.yml/badge.svg)](https://github.com/nix-darwin/nix-darwin/actions/workflows/test.yml)

Nix modules for darwin, `/etc/nixos/configuration.nix` for macOS.

This project aims to bring the convenience of a declarative system approach to macOS.
nix-darwin is built up around [Nixpkgs](https://github.com/NixOS/nixpkgs), quite similar to [NixOS](https://nixos.org/).

## Prerequisites

The only prerequisite is a Nix implementation; both Nix and Lix are supported.

As the official Nix installer does not include an automated uninstaller, and manual uninstallation on macOS is a complex process, we recommend using one of the following installers instead:

* The [Nix installer from Determinate Systems](https://github.com/DeterminateSystems/nix-installer?tab=readme-ov-file#determinate-nix-installer) is only recommended for use with flake-based setups.
  It can install one of two distributions of Nix:

  * To install the **recommended** vanilla upstream [Nix](https://nixos.org), you will need to explicitly say `no` when prompted to install `Determinate Nix`.

  * When run with the `--determinate` flag, it will install the [Determinate](https://docs.determinate.systems/) distribution.
    As Determinate manages the Nix installation itself, you will need to set `nix.enable = false;` in your configuration to disable nix-darwin‚Äôs own Nix management.
    Some nix-darwin functionality that relies on managing the Nix installation, like the `nix.*` options to adjust Nix settings or configure a Linux builder, will be unavailable.

* The [Lix installer](https://lix.systems/install/#on-any-other-linuxmacos-system) supports both flake-based and channel-based setups.



## Getting started

Despite being an experimental feature in Nix currently, nix-darwin recommends that beginners use flakes to manage their nix-darwin configurations.

<details>
<summary>Flakes (Recommended for beginners)</summary>

### Step 1. Creating `flake.nix`

<details>
<summary>Getting started from scratch</summary>
<p></p>

If you don't have an existing `configuration.nix`, you can run the following commands to generate a basic `flake.nix` inside `/etc/nix-darwin`:

```bash
sudo mkdir -p /etc/nix-darwin
sudo chown $(id -nu):$(id -ng) /etc/nix-darwin
cd /etc/nix-darwin

# To use Nixpkgs unstable:
nix flake init -t nix-darwin/master
# To use Nixpkgs 25.05:
nix flake init -t nix-darwin/nix-darwin-25.05

sed -i '' "s/simple/$(scutil --get LocalHostName)/" flake.nix
```

Make sure to check if `nixpkgs.hostPlatform` is set to either `x86_64-darwin` for Intel or `aarch64-darwin` for Apple Silicon.

</details>

<details>
<summary>Migrating from an existing configuration.nix</summary>
<p></p>

Add the following to `flake.nix` in the same folder as `configuration.nix`:

```nix
{
  description = "John's darwin system";

  inputs = {
    # Use `github:NixOS/nixpkgs/nixpkgs-25.05-darwin` to use Nixpkgs 25.05.
    nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";
    # Use `github:nix-darwin/nix-darwin/nix-darwin-25.05` to use Nixpkgs 25.05.
    nix-darwin.url = "github:nix-darwin/nix-darwin/master";
    nix-darwin.inputs.nixpkgs.follows = "nixpkgs";
  };

  outputs = inputs@{ self, nix-darwin, nixpkgs }: {
    darwinConfigurations."Johns-MacBook" = nix-darwin.lib.darwinSystem {
      modules = [ ./configuration.nix ];
    };
  };
}
```

Make sure to replace `Johns-MacBook` with your hostname which you can find by running `scutil --get LocalHostName`.

Make sure to set `nixpkgs.hostPlatform` in your `configuration.nix` to either `x86_64-darwin` (Intel) or `aarch64-darwin` (Apple Silicon).

</details>

### Step 2. Installing `nix-darwin`

Unlike NixOS, `nix-darwin` does not have an installer, you can just run `darwin-rebuild switch` to install nix-darwin. As `darwin-rebuild` won't be installed in your `PATH` yet, you can use the following command:

```bash
# To use Nixpkgs unstable:
sudo nix run nix-darwin/master#darwin-rebuild -- switch
# To use Nixpkgs 25.05:
sudo nix run nix-darwin/nix-darwin-25.05#darwin-rebuild -- switch
```

### Step 3. Using `nix-darwin`

After installing, you can run `darwin-rebuild` to apply changes to your system:

```bash
sudo darwin-rebuild switch
```

#### Using flake inputs

Inputs from the flake can also be passed into `darwinSystem`. These inputs are then
accessible as an argument `inputs`, similar to `pkgs` and `lib`, inside the configuration.

```nix
# in flake.nix
nix-darwin.lib.darwinSystem {
  modules = [ ./configuration.nix ];
  specialArgs = { inherit inputs; };
}
```

```nix
# in configuration.nix
{ pkgs, lib, inputs }:
# inputs.self, inputs.nix-darwin, and inputs.nixpkgs can be accessed here
```
</details>

<details>
<summary>Channels</summary>

### Step 1. Creating `configuration.nix`

Copy the [simple](./modules/examples/simple.nix) example to `/etc/nix-darwin/configuration.nix`.

### Step 2. Adding `nix-darwin` channel

```bash
# If you use Nixpkgs unstable (the default):
sudo nix-channel --add https://github.com/nix-darwin/nix-darwin/archive/master.tar.gz darwin
# If you use Nixpkgs 25.05:
sudo nix-channel --add https://github.com/nix-darwin/nix-darwin/archive/nix-darwin-25.05.tar.gz darwin

sudo nix-channel --update
```

### Step 3. Installing `nix-darwin`

To install `nix-darwin`, you can just run `darwin-rebuild switch` to install nix-darwin. As `darwin-rebuild` won't be installed in your `PATH` yet, you can use the following command:

```bash
nix-build '<darwin>' -A darwin-rebuild
sudo ./result/bin/darwin-rebuild switch -I darwin-config=/etc/nix-darwin/configuration.nix
```

### Step 4. Using `nix-darwin`

After installing, you can run `darwin-rebuild` to apply changes to your system:

```bash
sudo darwin-rebuild switch
```

### Step 5. Updating `nix-darwin`

You can update Nixpkgs and `nix-darwin` using the following command:

```bash
sudo nix-channel --update
```
</details>

## Documentation

`darwin-help` will open up a local copy of the reference documentation, it can also be found online [here](https://nix-darwin.github.io/nix-darwin/manual/index.html).

The documentation is also available as manpages by running `man 5 configuration.nix`.

## Uninstalling

To run the latest version of the uninstaller, you can run the following command:

```
sudo nix --extra-experimental-features "nix-command flakes" run nix-darwin#darwin-uninstaller
```

If that command doesn't work for you, you can try the locally installed uninstaller:

```
sudo darwin-uninstaller
```

## Tests

There are basic tests that run sanity checks for some of the modules,
you can run them like this:

```bash
# run all tests
nix-build release.nix -A tests
# or just a subset
nix-build release.nix -A tests.environment-path
```

## Contributing

Let's make Nix on macOS awesome!

Don't hesitate to contribute modules or open an issue.

To build your configuration with local changes you can run this. This
flag can also be used to override darwin-config or nixpkgs, for more
information on the `-I` flag look at the nix-build [manpage](https://nixos.org/manual/nix/stable/command-ref/nix-build.html).

```bash
sudo darwin-rebuild switch -I darwin=.
```

If you're adding a module, please add yourself to `meta.maintainers`, for example

```nix
  meta.maintainers = [
    lib.maintainers.alice or "alice"
  ];

  options.services.alicebot = # ...
```

The `or` operator takes care of graceful degradation when `lib` from Nixpkgs
goes out of sync.

Feel free to contact us on Matrix if you have questions:
* **User support:** [#macos:nixos.org](https://matrix.to/#/#macos:nixos.org)
* **Development discussion:** [#nix-darwin-dev:nixos.org](https://matrix.to/#/#nix-darwin-dev:nixos.org)
</file>

<file path="release.nix">
{ nixpkgs ? <nixpkgs>
# Adapted from https://github.com/NixOS/nixpkgs/blob/e818264fe227ad8861e0598166cf1417297fdf54/pkgs/top-level/release.nix#L11
, nix-darwin ? { }
, system ? builtins.currentSystem
, supportedSystems ? [ "x86_64-darwin" "aarch64-darwin" ]
, scrubJobs ? true
}:

let
  buildFromConfig = configuration: sel: sel
    (import ./. { inherit nixpkgs configuration system; }).config;

  makeSystem = configuration: buildFromConfig configuration (config: config.system.build.toplevel);

  makeTest = test:
    let
      testName =
        builtins.replaceStrings [ ".nix" ] [ "" ]
          (builtins.baseNameOf test);

      configuration =
        { config, lib, pkgs, ... }:
        with lib;
        {
          imports = [ test ];

          options = {
            out = mkOption {
              type = types.package;
            };

            test = mkOption {
              type = types.lines;
            };
          };

          config = {
            system.stateVersion = lib.mkDefault config.system.maxStateVersion;

            system.build.run-test = pkgs.runCommand "darwin-test-${testName}"
              { allowSubstitutes = false; preferLocalBuild = true; }
              ''
                #! ${pkgs.stdenv.shell}
                set -e

                echo >&2 "running tests for system ${config.out}"
                echo >&2
                ${config.test}
                echo >&2 ok
                touch $out
              '';

            out = config.system.build.toplevel;
          };
        };
    in
      buildFromConfig configuration (config: config.system.build.run-test);

  manual = buildFromConfig ({ lib, config, ... }: {
    system.stateVersion = lib.mkDefault config.system.maxStateVersion;

    system.darwinVersionSuffix = let
      shortRev = nix-darwin.shortRev or nix-darwin.dirtyShortRev or null;
    in
      lib.mkIf (shortRev != null) ".${shortRev}";
    system.darwinRevision = let
      rev = nix-darwin.rev or nix-darwin.dirtyRev or null;
    in
      lib.mkIf (rev != null) rev;
  }) (config: config.system.build.manual);

in {
  docs = {
    inherit (manual) manualHTML manpages optionsJSON;
  };

  examples.hydra = makeSystem ./modules/examples/hydra.nix;
  examples.lnl = makeSystem ./modules/examples/lnl.nix;
  examples.simple = makeSystem ./modules/examples/simple.nix;

  tests.activation-scripts = makeTest ./tests/activation-scripts.nix;
  tests.autossh = makeTest ./tests/autossh.nix;
  tests.environment-path = makeTest ./tests/environment-path.nix;
  tests.environment-terminfo = makeTest ./tests/environment-terminfo.nix;
  tests.homebrew = makeTest ./tests/homebrew.nix;
  tests.launchd-daemons = makeTest ./tests/launchd-daemons.nix;
  tests.launchd-setenv = makeTest ./tests/launchd-setenv.nix;
  tests.networking-hostname = makeTest ./tests/networking-hostname.nix;
  tests.networking-networkservices = makeTest ./tests/networking-networkservices.nix;
  tests.nix-enable = makeTest ./tests/nix-enable.nix;
  tests.nixpkgs-overlays = makeTest ./tests/nixpkgs-overlays.nix;
  tests.programs-ssh = makeTest ./tests/programs-ssh.nix;
  tests.programs-tmux = makeTest ./tests/programs-tmux.nix;
  tests.programs-zsh = makeTest ./tests/programs-zsh.nix;
  tests.programs-ssh-empty-known-hosts = makeTest ./tests/programs-ssh-empty-known-hosts.nix;
  tests.security-pki = makeTest ./tests/security-pki.nix;
  tests.services-activate-system = makeTest ./tests/services-activate-system.nix;
  tests.services-activate-system-changed-label-prefix = makeTest ./tests/services-activate-system-changed-label-prefix.nix;
  tests.services-buildkite-agent = makeTest ./tests/services-buildkite-agent.nix;
  tests.services-github-runners = makeTest ./tests/services-github-runners.nix;
  tests.services-lorri = makeTest ./tests/services-lorri.nix;
  tests.services-nix-daemon = makeTest ./tests/services-nix-daemon.nix;
  tests.sockets-nix-daemon = makeTest ./tests/sockets-nix-daemon.nix;
  tests.services-aerospace = makeTest ./tests/services-aerospace.nix;
  tests.services-dnsmasq = makeTest ./tests/services-dnsmasq.nix;
  tests.services-dnscrypt-proxy = makeTest ./tests/services-dnscrypt-proxy.nix;
  tests.services-eternal-terminal = makeTest ./tests/services-eternal-terminal.nix;
  tests.services-nix-gc = makeTest ./tests/services-nix-gc.nix;
  tests.services-nix-optimise = makeTest ./tests/services-nix-optimise.nix;
  tests.services-nextdns = makeTest ./tests/services-nextdns.nix;
  tests.services-netdata = makeTest ./tests/services-netdata.nix;
  tests.services-ofborg = makeTest ./tests/services-ofborg.nix;
  tests.services-offlineimap = makeTest ./tests/services-offlineimap.nix;
  tests.services-openssh = makeTest ./tests/services-openssh.nix;
  tests.services-privoxy = makeTest ./tests/services-privoxy.nix;
  tests.services-redis = makeTest ./tests/services-redis.nix;
  tests.services-skhd = makeTest ./tests/services-skhd.nix;
  tests.services-spacebar = makeTest ./tests/services-spacebar.nix;
  tests.services-spotifyd = makeTest ./tests/services-spotifyd.nix;
  tests.services-synapse-bt = makeTest ./tests/services-synapse-bt.nix;
  tests.services-synergy = makeTest ./tests/services-synergy.nix;
  tests.services-yabai = makeTest ./tests/services-yabai.nix;
  tests.services-jankyborders = makeTest ./tests/services-jankyborders.nix;
  tests.system-defaults-write = makeTest ./tests/system-defaults-write.nix;
  tests.system-environment = makeTest ./tests/system-environment.nix;
  tests.system-keyboard-mapping = makeTest ./tests/system-keyboard-mapping.nix;
  tests.system-packages = makeTest ./tests/system-packages.nix;
  tests.system-path = makeTest ./tests/system-path.nix;
  tests.system-shells = makeTest ./tests/system-shells.nix;
  tests.users-groups = makeTest ./tests/users-groups.nix;
  tests.users-packages = makeTest ./tests/users-packages.nix;
  tests.fonts = makeTest ./tests/fonts.nix;
}
</file>

<file path="version.json">
{
  "release": "25.11",
  "isReleaseBranch": false
}
</file>

</files>
